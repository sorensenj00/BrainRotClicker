
================================================================================
FILE: src\client\AdminPanel.client.luau
================================================================================

--[[
	AdminPanel Client Script
	
	Provides a UI for testing commands.
	- Reset Plot
	- Add Money
	- Toggle Fly
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Wait for RemoteEvents
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local AdminAction = RemoteEvents:WaitForChild("AdminAction")

-- Configuration
local UI_CONFIG = {
	BUTTON_SIZE = UDim2.new(0, 50, 0, 50),
	PANEL_SIZE = UDim2.new(0, 200, 0, 320), -- Increased for 4 buttons
	COLOR_PRIMARY = Color3.fromRGB(40, 40, 50),
	COLOR_ACCENT = Color3.fromRGB(255, 100, 100), -- Red for dev
	TEXT_COLOR = Color3.fromRGB(255, 255, 255),
}

--------------------------------------------------------------------------------
-- UI CREATION
--------------------------------------------------------------------------------

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "AdminPanel"
screenGui.ResetOnSpawn = false
screenGui.Parent = playerGui

-- Toggle Button (Bottom Right)
local toggleBtn = Instance.new("TextButton")
toggleBtn.Name = "ToggleBtn"
toggleBtn.Size = UI_CONFIG.BUTTON_SIZE
toggleBtn.Position = UDim2.new(1, -60, 1, -60)
toggleBtn.BackgroundColor3 = UI_CONFIG.COLOR_ACCENT
toggleBtn.Text = "DEV"
toggleBtn.TextColor3 = UI_CONFIG.TEXT_COLOR
toggleBtn.Font = Enum.Font.GothamBold
toggleBtn.TextSize = 14
toggleBtn.AutoButtonColor = true
toggleBtn.Parent = screenGui

local uiCorner = Instance.new("UICorner")
uiCorner.CornerRadius = UDim.new(0.5, 0)
uiCorner.Parent = toggleBtn

-- Main Panel
local panel = Instance.new("Frame")
panel.Name = "MainPanel"
panel.Size = UI_CONFIG.PANEL_SIZE
panel.Position = UDim2.new(1, -270, 1, -320) 
panel.BackgroundColor3 = UI_CONFIG.COLOR_PRIMARY
panel.Visible = false 
panel.Parent = screenGui

local panelCorner = Instance.new("UICorner")
panelCorner.CornerRadius = UDim.new(0, 8)
panelCorner.Parent = panel

local listLayout = Instance.new("UIListLayout")
listLayout.Padding = UDim.new(0, 10)
listLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
listLayout.VerticalAlignment = Enum.VerticalAlignment.Top
listLayout.Parent = panel

local padding = Instance.new("UIPadding")
padding.PaddingTop = UDim.new(0, 15)
padding.PaddingBottom = UDim.new(0, 15)
padding.PaddingLeft = UDim.new(0, 15)
padding.PaddingRight = UDim.new(0, 15)
padding.Parent = panel

-- Helper to create buttons
local function createButton(text, callback)
	local btn = Instance.new("TextButton")
	btn.Size = UDim2.new(1, 0, 0, 40)
	btn.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
	btn.Text = text
	btn.TextColor3 = UI_CONFIG.TEXT_COLOR
	btn.Font = Enum.Font.GothamBold
	btn.TextSize = 14
	btn.AutoButtonColor = true
	btn.Parent = panel
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 6)
	corner.Parent = btn
	
	btn.MouseButton1Click:Connect(function()
		-- Visual feedback
		local originalColor = btn.BackgroundColor3
		btn.BackgroundColor3 = Color3.fromRGB(100, 100, 110)
		task.delay(0.1, function() btn.BackgroundColor3 = originalColor end)
		
		callback()
	end)
	
	return btn
end

-- Create Buttons
createButton("ðŸ”„ Reset Plot", function()
	local success, msg = AdminAction:InvokeServer("ResetPlot")
	print(msg)
end)

createButton("ðŸ’° Add $1M", function()
	local success, msg = AdminAction:InvokeServer("AddMoney")
	print(msg)
end)

createButton("ðŸ•Šï¸ Toggle Fly", function()
	local success, msg = AdminAction:InvokeServer("ToggleFly")
	print(msg)
end)

createButton("ðŸ’€ WIPE DATA", function()
	local success, msg = AdminAction:InvokeServer("WipeProfile")
	print(msg)
	if success then
		game.Players.LocalPlayer:Kick("Data wiped! Rejoin for fresh start.")
	end
end)

-- Toggle Logic
toggleBtn.MouseButton1Click:Connect(function()
	panel.Visible = not panel.Visible
end)

--------------------------------------------------------------------------------
-- FLIGHT LOGIC
--------------------------------------------------------------------------------

local flightConnection = nil
local bodyVelocity = nil
local bodyGyro = nil
local FLIGHT_SPEED = 50

local function stopFlying()
	if flightConnection then
		flightConnection:Disconnect()
		flightConnection = nil
	end
	
	if bodyVelocity then bodyVelocity:Destroy() bodyVelocity = nil end
	if bodyGyro then bodyGyro:Destroy() bodyGyro = nil end
	
	local character = player.Character
	if character then
		local humanoid = character:FindFirstChild("Humanoid")
		if humanoid then
			humanoid.PlatformStand = false
		end
	end
end

local function startFlying()
	local character = player.Character
	if not character then return end
	local hrp = character:FindFirstChild("HumanoidRootPart")
	local humanoid = character:FindFirstChild("Humanoid")
	if not hrp or not humanoid then return end
	
	-- Create physics movers
	bodyVelocity = Instance.new("BodyVelocity")
	bodyVelocity.Velocity = Vector3.new(0, 0, 0)
	bodyVelocity.MaxForce = Vector3.new(1e5, 1e5, 1e5)
	bodyVelocity.Parent = hrp
	
	bodyGyro = Instance.new("BodyGyro")
	bodyGyro.MaxTorque = Vector3.new(1e5, 1e5, 1e5)
	bodyGyro.CFrame = hrp.CFrame
	bodyGyro.Parent = hrp
	
	humanoid.PlatformStand = true
	
	flightConnection = RunService.RenderStepped:Connect(function()
		if not player:GetAttribute("IsFlying") then
			stopFlying()
			return
		end
		
		local camCFrame = workspace.CurrentCamera.CFrame
		local moveDir = Vector3.new(0, 0, 0)
		
		if UserInputService:IsKeyDown(Enum.KeyCode.W) then
			moveDir += camCFrame.LookVector
		end
		if UserInputService:IsKeyDown(Enum.KeyCode.S) then
			moveDir -= camCFrame.LookVector
		end
		if UserInputService:IsKeyDown(Enum.KeyCode.A) then
			moveDir -= camCFrame.RightVector
		end
		if UserInputService:IsKeyDown(Enum.KeyCode.D) then
			moveDir += camCFrame.RightVector
		end
		if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
			moveDir += Vector3.new(0, 1, 0)
		end
		if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
			moveDir -= Vector3.new(0, 1, 0)
		end
		
		if moveDir.Magnitude > 0 then
			moveDir = moveDir.Unit
		end
		
		bodyVelocity.Velocity = moveDir * FLIGHT_SPEED
		bodyGyro.CFrame = camCFrame
	end)
end

-- Listen for attribute change
player:GetAttributeChangedSignal("IsFlying"):Connect(function()
	if player:GetAttribute("IsFlying") then
		startFlying()
	else
		stopFlying()
	end
end)

-- Handle respawn
player.CharacterAdded:Connect(function()
	if player:GetAttribute("IsFlying") then
		task.wait(0.5)
		startFlying()
	end
end)

print("âœ“ AdminPanel loaded")


================================================================================
FILE: src\client\BackpackHUD.client.luau
================================================================================

--[[
	BackpackHUD LocalScript
	
	Unified Inventory UI ("Backpack").
	Displays Units and Artifacts in a grid.
	Features rich interaction with 3D previews and stats.
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local _UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local Player = Players.LocalPlayer
local PlayerGui = Player:WaitForChild("PlayerGui")

local Shared = ReplicatedStorage:WaitForChild("Shared")
local _ItemTypes = require(Shared:WaitForChild("ItemTypes"))
local _ArtifactConfig = require(Shared:WaitForChild("ArtifactConfig"))
local _ShopConfig = require(Shared:WaitForChild("ShopConfig"))
local ItemConfig = require(Shared:WaitForChild("ItemConfig"))

local RemoteFunctions = ReplicatedStorage:WaitForChild("RemoteFunctions")
local GetUnifiedInventoryFunc = RemoteFunctions:WaitForChild("GetUnifiedInventory")
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")

-- Storage remotes
local GetStorageFunction = RemoteFunctions:WaitForChild("GetStorage")
local StorageUpdatedEvent = RemoteEvents:WaitForChild("StorageUpdated")
local TakeFromStorageEvent = RemoteEvents:FindFirstChild("TakeFromStorage") or Instance.new("RemoteEvent")
TakeFromStorageEvent.Name = "TakeFromStorage"
TakeFromStorageEvent.Parent = RemoteEvents

-- Folders for 3D preview
local BrainrotsFolder = ReplicatedStorage:WaitForChild("Brainrots")

local UI_CONFIG = {
	PANEL_WIDTH = 500,
	PANEL_HEIGHT = 600,
	SLOT_SIZE = 70, -- Larger slots for better visibility
	GRID_PADDING = 6,
	CORNER_RADIUS = 16,
	
	COLOR_BG = Color3.fromRGB(25, 25, 35),
	COLOR_PANEL = Color3.fromRGB(35, 35, 45),
	COLOR_SLOT = Color3.fromRGB(45, 45, 55),
	COLOR_ACCENT = Color3.fromRGB(100, 150, 255),
	COLOR_TEXT = Color3.fromRGB(240, 240, 240),
	COLOR_TEXT_DIM = Color3.fromRGB(150, 150, 160),
	
	RARITY_COLORS = {
		Normal = Color3.fromRGB(180, 180, 180),
		Spicy = Color3.fromRGB(255, 80, 80),
		Galaxy = Color3.fromRGB(180, 100, 255),
	},
	
	-- Hover tooltip settings
	HOVER_DELAY = 0.3, -- Seconds before tooltip appears
	TOOLTIP_FADE_TIME = 0.2, -- Fade in/out duration
}

local BackpackGui
local BackpackVisible = false
local CurrentItems = {}
local CurrentFilter = "All" -- "All", "Unit", "Artifact", "Storage"

-- Storage state
local CurrentStorageItems = {} -- {[itemId] = count}
local StorageUsage = 0

-- Hover tooltip state
local CurrentHoverTooltip = nil
local HoverDelayThread = nil
local StorageCapacity = 0 -- Updated via Player Attribute

--------------------------------------------------------------------------------
-- HELPERS
--------------------------------------------------------------------------------

local function addCorner(parent, radius)
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, radius)
	corner.Parent = parent
	return corner
end

local function addStroke(parent, color, thickness)
	local stroke = Instance.new("UIStroke")
	stroke.Color = color
	stroke.Thickness = thickness
	stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	stroke.Parent = parent
	return stroke
end

local function getRarityColor(rarity)
	return UI_CONFIG.RARITY_COLORS[rarity] or UI_CONFIG.RARITY_COLORS.Normal
end

--[[
	Checks if player is standing on their own island.
	Used to enable/disable taking items from storage.
]]
local function isOnOwnIsland()
	local character = Player.Character
	if not character then return false end
	
	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return false end
	
	local playerPos = hrp.Position
	local plotsFolder = workspace:FindFirstChild("Plots")
	if not plotsFolder then return false end
	
	for _, plot in plotsFolder:GetChildren() do
		local ownerId = plot:GetAttribute("OwnerId")
		if ownerId == Player.UserId then
			-- Find the floor part
			local floor = plot:FindFirstChild("Island")
				or plot:FindFirstChild("PlotFloor")
				or plot:FindFirstChild("Floor")
				or plot:FindFirstChildWhichIsA("BasePart")
			
			if floor then
				local floorPos = floor.Position
				local floorSize = floor.Size
				
				-- Check if player is within plot bounds (XZ)
				local dx = math.abs(playerPos.X - floorPos.X)
				local dz = math.abs(playerPos.Z - floorPos.Z)
				
				if dx <= floorSize.X / 2 + 10 and dz <= floorSize.Z / 2 + 10 then
					return true
				end
			end
		end
	end
	
	return false
end

--[[
	Finds the brainrot visual template.
]]
local function getBrainrotTemplate(unitName)
	-- Try to find in various locations
	local t = BrainrotsFolder:FindFirstChild(unitName)
	if t then return t end
	
	-- Check ReplicatedStorage.Assets.Brainrots if exists
	local assets = ReplicatedStorage:FindFirstChild("Assets")
	if assets and assets:FindFirstChild("Brainrots") then
		t = assets.Brainrots:FindFirstChild(unitName)
		if t then return t end
	end
	
	return nil
end

--------------------------------------------------------------------------------
-- HOVER TOOLTIP
--------------------------------------------------------------------------------

local function clearHoverTooltip()
	if HoverDelayThread then
		-- pcall because thread may have already completed
		pcall(function()
			task.cancel(HoverDelayThread)
		end)
		HoverDelayThread = nil
	end
	
	if CurrentHoverTooltip then
		-- Fade out smoothly
		local tooltip = CurrentHoverTooltip
		CurrentHoverTooltip = nil
		
		local fadeOut = TweenService:Create(tooltip, TweenInfo.new(UI_CONFIG.TOOLTIP_FADE_TIME, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
			BackgroundTransparency = 1,
			GroupTransparency = 1
		})
		fadeOut:Play()
		fadeOut.Completed:Connect(function()
			if tooltip and tooltip.Parent then
				tooltip:Destroy()
			end
		end)
	end
end

local function spawn3DPreviewForTooltip(viewport, unitName)
	viewport:ClearAllChildren()
	
	local template = getBrainrotTemplate(unitName)
	if not template then return end
	
	local model = template:Clone()
	model.Parent = viewport
	
	-- Setup Camera
	local cam = Instance.new("Camera")
	cam.Parent = viewport
	viewport.CurrentCamera = cam
	
	local success, cf, size = pcall(function()
		return model:GetBoundingBox()
	end)
	if not success then return end
	
	local maxDim = math.max(size.X, size.Y, size.Z)
	local dist = maxDim * 2.5 -- Further back for better framing
	
	-- Calculate center of model (vertically centered)
	local modelCenter = cf.Position
	
	-- Rotate model with camera positioned at eye level
	local rotation = 0
	local connection
	connection = RunService.RenderStepped:Connect(function(dt)
		if not model.Parent then 
			connection:Disconnect()
			return 
		end
		rotation = rotation + dt * 0.5
		local rotCFrame = CFrame.Angles(0, rotation, 0)
		-- Camera positioned at model's vertical center, slightly elevated
		local camHeight = size.Y * 0.3
		local newPos = modelCenter + (rotCFrame * Vector3.new(0, camHeight, dist))
		cam.CFrame = CFrame.new(newPos, modelCenter)
	end)
end

local function createHoverTooltip(item, slotPosition)
	clearHoverTooltip()
	
	-- Guard: need a valid GUI parent
	local guiParent = BackpackGui or PlayerGui:FindFirstChild("BackpackHUD")
	if not guiParent then
		warn("BackpackHUD: No GUI parent for hover tooltip")
		return
	end
	
	local tooltip = Instance.new("CanvasGroup")
	tooltip.Name = "HoverTooltip"
	tooltip.Size = UDim2.new(0, 220, 0, 280)
	tooltip.BackgroundColor3 = UI_CONFIG.COLOR_BG
	tooltip.BorderSizePixel = 0
	tooltip.GroupTransparency = 1 -- Start invisible for fade-in
	tooltip.ZIndex = 200
	
	-- Position tooltip to the right of cursor, with screen boundary check
	local screenSize = guiParent.AbsoluteSize
	local tooltipX = slotPosition.X + 80 -- Offset to the right of the slot
	local tooltipY = slotPosition.Y
	
	-- Keep tooltip on screen
	if tooltipX + 220 > screenSize.X then
		tooltipX = slotPosition.X - 230 -- Show on left if no room on right
	end
	if tooltipY + 280 > screenSize.Y then
		tooltipY = screenSize.Y - 290
	end
	if tooltipY < 10 then
		tooltipY = 10
	end
	
	tooltip.Position = UDim2.new(0, tooltipX, 0, tooltipY)
	tooltip.Parent = guiParent
	
	addCorner(tooltip, 12)
	addStroke(tooltip, getRarityColor(item.Rarity), 2)
	
	-- Content padding
	local padding = Instance.new("UIPadding")
	padding.PaddingLeft = UDim.new(0, 10)
	padding.PaddingRight = UDim.new(0, 10)
	padding.PaddingTop = UDim.new(0, 10)
	padding.PaddingBottom = UDim.new(0, 10)
	padding.Parent = tooltip
	
	local content = Instance.new("Frame")
	content.Size = UDim2.new(1, 0, 1, 0)
	content.BackgroundTransparency = 1
	content.Parent = tooltip
	
	local layout = Instance.new("UIListLayout")
	layout.SortOrder = Enum.SortOrder.LayoutOrder
	layout.Padding = UDim.new(0, 6)
	layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	layout.Parent = content
	
	-- Header with rarity glow
	local header = Instance.new("TextLabel")
	header.Text = item.Rarity .. "  " .. item.Name
	header.TextColor3 = getRarityColor(item.Rarity)
	header.Font = Enum.Font.GothamBold
	header.TextSize = 14
	header.TextTruncate = Enum.TextTruncate.AtEnd
	header.Size = UDim2.new(1, 0, 0, 20)
	header.BackgroundTransparency = 1
	header.LayoutOrder = 1
	header.Parent = content
	
	-- Preview area
	local previewFrame = Instance.new("Frame")
	previewFrame.Size = UDim2.new(0, 140, 0, 140)
	previewFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 28)
	previewFrame.LayoutOrder = 2
	previewFrame.Parent = content
	addCorner(previewFrame, 8)
	
	if item.Type == "Unit" then
		local vp = Instance.new("ViewportFrame")
		vp.Size = UDim2.new(1, 0, 1, 0)
		vp.BackgroundTransparency = 1
		vp.Parent = previewFrame
		spawn3DPreviewForTooltip(vp, item.UUID)
	else
		-- Fallback icon logic if item.Icon is missing
		local displayIcon = item.Icon
		if not displayIcon or displayIcon == "" then
			-- Try to look up based on base ID/Name if possible, or use generic
			displayIcon = "âš”ï¸" -- Generic artifact icon
		end
		
		local iconLabel = Instance.new("TextLabel")
		iconLabel.Text = displayIcon
		iconLabel.Size = UDim2.new(1, 0, 1, 0)
		iconLabel.BackgroundTransparency = 1
		iconLabel.TextSize = 60
		iconLabel.Parent = previewFrame
	end
	
	-- Slot/Status line
	local statusLabel = Instance.new("TextLabel")
	if item.Type == "Unit" then
		statusLabel.Text = item.IsPlaced and "Slot: Placed" or "Slot: Inventory"
	else
		statusLabel.Text = "Slot: " .. (item.Data.EquippedTo and "Equipped" or "Inventory")
	end
	statusLabel.TextColor3 = UI_CONFIG.COLOR_TEXT_DIM
	statusLabel.Font = Enum.Font.Gotham
	statusLabel.TextSize = 11
	statusLabel.Size = UDim2.new(1, 0, 0, 16)
	statusLabel.BackgroundTransparency = 1
	statusLabel.LayoutOrder = 3
	statusLabel.Parent = content
	
	-- Stats section
	local statsFrame = Instance.new("Frame")
	statsFrame.Size = UDim2.new(1, 0, 0, 60)
	statsFrame.BackgroundTransparency = 1
	statsFrame.LayoutOrder = 4
	statsFrame.Parent = content
	
	local statsLayout = Instance.new("UIListLayout")
	statsLayout.Padding = UDim.new(0, 3)
	statsLayout.Parent = statsFrame
	
	local function addStat(text, color)
		local l = Instance.new("TextLabel")
		l.Text = text
		l.TextColor3 = color or UI_CONFIG.COLOR_TEXT
		l.TextSize = 12
		l.Font = Enum.Font.Gotham
		l.Size = UDim2.new(1, 0, 0, 14)
		l.BackgroundTransparency = 1
		l.Parent = statsFrame
	end
	
	if item.Type == "Unit" then
		addStat("â­ Level: " .. (item.Data.Level or 1), Color3.fromRGB(255, 220, 100))
	else
		local stats = item.Data.Stats or {}
		if stats.CycleTimeMult and stats.CycleTimeMult ~= 1 then
			local p = math.round((1 - stats.CycleTimeMult) * 100)
			addStat("âš¡ Cycle Time: -" .. p .. "%", Color3.fromRGB(255, 255, 100))
		end
		if stats.ItemTierBonus and stats.ItemTierBonus > 0 then
			addStat("â­ Tier: +" .. stats.ItemTierBonus, Color3.fromRGB(255, 200, 100))
		end
		if stats.LuckBonus and stats.LuckBonus > 0 then
			addStat("ðŸ€ Luck: +" .. stats.LuckBonus, Color3.fromRGB(100, 255, 100))
		end
	end
	
	CurrentHoverTooltip = tooltip
	
	-- Smooth fade in
	local fadeIn = TweenService:Create(tooltip, TweenInfo.new(UI_CONFIG.TOOLTIP_FADE_TIME, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		GroupTransparency = 0
	})
	fadeIn:Play()
end

local function scheduleHoverTooltip(item, slot)
	clearHoverTooltip()
	
	HoverDelayThread = task.delay(UI_CONFIG.HOVER_DELAY, function()
		if slot and slot.Parent then
			local slotPos = slot.AbsolutePosition
			createHoverTooltip(item, slotPos)
		end
		HoverDelayThread = nil
	end)
end

--------------------------------------------------------------------------------
-- DETAIL POPUP
--------------------------------------------------------------------------------

local function spawn3DPreview(viewport, unitName)
	viewport:ClearAllChildren()
	
	local template = getBrainrotTemplate(unitName)
	if not template then return end
	
	local model = template:Clone()
	model.Parent = viewport
	
	-- Setup Camera
	local cam = Instance.new("Camera")
	cam.Parent = viewport
	viewport.CurrentCamera = cam
	
	local cf, size = model:GetBoundingBox()
	local maxDim = math.max(size.X, size.Y, size.Z)
	local dist = maxDim * 2
	
	-- Rotate model
	local rotation = 0
	local connection
	connection = RunService.RenderStepped:Connect(function(dt)
		if not model.Parent then 
			connection:Disconnect()
			return 
		end
		rotation = rotation + dt * 0.5
		local rotCFrame = CFrame.Angles(0, rotation, 0)
		local newPos = cf.Position + (rotCFrame * Vector3.new(0, maxDim*0.2, dist))
		cam.CFrame = CFrame.new(newPos, cf.Position)
	end)
end

local function openDetailPopup(item)
	-- Remove existing popup
	local oldPopup = BackpackGui:FindFirstChild("DetailPopup")
	if oldPopup then oldPopup:Destroy() end
	
	local popup = Instance.new("Frame")
	popup.Name = "DetailPopup"
	popup.Size = UDim2.new(0, 300, 0, 400)
	-- Center related to screen? Or panel? let's center on screen for now
	popup.Position = UDim2.new(0.5, 0, 0.5, 0)
	popup.AnchorPoint = Vector2.new(0.5, 0.5)
	popup.BackgroundColor3 = UI_CONFIG.COLOR_BG
	popup.BorderSizePixel = 0
	popup.ZIndex = 100
	popup.Parent = BackpackGui
	
	addCorner(popup, 16)
	addStroke(popup, getRarityColor(item.Rarity), 2)
	
	-- Close Button (Top Right)
	local close = Instance.new("TextButton")
	close.Text = "âœ•"
	close.Size = UDim2.new(0, 30, 0, 30)
	close.Position = UDim2.new(1, -35, 0, 5)
	close.BackgroundTransparency = 1
	close.TextColor3 = UI_CONFIG.COLOR_TEXT_DIM
	close.TextSize = 20
	close.Parent = popup
	close.MouseButton1Click:Connect(function() popup:Destroy() end)
	
	-- Content Layout
	local content = Instance.new("Frame")
	content.Size = UDim2.new(1, -20, 1, -20)
	content.Position = UDim2.new(0, 10, 0, 10)
	content.BackgroundTransparency = 1
	content.Parent = popup
	
	local uiList = Instance.new("UIListLayout")
	uiList.SortOrder = Enum.SortOrder.LayoutOrder
	uiList.Padding = UDim.new(0, 10)
	uiList.HorizontalAlignment = Enum.HorizontalAlignment.Center
	uiList.Parent = content
	
	-- 1. Header (Name & Rarity)
	local header = Instance.new("TextLabel")
	header.Text = item.Name
	header.TextColor3 = getRarityColor(item.Rarity)
	header.Font = Enum.Font.GothamBold
	header.TextSize = 18
	header.Size = UDim2.new(1, 0, 0, 24)
	header.BackgroundTransparency = 1
	header.LayoutOrder = 1
	header.Parent = content
	
	-- 2. Preview Area
	local previewFrame = Instance.new("Frame")
	previewFrame.Size = UDim2.new(0, 200, 0, 200)
	previewFrame.BackgroundColor3 = Color3.fromRGB(20,20,25)
	previewFrame.LayoutOrder = 2
	previewFrame.Parent = content
	addCorner(previewFrame, 8)
	
	if item.Type == "Unit" then
		-- 3D Viewport
		local vp = Instance.new("ViewportFrame")
		vp.Size = UDim2.new(1, 0, 1, 0)
		vp.BackgroundTransparency = 1
		vp.Parent = previewFrame
		spawn3DPreview(vp, item.UUID) -- UUID is unitName for units
		
	elseif item.Type == "Artifact" then
		-- Icon Image
		local icon = Instance.new("TextLabel") -- Using TextLabel for emoji icons?
		-- If Icon is an asset ID, use ImageLabel. If emoji, use TextLabel.
		-- Artifact system uses generic Image/Emoji.
		
		-- FALLBACK LOGIC
		local displayIcon = item.Icon
		if not displayIcon or displayIcon == "" then
			displayIcon = "âš”ï¸" -- Generic fallback
		end
		
		icon.Text = displayIcon
		icon.Size = UDim2.new(1,0,1,0)
		icon.BackgroundTransparency = 1
		icon.TextSize = 100
		icon.Parent = previewFrame
	end
	
	-- 3. Stats / Info
	local infoFrame = Instance.new("Frame")
	infoFrame.Size = UDim2.new(1, 0, 0, 100)
	infoFrame.BackgroundTransparency = 1
	infoFrame.LayoutOrder = 3
	infoFrame.Parent = content
	
	local infoList = Instance.new("UIListLayout")
	infoList.Padding = UDim.new(0, 4)
	infoList.Parent = infoFrame
	
	local function addLine(text, color)
		local l = Instance.new("TextLabel")
		l.Text = text
		l.TextColor3 = color or UI_CONFIG.COLOR_TEXT
		l.TextSize = 14
		l.Font = Enum.Font.Gotham
		l.Size = UDim2.new(1, 0, 0, 18)
		l.BackgroundTransparency = 1
		l.Parent = infoFrame
	end
	
	if item.Type == "Unit" then
		addLine("Level: " .. (item.Data.Level or 1), UI_CONFIG.COLOR_TEXT)
		addLine("Status: " .. (item.IsPlaced and "Placed (On Grid)" or "Stored"), 
			item.IsPlaced and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(255, 200, 100))
			
		-- TODO: Show slots?
	else -- Artifact
		addLine("Slot: " .. (item.Data.EquippedTo and "Equipped" or "Inventory"), UI_CONFIG.COLOR_TEXT_DIM)
		
		local stats = item.Data.Stats or {}
		if stats.CycleTimeMult and stats.CycleTimeMult ~= 1 then
			local p = math.round((1 - stats.CycleTimeMult) * 100)
			addLine("âš¡ Cycle Time: -" .. p .. "%", Color3.fromRGB(255,255,100))
		end
		if stats.LuckBonus and stats.LuckBonus > 0 then
			addLine("ðŸ€ Luck: +" .. stats.LuckBonus, Color3.fromRGB(100,255,100))
		end
		if stats.ItemTierBonus and stats.ItemTierBonus > 0 then
			addLine("â­ Tier: +" .. stats.ItemTierBonus, Color3.fromRGB(255,100,255))
		end
	end
end

--------------------------------------------------------------------------------
-- GRID UI
--------------------------------------------------------------------------------

local IsRefreshing = false -- Debounce flag to prevent duplicate renders

local function refreshGrid()
	-- Debounce to prevent duplicate renders from rapid event firing
	if IsRefreshing then return end
	IsRefreshing = true
	task.defer(function() IsRefreshing = false end)
	
	if not BackpackGui then
		IsRefreshing = false
		return
	end
	local mainPanel = BackpackGui:FindFirstChild("MainPanel")
	if not mainPanel then
		IsRefreshing = false
		return
	end
	local grid = mainPanel:FindFirstChild("Grid")
	if not grid then
		IsRefreshing = false
		return
	end
	
	-- Clean ALL children (including layouts) to prevent duplicates
	for _, c in pairs(grid:GetChildren()) do
		c:Destroy()
	end
	
	-- If Storage tab, show storage items instead
	if CurrentFilter == "Storage" then
		-- Fetch storage data from server
		local success, items, total, capacity = pcall(function()
			return GetStorageFunction:InvokeServer()
		end)
		
		if not success or not items then
			items = {}
			total = 0
			capacity = 2000
		end
		
		CurrentStorageItems = items
		StorageUsage = total or 0
		StorageCapacity = Player:GetAttribute("StorageCapacity") or capacity or 0
		
		local onIsland = isOnOwnIsland()
		
		-- Storage header showing total
		local header = Instance.new("Frame")
		header.Name = "StorageHeader"
		header.Size = UDim2.new(1, 0, 0, 44)
		header.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
		header.BackgroundTransparency = 0.3
		header.LayoutOrder = 0
		header.Parent = grid
		addCorner(header, 8)
		
		local headerText = Instance.new("TextLabel")
		headerText.Text = string.format("ðŸ“¦ %d / %d", StorageUsage, StorageCapacity)
		headerText.Size = UDim2.new(0, 100, 1, 0)
		headerText.Position = UDim2.new(0, 8, 0, 0)
		headerText.BackgroundTransparency = 1
		headerText.TextColor3 = UI_CONFIG.COLOR_TEXT
		headerText.TextSize = 13
		headerText.Font = Enum.Font.GothamBold
		headerText.TextXAlignment = Enum.TextXAlignment.Left
		headerText.Parent = header
		
		-- Take All button (center)
		local takeAllBtn = Instance.new("TextButton")
		takeAllBtn.Name = "TakeAllButton"
		takeAllBtn.Text = onIsland and "ðŸ“¥ Take All" or "ðŸ”’"
		takeAllBtn.Size = UDim2.new(0, 80, 0, 28)
		takeAllBtn.Position = UDim2.new(0.5, -40, 0.5, -14)
		takeAllBtn.BackgroundColor3 = onIsland and Color3.fromRGB(80, 160, 80) or Color3.fromRGB(60, 60, 60)
		takeAllBtn.TextColor3 = Color3.new(1, 1, 1)
		takeAllBtn.TextSize = 11
		takeAllBtn.Font = Enum.Font.GothamBold
		takeAllBtn.AutoButtonColor = onIsland
		takeAllBtn.Parent = header
		addCorner(takeAllBtn, 6)
		
		if onIsland then
			takeAllBtn.MouseButton1Click:Connect(function()
				-- Take all items from storage
				for itemId, count in pairs(CurrentStorageItems) do
					if count > 0 then
						TakeFromStorageEvent:FireServer(itemId, count)
					end
				end
				-- Refresh after short delay
				task.wait(0.3)
				refreshGrid()
			end)
			
			-- Hover effect
			takeAllBtn.MouseEnter:Connect(function()
				TweenService:Create(takeAllBtn, TweenInfo.new(0.1), {BackgroundColor3 = Color3.fromRGB(100, 200, 100)}):Play()
			end)
			takeAllBtn.MouseLeave:Connect(function()
				TweenService:Create(takeAllBtn, TweenInfo.new(0.1), {BackgroundColor3 = Color3.fromRGB(80, 160, 80)}):Play()
			end)
		end
		
		-- Island status indicator (right side)
		local statusLabel = Instance.new("TextLabel")
		statusLabel.Text = onIsland and "âœ“ On Island" or "âš  Go to island"
		statusLabel.Size = UDim2.new(0, 90, 1, 0)
		statusLabel.Position = UDim2.new(1, -95, 0, 0)
		statusLabel.BackgroundTransparency = 1
		statusLabel.TextColor3 = onIsland and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(255, 150, 100)
		statusLabel.TextSize = 10
		statusLabel.Font = Enum.Font.Gotham
		statusLabel.TextXAlignment = Enum.TextXAlignment.Right
		statusLabel.Parent = header
		
		-- Create storage item slots
		local itemIndex = 1
		for itemId, count in pairs(CurrentStorageItems) do
			if count > 0 then
				local itemInfo = ItemConfig.Items[itemId]
				local icon = itemInfo and itemInfo.icon or "ðŸ“¦"
				local displayName = itemInfo and itemInfo.displayName or itemId
				
				local slot = Instance.new("Frame")
				slot.Name = "StorageSlot_" .. itemIndex
				slot.Size = UDim2.new(1, 0, 0, 55)
				slot.BackgroundColor3 = UI_CONFIG.COLOR_SLOT
				slot.LayoutOrder = itemIndex
				slot.Parent = grid
				addCorner(slot, 8)
				addStroke(slot, UI_CONFIG.COLOR_ACCENT, 1)
				
				-- Icon
				local iconLabel = Instance.new("TextLabel")
				iconLabel.Text = icon
				iconLabel.Size = UDim2.new(0, 40, 0, 40)
				iconLabel.Position = UDim2.new(0, 5, 0.5, -20)
				iconLabel.BackgroundTransparency = 1
				iconLabel.TextSize = 28
				iconLabel.Parent = slot
				
				-- Name + Count
				local nameLabel = Instance.new("TextLabel")
				nameLabel.Text = displayName
				nameLabel.Size = UDim2.new(0.45, 0, 0, 20)
				nameLabel.Position = UDim2.new(0, 50, 0, 8)
				nameLabel.BackgroundTransparency = 1
				nameLabel.TextColor3 = UI_CONFIG.COLOR_TEXT
				nameLabel.TextSize = 13
				nameLabel.Font = Enum.Font.GothamBold
				nameLabel.TextXAlignment = Enum.TextXAlignment.Left
				nameLabel.Parent = slot
				
				local countLabel = Instance.new("TextLabel")
				countLabel.Text = "x" .. count
				countLabel.Size = UDim2.new(0.45, 0, 0, 18)
				countLabel.Position = UDim2.new(0, 50, 0, 28)
				countLabel.BackgroundTransparency = 1
				countLabel.TextColor3 = UI_CONFIG.COLOR_TEXT_DIM
				countLabel.TextSize = 12
				countLabel.Font = Enum.Font.Gotham
				countLabel.TextXAlignment = Enum.TextXAlignment.Left
				countLabel.Parent = slot
				
				-- Take button
				local takeBtn = Instance.new("TextButton")
				takeBtn.Name = "TakeButton"
				takeBtn.Text = onIsland and "Take" or "ðŸ”’"
				takeBtn.Size = UDim2.new(0, 60, 0, 32)
				takeBtn.Position = UDim2.new(1, -70, 0.5, -16)
				takeBtn.BackgroundColor3 = onIsland and Color3.fromRGB(80, 160, 80) or Color3.fromRGB(80, 80, 80)
				takeBtn.TextColor3 = Color3.new(1, 1, 1)
				takeBtn.TextSize = 12
				takeBtn.Font = Enum.Font.GothamBold
				takeBtn.AutoButtonColor = onIsland
				takeBtn.Parent = slot
				addCorner(takeBtn, 6)
				
				if onIsland then
					takeBtn.MouseButton1Click:Connect(function()
						-- Request take from server (take 1 at a time for now)
						TakeFromStorageEvent:FireServer(itemId, 1)
						-- Refresh after a short delay
						task.wait(0.2)
						refreshGrid()
					end)
					
					-- Hover effect
					takeBtn.MouseEnter:Connect(function()
						TweenService:Create(takeBtn, TweenInfo.new(0.1), {BackgroundColor3 = Color3.fromRGB(100, 200, 100)}):Play()
					end)
					takeBtn.MouseLeave:Connect(function()
						TweenService:Create(takeBtn, TweenInfo.new(0.1), {BackgroundColor3 = Color3.fromRGB(80, 160, 80)}):Play()
					end)
				end
				
				itemIndex = itemIndex + 1
			end
		end
		
		-- If no items
		if itemIndex == 1 then
			local emptyLabel = Instance.new("TextLabel")
			emptyLabel.Text = "Storage is empty"
			emptyLabel.Size = UDim2.new(1, 0, 0, 50)
			emptyLabel.LayoutOrder = 1
			emptyLabel.BackgroundTransparency = 1
			emptyLabel.TextColor3 = UI_CONFIG.COLOR_TEXT_DIM
			emptyLabel.TextSize = 14
			emptyLabel.Font = Enum.Font.Gotham
			emptyLabel.Parent = grid
		end
		
		-- Change to list layout for Storage
		local existingLayout = grid:FindFirstChildOfClass("UIGridLayout")
		if existingLayout then existingLayout:Destroy() end
		
		local listLayout = grid:FindFirstChildOfClass("UIListLayout")
		if not listLayout then
			listLayout = Instance.new("UIListLayout")
			listLayout.SortOrder = Enum.SortOrder.LayoutOrder
			listLayout.Padding = UDim.new(0, 8)
			listLayout.Parent = grid
		end
		
		return
	end
	
	-- Standard grid layout for non-storage items
	local existingList = grid:FindFirstChildOfClass("UIListLayout")
	if existingList then existingList:Destroy() end
	
	local existingGrid = grid:FindFirstChildOfClass("UIGridLayout")
	if not existingGrid then
		local gridLayout = Instance.new("UIGridLayout")
		gridLayout.CellSize = UDim2.new(0, UI_CONFIG.SLOT_SIZE, 0, UI_CONFIG.SLOT_SIZE)
		gridLayout.CellPadding = UDim2.new(0, UI_CONFIG.GRID_PADDING, 0, UI_CONFIG.GRID_PADDING)
		gridLayout.Parent = grid
	end
	
	-- Filter Items
	local displayItems = {}
	for _, item in ipairs(CurrentItems) do
		if CurrentFilter == "All" or item.Type == CurrentFilter then
			table.insert(displayItems, item)
		end
	end
	
	-- Create Slots
	for i, item in ipairs(displayItems) do
		local slot = Instance.new("ImageButton")
		slot.Name = "Slot_" .. i
		slot.BackgroundColor3 = UI_CONFIG.COLOR_SLOT
		slot.AutoButtonColor = false
		slot.Parent = grid
		addCorner(slot, 8)
		addStroke(slot, getRarityColor(item.Rarity), 1.5)
		
		-- Icon
		local icon = Instance.new("TextLabel")
		
		-- robust fallback for icon
		local displayIcon = item.Icon
		if not displayIcon or displayIcon == "" then
			displayIcon = "â“"
			if item.Type == "Artifact" then
				displayIcon = "âš”ï¸"
			elseif item.Type == "Unit" then
				displayIcon = "ðŸ‘¤"
			end
		end
		
		icon.Text = displayIcon
		icon.Size = UDim2.new(1,0,1,0)
		icon.BackgroundTransparency = 1
		icon.TextSize = 24
		icon.Parent = slot
		
		-- Level badge (for Units)
		if item.Type == "Unit" and item.Data and item.Data.Level then
			local levelBadge = Instance.new("Frame")
			levelBadge.Name = "LevelBadge"
			levelBadge.Size = UDim2.new(0, 22, 0, 16)
			levelBadge.Position = UDim2.new(0, 2, 1, -18)
			levelBadge.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
			levelBadge.BorderSizePixel = 0
			levelBadge.Parent = slot
			addCorner(levelBadge, 4)
			addStroke(levelBadge, Color3.fromRGB(255, 200, 100), 1)
			
			local levelLabel = Instance.new("TextLabel")
			levelLabel.Text = "Lv" .. item.Data.Level
			levelLabel.Size = UDim2.new(1, 0, 1, 0)
			levelLabel.BackgroundTransparency = 1
			levelLabel.TextSize = 10
			levelLabel.Font = Enum.Font.GothamBold
			levelLabel.TextColor3 = Color3.fromRGB(255, 220, 100)
			levelLabel.Parent = levelBadge
		end
		
		-- Placed/Equipped indicator
		if item.IsPlaced or item.IsEquipped then
			local ind = Instance.new("Frame")
			ind.Size = UDim2.new(0, 14, 0, 14)
			ind.Position = UDim2.new(1, -16, 0, 2)
			ind.BackgroundColor3 = item.IsPlaced and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(100, 180, 255)
			ind.BorderSizePixel = 0
			ind.Parent = slot
			addCorner(ind, 7)
			
			local sLabel = Instance.new("TextLabel")
			sLabel.Text = item.IsPlaced and "âœ“" or "E"
			sLabel.Size = UDim2.new(1,0,1,0)
			sLabel.BackgroundTransparency = 1
			sLabel.TextSize = 9
			sLabel.Font = Enum.Font.GothamBold
			sLabel.TextColor3 = Color3.new(0,0,0)
			sLabel.Parent = ind
		end
		
		-- Click to open detail
		slot.MouseButton1Click:Connect(function()
			clearHoverTooltip()
			openDetailPopup(item)
		end)
		
		-- Hover effect with smooth scale and tooltip
		slot.MouseEnter:Connect(function()
			-- Smooth background color change
			TweenService:Create(slot, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
				BackgroundColor3 = Color3.fromRGB(65, 65, 80)
			}):Play()
			
			-- Get the stroke and make it brighter
			local stroke = slot:FindFirstChildOfClass("UIStroke")
			if stroke then
				local originalColor = getRarityColor(item.Rarity)
				local brighterColor = Color3.new(
					math.min(originalColor.R * 1.3, 1),
					math.min(originalColor.G * 1.3, 1),
					math.min(originalColor.B * 1.3, 1)
				)
				TweenService:Create(stroke, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
					Color = brighterColor,
					Thickness = 2.5
				}):Play()
			end
			
			-- Schedule hover tooltip
			scheduleHoverTooltip(item, slot)
		end)
		
		slot.MouseLeave:Connect(function()
			-- Smooth background color reset
			TweenService:Create(slot, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
				BackgroundColor3 = UI_CONFIG.COLOR_SLOT
			}):Play()
			
			-- Reset stroke
			local stroke = slot:FindFirstChildOfClass("UIStroke")
			if stroke then
				TweenService:Create(stroke, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
					Color = getRarityColor(item.Rarity),
					Thickness = 1.5
				}):Play()
			end
			
			-- Clear hover tooltip
			clearHoverTooltip()
		end)
	end
end

--------------------------------------------------------------------------------
-- MAIN GUI
--------------------------------------------------------------------------------

local function createBackpackHUD()
	local screen = Instance.new("ScreenGui")
	screen.Name = "BackpackHUD"
	screen.ResetOnSpawn = false
	screen.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	
	local panel = Instance.new("Frame")
	panel.Name = "MainPanel"
	panel.Size = UDim2.new(0, UI_CONFIG.PANEL_WIDTH, 0, UI_CONFIG.PANEL_HEIGHT)
	panel.Position = UDim2.new(0.5, 0, 0.5, 0)
	panel.AnchorPoint = Vector2.new(0.5, 0.5)
	panel.BackgroundColor3 = UI_CONFIG.COLOR_PANEL
	panel.Visible = false
	panel.Parent = screen
	addCorner(panel, UI_CONFIG.CORNER_RADIUS)
	addStroke(panel, Color3.fromRGB(60,60,80), 2)
	
	-- Header
	local header = Instance.new("Frame")
	header.Size = UDim2.new(1, 0, 0, 50)
	header.BackgroundTransparency = 1
	header.Parent = panel
	
	local title = Instance.new("TextLabel")
	title.Text = "ðŸŽ’ BACKPACK"
	title.Font = Enum.Font.GothamBold
	title.TextSize = 24
	title.TextColor3 = UI_CONFIG.COLOR_TEXT
	title.Size = UDim2.new(1, -60, 1, 0)
	title.Position = UDim2.new(0, 20, 0, 0)
	title.TextXAlignment = Enum.TextXAlignment.Left
	title.BackgroundTransparency = 1
	title.Parent = header
	
	local closeBtn = Instance.new("TextButton")
	closeBtn.Text = "âœ•"
	closeBtn.TextSize = 24
	closeBtn.TextColor3 = Color3.fromRGB(200, 80, 80)
	closeBtn.Size = UDim2.new(0, 40, 0, 40)
	closeBtn.Position = UDim2.new(1, -50, 0, 5)
	closeBtn.BackgroundTransparency = 1
	closeBtn.Font = Enum.Font.GothamBold
	closeBtn.Parent = header
	closeBtn.MouseButton1Click:Connect(function()
		BackpackVisible = false
		panel.Visible = false
		local popup = screen:FindFirstChild("DetailPopup")
		if popup then popup:Destroy() end
	end)
	
	-- Filter Tabs
	local tabsFrame = Instance.new("Frame")
	tabsFrame.Size = UDim2.new(1, -40, 0, 36)
	tabsFrame.Position = UDim2.new(0, 20, 0, 50)
	tabsFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 30)
	tabsFrame.Parent = panel
	addCorner(tabsFrame, 8)
	
	local tabLayout = Instance.new("UIListLayout")
	tabLayout.FillDirection = Enum.FillDirection.Horizontal
	tabLayout.Parent = tabsFrame
	
	local function createTab(name, filter)
		local t = Instance.new("TextButton")
		t.Text = name
		t.Size = UDim2.new(0.25, 0, 1, 0)
		t.BackgroundTransparency = 1
		t.TextColor3 = UI_CONFIG.COLOR_TEXT
		t.TextSize = 11
		t.Font = Enum.Font.GothamBold
		t.Parent = tabsFrame
		
		t.MouseButton1Click:Connect(function()
			CurrentFilter = filter
			-- Visual update for tabs could go here
			refreshGrid()
		end)
	end
	
	createTab("ALL", "All")
	createTab("UNITS", "Unit")
	createTab("ARTIFACTS", "Artifact")
	createTab("STORAGE", "Storage")
	
	-- Grid Scroll
	local scroll = Instance.new("ScrollingFrame")
	scroll.Name = "Grid"
	scroll.Size = UDim2.new(1, -40, 1, -110)
	scroll.Position = UDim2.new(0, 20, 0, 100)
	scroll.BackgroundTransparency = 1
	scroll.ScrollBarThickness = 6
	scroll.Parent = panel
	
	local gridLayout = Instance.new("UIGridLayout")
	gridLayout.CellSize = UDim2.new(0, UI_CONFIG.SLOT_SIZE, 0, UI_CONFIG.SLOT_SIZE)
	gridLayout.CellPadding = UDim2.new(0, UI_CONFIG.GRID_PADDING, 0, UI_CONFIG.GRID_PADDING)
	gridLayout.Parent = scroll
	
	return screen
end

--------------------------------------------------------------------------------
-- LOGIC
--------------------------------------------------------------------------------

local function loadInventory()
	local items = GetUnifiedInventoryFunc:InvokeServer()
	if items then
		CurrentItems = items
		refreshGrid()
	end
end

local function toggleBackpack(filterOverride)
	BackpackVisible = not BackpackVisible
	-- If opening with a specific filter, ensure it's visible and set filter
	if filterOverride and typeof(filterOverride) == "string" then
		CurrentFilter = filterOverride
		BackpackVisible = true -- Force open if filter provided
	end

	if not BackpackGui then
		BackpackGui = createBackpackHUD()
		BackpackGui.Parent = PlayerGui
	end
	
	local panel = BackpackGui:FindFirstChild("MainPanel")
	panel.Visible = BackpackVisible
	
	if BackpackVisible then
		loadInventory()
	end
end

-- Events
local BackpackToggleEvent = ReplicatedStorage:FindFirstChild("BackpackToggleEvent")
if not BackpackToggleEvent then
	BackpackToggleEvent = Instance.new("BindableEvent")
	BackpackToggleEvent.Name = "BackpackToggleEvent"
	BackpackToggleEvent.Parent = ReplicatedStorage
end
BackpackToggleEvent.Event:Connect(toggleBackpack)

-- Listen for updates from Server-side InventoryService? 
-- The plan said "InventoryChanged" (Units) and "ArtifactDropped" (Artifacts).
-- Let's listen to those and re-fetch if Backpack is open.

local function onUpdate()
	if BackpackVisible then
		loadInventory()
	end
end

local InventoryChanged = RemoteEvents:FindFirstChild("InventoryChanged")
if InventoryChanged then InventoryChanged.OnClientEvent:Connect(onUpdate) end

local ArtifactDropped = RemoteEvents:FindFirstChild("ArtifactDropped")
if ArtifactDropped then ArtifactDropped.OnClientEvent:Connect(onUpdate) end

-- Listen for storage updates to refresh when in Storage tab
StorageUpdatedEvent.OnClientEvent:Connect(function()
	if BackpackVisible and CurrentFilter == "Storage" then
		refreshGrid()
	end
end)

-- Auto-refresh timer for Storage tab (every 2 seconds)
task.spawn(function()
	while true do
		task.wait(2)
		if BackpackVisible and CurrentFilter == "Storage" then
			refreshGrid()
		end
	end
end)


================================================================================
FILE: src\client\BuildModeUI.client.luau
================================================================================

--[[
	BuildModeUI Client Script
	
	"Architect Overlay" interface for placing and arranging brainrots.
	
	Features:
	- Press TAB to enter/exit Build Mode
	- Isometric camera view of plot
	- Grid visualization
	- KINEMATIC DRAG AND DROP (TFT Style)
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local CollectionService = game:GetService("CollectionService")

-- Shared Configs
local Shared = ReplicatedStorage:WaitForChild("Shared")
local TileConfig = require(Shared:WaitForChild("TileConfig"))
local ArtifactConfig = require(Shared:WaitForChild("ArtifactConfig"))

-- Player
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- Wait for remotes
local RemoteFunctions = ReplicatedStorage:WaitForChild("RemoteFunctions")
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")

local EnterBuildMode = RemoteFunctions:WaitForChild("EnterBuildMode")
local ExitBuildMode = RemoteFunctions:WaitForChild("ExitBuildMode")
local GetGrid = RemoteFunctions:WaitForChild("GetGrid")
local MoveUnit = RemoteFunctions:WaitForChild("MoveUnit")
local SwapUnits = RemoteFunctions:WaitForChild("SwapUnits")

-- Inventory remotes (RemoteFunctions but parented to RemoteEvents folder)
local GetInventoryRemote = RemoteEvents:WaitForChild("GetInventory")
local PlaceBrainrotRemote = RemoteEvents:WaitForChild("PlaceBrainrot")
local RemoveBrainrotRemote = RemoteEvents:WaitForChild("RemoveBrainrot")

-- Tile remotes
local PlaceTileRemote = RemoteFunctions:WaitForChild("PlaceTile")
local RemoveTileRemote = RemoteFunctions:WaitForChild("RemoveTile")

-- State
local currentTab = "Units" -- "Units" or "Tiles"
local tileList = {} -- To be populated from TileConfig

-- Events
local InventoryChangedEvent = RemoteEvents:WaitForChild("InventoryChanged")
local _BuildModeChangedEvent = RemoteEvents:WaitForChild("BuildModeChanged")
local GridUpdatedEvent = RemoteEvents:WaitForChild("GridUpdated")

-- Configuration
local CONFIG = {
	-- Camera
	CAMERA_HEIGHT = 60,
	CAMERA_ANGLE = 45, -- degrees from horizontal
	CAMERA_TWEEN_TIME = 0.5,
	
	-- Grid
	TILE_SIZE = 10,
	TILE_HEIGHT = 0.1,
	
	-- Drag Physics (TFT Feel)
	DRAG_HEIGHT = 4.0,       -- How high it hovers when dragging
	DRAG_SMOOTHNESS = 20.0,  -- Position Lerp speed (Higher = Snappier, Lower = Heavier)
	TILT_STRENGTH = 0.3,     -- How much it tilts when moving
	TILT_RETURN_SPEED = 10.0,-- How fast it straightens up
	MAX_TILT_ANGLE = 25,     -- Max degrees of tilt
	
	-- Colors (more subtle)
	EMPTY_COLOR = Color3.fromRGB(100, 100, 150),
	OCCUPIED_COLOR = Color3.fromRGB(80, 200, 80),
	HOVER_COLOR = Color3.fromRGB(100, 200, 255),
	SELECTED_COLOR = Color3.fromRGB(255, 200, 50),
	INVALID_COLOR = Color3.fromRGB(255, 80, 80),
	SYNERGY_COLOR = Color3.fromRGB(200, 100, 255),
	
	-- UI
	TOOLBAR_HEIGHT = 80,
	BUTTON_SIZE = 60,
	INVENTORY_WIDTH = 220,
	
	-- Rarity colors
	RARITY_COLORS = {
		Normal = Color3.fromRGB(180, 180, 180),
		Spicy = Color3.fromRGB(255, 80, 80),
		Galaxy = Color3.fromRGB(180, 100, 255),
	},
	
	-- Modern Dark Theme (MoneyHUD Style)
	THEME_BG = Color3.fromRGB(20, 20, 30),
	THEME_STROKE = Color3.fromRGB(50, 50, 70),
	THEME_ACCENT_PURPLE = Color3.fromRGB(80, 60, 140),
	THEME_ACCENT_PINK = Color3.fromRGB(140, 80, 160),
	THEME_ACCENT_GOLD = Color3.fromRGB(200, 150, 60),
	THEME_ACCENT_BLUE = Color3.fromRGB(80, 160, 200),
	THEME_ACCENT_GREEN = Color3.fromRGB(100, 255, 100), -- For valid
	THEME_TEXT_PRIMARY = Color3.fromRGB(255, 255, 255),
	THEME_TEXT_SECONDARY = Color3.fromRGB(180, 180, 180),
	THEME_PANEL_RADIUS = 16,
	THEME_BUTTON_RADIUS = 6,
}

-- State
local isInBuildMode = false
local savedCameraCFrame = nil
local gridTiles = {}
local gridContainer = nil
local buildModeGui = nil
local selectedSlot = nil
local hoveredSlot = nil
local isDragging = false
local currentHoverConnection = nil
local gridFloorHeight = 0 -- Detected automatically

-- Drag-drop state
local draggedUnit = nil  -- {name: string, rarity: string}
local inventoryPanel = nil
local inventoryData = {}  -- {[unitName]: {[rarity]: {total, active}}}

-- Placement ghost state
local placementGhost = nil  -- The ghost model in workspace
local ghostPulseTween = nil  -- Current pulse tween
local isGhostValid = false  -- Is ghost in a valid position
local dragConnection = nil  -- Mouse move connection during drag
local ghostCenterOffset = Vector3.new() -- Offset from pivot to bounding box center

-- Modules
local ViewportPreview = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("ViewportPreview"))

-- Model folder for 3D previews
local BrainrotsFolder = ReplicatedStorage:WaitForChild("Brainrots")

-- Track inventory previews for cleanup
local inventoryPreviews = {}
-- Forward declarations
local exitBuildModeLocal
local refreshInventoryPanel
local getSlotUnderMouse
local renderBuildGrid
local startDrag
local startTileDrag
local completeDrop

-- Helper for rounded stroke panels (MoneyHUD style)
local function _stylePanel(frame, radius)
	frame.BackgroundColor3 = CONFIG.THEME_BG
	frame.BackgroundTransparency = 0.1 -- Slight transparency like MoneyHUD
	frame.BorderSizePixel = 0
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, radius or CONFIG.THEME_PANEL_RADIUS)
	corner.Parent = frame
	
	local stroke = Instance.new("UIStroke")
	stroke.Color = CONFIG.THEME_STROKE
	stroke.Thickness = 2
	stroke.Parent = frame
	return frame
end

-- Camera reference
local camera = workspace.CurrentCamera

--------------------------------------------------------------------------------
-- GRID VISUALIZATION
--------------------------------------------------------------------------------

--[[
	Finds all plots owned by the player.
]]
local function findAllPlayerPlots()
	local plots = {}
	local plotsFolder = workspace:FindFirstChild("Plots")
	if not plotsFolder then return plots end
	
	for _, plot in plotsFolder:GetChildren() do
		if plot:GetAttribute("OwnerId") == LocalPlayer.UserId then
			table.insert(plots, plot)
		end
	end
	
	return plots
end

--[[
	Finds the island/plot the player is currently standing on.
	Uses raycast detection from player position.
]]
local function findCurrentIsland()
	local character = LocalPlayer.Character
	if not character then return nil end
	
	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	if not humanoidRootPart then return nil end
	
	local playerPos = humanoidRootPart.Position
	
	-- Get all player's plots
	local playerPlots = findAllPlayerPlots()
	if #playerPlots == 0 then return nil end
	
	-- Find which plot the player is standing on
	local closestPlot = nil
	local closestDistance = math.huge
	
	for _, plot in playerPlots do
		local floor = plot:FindFirstChild("Island") 
			or plot:FindFirstChild("PlotFloor") 
			or plot:FindFirstChild("Floor")
			or plot:FindFirstChildWhichIsA("BasePart")
		
		if floor then
			local floorPos = floor.Position
			local floorSize = floor.Size
			
			-- Check if player is within the plot bounds (XZ)
			local dx = math.abs(playerPos.X - floorPos.X)
			local dz = math.abs(playerPos.Z - floorPos.Z)
			
			if dx <= floorSize.X / 2 + 10 and dz <= floorSize.Z / 2 + 10 then
				-- Player is on or near this plot
				local distance = (playerPos - floorPos).Magnitude
				if distance < closestDistance then
					closestDistance = distance
					closestPlot = plot
				end
			end
		end
	end
	
	-- If not standing on any, return first plot as fallback
	if not closestPlot and #playerPlots > 0 then
		closestPlot = playerPlots[1]
	end
	
	return closestPlot
end

--[[
	Finds the player's plot (for backwards compatibility - returns current island).
]]
local function findPlayerPlot()
	return findCurrentIsland()
end

--[[
	Creates a grid tile part (invisible, outline-only for selection).
]]
local function createGridTile(slotIndex, position, isOccupied, unitName)
	local tile = Instance.new("Part")
	tile.Name = "BuildTile_" .. slotIndex
	tile.Size = Vector3.new(CONFIG.TILE_SIZE - 0.5, CONFIG.TILE_HEIGHT, CONFIG.TILE_SIZE - 0.5)
	tile.Position = position
	tile.Anchored = true
	tile.CanCollide = false
	tile.Transparency = 1  -- Fully invisible
	tile:SetAttribute("SlotIndex", slotIndex)
	tile:SetAttribute("IsOccupied", isOccupied)
	tile:SetAttribute("UnitName", unitName)
	
	-- Add border/outline effect (this is all we show)
	local selectionBox = Instance.new("SelectionBox")
	selectionBox.Name = "Outline"
	selectionBox.Adornee = tile
	selectionBox.Color3 = isOccupied and CONFIG.OCCUPIED_COLOR or CONFIG.EMPTY_COLOR
	selectionBox.LineThickness = 0.03
	selectionBox.Transparency = 0.3
	selectionBox.Parent = tile
	
	-- Slot number label (small, only for empty slots)
	if not isOccupied then
		local billboard = Instance.new("BillboardGui")
		billboard.Name = "SlotLabel"
		billboard.Size = UDim2.new(1, 0, 0.5, 0)
		billboard.StudsOffset = Vector3.new(0, 0.5, 0)
		billboard.AlwaysOnTop = false
		billboard.Parent = tile
		
		local label = Instance.new("TextLabel")
		label.Size = UDim2.new(1, 0, 1, 0)
		label.BackgroundTransparency = 1
		label.Text = tostring(slotIndex)
		label.TextColor3 = Color3.fromRGB(150, 150, 150)
		label.TextScaled = true
		label.Font = Enum.Font.Gotham
		label.TextStrokeTransparency = 0.5
		label.TextStrokeColor3 = Color3.new(0, 0, 0)
		label.Parent = billboard
	end
	
	return tile
end

--[[
	Renders the build mode grid using 4 corner clusters.
]]
renderBuildGrid = function()
	-- Get grid state from server (for tracking occupancy)
	local gridState = GetGrid:InvokeServer()
	if not gridState then return end
	
	local plot = findPlayerPlot()
	if not plot then return end
	
	-- Get plot info
	local floor = plot:FindFirstChild("Island") 
		or plot:FindFirstChild("PlotFloor") 
		or plot:FindFirstChild("Floor")
		or plot:FindFirstChildWhichIsA("BasePart")
	
	if not floor then return end
	
	local plotCenter = floor.Position
	local plotSize = floor.Size
	local plotTop = Vector3.new(plotCenter.X, plotCenter.Y + plotSize.Y/2, plotCenter.Z)
	local gridY = plotTop.Y + 0.5
	gridFloorHeight = gridY -- Store for physics raycasting
	
	-- Clear any old grid container
	if gridContainer then
		gridContainer:Destroy()
	end
	
	gridContainer = Instance.new("Folder")
	gridContainer.Name = "BuildModeGrid"
	gridContainer.Parent = workspace
	
	-- Clear old tiles
	gridTiles = {}
	
	-- Corner cluster configuration (matches server)
	local CLUSTER_SIZE = 2  -- 2x2 per corner
	local TILE_SPACING = CONFIG.TILE_SIZE
	
	-- Calculate corner offsets (distance from center to corner cluster center)
	local cornerOffsetX = (plotSize.X / 2) - (CLUSTER_SIZE * TILE_SPACING / 2) - TILE_SPACING
	local cornerOffsetZ = (plotSize.Z / 2) - (CLUSTER_SIZE * TILE_SPACING / 2) - TILE_SPACING
	
	-- Corner base positions (relative to plot center)
	local cornerPositions = {
		{x = -cornerOffsetX, z = -cornerOffsetZ},  -- Top-left (slots 1-4)
		{x = cornerOffsetX, z = -cornerOffsetZ},   -- Top-right (slots 5-8)
		{x = -cornerOffsetX, z = cornerOffsetZ},   -- Bottom-left (slots 9-12)
		{x = cornerOffsetX, z = cornerOffsetZ},    -- Bottom-right (slots 13-16)
	}
	
	-- Create 16 tiles (4 corners x 4 slots each)
	for slotIndex = 1, 16 do
		local cornerIndex = math.floor((slotIndex - 1) / 4)
		local posInCorner = (slotIndex - 1) % 4
		
		local localRow = math.floor(posInCorner / 2)
		local localCol = posInCorner % 2
		
		local corner = cornerPositions[cornerIndex + 1]
		
		local posX = plotCenter.X + corner.x + (localCol - 0.5) * TILE_SPACING
		local posZ = plotCenter.Z + corner.z + (localRow - 0.5) * TILE_SPACING
		
		-- Handle new layered slot format: {unitType = string?, tileId = string?}
		local slotData = gridState.slots[slotIndex]
		local unitName = nil
		
		if type(slotData) == "table" then
			unitName = slotData.unitType
		elseif type(slotData) == "string" then
			unitName = slotData
		end
		
		local isOccupied = unitName ~= nil
		local tile = createGridTile(slotIndex, Vector3.new(posX, gridY, posZ), isOccupied, unitName)
		tile.Parent = gridContainer
		
		gridTiles[slotIndex] = tile
	end
	
	print("BuildModeUI: Rendered 16 grid tiles (4 corners x 4 slots)")
	return plotTop
end

--[[
	Destroys the build grid.
]]
local function destroyBuildGrid()
	if gridContainer then
		gridContainer:Destroy()
		gridContainer = nil
		gridTiles = {}
	end
end

--[[
	Highlights a tile.
]]
local function highlightTile(slotIndex, color)
	local tile = gridTiles[slotIndex]
	if not tile then return end
	
	TweenService:Create(tile, TweenInfo.new(0.1), {
		Color = color,
		Transparency = 0.3
	}):Play()
	
	local outline = tile:FindFirstChild("Outline")
	if outline then
		outline.Color3 = color
		outline.Transparency = 0
	end
end

--[[
	Unhighlights a tile.
]]
local function unhighlightTile(slotIndex)
	local tile = gridTiles[slotIndex]
	if not tile then return end
	
	local isOccupied = tile:GetAttribute("IsOccupied")
	TweenService:Create(tile, TweenInfo.new(0.1), {
		Color = isOccupied and CONFIG.OCCUPIED_COLOR or CONFIG.EMPTY_COLOR,
		Transparency = 0.85
	}):Play()
	
	local outline = tile:FindFirstChild("Outline")
	if outline then
		outline.Color3 = Color3.fromRGB(200, 200, 200)
		outline.Transparency = 0.5
	end
end

--------------------------------------------------------------------------------
-- CAMERA CONTROLS
--------------------------------------------------------------------------------

--[[
	Tweens camera to isometric build view.
]]
local function tweenToIsometricView(plotCenter)
	savedCameraCFrame = camera.CFrame
	
	-- Calculate isometric camera position
	local angleRad = math.rad(CONFIG.CAMERA_ANGLE)
	local distance = CONFIG.CAMERA_HEIGHT / math.sin(angleRad)
	
	-- Position camera above and slightly back
	local cameraPos = plotCenter + Vector3.new(0, CONFIG.CAMERA_HEIGHT, distance * math.cos(angleRad))
	local targetCFrame = CFrame.new(cameraPos, plotCenter)
	
	-- Switch to scriptable camera
	camera.CameraType = Enum.CameraType.Scriptable
	
	-- Tween to position
	local tween = TweenService:Create(camera, TweenInfo.new(CONFIG.CAMERA_TWEEN_TIME, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		CFrame = targetCFrame
	})
	tween:Play()
	
	print("BuildModeUI: Camera tweened to isometric view")
end

--[[
	Tweens camera back to player view.
]]
local function tweenToPlayerView()
	if not savedCameraCFrame then return end
	
	-- Tween back
	local tween = TweenService:Create(camera, TweenInfo.new(CONFIG.CAMERA_TWEEN_TIME, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		CFrame = savedCameraCFrame
	})
	tween:Play()
	
	tween.Completed:Connect(function()
		camera.CameraType = Enum.CameraType.Custom
		savedCameraCFrame = nil
	end)
	
	print("BuildModeUI: Camera returned to player view")
end

--------------------------------------------------------------------------------
-- BUILD MODE UI
--------------------------------------------------------------------------------

--[[
	Updates the status text.
]]
local function updateStatus(text)
	if not buildModeGui then return end
	local bottomBar = buildModeGui:FindFirstChild("BottomBar")
	if bottomBar then
		local status = bottomBar:FindFirstChild("Status")
		if status then
			status.Text = text
		end
	end
end

--[[
	Creates the build mode UI overlay with Roblox STUD theme.
]]
local function createBuildModeUI()
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "BuildModeUI"
	screenGui.ResetOnSpawn = false
	screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	screenGui.DisplayOrder = 100
	
	-- Top bar (transparent container)
	local topBar = Instance.new("Frame")
	topBar.Name = "TopBar"
	topBar.Size = UDim2.new(1, 0, 0, 50)
	topBar.Position = UDim2.new(0, 0, 0, 0)
	topBar.BackgroundTransparency = 1
	topBar.BorderSizePixel = 0
	topBar.Parent = screenGui
	
	-- BUILD MODE title badge
	local titleContainer = Instance.new("Frame")
	titleContainer.Name = "TitleContainer"
	titleContainer.Size = UDim2.new(0, 160, 0, 32)
	titleContainer.Position = UDim2.new(0, 140, 0.5, -16)
	titleContainer.BackgroundColor3 = CONFIG.THEME_ACCENT_PINK
	titleContainer.BorderSizePixel = 0
	titleContainer.Parent = topBar
	
	local titleCorner = Instance.new("UICorner")
	titleCorner.CornerRadius = UDim.new(0, CONFIG.THEME_BUTTON_RADIUS)
	titleCorner.Parent = titleContainer
	
	local title = Instance.new("TextLabel")
	title.Name = "Title"
	title.Size = UDim2.new(1, 0, 1, 0)
	title.Position = UDim2.new(0, 0, 0, 0)
	title.BackgroundTransparency = 1
	title.Text = "ðŸ—ï¸ BUILD MODE"
	title.TextColor3 = CONFIG.THEME_TEXT_PRIMARY
	title.TextSize = 14
	title.Font = Enum.Font.GothamBold
	title.Parent = titleContainer
	
	-- Instructions
	local instructions = Instance.new("TextLabel")
	instructions.Name = "Instructions"
	instructions.Size = UDim2.new(0, 400, 1, 0)
	instructions.Position = UDim2.new(0.5, -200, 0, 0)
	instructions.BackgroundTransparency = 1
	instructions.Text = "Click to select â€¢ Drag to move"
	instructions.TextColor3 = CONFIG.THEME_TEXT_SECONDARY
	instructions.TextSize = 14
	instructions.Font = Enum.Font.GothamBold
	instructions.Parent = topBar
	
	-- Exit button (Matching theme style)
	local exitButton = Instance.new("TextButton")
	exitButton.Name = "ExitButton"
	exitButton.Size = UDim2.new(0, 90, 0, 36)
	exitButton.Position = UDim2.new(1, -105, 0.5, -18)
	exitButton.BackgroundColor3 = CONFIG.THEME_ACCENT_PURPLE -- Matching theme button color
	exitButton.Text = "EXIT"
	exitButton.TextColor3 = CONFIG.THEME_TEXT_PRIMARY
	exitButton.TextSize = 14
	exitButton.Font = Enum.Font.GothamBold
	exitButton.Parent = topBar
	
	local exitCorner = Instance.new("UICorner")
	exitCorner.CornerRadius = UDim.new(0, CONFIG.THEME_BUTTON_RADIUS)
	exitCorner.Parent = exitButton
	
	-- Hover effect
	exitButton.MouseEnter:Connect(function()
		TweenService:Create(exitButton, TweenInfo.new(0.1), {
			BackgroundColor3 = CONFIG.THEME_ACCENT_PURPLE:Lerp(Color3.new(1,1,1), 0.1)
		}):Play()
	end)
	
	exitButton.MouseLeave:Connect(function()
		TweenService:Create(exitButton, TweenInfo.new(0.1), {
			BackgroundColor3 = CONFIG.THEME_ACCENT_PURPLE
		}):Play()
	end)
	
	-- Status bar at bottom (transparent container)
	local bottomBar = Instance.new("Frame")
	bottomBar.Name = "BottomBar"
	bottomBar.Size = UDim2.new(1, 0, 0, 36)
	bottomBar.Position = UDim2.new(0, 0, 1, -36)
	bottomBar.BackgroundTransparency = 1
	bottomBar.BorderSizePixel = 0
	bottomBar.Parent = screenGui
	
	-- Status text
	local statusLabel = Instance.new("TextLabel")
	statusLabel.Name = "Status"
	statusLabel.Size = UDim2.new(1, -40, 1, 0)
	statusLabel.Position = UDim2.new(0, 20, 0, 0)
	statusLabel.BackgroundTransparency = 1
	statusLabel.Text = "Editing Plot - Click tile or drag from inventory"
	statusLabel.TextColor3 = CONFIG.THEME_TEXT_PRIMARY
	statusLabel.TextSize = 14
	statusLabel.Font = Enum.Font.GothamBold
	statusLabel.TextXAlignment = Enum.TextXAlignment.Left
	statusLabel.Parent = bottomBar
	

	
	return screenGui
end



--------------------------------------------------------------------------------
-- INVENTORY PANEL (for Build Mode)
--------------------------------------------------------------------------------

local RARITY_ORDER = {"Normal", "Spicy", "Galaxy"}
local inventoryItems = {}  -- UI item frames

--[[
	Creates the inventory panel for Build Mode with Tabs.
]]
local function createInventoryPanel(parent)
	local panel = Instance.new("Frame")
	panel.Name = "InventoryPanel"
	panel.Size = UDim2.new(0, CONFIG.INVENTORY_WIDTH, 1, -110)
	panel.Position = UDim2.new(0, 10, 0, 60)
	_stylePanel(panel)
	panel.Parent = parent
	
	-- Tab Container
	local tabContainer = Instance.new("Frame")
	tabContainer.Name = "TabContainer"
	tabContainer.Size = UDim2.new(1, -20, 0, 36)
	tabContainer.Position = UDim2.new(0, 10, 0, 10)
	tabContainer.BackgroundTransparency = 1
	tabContainer.Parent = panel
	
	-- Units Tab Button
	local unitsBtn = Instance.new("TextButton")
	unitsBtn.Name = "UnitsButton"
	unitsBtn.Size = UDim2.new(0.5, -5, 1, 0)
	unitsBtn.Position = UDim2.new(0, 0, 0, 0)
	unitsBtn.BackgroundColor3 = currentTab == "Units" and CONFIG.THEME_ACCENT_PURPLE or Color3.fromRGB(40,40,50)
	unitsBtn.Text = "ðŸ§  UNITS"
	unitsBtn.TextColor3 = CONFIG.THEME_TEXT_PRIMARY
	unitsBtn.TextSize = 12
	unitsBtn.Font = Enum.Font.GothamBold
	unitsBtn.Parent = tabContainer
	
	local uCorner = Instance.new("UICorner")
	uCorner.CornerRadius = UDim.new(0, 6)
	uCorner.Parent = unitsBtn
	
	-- Tiles Tab Button
	local tilesBtn = Instance.new("TextButton")
	tilesBtn.Name = "TilesButton"
	tilesBtn.Size = UDim2.new(0.5, -5, 1, 0)
	tilesBtn.Position = UDim2.new(0.5, 5, 0, 0)
	tilesBtn.BackgroundColor3 = currentTab == "Tiles" and CONFIG.THEME_ACCENT_PINK or Color3.fromRGB(40,40,50)
	tilesBtn.Text = "ðŸ§± TILES"
	tilesBtn.TextColor3 = CONFIG.THEME_TEXT_PRIMARY
	tilesBtn.TextSize = 12
	tilesBtn.Font = Enum.Font.GothamBold
	tilesBtn.Parent = tabContainer
	
	local tCorner = Instance.new("UICorner")
	tCorner.CornerRadius = UDim.new(0, 6)
	tCorner.Parent = tilesBtn
	
	-- Tab Logic
	unitsBtn.MouseButton1Click:Connect(function()
		currentTab = "Units"
		unitsBtn.BackgroundColor3 = CONFIG.THEME_ACCENT_PURPLE
		tilesBtn.BackgroundColor3 = Color3.fromRGB(40,40,50)
		refreshInventoryPanel()
	end)
	
	tilesBtn.MouseButton1Click:Connect(function()
		currentTab = "Tiles"
		tilesBtn.BackgroundColor3 = CONFIG.THEME_ACCENT_PINK
		unitsBtn.BackgroundColor3 = Color3.fromRGB(40,40,50)
		refreshInventoryPanel()
	end)

	-- Scrolling frame for items
	local scrollFrame = Instance.new("ScrollingFrame")
	scrollFrame.Name = "ItemsList"
	scrollFrame.Size = UDim2.new(1, -20, 1, -60)
	scrollFrame.Position = UDim2.new(0, 10, 0, 55)
	scrollFrame.BackgroundTransparency = 1
	scrollFrame.BorderSizePixel = 0
	scrollFrame.ScrollBarThickness = 4
	scrollFrame.ScrollBarImageColor3 = CONFIG.THEME_ACCENT_PURPLE
	scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
	scrollFrame.Parent = panel
	
	local listLayout = Instance.new("UIListLayout")
	listLayout.SortOrder = Enum.SortOrder.LayoutOrder -- Changed to manual order
	listLayout.Padding = UDim.new(0, 8)
	listLayout.Parent = scrollFrame
	
	-- Auto-resize canvas
	listLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
		scrollFrame.CanvasSize = UDim2.new(0, 0, 0, listLayout.AbsoluteContentSize.Y + 10)
	end)
	
	inventoryPanel = panel
	return panel;
end

--[[
	Populates the inventory panel with stored units.
	Called when entering build mode and after placing/removing units.
]]
--[[
	Gets the brainrot model from ReplicatedStorage.
]]
local function getBrainrotModel(unitName: string): Model?
	-- Check main Brainrots folder first
	if BrainrotsFolder then
		local model = BrainrotsFolder:FindFirstChild(unitName)
		if model then return model end
	end
	
	-- Fallback: Check Units folder
	local unitsFolder = ReplicatedStorage:FindFirstChild("Units")
	if unitsFolder then
		local model = unitsFolder:FindFirstChild(unitName)
		if model then return model end
	end
	
	-- Fallback: Check Assets/Brainrots
	local assetsFolder = ReplicatedStorage:FindFirstChild("Assets")
	if assetsFolder then
		local brainrotsSubfolder = assetsFolder:FindFirstChild("Brainrots")
		if brainrotsSubfolder then
			local model = brainrotsSubfolder:FindFirstChild(unitName)
			if model then return model end
		end
	end
	
	return nil
end

--[[
	Populates the inventory panel with stored units.
	Called when entering build mode and after placing/removing units.
]]
local isRefreshingInventory = false -- Debounce lock

refreshInventoryPanel = function()
	if not inventoryPanel then return end
	
	-- Debounce: Skip if already refreshing (prevents race condition duplicates)
	if isRefreshingInventory then return end
	isRefreshingInventory = true
	
	local scrollFrame = inventoryPanel:FindFirstChild("ItemsList")
	if not scrollFrame then 
		isRefreshingInventory = false
		return 
	end
	
	-- Fetch inventory from server FIRST (async operation)
	local success, inventory = pcall(function()
		return GetInventoryRemote:InvokeServer()
	end)
	
	-- Clear and rebuild AFTER server returns (prevents race condition)
	-- Clear old entries (destroy everything except UIListLayout)
	for _, child in scrollFrame:GetChildren() do
		if not child:IsA("UIListLayout") then
			child:Destroy()
		end
	end
	inventoryItems = {}
	
	-- Clean up old previews
	for _, previewFrame in pairs(inventoryPreviews) do
		if previewFrame and previewFrame.Parent then
			previewFrame:Destroy()
		end
	end
	inventoryPreviews = {}
	
	if not success then 
		isRefreshingInventory = false
		return 
	end
	
	if currentTab == "Units" then
		if not inventory or not inventory.units then return end
		
		-- Create an entry for each unit that is STORED (not placed)
		for unitName, unitData in pairs(inventory.units) do
			if unitData.status == "stored" and (unitData.level or 0) > 0 then

			local rarityColor = CONFIG.RARITY_COLORS[unitData.rarity] or CONFIG.THEME_TEXT_SECONDARY
			
			-- Card container (Modern Style)
			local itemFrame = Instance.new("Frame")
			itemFrame.Name = "Item_" .. unitName
			itemFrame.Size = UDim2.new(1, 0, 0, 90) -- Slightly taller for new layout
			itemFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 50) -- Dark inner panel
			itemFrame.BorderSizePixel = 0
			itemFrame.Parent = scrollFrame
			
			local corner = Instance.new("UICorner")
			corner.CornerRadius = UDim.new(0, CONFIG.THEME_BUTTON_RADIUS)
			corner.Parent = itemFrame
			
			-- Viewport (Preview)
			local viewport = Instance.new("ViewportFrame")
			viewport.Name = "Preview"
			viewport.Size = UDim2.new(0, 70, 0, 70)
			viewport.Position = UDim2.new(0, 10, 0, 10)
			viewport.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
			viewport.BorderSizePixel = 0
			viewport.Parent = itemFrame
			
			local viewCorner = Instance.new("UICorner")
			viewCorner.CornerRadius = UDim.new(0, CONFIG.THEME_BUTTON_RADIUS)
			viewCorner.Parent = viewport
			
			-- Info Group
			local infoGroup = Instance.new("Frame")
			infoGroup.Name = "Info"
			infoGroup.Size = UDim2.new(1, -90, 1, 0)
			infoGroup.Position = UDim2.new(0, 90, 0, 0)
			infoGroup.BackgroundTransparency = 1
			infoGroup.Parent = itemFrame
			
			-- Unit Name
			local nameLabel = Instance.new("TextLabel")
			nameLabel.Name = "Name"
			nameLabel.Size = UDim2.new(1, 0, 0, 20)
			nameLabel.Position = UDim2.new(0, 0, 0, 10)
			nameLabel.BackgroundTransparency = 1
			nameLabel.Text = unitName
			nameLabel.TextColor3 = CONFIG.THEME_TEXT_PRIMARY
			nameLabel.TextSize = 14
			nameLabel.Font = Enum.Font.GothamBold
			nameLabel.TextXAlignment = Enum.TextXAlignment.Left
			nameLabel.TextTruncate = Enum.TextTruncate.AtEnd
			nameLabel.Parent = infoGroup
			
			-- Level / Rarity
			local rarityLabel = Instance.new("TextLabel")
			rarityLabel.Name = "Rarity"
			rarityLabel.Size = UDim2.new(1, 0, 0, 16)
			rarityLabel.Position = UDim2.new(0, 0, 0, 30)
			rarityLabel.BackgroundTransparency = 1
			rarityLabel.Text = string.format("Lvl %d â€¢ %s", unitData.level or 1, unitData.rarity or "Normal")
			rarityLabel.TextColor3 = rarityColor
			rarityLabel.TextSize = 11
			rarityLabel.Font = Enum.Font.Gotham
			rarityLabel.TextXAlignment = Enum.TextXAlignment.Left
			rarityLabel.Parent = infoGroup
			
			-- HP Label
			local hpLabel = Instance.new("TextLabel")
			hpLabel.Name = "HP"
			hpLabel.Size = UDim2.new(1, 0, 0, 16)
			hpLabel.Position = UDim2.new(0, 0, 0, 46)
			hpLabel.BackgroundTransparency = 1
			hpLabel.Text = "â¤ï¸ " .. tostring((unitData.level or 1) * 10 + 25) -- Example HP calculation
			hpLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
			hpLabel.TextSize = 11
			hpLabel.Font = Enum.Font.GothamBold
			hpLabel.TextXAlignment = Enum.TextXAlignment.Left
			hpLabel.Parent = infoGroup
			
			-- Full-card drag overlay (click anywhere to drag)
			local dragOverlay = Instance.new("TextButton")
			dragOverlay.Name = "DragOverlay"
			dragOverlay.Size = UDim2.new(1, 0, 1, 0)
			dragOverlay.Position = UDim2.new(0, 0, 0, 0)
			dragOverlay.BackgroundTransparency = 1
			dragOverlay.Text = ""
			dragOverlay.ZIndex = 10 -- Ensure it's on top
			dragOverlay.Parent = itemFrame
			
			-- Hover effect for entire card
			dragOverlay.MouseEnter:Connect(function()
				TweenService:Create(itemFrame, TweenInfo.new(0.1), {
					BackgroundColor3 = Color3.fromRGB(55, 55, 70)
				}):Play()
			end)
			dragOverlay.MouseLeave:Connect(function()
				TweenService:Create(itemFrame, TweenInfo.new(0.1), {
					BackgroundColor3 = Color3.fromRGB(40, 40, 50)
				}):Play()
			end)
			
			-- Drag trigger on mouse down anywhere on the card
			dragOverlay.MouseButton1Down:Connect(function()
				startDrag(unitName, unitData.rarity or "Normal")
			end)
			
			-- Try to add model preview
			local template = getBrainrotModel(unitName)
			if template then
				local previewModel = template:Clone()
				previewModel.Parent = viewport
				
				local previewCamera = Instance.new("Camera")
				previewCamera.Parent = viewport
				viewport.CurrentCamera = previewCamera
				
				-- Calculate bounding box to properly frame the model
				local cf, size = previewModel:GetBoundingBox()
				local maxDim = math.max(size.X, size.Y, size.Z)
				local distance = maxDim * 1.0  -- Zoomed in closer
				
				-- Isolate visual center
				local center = cf.Position
				if previewModel.PrimaryPart then
					center = previewModel.PrimaryPart.Position
				end
				
				previewCamera.CFrame = CFrame.new(center + Vector3.new(distance, distance*0.5, distance), center)
				
				inventoryItems[unitName] = itemFrame
			end
		end
	end
	
	end
	
	if currentTab == "Tiles" then
		-- Render Tiles List
		local tileIds = TileConfig.GetAllTileIds()
		
		for _, tileId in ipairs(tileIds) do
			local tileData = TileConfig.Tiles[tileId]
			if not tileData then continue end
			
			-- Card container
			local itemFrame = Instance.new("Frame")
			itemFrame.Name = "Tile_" .. tileId
			itemFrame.Size = UDim2.new(1, 0, 0, 80)
			itemFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
			itemFrame.BorderSizePixel = 0
			itemFrame.Parent = scrollFrame
			
			local corner = Instance.new("UICorner")
			corner.CornerRadius = UDim.new(0, CONFIG.THEME_BUTTON_RADIUS)
			corner.Parent = itemFrame
			
			-- Color strip
			local colorStrip = Instance.new("Frame")
			colorStrip.Name = "ColorStrip"
			colorStrip.Size = UDim2.new(0, 50, 1, -20)
			colorStrip.Position = UDim2.new(0, 10, 0, 10)
			colorStrip.BackgroundColor3 = tileData.Color or Color3.fromRGB(150,150,150)
			colorStrip.BorderSizePixel = 0
			colorStrip.Parent = itemFrame
			
			local stripCorner = Instance.new("UICorner")
			stripCorner.CornerRadius = UDim.new(0, 8)
			stripCorner.Parent = colorStrip
			
			-- Info
			local infoGroup = Instance.new("Frame")
			infoGroup.Name = "Info"
			infoGroup.Size = UDim2.new(1, -70, 1, 0)
			infoGroup.Position = UDim2.new(0, 70, 0, 0)
			infoGroup.BackgroundTransparency = 1
			infoGroup.Parent = itemFrame
			
			local nameLabel = Instance.new("TextLabel")
			nameLabel.Name = "Name"
			nameLabel.Size = UDim2.new(1, 0, 0, 20)
			nameLabel.Position = UDim2.new(0, 0, 0, 15)
			nameLabel.BackgroundTransparency = 1
			nameLabel.Text = tileData.Name
			nameLabel.TextColor3 = CONFIG.THEME_TEXT_PRIMARY
			nameLabel.TextSize = 14
			nameLabel.Font = Enum.Font.GothamBold
			nameLabel.TextXAlignment = Enum.TextXAlignment.Left
			nameLabel.Parent = infoGroup
			
			local descLabel = Instance.new("TextLabel")
			descLabel.Name = "Desc"
			descLabel.Size = UDim2.new(1, 0, 0, 30)
			descLabel.Position = UDim2.new(0, 0, 0, 35)
			descLabel.BackgroundTransparency = 1
			descLabel.Text = tileData.Description
			descLabel.TextColor3 = CONFIG.THEME_TEXT_SECONDARY
			descLabel.TextSize = 11
			descLabel.Font = Enum.Font.Gotham
			descLabel.TextXAlignment = Enum.TextXAlignment.Left
			descLabel.TextWrapped = true
			descLabel.Parent = infoGroup
			
			-- Drag Button (Transparent overlay)
			local dragBtn = Instance.new("TextButton")
			dragBtn.Name = "DragButton"
			dragBtn.Size = UDim2.new(1, 0, 1, 0)
			dragBtn.BackgroundTransparency = 1
			dragBtn.Text = ""
			dragBtn.Parent = itemFrame
			
			dragBtn.MouseButton1Down:Connect(function()
				startTileDrag(tileId)
			end)
		end
	end
	
	-- Release debounce lock
	isRefreshingInventory = false
end

-- Ghost colors

local GHOST_VALID_COLOR = Color3.fromRGB(100, 255, 100)

local GHOST_INVALID_COLOR = Color3.fromRGB(255, 80, 80)



--[[
	Sets transparency on all parts in a model (for ghost effects).
]]
local function setModelTransparency(model: Model, transparency: number)
	for _, part in model:GetDescendants() do
		if part:IsA("BasePart") then
			part.Transparency = transparency
		end
	end
end

--[[
	Sets color on all parts in a model (for ghost effects).
]]
local function setModelColor(model: Model, color: Color3)
	for _, part in model:GetDescendants() do
		if part:IsA("BasePart") then
			part.Color = color
		end
	end
	
	-- Also update highlight if present
	local highlight = model:FindFirstChildWhichIsA("Highlight")
	if highlight then
		highlight.FillColor = color
		highlight.OutlineColor = color
	end
end

--[[
	Creates a ghost preview using the MeshPart-only approach.
]]
--[[
	Creates a ghost preview using the MeshPart-only approach.
]]
--[[
	Creates a ghost preview using the MeshPart-only approach.
]]
local function createPlacementGhost(nameOrId: string, isTile: boolean?): Model?
	local ghost
	
	if isTile then
		-- Create Tile Ghost
		local tileData = TileConfig.GetTile(nameOrId)
		if not tileData then return nil end
		
		ghost = Instance.new("Model")
		local part = Instance.new("Part")
		part.Name = "TileGhost"
		part.Size = Vector3.new(CONFIG.TILE_SIZE - 0.5, CONFIG.TILE_HEIGHT, CONFIG.TILE_SIZE - 0.5)
		part.Transparency = 0.3
		part.Color = tileData.Color or GHOST_VALID_COLOR
		part.Material = Enum.Material.ForceField
		part.Anchored = true
		part.CanCollide = false
		part.CastShadow = false
		part.Parent = ghost
		ghost.PrimaryPart = part
		
		-- Add slight glow
		local highlight = Instance.new("SurfaceLight")
		highlight.Color = tileData.Color or GHOST_VALID_COLOR
		highlight.Brightness = 0.5
		highlight.Face = Enum.NormalId.Top
		highlight.Parent = part
		
		ghost.Name = "PlacementGhost_Tile"
		ghost.Parent = workspace
		placementGhost = ghost
		isGhostValid = true
		ghostCenterOffset = Vector3.new()
		return ghost
	end

	local originalModel = getBrainrotModel(nameOrId)

	-- 1. Create the Clone
	if originalModel then
		ghost = originalModel:Clone()
		-- Calculate bounding box center offset from pivot
		-- This ensures the ghost is centered on the model's visual center
		local cf, _size = originalModel:GetBoundingBox()
		local pivotPos = originalModel:GetPivot().Position
		local boundingBoxCenter = cf.Position
		ghostCenterOffset = pivotPos - boundingBoxCenter
	else
		-- Fallback if model is missing
		ghost = Instance.new("Model")
		local part = Instance.new("Part")
		part.Name = "FallbackGhost"
		part.Size = Vector3.new(3, 5, 3)
		part.Transparency = 0.5
		part.Color = GHOST_VALID_COLOR
		part.Material = Enum.Material.ForceField
		part.Anchored = true
		part.CanCollide = false
		part.CastShadow = false
		part.Parent = ghost
		ghost.PrimaryPart = part
		
		ghost.Name = "PlacementGhost"
		ghost.Parent = workspace
		placementGhost = ghost
		isGhostValid = true
		ghostCenterOffset = Vector3.new()
		return ghost
	end

	ghost.Name = "PlacementGhost"

	-- 2. Clean up logic (Destroy specific types AND specific names)
	local descendants = ghost:GetDescendants()
	for _, item in descendants do
		-- Check if the item still exists (it might have been a child of a previously destroyed item)
		if not item.Parent then continue end

		-- A. Remove unwanted classes (Scripts, UI, Sounds, Humanoids)
		if item:IsA("Humanoid") 
			or item:IsA("LuaSourceContainer") 
			or item:IsA("Sound") 
			or item:IsA("Light") 
			or item:IsA("ParticleEmitter") 
			or item:IsA("Trail")
			or item:IsA("Beam")
			or item:IsA("BillboardGui")
			or item:IsA("SurfaceGui")
		then
			item:Destroy()
			continue
		end

		-- B. Remove unwanted specific Parts (The "Weird Box" fix)
		if item.Name == "FakeRootPart" 
			or item.Name == "RootPart" 
			or item.Name == "HumanoidRootPart" 
			or item.Name == "Hitbox" 
			or item.Name == "VfxInstance"
            or item.Name == "AnimationController" -- Also usually junk in ghosts
		then
			item:Destroy()
			continue
		end
		
		-- C. Apply Ghost Visuals to what remains
		if item:IsA("BasePart") then
			if item:IsA("MeshPart") then
				-- MeshPart = actual visual geometry, apply ghost effect
				item.CanCollide = false
				item.CastShadow = false
				item.Anchored = true
				item.Transparency = 0.3
				item.Color = GHOST_VALID_COLOR
				item.Material = Enum.Material.ForceField
			else
				-- Regular Parts/Unions = remaining structure - keep invisible
				-- (If any survived the delete list above)
				item.CanCollide = false
				item.CastShadow = false
				item.Anchored = true
				item.Transparency = 1
			end
		elseif item:IsA("Decal") or item:IsA("Texture") then
			item:Destroy() -- Clean up textures too for a cleaner ghost look
		end
	end

	ghost.Parent = workspace
	placementGhost = ghost
	isGhostValid = true

	return ghost
end

--[[
	Destroys the placement ghost.
]]
local function destroyPlacementGhost()
	if ghostPulseTween then
		ghostPulseTween:Cancel()
		ghostPulseTween = nil
	end
	
	if placementGhost then
		placementGhost:Destroy()
		placementGhost = nil
	end
	
	isGhostValid = false
end

--[[
	Starts the pulsing effect on ghost (valid position).
]]
local function startGhostPulse()
	if not placementGhost then return end
	
	-- Stop existing pulse
	if ghostPulseTween then
		ghostPulseTween:Cancel()
	end
	
	-- Set valid color
	setModelColor(placementGhost, GHOST_VALID_COLOR)
	isGhostValid = true
	
	-- Create pulse loop
	local pulsing = true
	local currentTransparency = 0.3
	local direction = 1
	
	task.spawn(function()
		while pulsing and placementGhost and placementGhost.Parent do
			currentTransparency = currentTransparency + (direction * 0.15 * 0.016)
			
			if currentTransparency >= 0.6 then
				direction = -1
				currentTransparency = 0.6
			elseif currentTransparency <= 0.3 then
				direction = 1
				currentTransparency = 0.3
			end
			
			setModelTransparency(placementGhost, currentTransparency)
			task.wait()
		end
	end)
end

--[[
	Stops pulsing and sets ghost to invalid (solid red).
]]
local function setGhostInvalid()
	if not placementGhost then return end
	
	if ghostPulseTween then
		ghostPulseTween:Cancel()
		ghostPulseTween = nil
	end
	
	setModelColor(placementGhost, GHOST_INVALID_COLOR)
	setModelTransparency(placementGhost, 0.5)
	isGhostValid = false
end

--------------------------------------------------------------------------------
-- DRAG AND DROP SYSTEM
--------------------------------------------------------------------------------

--[[
	Calculates the mouse position on the 3D plane at grid height.
	Allows dragging freely between tiles.
]]
local function getMousePlanePosition()
	local mouse = UserInputService:GetMouseLocation()
	local ray = camera:ViewportPointToRay(mouse.X, mouse.Y)
	
	-- Create a mathematical plane at the grid height (y = gridFloorHeight)
	-- Plane equation: (P - P0) dot Normal = 0
	-- Ray: P = Origin + Direction * t
	-- (Origin + Dir*t - P0) dot Normal = 0
	-- t = (P0 - Origin) dot Normal / (Dir dot Normal)
	
	local normal = Vector3.new(0, 1, 0)
	local p0 = Vector3.new(0, gridFloorHeight, 0)
	
	local denominator = ray.Direction:Dot(normal)
	
	if math.abs(denominator) > 0.001 then -- Prevent division by zero
		local t = (p0 - ray.Origin):Dot(normal) / denominator
		if t > 0 then
			return ray.Origin + ray.Direction * t
		end
	end
	
	return nil
end

--[[
	Starts a drag operation from inventory.
]]
startDrag = function(unitName: string, rarity: string)
	print("DEBUG: startDrag called for", unitName)
	if isDragging then return end
	
	isDragging = true
	draggedUnit = {type = "unit", name = unitName, rarity = rarity}
	
	-- Determine Start Position
	local mousePos = getMousePlanePosition()
	local startPos = mousePos or Vector3.new(0, gridFloorHeight, 0)
	
	-- Physics State Variables
	local currentPos = startPos
	local currentVelocity = Vector3.new()
	local currentTilt = CFrame.new()
	
	-- Create ghost
	local ghost = createPlacementGhost(unitName)
	if ghost then
		print("DEBUG: Ghost created successfully")
		-- Apply offset so visual center is at the target position
		ghost:PivotTo(CFrame.new(startPos + Vector3.new(0, CONFIG.DRAG_HEIGHT, 0) + ghostCenterOffset))
		startGhostPulse()
	else
		warn("DEBUG: Ghost creation FAILED for " .. unitName)
	end
	
	updateStatus("ðŸŽ¯ Release over an empty tile to place " .. unitName)
	
	-- KINEMATIC DRAG LOOP
	dragConnection = RunService.RenderStepped:Connect(function(dt)
		if not isDragging then return end
		
		-- 1. Determine Target Position (Mouse on Floor Plane)
		local rawMousePos = getMousePlanePosition()
		if not rawMousePos then return end
		
		local targetPos = rawMousePos + Vector3.new(0, CONFIG.DRAG_HEIGHT, 0)
		
		-- 2. Smooth Position (Lag Effect)
		-- Simple Lerp is often smoother than Spring for Mouse Drag in Roblox due to update rates
		local lerpAlpha = math.clamp(dt * CONFIG.DRAG_SMOOTHNESS, 0, 1)
		local newPos = currentPos:Lerp(targetPos, lerpAlpha)
		
		-- Calculate velocity for tilt
		local velocity = (newPos - currentPos) / dt
		currentPos = newPos
		
		-- 3. Calculate Tilt (Procedural Animation)
		-- Tilt axis is perpendicular to velocity and up vector
		local tiltAxis = velocity:Cross(Vector3.yAxis)
		local speed = velocity.Magnitude
		
		-- Calculate target tilt rotation
		local targetTiltRot = CFrame.new()
		if speed > 0.1 and tiltAxis.Magnitude > 0.01 then
			-- Calculate angle based on speed (clamped)
			local tiltAngle = math.rad(math.clamp(speed * CONFIG.TILT_STRENGTH, -CONFIG.MAX_TILT_ANGLE, CONFIG.MAX_TILT_ANGLE))
			
			-- We invert the angle so it "drags" behind
			targetTiltRot = CFrame.fromAxisAngle(tiltAxis.Unit, -tiltAngle)
		end
		
		-- Smoothly interpolate tilt
		currentTilt = currentTilt:Lerp(targetTiltRot, dt * CONFIG.TILT_RETURN_SPEED)
		
		-- 4. Apply to Ghost
		if placementGhost then
			-- Apply offset so visual center follows cursor
			placementGhost:PivotTo(CFrame.new(currentPos + ghostCenterOffset) * currentTilt)
		end
		
		-- 5. Grid Interaction (Highlighting)
		local slot = getSlotUnderMouse()
		
		if slot then
			local tile = gridTiles[slot]
			local isOccupied = tile and tile:GetAttribute("IsOccupied")
			
			if isOccupied then
				if placementGhost then setGhostInvalid() end
				if tile then highlightTile(slot, CONFIG.INVALID_COLOR) end
				isGhostValid = false
			else
				if placementGhost and not isGhostValid then startGhostPulse() end
				if tile then highlightTile(slot, CONFIG.HOVER_COLOR) end
				isGhostValid = true
			end
		else
			-- Check if hovering over inventory panel (valid cancel target)
			local mouse = LocalPlayer:GetMouse()
			if inventoryPanel then
				local panelPos = inventoryPanel.AbsolutePosition
				local panelSize = inventoryPanel.AbsoluteSize
				if mouse.X >= panelPos.X and mouse.X <= panelPos.X + panelSize.X and
				   mouse.Y >= panelPos.Y and mouse.Y <= panelPos.Y + panelSize.Y then
					if placementGhost and not isGhostValid then startGhostPulse() end
					isGhostValid = true
				else
					if placementGhost then setGhostInvalid() end
					isGhostValid = false
				end
			else
				if placementGhost then setGhostInvalid() end
				isGhostValid = false
			end
		end
	end)
end

--[[
	Starts a drag operation from inventory for a TILE.
]]
startTileDrag = function(tileId: string)
	if isDragging then return end
	
	isDragging = true
	draggedUnit = {type = "tile", id = tileId}
	
	-- Determine Start Position
	local mousePos = getMousePlanePosition()
	local startPos = mousePos or Vector3.new(0, gridFloorHeight, 0)
	
	-- Physics State Variables
	local currentPos = startPos
	
	-- Create ghost (pass true for isTile)
	local ghost = createPlacementGhost(tileId, true)
	if ghost then
		-- Apply offset so visual center is at the target position
		ghost:PivotTo(CFrame.new(startPos + Vector3.new(0, CONFIG.DRAG_HEIGHT, 0) + ghostCenterOffset))
		startGhostPulse()
	end
	
	updateStatus("ðŸŽ¯ Tile Mode: Release over a slot to place " .. tileId)
	
	-- KINEMATIC DRAG LOOP (Tiles - simplified, no tilt needed for flat tiles usually)
	dragConnection = RunService.RenderStepped:Connect(function(dt)
		if not isDragging then return end
		
		-- 1. Determine Target Position (Mouse on Floor Plane)
		local rawMousePos = getMousePlanePosition()
		if not rawMousePos then return end
		
		local targetPos = rawMousePos + Vector3.new(0, CONFIG.DRAG_HEIGHT, 0)
		
		-- 2. Smooth Position
		local lerpAlpha = math.clamp(dt * CONFIG.DRAG_SMOOTHNESS, 0, 1)
		local newPos = currentPos:Lerp(targetPos, lerpAlpha)
		currentPos = newPos
		
		-- 4. Apply to Ghost
		if placementGhost then
			placementGhost:PivotTo(CFrame.new(currentPos + ghostCenterOffset))
		end
		
		-- 5. Grid Interaction (Highlighting)
		local slot = getSlotUnderMouse()
		
		if slot then
			-- For tiles, we check if the slot already has THIS tile? Or just highlight valid
			if placementGhost and not isGhostValid then startGhostPulse() end
			highlightTile(slot, CONFIG.HOVER_COLOR)
			isGhostValid = true
		else
			if placementGhost then setGhostInvalid() end
			isGhostValid = false
		end
	end)
end

--[[
	Cancels the current drag operation.
]]
local function cancelDrag()
	if not isDragging then return end
	
	isDragging = false
	draggedUnit = nil
	
	if dragConnection then
		dragConnection:Disconnect()
		dragConnection = nil
	end
	
	destroyPlacementGhost()
	updateStatus("Drag cancelled")
end

--[[
	Completes a drop operation.
]]
completeDrop = function()
	if not isDragging or not draggedUnit then 
		cancelDrag()
		return 
	end
	
	-- Get slot under mouse
	local slot = getSlotUnderMouse()
	
	if slot and isGhostValid then
		-- Handle different drag types
		if draggedUnit.type == "tile" then
			-- Place Tile
			local success, msg = PlaceTileRemote:InvokeServer(draggedUnit.id, slot)
			
			if success then
				updateStatus("âœ“ Placed " .. (draggedUnit.id or "tile") .. " at slot " .. slot)
				task.defer(renderBuildGrid)
			else
				updateStatus("âœ— " .. (msg or "Tile placement failed"))
			end
			
		elseif draggedUnit.type == "unit" or draggedUnit.type == nil then -- Default to unit
			-- Check if slot is empty (units can't overlap)
			local tile = gridTiles[slot]
			local isOccupied = tile and tile:GetAttribute("IsOccupied")
			
			if not isOccupied then
				-- Place the unit!
				local success, msg = PlaceBrainrotRemote:InvokeServer(draggedUnit.name, draggedUnit.rarity, slot)
				
				if success then
					updateStatus("âœ“ Placed " .. (draggedUnit.name or "unit") .. " at slot " .. slot)
					task.defer(renderBuildGrid)
					task.defer(refreshInventoryPanel)
				else
					updateStatus("âœ— " .. (msg or "Place failed"))
				end
			else
				updateStatus("âœ— Slot is occupied")
			end
		end
	else
		-- Check if dropped on inventory panel (cancel gracefully - unit stays in storage)
		local mouse = LocalPlayer:GetMouse()
		if inventoryPanel then
			local panelPos = inventoryPanel.AbsolutePosition
			local panelSize = inventoryPanel.AbsoluteSize
			if mouse.X >= panelPos.X and mouse.X <= panelPos.X + panelSize.X and
			   mouse.Y >= panelPos.Y and mouse.Y <= panelPos.Y + panelSize.Y then
				updateStatus("âœ“ Drag cancelled - unit stays in inventory")
			else
				updateStatus("âœ— Invalid drop location")
			end
		else
			updateStatus("âœ— Invalid drop location")
		end
	end
	
	-- Cleanup
	isDragging = false
	draggedUnit = nil
	
	if dragConnection then
		dragConnection:Disconnect()
		dragConnection = nil
	end
	
	destroyPlacementGhost()
end

--[[
	Gets the brainrot model under the mouse cursor.
	Returns the model and its slot index if found.
]]
local function getBrainrotUnderMouse(): (Model?, number?)
	local mousePos = UserInputService:GetMouseLocation()
	
	-- Get all brainrots and check if we're clicking on any
	local brainrots = CollectionService:GetTagged("ActiveBrainrot")
	
	local closestBrainrot = nil
	local closestSlot = nil
	local closestDist = math.huge
	
	for _, brainrot in brainrots do
		local ownerId = brainrot:GetAttribute("OwnerId")
		local slotIndex = brainrot:GetAttribute("GridSlot")
		
		-- Only check brainrots owned by this player
		if ownerId ~= LocalPlayer.UserId then
			continue
		end
		
		if not slotIndex then 
			continue 
		end
		
		-- Get brainrot position
		local brainrotPos
		if brainrot:IsA("Model") then
			if brainrot.PrimaryPart then
				brainrotPos = brainrot.PrimaryPart.Position
			else
				brainrotPos = brainrot:GetPivot().Position
			end
		elseif brainrot:IsA("BasePart") then
			brainrotPos = brainrot.Position
		end
		
		if not brainrotPos then 
			continue 
		end
		
		-- Project to screen
		local screenPos, onScreen = camera:WorldToViewportPoint(brainrotPos)
		
		if not onScreen then continue end
		
		-- Check distance from mouse to brainrot's screen position
		local screenDist = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
		
		-- Use a generous click radius (80 pixels)
		if screenDist < 80 and screenDist < closestDist then
			closestDist = screenDist
			closestBrainrot = brainrot
			closestSlot = slotIndex
		end
	end
	
	return closestBrainrot, closestSlot
end

--[[
	Toggles visibility of all visual elements in a model.
]]
local function setVisualsEnabled(model: Model, enabled: boolean)
	for _, descendant in model:GetDescendants() do
		-- Skip parts that should ALWAYS remain hidden
		if descendant.Name == "FakeRootPart" 
			or descendant.Name == "VfxInstance" 
			or descendant.Name == "RootPart"
			or descendant.Name == "HumanoidRootPart"
			or descendant.Name == "Hitbox"
		then
			if descendant:IsA("BasePart") then
				descendant.Transparency = 1
			end
			continue
		end
		
		if descendant:IsA("MeshPart") then
			descendant.Transparency = enabled and 0 or 1
		elseif descendant:IsA("Part") or descendant:IsA("UnionOperation") then
			descendant.Transparency = 1
		elseif descendant:IsA("Decal") or descendant:IsA("Texture") then
			descendant.Transparency = enabled and 0 or 1
		elseif descendant:IsA("ParticleEmitter") or descendant:IsA("Trail") or descendant:IsA("Beam") then
			descendant.Enabled = enabled
		elseif descendant:IsA("LayerCollector") then
			descendant.Enabled = enabled
		end
	end
end

--[[
	Starts dragging an existing brainrot from the world.
]]
local function startDragFromWorld(brainrotModel: Model, slotIndex: number)
	if isDragging then return end
	
	isDragging = true
	draggedUnit = {
		type = "unit",
		name = brainrotModel:GetAttribute("UnitType") or brainrotModel.Name,
		rarity = brainrotModel:GetAttribute("Rarity") or "Normal",
		fromSlot = slotIndex,
		isFromWorld = true,
		originalModel = brainrotModel
	}
	
	updateStatus("ðŸŽ¯ Drag to new slot or inventory panel to store")
	
	-- Setup Physics State
	-- Start exactly where the unit currently is
	local startPos
	if brainrotModel.PrimaryPart then
		startPos = brainrotModel.PrimaryPart.Position
	else
		startPos = brainrotModel:GetPivot().Position
	end
	
	local currentPos = startPos
	local currentTilt = CFrame.new()
	
	-- Create placement ghost
	createPlacementGhost(draggedUnit.name)
	if placementGhost then
		-- Apply offset so visual center is at the start position
		placementGhost:PivotTo(CFrame.new(startPos + ghostCenterOffset))
	end
	
	-- Hide the original model while dragging
	if brainrotModel then
		setVisualsEnabled(brainrotModel, false)
	end
	
	-- Highlight the source slot
	if gridTiles[slotIndex] then
		highlightTile(slotIndex, CONFIG.SELECTED_COLOR)
	end
	
	-- KINEMATIC DRAG LOOP (World)
	dragConnection = RunService.RenderStepped:Connect(function(dt)
		if not isDragging then return end
		
		-- 1. Determine Target (Mouse on Floor Plane)
		local rawMousePos = getMousePlanePosition()
		if not rawMousePos then return end
		
		local targetPos = rawMousePos + Vector3.new(0, CONFIG.DRAG_HEIGHT, 0)
		
		-- 2. Smooth Position
		local lerpAlpha = math.clamp(dt * CONFIG.DRAG_SMOOTHNESS, 0, 1)
		local newPos = currentPos:Lerp(targetPos, lerpAlpha)
		
		local velocity = (newPos - currentPos) / dt
		currentPos = newPos
		
		-- 3. Calculate Tilt
		local tiltAxis = velocity:Cross(Vector3.yAxis)
		local speed = velocity.Magnitude
		
		local targetTiltRot = CFrame.new()
		if speed > 0.1 and tiltAxis.Magnitude > 0.01 then
			local tiltAngle = math.rad(math.clamp(speed * CONFIG.TILT_STRENGTH, -CONFIG.MAX_TILT_ANGLE, CONFIG.MAX_TILT_ANGLE))
			targetTiltRot = CFrame.fromAxisAngle(tiltAxis.Unit, -tiltAngle)
		end
		
		currentTilt = currentTilt:Lerp(targetTiltRot, dt * CONFIG.TILT_RETURN_SPEED)
		
		-- 4. Apply
		if placementGhost then
			-- Apply offset so visual center follows cursor
			placementGhost:PivotTo(CFrame.new(currentPos + ghostCenterOffset) * currentTilt)
		end
		
		-- 5. Logic Checks
		local slot = getSlotUnderMouse()
		
		if slot then
			local tile = gridTiles[slot]
			local isOccupied = tile and tile:GetAttribute("IsOccupied")
			
			if slot == draggedUnit.fromSlot then
				startGhostPulse()
			elseif isOccupied then
				setGhostInvalid()
				highlightTile(slot, CONFIG.INVALID_COLOR)
			else
				startGhostPulse()
				highlightTile(slot, CONFIG.HOVER_COLOR)
			end
		elseif placementGhost then
			-- Check inventory hover
			local mouse = LocalPlayer:GetMouse()
			if inventoryPanel then
				local panelPos = inventoryPanel.AbsolutePosition
				local panelSize = inventoryPanel.AbsoluteSize
				if mouse.X >= panelPos.X and mouse.X <= panelPos.X + panelSize.X and
				   mouse.Y >= panelPos.Y and mouse.Y <= panelPos.Y + panelSize.Y then
					startGhostPulse() -- Valid to drop on inventory
				else
					setGhostInvalid()
				end
			end
		end
	end)
end

--[[
	Completes a drag operation from world model.
]]
local function completeDragFromWorld()
	if not isDragging or not draggedUnit or not draggedUnit.isFromWorld then
		return
	end
	
	local targetSlot = getSlotUnderMouse()
	local sourceSlot = draggedUnit.fromSlot
	
	-- Check if dropped on inventory panel (store the unit)
	local mouse = LocalPlayer:GetMouse()
	if inventoryPanel then
		local panelPos = inventoryPanel.AbsolutePosition
		local panelSize = inventoryPanel.AbsoluteSize

		
		if mouse.X >= panelPos.X and mouse.X <= panelPos.X + panelSize.X and
		   mouse.Y >= panelPos.Y and mouse.Y <= panelPos.Y + panelSize.Y then
			-- BUGFIX: Restore visibility BEFORE stashing so model is visible when placed later
			if draggedUnit and draggedUnit.originalModel and draggedUnit.originalModel.Parent then
				setVisualsEnabled(draggedUnit.originalModel, true)
			end
			
			-- Drop on inventory - remove from grid to storage
			local success, msg = RemoveBrainrotRemote:InvokeServer(sourceSlot)
			if success then
				updateStatus("âœ“ Stored " .. draggedUnit.name .. " in inventory")
				task.defer(renderBuildGrid)
				task.defer(refreshInventoryPanel)
			else
				updateStatus("âœ— " .. (msg or "Store failed"))
			end
			
			isDragging = false
			draggedUnit = nil
			if dragConnection then
				dragConnection:Disconnect()
				dragConnection = nil
			end
			destroyPlacementGhost()
			return
		end
	end
	
	-- Check if dropped on a valid grid slot
	if targetSlot and targetSlot ~= sourceSlot then
		local tile = gridTiles[targetSlot]
		local isOccupied = tile and tile:GetAttribute("IsOccupied")
		
		if isOccupied then
			-- Swap
			local success, err = SwapUnits:InvokeServer(sourceSlot, targetSlot)
			if success then
				updateStatus("âœ“ Swapped units!")
			else
				updateStatus("âœ— " .. (err or "Swap failed"))
			end
		else
			-- Move to empty slot
			local success, err = MoveUnit:InvokeServer(sourceSlot, targetSlot)
			if success then
				updateStatus("âœ“ Moved to slot " .. targetSlot)
			else
				updateStatus("âœ— " .. (err or "Move failed"))
			end
		end
		task.defer(renderBuildGrid)
	else
		updateStatus("Drag cancelled")
	end
	
	-- Restore original model visibility
	if draggedUnit and draggedUnit.originalModel and draggedUnit.originalModel.Parent then
		setVisualsEnabled(draggedUnit.originalModel, true)
	end

	-- Cleanup
	isDragging = false
	draggedUnit = nil
	if dragConnection then
		dragConnection:Disconnect()
		dragConnection = nil
	end
	
	-- Destroy ghost
	destroyPlacementGhost()
	
	-- Unhighlight source
	if gridTiles[sourceSlot] then
		unhighlightTile(sourceSlot)
	end
end

--------------------------------------------------------------------------------
-- INTERACTION
--------------------------------------------------------------------------------

--[[
	Gets the slot under the mouse cursor.
]]
getSlotUnderMouse = function()
	if not gridContainer then return nil end
	
	local mouse = LocalPlayer:GetMouse()
	local ray = camera:ScreenPointToRay(mouse.X, mouse.Y)
	
	local raycastParams = RaycastParams.new()
	raycastParams.FilterType = Enum.RaycastFilterType.Include
	raycastParams.FilterDescendantsInstances = {gridContainer}
	
	local result = workspace:Raycast(ray.Origin, ray.Direction * 1000, raycastParams)
	if result and result.Instance then
		return result.Instance:GetAttribute("SlotIndex")
	end
	
	return nil
end

--[[
	Handles mouse click on grid.
]]
local function handleClick()
	local slot = getSlotUnderMouse()
	if not slot then return end
	
	local tile = gridTiles[slot]
	if not tile then return end
	
	if selectedSlot then
		-- If we have a selection, try to move/swap
		if slot ~= selectedSlot then
			local sourceOccupied = gridTiles[selectedSlot]:GetAttribute("IsOccupied")
			local targetOccupied = tile:GetAttribute("IsOccupied")
			
			if sourceOccupied then
				if targetOccupied then
					-- Swap
					local success, err = SwapUnits:InvokeServer(selectedSlot, slot)
					if success then
						updateStatus("âœ“ Swapped units!")
					else
						updateStatus("âœ— " .. (err or "Swap failed"))
					end
				else
					-- Move
					local success, err = MoveUnit:InvokeServer(selectedSlot, slot)
					if success then
						updateStatus("âœ“ Moved unit!")
					else
						updateStatus("âœ— " .. (err or "Move failed"))
					end
				end
				
				-- Refresh grid
				task.defer(renderBuildGrid)
			end
		end
		
		-- Deselect
		unhighlightTile(selectedSlot)
		selectedSlot = nil
	else
		-- Select this slot
		if tile:GetAttribute("IsOccupied") then
			selectedSlot = slot
			highlightTile(slot, CONFIG.SELECTED_COLOR)
			updateStatus("Selected: " .. (tile:GetAttribute("UnitName") or "Unit") .. " â€¢ Click tile to move/swap")
		else
			updateStatus("Empty slot - select an occupied tile first")
		end
	end
end

--[[
	Handles mouse hover.
]]
local function setupHoverTracking()
	if currentHoverConnection then
		currentHoverConnection:Disconnect()
	end
	
	currentHoverConnection = RunService.RenderStepped:Connect(function()
		if not isInBuildMode then return end
		
		local slot = getSlotUnderMouse()
		
		if slot ~= hoveredSlot then
			-- Unhighlight old
			if hoveredSlot and hoveredSlot ~= selectedSlot then
				unhighlightTile(hoveredSlot)
			end
			
			-- Highlight new
			if slot and slot ~= selectedSlot then
				highlightTile(slot, CONFIG.HOVER_COLOR)
			end
			
			hoveredSlot = slot
		end
	end)
end

--------------------------------------------------------------------------------
-- BUILD MODE TOGGLE
--------------------------------------------------------------------------------

--[[
	Enters build mode.
]]
local function enterBuildModeLocal()
	if isInBuildMode then return end
	
	local success, err = EnterBuildMode:InvokeServer()
	if not success then
		warn("BuildModeUI: Failed to enter - " .. tostring(err))
		return
	end
	
	isInBuildMode = true
	
	-- Get current island info
	local currentPlot = findCurrentIsland()
	local islandName = currentPlot and currentPlot.Name or "Unknown"
	
	-- Render grid and get plot center
	local plotCenter = renderBuildGrid()
	
	-- Create UI
	buildModeGui = createBuildModeUI()
	buildModeGui.Parent = PlayerGui
	
	-- Create and populate inventory panel
	createInventoryPanel(buildModeGui)
	refreshInventoryPanel()
	
	-- Update status with island name
	updateStatus("Editing: " .. islandName .. " â€¢ Click tile or Place from inventory")
	
	-- Setup exit button
	local topBar = buildModeGui:FindFirstChild("TopBar")
	if topBar then
		local exitButton = topBar:FindFirstChild("ExitButton")
		if exitButton then
			exitButton.MouseButton1Click:Connect(function()
				exitBuildModeLocal()
			end)
		end
	end
	
	-- Tween camera
	if plotCenter then
		tweenToIsometricView(plotCenter)
	end
	
	-- Setup interaction
	setupHoverTracking()
	
	-- Fire event for GridOverlay
	local buildModeToggle = ReplicatedStorage:FindFirstChild("BuildModeToggle")
	if buildModeToggle then
		buildModeToggle:Fire(true)
	end
	
	print("BuildModeUI: Entered Build Mode for " .. islandName)
end

--[[
	Exits build mode.
]]
exitBuildModeLocal = function()
	if not isInBuildMode then return end
	
	ExitBuildMode:InvokeServer()
	
	isInBuildMode = false
	
	if currentHoverConnection then
		currentHoverConnection:Disconnect()
		currentHoverConnection = nil
	end
	
	destroyBuildGrid()
	
	inventoryPanel = nil
	inventoryItems = {}
	
	if buildModeGui then
		buildModeGui:Destroy()
		buildModeGui = nil
	end
	
	tweenToPlayerView()
	
	selectedSlot = nil
	hoveredSlot = nil
	
	local buildModeToggle = ReplicatedStorage:FindFirstChild("BuildModeToggle")
	if buildModeToggle then
		buildModeToggle:Fire(false)
	end
	
	print("BuildModeUI: Exited Build Mode")
end

--[[
	Toggles build mode.
]]
local function toggleBuildMode()
	if isInBuildMode then
		exitBuildModeLocal()
	else
		enterBuildModeLocal()
	end
end

--------------------------------------------------------------------------------
-- INPUT HANDLING
--------------------------------------------------------------------------------

UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	
	if input.KeyCode == Enum.KeyCode.G or input.KeyCode == Enum.KeyCode.Tab then
		toggleBuildMode()
	elseif input.KeyCode == Enum.KeyCode.Escape and isInBuildMode then
		exitBuildModeLocal()
	end
end)

-- Mouse click handling
local mouse = LocalPlayer:GetMouse()
mouse.Button1Down:Connect(function()
	if not isInBuildMode then return end
	if isDragging then return end
	
	local brainrot, slotIndex = getBrainrotUnderMouse()
	if brainrot and slotIndex then
		startDragFromWorld(brainrot, slotIndex)
		return
	end
	
	handleClick()
end)

-- Mouse release
mouse.Button1Up:Connect(function()
	if not isInBuildMode or not isDragging then return end
	
	if draggedUnit and draggedUnit.isFromWorld then
		completeDragFromWorld()
	else
		completeDrop()
	end
end)

--------------------------------------------------------------------------------
-- LISTEN FOR GRID UPDATES
--------------------------------------------------------------------------------

GridUpdatedEvent.OnClientEvent:Connect(function(slotIndex, unitName, action)
	if isInBuildMode then
		task.defer(renderBuildGrid)
	end
end)

--------------------------------------------------------------------------------
-- LISTEN FOR INVENTORY CHANGES (when brainrots are purchased)
--------------------------------------------------------------------------------

InventoryChangedEvent.OnClientEvent:Connect(function()
	if isInBuildMode then
		task.defer(refreshInventoryPanel)
	end
end)

-- Listen for InventoryToggleEvent (from HUD)
local InventoryToggleEvent = ReplicatedStorage:FindFirstChild("InventoryToggleEvent")
if not InventoryToggleEvent then
	InventoryToggleEvent = Instance.new("BindableEvent")
	InventoryToggleEvent.Name = "InventoryToggleEvent"
	InventoryToggleEvent.Parent = ReplicatedStorage
end
InventoryToggleEvent.Event:Connect(toggleBuildMode)

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

print("âœ“ BuildModeUI initialized - Press TAB to toggle Build Mode")

_G.BuildModeUI = {
	Toggle = toggleBuildMode,
	Enter = enterBuildModeLocal,
	Exit = exitBuildModeLocal,
	IsActive = function() return isInBuildMode end,
}



================================================================================
FILE: src\client\ConvenienceUpgradesUI.client.luau
================================================================================

--[[
	ConvenienceUpgradesUI Client Script
	
	Handles the UI for the Convenience Upgrades Shop where players can:
	1. Browse upgrades by category
	2. View owned vs available upgrades
	3. Purchase upgrades
	4. See upgrade effects
	
	Opens when player presses E near the Convenience Shop vendor.
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local CollectionService = game:GetService("CollectionService")

-- Player reference
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Modules
local ConvenienceUpgradesConfig = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("ConvenienceUpgradesConfig"))

-- Remote Events
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local PurchaseUpgradeEvent = RemoteEvents:WaitForChild("PurchaseConvenienceUpgrade")
local GetUpgradesInfoEvent = RemoteEvents:WaitForChild("GetConvenienceUpgradesInfo")

-- Configuration
local UI_CONFIG = {
	INTERACTION_DISTANCE = 20,
	TWEEN_TIME = 0.3,
	COLORS = {
		Background = Color3.fromRGB(25, 20, 35),
		Header = Color3.fromRGB(80, 50, 30),
		Card = Color3.fromRGB(40, 30, 50),
		CardOwned = Color3.fromRGB(30, 60, 40),
		CardLocked = Color3.fromRGB(50, 40, 50),
		Accent = Color3.fromRGB(255, 180, 80),
		Text = Color3.fromRGB(255, 255, 255),
		TextMuted = Color3.fromRGB(150, 150, 150),
		Green = Color3.fromRGB(100, 255, 100),
		Red = Color3.fromRGB(255, 100, 100),
	},
}

-- State
local shopOpen = false
local currentCategory = "Movement"
local ownedUpgrades: {string} = {}

--------------------------------------------------------------------------------
-- UI CREATION
--------------------------------------------------------------------------------

local function formatPrice(price: number): string
	local suffixes = {"K", "M", "B", "T", "Qa", "Qi", "Sx", "Sp", "Oc", "No", "Dc"}
	
	if price < 1000 then
		return tostring(math.floor(price))
	end
	
	-- Calculate the magnitude (power of 1000)
	local magnitude = math.floor(math.log(price, 1000))
	
	-- Cap at the largest suffix
	if magnitude > #suffixes then
		magnitude = #suffixes
	end
	
	local value = price / (1000 ^ magnitude)
	
	-- Format with 1 decimal place if < 100, otherwise no decimals
	if value < 100 and value % 1 ~= 0 then
		return string.format("%.1f%s", value, suffixes[magnitude])
	else
		return string.format("%.0f%s", value, suffixes[magnitude])
	end
end

local function createShopUI()
	-- Create ScreenGui
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "ConvenienceUpgradesUI"
	screenGui.ResetOnSpawn = false
	screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	
	-- Main container
	local mainFrame = Instance.new("Frame")
	mainFrame.Name = "MainFrame"
	mainFrame.Size = UDim2.new(0, 550, 0, 500)
	mainFrame.Position = UDim2.new(0.5, -275, 0.5, -250)
	mainFrame.BackgroundColor3 = UI_CONFIG.COLORS.Background
	mainFrame.BorderSizePixel = 0
	mainFrame.Visible = false
	mainFrame.Parent = screenGui
	
	local mainCorner = Instance.new("UICorner")
	mainCorner.CornerRadius = UDim.new(0, 16)
	mainCorner.Parent = mainFrame
	
	local mainStroke = Instance.new("UIStroke")
	mainStroke.Color = UI_CONFIG.COLORS.Accent
	mainStroke.Thickness = 2
	mainStroke.Parent = mainFrame
	
	-- Header
	local header = Instance.new("Frame")
	header.Name = "Header"
	header.Size = UDim2.new(1, 0, 0, 60)
	header.BackgroundColor3 = UI_CONFIG.COLORS.Header
	header.BorderSizePixel = 0
	header.Parent = mainFrame
	
	local headerCorner = Instance.new("UICorner")
	headerCorner.CornerRadius = UDim.new(0, 16)
	headerCorner.Parent = header
	
	local headerFix = Instance.new("Frame")
	headerFix.Size = UDim2.new(1, 0, 0, 16)
	headerFix.Position = UDim2.new(0, 0, 1, -16)
	headerFix.BackgroundColor3 = UI_CONFIG.COLORS.Header
	headerFix.BorderSizePixel = 0
	headerFix.Parent = header
	
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "Title"
	titleLabel.Size = UDim2.new(1, -60, 1, 0)
	titleLabel.Position = UDim2.new(0, 20, 0, 0)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Text = "âš¡ CONVENIENCE UPGRADES"
	titleLabel.TextColor3 = UI_CONFIG.COLORS.Accent
	titleLabel.TextSize = 24
	titleLabel.Font = Enum.Font.GothamBold
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	titleLabel.Parent = header
	
	-- Close button
	local closeButton = Instance.new("TextButton")
	closeButton.Name = "CloseButton"
	closeButton.Size = UDim2.new(0, 40, 0, 40)
	closeButton.Position = UDim2.new(1, -50, 0, 10)
	closeButton.BackgroundColor3 = Color3.fromRGB(200, 60, 60)
	closeButton.Text = "âœ•"
	closeButton.TextColor3 = Color3.new(1, 1, 1)
	closeButton.TextSize = 20
	closeButton.Font = Enum.Font.GothamBold
	closeButton.Parent = header
	
	local closeCorner = Instance.new("UICorner")
	closeCorner.CornerRadius = UDim.new(0.5, 0)
	closeCorner.Parent = closeButton
	
	-- Category tabs
	local tabsFrame = Instance.new("Frame")
	tabsFrame.Name = "TabsFrame"
	tabsFrame.Size = UDim2.new(1, -40, 0, 40)
	tabsFrame.Position = UDim2.new(0, 20, 0, 70)
	tabsFrame.BackgroundTransparency = 1
	tabsFrame.Parent = mainFrame
	
	local tabsLayout = Instance.new("UIListLayout")
	tabsLayout.FillDirection = Enum.FillDirection.Horizontal
	tabsLayout.Padding = UDim.new(0, 10)
	tabsLayout.Parent = tabsFrame
	
	-- Content area (scrolling)
	local contentFrame = Instance.new("ScrollingFrame")
	contentFrame.Name = "ContentFrame"
	contentFrame.Size = UDim2.new(1, -40, 1, -140)
	contentFrame.Position = UDim2.new(0, 20, 0, 120)
	contentFrame.BackgroundTransparency = 1
	contentFrame.ScrollBarThickness = 6
	contentFrame.ScrollBarImageColor3 = UI_CONFIG.COLORS.Accent
	contentFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
	contentFrame.Parent = mainFrame
	
	local contentLayout = Instance.new("UIListLayout")
	contentLayout.Padding = UDim.new(0, 10)
	contentLayout.Parent = contentFrame
	
	-- Message label
	local messageLabel = Instance.new("TextLabel")
	messageLabel.Name = "MessageLabel"
	messageLabel.Size = UDim2.new(1, -40, 0, 30)
	messageLabel.Position = UDim2.new(0, 20, 1, -35)
	messageLabel.BackgroundTransparency = 1
	messageLabel.Text = ""
	messageLabel.TextColor3 = UI_CONFIG.COLORS.Green
	messageLabel.TextSize = 14
	messageLabel.Font = Enum.Font.GothamBold
	messageLabel.Parent = mainFrame
	
	screenGui.Parent = playerGui
	return screenGui
end

--------------------------------------------------------------------------------
-- UI COMPONENTS
--------------------------------------------------------------------------------

local screenGui = createShopUI()
local mainFrame = screenGui:WaitForChild("MainFrame")
local tabsFrame = mainFrame:WaitForChild("TabsFrame")
local contentFrame = mainFrame:WaitForChild("ContentFrame")
local messageLabel = mainFrame:WaitForChild("MessageLabel")

local function isOwned(upgradeName: string): boolean
	for _, owned in ownedUpgrades do
		if owned == upgradeName then
			return true
		end
	end
	return false
end

local function createCategoryTab(category: string, index: number)
	local icons = {
		Movement = "ðŸƒ",
		Income = "ðŸ’°",
		Automation = "ðŸ¤–",
	}
	
	local tab = Instance.new("TextButton")
	tab.Name = "Tab_" .. category
	tab.Size = UDim2.new(0, 120, 1, 0)
	tab.BackgroundColor3 = currentCategory == category and UI_CONFIG.COLORS.Accent or UI_CONFIG.COLORS.Card
	tab.Text = (icons[category] or "ðŸ“¦") .. " " .. category
	tab.TextColor3 = UI_CONFIG.COLORS.Text
	tab.TextSize = 14
	tab.Font = Enum.Font.GothamBold
	tab.Parent = tabsFrame
	
	local tabCorner = Instance.new("UICorner")
	tabCorner.CornerRadius = UDim.new(0, 8)
	tabCorner.Parent = tab
	
	tab.MouseButton1Click:Connect(function()
		currentCategory = category
		refreshShop()
	end)
	
	return tab
end

local function createUpgradeCard(upgradeName: string, config)
	local owned = isOwned(upgradeName)
	local canPurchase, reason = ConvenienceUpgradesConfig.CanPurchase(upgradeName, ownedUpgrades)
	
	local cardColor = owned and UI_CONFIG.COLORS.CardOwned 
		or (canPurchase and UI_CONFIG.COLORS.Card or UI_CONFIG.COLORS.CardLocked)
	
	local card = Instance.new("Frame")
	card.Name = "Card_" .. upgradeName
	card.Size = UDim2.new(1, 0, 0, 90)
	card.BackgroundColor3 = cardColor
	card.Parent = contentFrame
	
	local cardCorner = Instance.new("UICorner")
	cardCorner.CornerRadius = UDim.new(0, 10)
	cardCorner.Parent = card
	
	-- Icon
	local iconLabel = Instance.new("TextLabel")
	iconLabel.Size = UDim2.new(0, 50, 0, 50)
	iconLabel.Position = UDim2.new(0, 15, 0.5, -25)
	iconLabel.BackgroundTransparency = 1
	iconLabel.Text = config.Icon
	iconLabel.TextSize = 36
	iconLabel.Parent = card
	
	-- Name
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Size = UDim2.new(0, 250, 0, 25)
	nameLabel.Position = UDim2.new(0, 75, 0, 10)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = upgradeName
	nameLabel.TextColor3 = UI_CONFIG.COLORS.Text
	nameLabel.TextSize = 16
	nameLabel.Font = Enum.Font.GothamBold
	nameLabel.TextXAlignment = Enum.TextXAlignment.Left
	nameLabel.Parent = card
	
	-- Description
	local descLabel = Instance.new("TextLabel")
	descLabel.Size = UDim2.new(0, 300, 0, 40)
	descLabel.Position = UDim2.new(0, 75, 0, 35)
	descLabel.BackgroundTransparency = 1
	descLabel.Text = config.Description
	descLabel.TextColor3 = UI_CONFIG.COLORS.TextMuted
	descLabel.TextSize = 12
	descLabel.Font = Enum.Font.Gotham
	descLabel.TextXAlignment = Enum.TextXAlignment.Left
	descLabel.TextWrapped = true
	descLabel.Parent = card
	
	-- Status/Button
	if owned then
		local ownedLabel = Instance.new("TextLabel")
		ownedLabel.Size = UDim2.new(0, 100, 0, 30)
		ownedLabel.Position = UDim2.new(1, -115, 0.5, -15)
		ownedLabel.BackgroundColor3 = UI_CONFIG.COLORS.Green
		ownedLabel.Text = "âœ“ OWNED"
		ownedLabel.TextColor3 = Color3.new(0, 0, 0)
		ownedLabel.TextSize = 14
		ownedLabel.Font = Enum.Font.GothamBold
		ownedLabel.Parent = card
		
		local ownedCorner = Instance.new("UICorner")
		ownedCorner.CornerRadius = UDim.new(0, 6)
		ownedCorner.Parent = ownedLabel
	else
		local buyButton = Instance.new("TextButton")
		buyButton.Name = "BuyButton"
		buyButton.Size = UDim2.new(0, 100, 0, 40)
		buyButton.Position = UDim2.new(1, -115, 0.5, -20)
		buyButton.BackgroundColor3 = canPurchase and UI_CONFIG.COLORS.Accent or UI_CONFIG.COLORS.CardLocked
		buyButton.Text = "$" .. formatPrice(config.Price)
		buyButton.TextColor3 = Color3.new(0, 0, 0)
		buyButton.TextSize = 14
		buyButton.Font = Enum.Font.GothamBold
		buyButton.Parent = card
		
		local buyCorner = Instance.new("UICorner")
		buyCorner.CornerRadius = UDim.new(0, 6)
		buyCorner.Parent = buyButton
		
		if not canPurchase and reason then
			local reasonLabel = Instance.new("TextLabel")
			reasonLabel.Size = UDim2.new(0, 100, 0, 15)
			reasonLabel.Position = UDim2.new(1, -115, 1, -20)
			reasonLabel.BackgroundTransparency = 1
			reasonLabel.Text = reason
			reasonLabel.TextColor3 = UI_CONFIG.COLORS.Red
			reasonLabel.TextSize = 10
			reasonLabel.Font = Enum.Font.Gotham
			reasonLabel.Parent = card
		end
		
		if canPurchase then
			buyButton.MouseButton1Click:Connect(function()
				buyButton.Text = "..."
				buyButton.BackgroundColor3 = UI_CONFIG.COLORS.CardLocked
				PurchaseUpgradeEvent:FireServer(upgradeName)
			end)
		end
	end
	
	return card
end

--------------------------------------------------------------------------------
-- SHOP LOGIC
--------------------------------------------------------------------------------

function refreshShop()
	-- Clear existing content
	for _, child in contentFrame:GetChildren() do
		if child:IsA("Frame") then
			child:Destroy()
		end
	end
	
	-- Update tabs
	for _, child in tabsFrame:GetChildren() do
		if child:IsA("TextButton") then
			child.BackgroundColor3 = child.Name == "Tab_" .. currentCategory 
				and UI_CONFIG.COLORS.Accent or UI_CONFIG.COLORS.Card
		end
	end
	
	-- Get upgrades for current category
	local categoryUpgrades = ConvenienceUpgradesConfig.GetUpgradesByCategory(currentCategory)
	
	-- Create cards
	for _, item in categoryUpgrades do
		createUpgradeCard(item.name, item.config)
	end
	
	-- Update canvas size
	local layout = contentFrame:FindFirstChild("UIListLayout")
	if layout then
		contentFrame.CanvasSize = UDim2.new(0, 0, 0, layout.AbsoluteContentSize.Y + 10)
	end
end

local function loadUpgradesInfo()
	local info = GetUpgradesInfoEvent:InvokeServer()
	if info then
		ownedUpgrades = info.OwnedUpgrades or {}
		
		-- Create category tabs
		for _, child in tabsFrame:GetChildren() do
			if child:IsA("TextButton") then
				child:Destroy()
			end
		end
		
		for i, category in info.Categories or {"Movement", "Income", "Automation"} do
			createCategoryTab(category, i)
		end
	end
end

local function openShop()
	if shopOpen then return end
	shopOpen = true
	
	loadUpgradesInfo()
	refreshShop()
	
	mainFrame.Visible = true
	mainFrame.Size = UDim2.new(0, 0, 0, 0)
	mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
	
	local tween = TweenService:Create(mainFrame, TweenInfo.new(UI_CONFIG.TWEEN_TIME, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
		Size = UDim2.new(0, 550, 0, 500),
		Position = UDim2.new(0.5, -275, 0.5, -250),
	})
	tween:Play()
end

local function closeShop()
	if not shopOpen then return end
	
	local tween = TweenService:Create(mainFrame, TweenInfo.new(UI_CONFIG.TWEEN_TIME, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
		Size = UDim2.new(0, 0, 0, 0),
		Position = UDim2.new(0.5, 0, 0.5, 0),
	})
	tween:Play()
	tween.Completed:Connect(function()
		mainFrame.Visible = false
	end)
	
	shopOpen = false
end

local function showMessage(text: string, color: Color3?)
	messageLabel.Text = text
	messageLabel.TextColor3 = color or UI_CONFIG.COLORS.Green
	
	task.delay(3, function()
		if messageLabel.Text == text then
			messageLabel.Text = ""
		end
	end)
end

--------------------------------------------------------------------------------
-- EVENT HANDLERS
--------------------------------------------------------------------------------

-- Close button
mainFrame.Header.CloseButton.MouseButton1Click:Connect(closeShop)

-- Purchase result
PurchaseUpgradeEvent.OnClientEvent:Connect(function(success, message)
	if success then
		showMessage(message, UI_CONFIG.COLORS.Green)
	else
		showMessage(message, UI_CONFIG.COLORS.Red)
	end
	
	-- Refresh the shop
	loadUpgradesInfo()
	refreshShop()
end)

--------------------------------------------------------------------------------
-- PROXIMITY DETECTION
--------------------------------------------------------------------------------

local function checkProximity(): boolean
	local character = player.Character
	if not character then return false end
	
	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	if not humanoidRootPart then return false end
	
	for _, vendor in CollectionService:GetTagged("ConvenienceShopVendor") do
		local distance = (humanoidRootPart.Position - vendor.Position).Magnitude
		if distance <= UI_CONFIG.INTERACTION_DISTANCE then
			return true
		end
	end
	
	return false
end

--------------------------------------------------------------------------------
-- INPUT HANDLING
--------------------------------------------------------------------------------

UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	
	if input.KeyCode == Enum.KeyCode.E then
		if shopOpen then
			closeShop()
		elseif checkProximity() then
			openShop()
		end
	elseif input.KeyCode == Enum.KeyCode.Escape then
		if shopOpen then
			closeShop()
		end
	elseif input.KeyCode == Enum.KeyCode.H then
		-- Teleport home if player has the upgrade
		if _G.ConvenienceUpgrades and _G.ConvenienceUpgrades.HasTeleportHome and _G.ConvenienceUpgrades.HasTeleportHome(player) then
			-- Teleport to main island
			local mainIsland = workspace:FindFirstChild("MainIsland")
			if mainIsland then
				local spawnPoint = mainIsland:FindFirstChild("Island") or mainIsland:FindFirstChildWhichIsA("BasePart")
				if spawnPoint and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
					player.Character.HumanoidRootPart.CFrame = spawnPoint.CFrame * CFrame.new(0, 10, 0)
				end
			end
		end
	end
end)

--------------------------------------------------------------------------------
-- PROXIMITY PROMPT LISTENER
--------------------------------------------------------------------------------

-- Setup listener for ProximityPrompt on Convenience Shop vendors
local function setupProximityPromptListener()
	-- Listen for any ConvenienceShopVendor that gets added
	for _, vendor in CollectionService:GetTagged("ConvenienceShopVendor") do
		local prompt = vendor:FindFirstChild("ConvenienceShopPrompt")
		if prompt and prompt:IsA("ProximityPrompt") then
			prompt.Triggered:Connect(function(playerWhoTriggered)
				if playerWhoTriggered == player then
					openShop()
				end
			end)
		end
	end
	
	-- Also listen for new vendors being added
	CollectionService:GetInstanceAddedSignal("ConvenienceShopVendor"):Connect(function(vendor)
		local prompt = vendor:WaitForChild("ConvenienceShopPrompt", 5)
		if prompt and prompt:IsA("ProximityPrompt") then
			prompt.Triggered:Connect(function(playerWhoTriggered)
				if playerWhoTriggered == player then
					openShop()
				end
			end)
		end
	end)
end

task.spawn(setupProximityPromptListener)

print("âœ“ ConvenienceUpgradesUI initialized")


================================================================================
FILE: src\client\IslandShopUI.client.luau
================================================================================

--[[
	IslandShopUI Client Script
	
	Handles the UI for the Island Shop where players can:
	1. View their current tier status
	2. Purchase tier unlocks
	
	Opens when player presses E near the Island Shop vendor.
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local CollectionService = game:GetService("CollectionService")

-- Player reference
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Remote Events
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local PurchaseTierEvent = RemoteEvents:WaitForChild("PurchaseTier")
local GetTierInfoEvent = RemoteEvents:WaitForChild("GetTierInfo")

-- Configuration
local UI_CONFIG = {
	INTERACTION_DISTANCE = 20,
	TWEEN_TIME = 0.3,
}

-- State
local shopOpen = false
local _nearVendor = false

--------------------------------------------------------------------------------
-- UI CREATION
--------------------------------------------------------------------------------

local function createShopUI()
	-- Create ScreenGui
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "IslandShopUI"
	screenGui.ResetOnSpawn = false
	screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	
	-- Main container
	local mainFrame = Instance.new("Frame")
	mainFrame.Name = "MainFrame"
	mainFrame.Size = UDim2.new(0, 400, 0, 350)
	mainFrame.Position = UDim2.new(0.5, -200, 0.5, -175)
	mainFrame.BackgroundColor3 = Color3.fromRGB(25, 15, 40)
	mainFrame.BorderSizePixel = 0
	mainFrame.Visible = false
	mainFrame.Parent = screenGui
	
	local mainCorner = Instance.new("UICorner")
	mainCorner.CornerRadius = UDim.new(0, 16)
	mainCorner.Parent = mainFrame
	
	local mainStroke = Instance.new("UIStroke")
	mainStroke.Color = Color3.fromRGB(150, 100, 200)
	mainStroke.Thickness = 2
	mainStroke.Parent = mainFrame
	
	-- Header
	local header = Instance.new("Frame")
	header.Name = "Header"
	header.Size = UDim2.new(1, 0, 0, 60)
	header.BackgroundColor3 = Color3.fromRGB(60, 30, 90)
	header.BorderSizePixel = 0
	header.Parent = mainFrame
	
	local headerCorner = Instance.new("UICorner")
	headerCorner.CornerRadius = UDim.new(0, 16)
	headerCorner.Parent = header
	
	-- Fix bottom corners of header
	local headerFix = Instance.new("Frame")
	headerFix.Size = UDim2.new(1, 0, 0, 16)
	headerFix.Position = UDim2.new(0, 0, 1, -16)
	headerFix.BackgroundColor3 = Color3.fromRGB(60, 30, 90)
	headerFix.BorderSizePixel = 0
	headerFix.Parent = header
	
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "Title"
	titleLabel.Size = UDim2.new(1, -60, 1, 0)
	titleLabel.Position = UDim2.new(0, 20, 0, 0)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Text = "ðŸï¸ ISLAND SHOP"
	titleLabel.TextColor3 = Color3.fromRGB(255, 200, 255)
	titleLabel.TextSize = 28
	titleLabel.Font = Enum.Font.GothamBold
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	titleLabel.Parent = header
	
	-- Close button
	local closeButton = Instance.new("TextButton")
	closeButton.Name = "CloseButton"
	closeButton.Size = UDim2.new(0, 40, 0, 40)
	closeButton.Position = UDim2.new(1, -50, 0, 10)
	closeButton.BackgroundColor3 = Color3.fromRGB(200, 60, 60)
	closeButton.Text = "âœ•"
	closeButton.TextColor3 = Color3.new(1, 1, 1)
	closeButton.TextSize = 20
	closeButton.Font = Enum.Font.GothamBold
	closeButton.Parent = header
	
	local closeCorner = Instance.new("UICorner")
	closeCorner.CornerRadius = UDim.new(0.5, 0)
	closeCorner.Parent = closeButton
	
	-- Content area
	local content = Instance.new("Frame")
	content.Name = "Content"
	content.Size = UDim2.new(1, -40, 1, -80)
	content.Position = UDim2.new(0, 20, 0, 70)
	content.BackgroundTransparency = 1
	content.Parent = mainFrame
	
	-- Status section
	local statusFrame = Instance.new("Frame")
	statusFrame.Name = "StatusFrame"
	statusFrame.Size = UDim2.new(1, 0, 0, 100)
	statusFrame.BackgroundColor3 = Color3.fromRGB(40, 25, 60)
	statusFrame.BorderSizePixel = 0
	statusFrame.Parent = content
	
	local statusCorner = Instance.new("UICorner")
	statusCorner.CornerRadius = UDim.new(0, 12)
	statusCorner.Parent = statusFrame
	
	local tiersLabel = Instance.new("TextLabel")
	tiersLabel.Name = "TiersLabel"
	tiersLabel.Size = UDim2.new(1, -20, 0, 30)
	tiersLabel.Position = UDim2.new(0, 10, 0, 10)
	tiersLabel.BackgroundTransparency = 1
	tiersLabel.Text = "Current Islands: 1 / 6"
	tiersLabel.TextColor3 = Color3.fromRGB(200, 200, 255)
	tiersLabel.TextSize = 18
	tiersLabel.Font = Enum.Font.GothamBold
	tiersLabel.TextXAlignment = Enum.TextXAlignment.Left
	tiersLabel.Parent = statusFrame
	
	local modelsLabel = Instance.new("TextLabel")
	modelsLabel.Name = "ModelsLabel"
	modelsLabel.Size = UDim2.new(1, -20, 0, 25)
	modelsLabel.Position = UDim2.new(0, 10, 0, 40)
	modelsLabel.BackgroundTransparency = 1
	modelsLabel.Text = "Total Models: 0"
	modelsLabel.TextColor3 = Color3.fromRGB(180, 180, 200)
	modelsLabel.TextSize = 16
	modelsLabel.Font = Enum.Font.Gotham
	modelsLabel.TextXAlignment = Enum.TextXAlignment.Left
	modelsLabel.Parent = statusFrame
	
	local fillLabel = Instance.new("TextLabel")
	fillLabel.Name = "FillLabel"
	fillLabel.Size = UDim2.new(1, -20, 0, 25)
	fillLabel.Position = UDim2.new(0, 10, 0, 65)
	fillLabel.BackgroundTransparency = 1
	fillLabel.Text = "Models per island: 12"
	fillLabel.TextColor3 = Color3.fromRGB(150, 150, 170)
	fillLabel.TextSize = 14
	fillLabel.Font = Enum.Font.Gotham
	fillLabel.TextXAlignment = Enum.TextXAlignment.Left
	fillLabel.Parent = statusFrame
	
	-- Purchase section
	local purchaseFrame = Instance.new("Frame")
	purchaseFrame.Name = "PurchaseFrame"
	purchaseFrame.Size = UDim2.new(1, 0, 0, 120)
	purchaseFrame.Position = UDim2.new(0, 0, 0, 110)
	purchaseFrame.BackgroundColor3 = Color3.fromRGB(40, 25, 60)
	purchaseFrame.BorderSizePixel = 0
	purchaseFrame.Parent = content
	
	local purchaseCorner = Instance.new("UICorner")
	purchaseCorner.CornerRadius = UDim.new(0, 12)
	purchaseCorner.Parent = purchaseFrame
	
	local purchaseTitle = Instance.new("TextLabel")
	purchaseTitle.Name = "PurchaseTitle"
	purchaseTitle.Size = UDim2.new(1, -20, 0, 30)
	purchaseTitle.Position = UDim2.new(0, 10, 0, 10)
	purchaseTitle.BackgroundTransparency = 1
	purchaseTitle.Text = "ðŸ›’ Purchase New Island"
	purchaseTitle.TextColor3 = Color3.fromRGB(255, 220, 100)
	purchaseTitle.TextSize = 18
	purchaseTitle.Font = Enum.Font.GothamBold
	purchaseTitle.TextXAlignment = Enum.TextXAlignment.Left
	purchaseTitle.Parent = purchaseFrame
	
	local priceLabel = Instance.new("TextLabel")
	priceLabel.Name = "PriceLabel"
	priceLabel.Size = UDim2.new(1, -20, 0, 25)
	priceLabel.Position = UDim2.new(0, 10, 0, 40)
	priceLabel.BackgroundTransparency = 1
	priceLabel.Text = "Price: $5,000"
	priceLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
	priceLabel.TextSize = 16
	priceLabel.Font = Enum.Font.GothamBold
	priceLabel.TextXAlignment = Enum.TextXAlignment.Left
	priceLabel.Parent = purchaseFrame
	
	local purchaseButton = Instance.new("TextButton")
	purchaseButton.Name = "PurchaseButton"
	purchaseButton.Size = UDim2.new(1, -20, 0, 40)
	purchaseButton.Position = UDim2.new(0, 10, 0, 70)
	purchaseButton.BackgroundColor3 = Color3.fromRGB(80, 180, 80)
	purchaseButton.Text = "PURCHASE ISLAND"
	purchaseButton.TextColor3 = Color3.new(1, 1, 1)
	purchaseButton.TextSize = 18
	purchaseButton.Font = Enum.Font.GothamBold
	purchaseButton.Parent = purchaseFrame
	
	local purchaseButtonCorner = Instance.new("UICorner")
	purchaseButtonCorner.CornerRadius = UDim.new(0, 8)
	purchaseButtonCorner.Parent = purchaseButton
	
	-- Message label
	local messageLabel = Instance.new("TextLabel")
	messageLabel.Name = "MessageLabel"
	messageLabel.Size = UDim2.new(1, 0, 0, 30)
	messageLabel.Position = UDim2.new(0, 0, 1, -30)
	messageLabel.BackgroundTransparency = 1
	messageLabel.Text = ""
	messageLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
	messageLabel.TextSize = 14
	messageLabel.Font = Enum.Font.Gotham
	messageLabel.Parent = content
	
	screenGui.Parent = playerGui
	
	return screenGui
end

--------------------------------------------------------------------------------
-- UI LOGIC
--------------------------------------------------------------------------------

local screenGui = createShopUI()
local mainFrame = screenGui:WaitForChild("MainFrame")
local content = mainFrame:WaitForChild("Content")
local statusFrame = content:WaitForChild("StatusFrame")
local purchaseFrame = content:WaitForChild("PurchaseFrame")

local function formatMoney(amount: number): string
	local suffixes = {"K", "M", "B", "T", "Qa", "Qi", "Sx", "Sp", "Oc", "No", "Dc"}
	
	if amount < 1000 then
		return "$" .. tostring(math.floor(amount))
	end
	
	-- Calculate the magnitude (power of 1000)
	local magnitude = math.floor(math.log(amount, 1000))
	
	-- Cap at the largest suffix
	if magnitude > #suffixes then
		magnitude = #suffixes
	end
	
	local value = amount / (1000 ^ magnitude)
	
	-- Format with 1 decimal place if < 100, otherwise no decimals
	if value < 100 and value % 1 ~= 0 then
		return string.format("$%.1f%s", value, suffixes[magnitude])
	else
		return string.format("$%.0f%s", value, suffixes[magnitude])
	end
end

local function updateShopInfo()
	local info = GetTierInfoEvent:InvokeServer()
	if not info then return end
	
	-- Update status labels
	statusFrame.TiersLabel.Text = string.format("Current Islands: %d / %d", info.CurrentTiers, info.MaxTiers)
	statusFrame.ModelsLabel.Text = string.format("Total Models: %d", info.TotalModels)
	statusFrame.FillLabel.Text = string.format("Models per island: %d", info.ModelsPerTier)
	
	-- Update purchase section
	if info.CanPurchase then
		purchaseFrame.PriceLabel.Text = string.format("Price: %s", formatMoney(info.NextTierPrice))
		purchaseFrame.PurchaseButton.BackgroundColor3 = Color3.fromRGB(80, 180, 80)
		purchaseFrame.PurchaseButton.Text = "PURCHASE ISLAND"
	else
		purchaseFrame.PriceLabel.Text = "Max islands reached!"
		purchaseFrame.PurchaseButton.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
		purchaseFrame.PurchaseButton.Text = "MAX ISLANDS"
	end
end

local function openShop()
	if shopOpen then return end
	shopOpen = true
	
	updateShopInfo()
	
	mainFrame.Visible = true
	mainFrame.Size = UDim2.new(0, 0, 0, 0)
	mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
	
	local tween = TweenService:Create(mainFrame, TweenInfo.new(UI_CONFIG.TWEEN_TIME, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
		Size = UDim2.new(0, 400, 0, 350),
		Position = UDim2.new(0.5, -200, 0.5, -175),
	})
	tween:Play()
end

local function closeShop()
	if not shopOpen then return end
	
	local tween = TweenService:Create(mainFrame, TweenInfo.new(UI_CONFIG.TWEEN_TIME, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
		Size = UDim2.new(0, 0, 0, 0),
		Position = UDim2.new(0.5, 0, 0.5, 0),
	})
	tween:Play()
	tween.Completed:Connect(function()
		mainFrame.Visible = false
	end)
	
	shopOpen = false
end

local function showMessage(text, color)
	local messageLabel = content:FindFirstChild("MessageLabel")
	if messageLabel then
		messageLabel.Text = text
		messageLabel.TextColor3 = color or Color3.fromRGB(255, 200, 100)
		
		task.delay(3, function()
			if messageLabel.Text == text then
				messageLabel.Text = ""
			end
		end)
	end
end

--------------------------------------------------------------------------------
-- BUTTON HANDLERS
--------------------------------------------------------------------------------

-- Close button
mainFrame.Header.CloseButton.MouseButton1Click:Connect(closeShop)

-- Purchase button
purchaseFrame.PurchaseButton.MouseButton1Click:Connect(function()
	purchaseFrame.PurchaseButton.Text = "Purchasing..."
	purchaseFrame.PurchaseButton.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
	
	PurchaseTierEvent:FireServer()
end)

-- Handle purchase result
PurchaseTierEvent.OnClientEvent:Connect(function(success, message)
	if success then
		showMessage(message, Color3.fromRGB(100, 255, 100))
	else
		showMessage(message, Color3.fromRGB(255, 100, 100))
	end
	
	-- Refresh info
	updateShopInfo()
end)

--------------------------------------------------------------------------------
-- PROXIMITY DETECTION
--------------------------------------------------------------------------------

local function checkProximity()
	local character = player.Character
	if not character then return false end
	
	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	if not humanoidRootPart then return false end
	
	-- Find vendor
	for _, vendor in CollectionService:GetTagged("IslandShopVendor") do
		local distance = (humanoidRootPart.Position - vendor.Position).Magnitude
		if distance <= UI_CONFIG.INTERACTION_DISTANCE then
			return true
		end
	end
	
	return false
end

--------------------------------------------------------------------------------
-- INPUT HANDLING
--------------------------------------------------------------------------------

UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	
	if input.KeyCode == Enum.KeyCode.E then
		if shopOpen then
			closeShop()
		elseif checkProximity() then
			openShop()
		end
	elseif input.KeyCode == Enum.KeyCode.Escape then
		if shopOpen then
			closeShop()
		end
	end
end)

-- Proximity check loop for showing hints
task.spawn(function()
	while true do
		_nearVendor = checkProximity()
		task.wait(0.5)
	end
end)

--------------------------------------------------------------------------------
-- PROXIMITY PROMPT LISTENER
--------------------------------------------------------------------------------

-- Setup listener for ProximityPrompt on Island Shop vendors
local function setupProximityPromptListener()
	-- Listen for any IslandShopVendor that gets added
	for _, vendor in CollectionService:GetTagged("IslandShopVendor") do
		local prompt = vendor:FindFirstChild("IslandShopPrompt")
		if prompt and prompt:IsA("ProximityPrompt") then
			prompt.Triggered:Connect(function(playerWhoTriggered)
				if playerWhoTriggered == player then
					openShop()
				end
			end)
		end
	end
	
	-- Also listen for new vendors being added
	CollectionService:GetInstanceAddedSignal("IslandShopVendor"):Connect(function(vendor)
		local prompt = vendor:WaitForChild("IslandShopPrompt", 5)
		if prompt and prompt:IsA("ProximityPrompt") then
			prompt.Triggered:Connect(function(playerWhoTriggered)
				if playerWhoTriggered == player then
					openShop()
				end
			end)
		end
	end)
end

task.spawn(setupProximityPromptListener)

print("âœ“ IslandShopUI initialized")


================================================================================
FILE: src\client\LoadingScreen.client.luau
================================================================================

--[[
	LoadingScreen Client Script
	
	Blocks view/interaction until server confirms all data and world elements are ready.
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local StarterGui = game:GetService("StarterGui")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- Remotes
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local PlayerReadyEvent = RemoteEvents:WaitForChild("PlayerReady")

-- Config
local CONFIG = {
	BG_COLOR = Color3.fromRGB(15, 15, 20),
	ACCENT_COLOR = Color3.fromRGB(140, 80, 160), -- Purple/Pink theme
	FADE_TIME = 0.8,
}

-- UI State
local screenGui
local mainFrame
local dotsLabel
local isLoaded = false

--------------------------------------------------------------------------------
-- UI CREATION
--------------------------------------------------------------------------------

local function createLoadingUI()
	screenGui = Instance.new("ScreenGui")
	screenGui.Name = "LoadingScreen"
	screenGui.IgnoreGuiInset = true -- Cover topbar
	screenGui.DisplayOrder = 10000 -- On top of everything
	screenGui.ResetOnSpawn = false
	screenGui.Parent = PlayerGui
	
	mainFrame = Instance.new("Frame")
	mainFrame.Name = "MainFrame"
	mainFrame.Size = UDim2.new(1, 0, 1, 0)
	mainFrame.BackgroundColor3 = CONFIG.BG_COLOR
	mainFrame.BorderSizePixel = 0
	mainFrame.Parent = screenGui
	
	-- Loading Container
	local container = Instance.new("Frame")
	container.Size = UDim2.new(0, 300, 0, 100)
	container.AnchorPoint = Vector2.new(0.5, 0.5)
	container.Position = UDim2.new(0.5, 0, 0.5, 0)
	container.BackgroundTransparency = 1
	container.Parent = mainFrame
	
	-- Title
	local title = Instance.new("TextLabel")
	title.Text = "BRAINROT CLICKER"
	title.Font = Enum.Font.GothamBlack
	title.TextSize = 32
	title.TextColor3 = Color3.new(1, 1, 1)
	title.Size = UDim2.new(1, 0, 0, 40)
	title.BackgroundTransparency = 1
	title.Parent = container
	
	-- Loading Text
	dotsLabel = Instance.new("TextLabel")
	dotsLabel.Text = "Loading..."
	dotsLabel.Font = Enum.Font.GothamMedium
	dotsLabel.TextSize = 18
	dotsLabel.TextColor3 = CONFIG.ACCENT_COLOR
	dotsLabel.Size = UDim2.new(1, 0, 0, 20)
	dotsLabel.Position = UDim2.new(0, 0, 0, 50)
	dotsLabel.BackgroundTransparency = 1
	dotsLabel.Parent = container
	
	-- Disable Core GUIs explicitly
	StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.All, false)
end

--------------------------------------------------------------------------------
-- LOGIC
--------------------------------------------------------------------------------

local function animateDots()
	local dots = "..."
	local count = 0
	while not isLoaded and mainFrame.Parent do
		count = (count + 1) % 4
		dotsLabel.Text = "Loading" .. string.rep(".", count)
		task.wait(0.5)
	end
end

local function onReady()
	if isLoaded then return end
	isLoaded = true
	
	print("LoadingScreen: Server says READY. Fading out...")
	
	-- Fade out
	local tweenInfo = TweenInfo.new(CONFIG.FADE_TIME, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
	local tween = TweenService:Create(mainFrame, tweenInfo, {BackgroundTransparency = 1})
	
	-- Fade text too
	for _, child in mainFrame:GetDescendants() do
		if child:IsA("TextLabel") then
			TweenService:Create(child, tweenInfo, {TextTransparency = 1}):Play()
		end
	end
	
	tween:Play()
	tween.Completed:Wait()
	
	screenGui:Destroy()
	
	-- Re-enable Core GUIs
	StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.All, true)
	StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, false) -- Keep custom if needed, or true
end

-- Init
createLoadingUI()
task.spawn(animateDots)

-- Listen for signal
PlayerReadyEvent.OnClientEvent:Connect(onReady)

-- Timeout Safety (15s)
task.delay(15, function()
	if not isLoaded then
		warn("LoadingScreen: Timed out waiting for server!")
		dotsLabel.Text = "Taking longer than expected..."
		-- Optional: Reveal anyway or show Retry button
		task.wait(5)
		if not isLoaded then
			dotsLabel.Text = "Connection slow. Please Rejoin."
		end
	end
end)


================================================================================
FILE: src\client\MarketTerminalUI.client.luau
================================================================================

--[[
	MarketTerminalUI Client Script
	
	Handles the market terminal interface for selling items.
	
	Features:
	- Shows backpack contents
	- Displays current prices with market multiplier
	- Sell individual items or all at once
	- Price updates in real-time
	
	Opens via ProximityPrompt on Market building or M key.
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

-- Get player
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- Wait for remotes
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local RemoteFunctions = ReplicatedStorage:WaitForChild("RemoteFunctions")

-- Stock market for rate display
local stockMarketFolder = ReplicatedStorage:WaitForChild("StockMarket")

-- Market events
local ItemSoldEvent = RemoteEvents:WaitForChild("ItemSold")
local SellItemFunction = RemoteFunctions:WaitForChild("SellItem")
local SellAllFunction = RemoteFunctions:WaitForChild("SellAll")
local GetMarketPricesFunction = RemoteFunctions:WaitForChild("GetMarketPrices")

-- Backpack events
local BackpackUpdatedEvent = RemoteEvents:WaitForChild("BackpackUpdated")
local GetBackpackFunction = RemoteFunctions:WaitForChild("GetBackpack")

-- Wait for ItemConfig
local Shared = ReplicatedStorage:WaitForChild("Shared")
local ItemConfig = require(Shared:WaitForChild("ItemConfig"))

-- UI Colors
local COLORS = {
	background = Color3.fromRGB(10, 10, 20),
	panel = Color3.fromRGB(20, 25, 35),
	accent = Color3.fromRGB(255, 200, 50),  -- Gold for market
	accentDark = Color3.fromRGB(200, 150, 30),
	text = Color3.fromRGB(255, 255, 255),
	textMuted = Color3.fromRGB(150, 150, 170),
	success = Color3.fromRGB(100, 255, 150),
	profit = Color3.fromRGB(50, 255, 100),
	loss = Color3.fromRGB(255, 80, 80),
	itemBg = Color3.fromRGB(30, 35, 50),
}

-- State
local isOpen = false
local currentBackpack = {}
local _backpackTotal = 0
local marketPrices = {} -- [itemId] = {currentPrice, sector, categoryRate, etc}

-- UI References
local screenGui = nil
local mainFrame = nil

--------------------------------------------------------------------------------
-- UI CREATION
--------------------------------------------------------------------------------

local function createScreenGui()
	local gui = Instance.new("ScreenGui")
	gui.Name = "MarketTerminalUI"
	gui.ResetOnSpawn = false
	gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	gui.Parent = PlayerGui
	return gui
end

local function createMainFrame(parent)
	local frame = Instance.new("Frame")
	frame.Name = "MainFrame"
	frame.Size = UDim2.new(0, 550, 0, 450)
	frame.Position = UDim2.new(0.5, -275, 0.5, -225)
	frame.BackgroundColor3 = COLORS.background
	frame.BackgroundTransparency = 0.05
	frame.BorderSizePixel = 0
	frame.Visible = false
	frame.Parent = parent
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 16)
	corner.Parent = frame
	
	local stroke = Instance.new("UIStroke")
	stroke.Color = COLORS.accent
	stroke.Thickness = 2
	stroke.Transparency = 0.3
	stroke.Parent = frame
	
	return frame
end

local function createHeader(parent)
	local header = Instance.new("Frame")
	header.Name = "Header"
	header.Size = UDim2.new(1, 0, 0, 60)
	header.BackgroundColor3 = COLORS.panel
	header.BackgroundTransparency = 0.3
	header.BorderSizePixel = 0
	header.Parent = parent
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 16)
	corner.Parent = header
	
	-- Title
	local title = Instance.new("TextLabel")
	title.Name = "Title"
	title.Size = UDim2.new(0.5, 0, 0, 30)
	title.Position = UDim2.new(0, 20, 0, 8)
	title.BackgroundTransparency = 1
	title.Text = "ðŸª MARKET TERMINAL"
	title.TextColor3 = COLORS.accent
	title.TextSize = 20
	title.Font = Enum.Font.GothamBold
	title.TextXAlignment = Enum.TextXAlignment.Left
	title.Parent = header
	
	-- Market rate display (Shows average or status)
	local rateLabel = Instance.new("TextLabel")
	rateLabel.Name = "RateLabel"
	rateLabel.Size = UDim2.new(0.5, -30, 0, 25)
	rateLabel.Position = UDim2.new(0, 20, 0, 35)
	rateLabel.BackgroundTransparency = 1
	rateLabel.Text = "ðŸ“Š Market open and active"
	rateLabel.TextColor3 = COLORS.success
	rateLabel.TextSize = 14
	rateLabel.Font = Enum.Font.GothamBold
	rateLabel.TextXAlignment = Enum.TextXAlignment.Left
	rateLabel.Parent = header
	
	-- Close button
	local closeBtn = Instance.new("TextButton")
	closeBtn.Name = "CloseButton"
	closeBtn.Size = UDim2.new(0, 40, 0, 40)
	closeBtn.Position = UDim2.new(1, -50, 0, 10)
	closeBtn.BackgroundColor3 = Color3.fromRGB(255, 80, 80)
	closeBtn.BackgroundTransparency = 0.7
	closeBtn.Text = "âœ•"
	closeBtn.TextColor3 = COLORS.text
	closeBtn.TextSize = 18
	closeBtn.Font = Enum.Font.GothamBold
	closeBtn.Parent = header
	
	local closeCorner = Instance.new("UICorner")
	closeCorner.CornerRadius = UDim.new(0, 8)
	closeCorner.Parent = closeBtn
	
	closeBtn.MouseButton1Click:Connect(function()
		closeUI()
	end)
	
	return header
end

local function createItemsPanel(parent)
	local panel = Instance.new("Frame")
	panel.Name = "ItemsPanel"
	panel.Size = UDim2.new(1, -20, 1, -130)
	panel.Position = UDim2.new(0, 10, 0, 70)
	panel.BackgroundColor3 = COLORS.panel
	panel.BackgroundTransparency = 0.5
	panel.BorderSizePixel = 0
	panel.Parent = parent
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 12)
	corner.Parent = panel
	
	-- Header row
	local headerRow = Instance.new("Frame")
	headerRow.Name = "HeaderRow"
	headerRow.Size = UDim2.new(1, -20, 0, 30)
	headerRow.Position = UDim2.new(0, 10, 0, 10)
	headerRow.BackgroundTransparency = 1
	headerRow.Parent = panel
	
	local itemHeader = Instance.new("TextLabel")
	itemHeader.Size = UDim2.new(0.3, 0, 1, 0)
	itemHeader.BackgroundTransparency = 1
	itemHeader.Text = "ITEM"
	itemHeader.TextColor3 = COLORS.textMuted
	itemHeader.TextSize = 12
	itemHeader.Font = Enum.Font.GothamBold
	itemHeader.TextXAlignment = Enum.TextXAlignment.Left
	itemHeader.Parent = headerRow
	
	local qtyHeader = Instance.new("TextLabel")
	qtyHeader.Size = UDim2.new(0.12, 0, 1, 0)
	qtyHeader.Position = UDim2.new(0.3, 0, 0, 0)
	qtyHeader.BackgroundTransparency = 1
	qtyHeader.Text = "QTY"
	qtyHeader.TextColor3 = COLORS.textMuted
	qtyHeader.TextSize = 12
	qtyHeader.Font = Enum.Font.GothamBold
	qtyHeader.Parent = headerRow

	local sectorHeader = Instance.new("TextLabel")
	sectorHeader.Size = UDim2.new(0.18, 0, 1, 0)
	sectorHeader.Position = UDim2.new(0.42, 0, 0, 0)
	sectorHeader.BackgroundTransparency = 1
	sectorHeader.Text = "SECTOR"
	sectorHeader.TextColor3 = COLORS.textMuted
	sectorHeader.TextSize = 12
	sectorHeader.Font = Enum.Font.GothamBold
	sectorHeader.Parent = headerRow
	
	local priceHeader = Instance.new("TextLabel")
	priceHeader.Size = UDim2.new(0.15, 0, 1, 0)
	priceHeader.Position = UDim2.new(0.6, 0, 0, 0)
	priceHeader.BackgroundTransparency = 1
	priceHeader.Text = "PRICE"
	priceHeader.TextColor3 = COLORS.textMuted
	priceHeader.TextSize = 12
	priceHeader.Font = Enum.Font.GothamBold
	priceHeader.Parent = headerRow
	
	local totalHeader = Instance.new("TextLabel")
	totalHeader.Size = UDim2.new(0.15, 0, 1, 0)
	totalHeader.Position = UDim2.new(0.75, 0, 0, 0)
	totalHeader.BackgroundTransparency = 1
	totalHeader.Text = "TOTAL"
	totalHeader.TextColor3 = COLORS.textMuted
	totalHeader.TextSize = 12
	totalHeader.Font = Enum.Font.GothamBold
	totalHeader.Parent = headerRow
	
	-- Scroll frame for items
	local scrollFrame = Instance.new("ScrollingFrame")
	scrollFrame.Name = "ItemList"
	scrollFrame.Size = UDim2.new(1, -20, 1, -50)
	scrollFrame.Position = UDim2.new(0, 10, 0, 45)
	scrollFrame.BackgroundTransparency = 1
	scrollFrame.ScrollBarThickness = 4
	scrollFrame.ScrollBarImageColor3 = COLORS.accent
	scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
	scrollFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
	scrollFrame.Parent = panel
	
	local listLayout = Instance.new("UIListLayout")
	listLayout.Padding = UDim.new(0, 4)
	listLayout.Parent = scrollFrame
	
	return panel
end

local function createBottomBar(parent)
	local bar = Instance.new("Frame")
	bar.Name = "BottomBar"
	bar.Size = UDim2.new(1, -20, 0, 50)
	bar.Position = UDim2.new(0, 10, 1, -55)
	bar.BackgroundColor3 = COLORS.panel
	bar.BackgroundTransparency = 0.3
	bar.BorderSizePixel = 0
	bar.Parent = parent
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 12)
	corner.Parent = bar
	
	-- Total value display
	local totalLabel = Instance.new("TextLabel")
	totalLabel.Name = "TotalValue"
	totalLabel.Size = UDim2.new(0.5, -10, 1, 0)
	totalLabel.Position = UDim2.new(0, 15, 0, 0)
	totalLabel.BackgroundTransparency = 1
	totalLabel.Text = "ðŸ’° Total Value: $0"
	totalLabel.TextColor3 = COLORS.profit
	totalLabel.TextSize = 18
	totalLabel.Font = Enum.Font.GothamBold
	totalLabel.TextXAlignment = Enum.TextXAlignment.Left
	totalLabel.Parent = bar
	
	-- Sell All button
	local sellAllBtn = Instance.new("TextButton")
	sellAllBtn.Name = "SellAllButton"
	sellAllBtn.Size = UDim2.new(0, 180, 0, 40)
	sellAllBtn.Position = UDim2.new(1, -190, 0.5, -20)
	sellAllBtn.BackgroundColor3 = COLORS.accent
	sellAllBtn.Text = "ðŸ’° SELL ALL"
	sellAllBtn.TextColor3 = COLORS.background
	sellAllBtn.TextSize = 16
	sellAllBtn.Font = Enum.Font.GothamBold
	sellAllBtn.Parent = bar
	
	local btnCorner = Instance.new("UICorner")
	btnCorner.CornerRadius = UDim.new(0, 8)
	btnCorner.Parent = sellAllBtn
	
	sellAllBtn.MouseButton1Click:Connect(function()
		local _, earned = SellAllFunction:InvokeServer()
		if earned > 0 then
			-- Flash the button green
			sellAllBtn.BackgroundColor3 = COLORS.profit
			task.wait(0.3)
			sellAllBtn.BackgroundColor3 = COLORS.accent
		end
	end)
	
	-- Hover effect
	sellAllBtn.MouseEnter:Connect(function()
		TweenService:Create(sellAllBtn, TweenInfo.new(0.2), {BackgroundColor3 = COLORS.accentDark}):Play()
	end)
	
	sellAllBtn.MouseLeave:Connect(function()
		TweenService:Create(sellAllBtn, TweenInfo.new(0.2), {BackgroundColor3 = COLORS.accent}):Play()
	end)
	
	return bar
end

local function createItemRow(parent, itemId, count, priceData)
	local tierEmoji = {"âšª", "ðŸŸ¡", "ðŸŸ ", "ðŸ’Ž"}
	local itemInfo = ItemConfig.Items[itemId] or {}
	local emoji = tierEmoji[itemInfo.tier or 1] or "âšª"
	
	local currentPrice = priceData.currentPrice or 0
	local totalValue = count * currentPrice
	local sector = priceData.sector or "Neutral"
	local rate = priceData.sectorRate or 1.0
	
	local row = Instance.new("Frame")
	row.Name = "Item_" .. itemId
	row.Size = UDim2.new(1, 0, 0, 36)
	row.BackgroundColor3 = COLORS.itemBg
	row.BackgroundTransparency = 0.4
	row.BorderSizePixel = 0
	row.Parent = parent
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 6)
	corner.Parent = row
	
	-- Item name
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Size = UDim2.new(0.3, 0, 1, 0)
	nameLabel.Position = UDim2.new(0, 10, 0, 0)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = emoji .. " " .. itemId
	nameLabel.TextColor3 = COLORS.text
	nameLabel.TextSize = 11
	nameLabel.Font = Enum.Font.Gotham
	nameLabel.TextXAlignment = Enum.TextXAlignment.Left
	nameLabel.TextTruncate = Enum.TextTruncate.AtEnd
	nameLabel.Parent = row
	
	-- Quantity
	local qtyLabel = Instance.new("TextLabel")
	qtyLabel.Size = UDim2.new(0.12, 0, 1, 0)
	qtyLabel.Position = UDim2.new(0.3, 0, 0, 0)
	qtyLabel.BackgroundTransparency = 1
	qtyLabel.Text = "x" .. count
	qtyLabel.TextColor3 = COLORS.textMuted
	qtyLabel.TextSize = 12
	qtyLabel.Font = Enum.Font.GothamBold
	qtyLabel.Parent = row

	-- Sector
	local sectorLabel = Instance.new("TextLabel")
	sectorLabel.Size = UDim2.new(0.18, 0, 1, 0)
	sectorLabel.Position = UDim2.new(0.42, 0, 0, 0)
	sectorLabel.BackgroundTransparency = 1
	sectorLabel.Text = sector
	sectorLabel.TextColor3 = rate >= 1.2 and COLORS.profit or (rate <= 0.8 and COLORS.loss or COLORS.textMuted)
	sectorLabel.TextSize = 10
	sectorLabel.Font = Enum.Font.GothamBold
	sectorLabel.Parent = row
	
	-- Price per item
	local priceLabel = Instance.new("TextLabel")
	priceLabel.Size = UDim2.new(0.15, 0, 1, 0)
	priceLabel.Position = UDim2.new(0.6, 0, 0, 0)
	priceLabel.BackgroundTransparency = 1
	priceLabel.Text = "$" .. currentPrice
	priceLabel.TextColor3 = rate >= 1.2 and COLORS.profit or (rate <= 0.8 and COLORS.loss or COLORS.text)
	priceLabel.TextSize = 12
	priceLabel.Font = Enum.Font.Gotham
	priceLabel.Parent = row
	
	-- Total value
	local totalLabel = Instance.new("TextLabel")
	totalLabel.Size = UDim2.new(0.15, 0, 1, 0)
	totalLabel.Position = UDim2.new(0.75, 0, 0, 0)
	totalLabel.BackgroundTransparency = 1
	totalLabel.Text = "$" .. totalValue
	totalLabel.TextColor3 = COLORS.profit
	totalLabel.TextSize = 12
	totalLabel.Font = Enum.Font.GothamBold
	totalLabel.Parent = row
	
	-- Sell button
	local sellBtn = Instance.new("TextButton")
	sellBtn.Name = "SellButton"
	sellBtn.Size = UDim2.new(0, 50, 0, 24)
	sellBtn.Position = UDim2.new(1, -60, 0.5, -12)
	sellBtn.BackgroundColor3 = COLORS.accent
	sellBtn.Text = "SELL"
	sellBtn.TextColor3 = COLORS.background
	sellBtn.TextSize = 10
	sellBtn.Font = Enum.Font.GothamBold
	sellBtn.Parent = row
	
	local btnCorner = Instance.new("UICorner")
	btnCorner.CornerRadius = UDim.new(0, 5)
	btnCorner.Parent = sellBtn
	
	sellBtn.MouseButton1Click:Connect(function()
		SellItemFunction:InvokeServer(itemId, count)
	end)
	
	return row
end

--------------------------------------------------------------------------------
-- UI UPDATE
--------------------------------------------------------------------------------

local function calculateTotalValue()
	local total = 0
	for itemId, count in pairs(currentBackpack) do
		if count > 0 then
			local priceInfo = marketPrices[itemId]
			if priceInfo then
				total = total + (priceInfo.currentPrice * count)
			end
		end
	end
	return total
end

local function updateUI()
	if not mainFrame then return end
	
	-- Update market rate display
	local header = mainFrame:FindFirstChild("Header")
	if header then
		local rateLabel = header:FindFirstChild("RateLabel")
		if rateLabel then
			local globalActive = stockMarketFolder:GetAttribute("GlobalPricingActive")
			local rateName = stockMarketFolder:GetAttribute("RateName") or "NORMAL"
			
			-- Check if any price data tells us we're endgame
			local isEndgame = false
			for _, pd in pairs(marketPrices) do
				if pd.isEndgame then isEndgame = true; break end
			end
			
			if globalActive then
				if isEndgame then
					rateLabel.Text = "ðŸ“Š " .. rateName .. " â€” True Market Rates"
					rateLabel.TextColor3 = COLORS.accent
				else
					rateLabel.Text = "ðŸ›¡ï¸ " .. rateName .. " â€” Welfare-Protected Prices"
					rateLabel.TextColor3 = COLORS.success
				end
			else
				rateLabel.Text = "ðŸ“Š " .. rateName .. " â€” Local Market"
				rateLabel.TextColor3 = COLORS.success
			end
		end
	end
	
	-- Update item list
	local itemsPanel = mainFrame:FindFirstChild("ItemsPanel")
	if itemsPanel then
		local scrollFrame = itemsPanel:FindFirstChild("ItemList")
		if scrollFrame then
			-- Clear existing
			for _, child in scrollFrame:GetChildren() do
				if child:IsA("Frame") then
					child:Destroy()
				end
			end
			
			-- Add items
			for itemId, count in pairs(currentBackpack) do
				if count > 0 then
					local priceInfo = marketPrices[itemId]
					if priceInfo then
						createItemRow(scrollFrame, itemId, count, priceInfo)
					end
				end
			end
		end
	end
	
	-- Update total value
	local bottomBar = mainFrame:FindFirstChild("BottomBar")
	if bottomBar then
		local totalLabel = bottomBar:FindFirstChild("TotalValue")
		if totalLabel then
			local total = calculateTotalValue()
			totalLabel.Text = string.format("ðŸ’° Total Value: $%d", total)
		end
	end
end

--------------------------------------------------------------------------------
-- OPEN/CLOSE
--------------------------------------------------------------------------------

local function refreshMarketData()
	-- Fetch latest pricing from server
	local prices, _baseRate = GetMarketPricesFunction:InvokeServer()
	marketPrices = prices or {}
	
	-- Fetch latest backpack data
	local backpackItems, backpackTot, _ = GetBackpackFunction:InvokeServer()
	currentBackpack = backpackItems or {}
	_backpackTotal = backpackTot or 0
end

local function openUI()
	if isOpen then return end
	isOpen = true
	
	refreshMarketData()
	updateUI()
	
	-- Show with animation
	mainFrame.Visible = true
	mainFrame.Size = UDim2.new(0, 550, 0, 0)
	TweenService:Create(mainFrame, TweenInfo.new(0.3, Enum.EasingStyle.Back), {
		Size = UDim2.new(0, 550, 0, 450)
	}):Play()
end

function closeUI()
	if not isOpen then return end
	isOpen = false
	
	TweenService:Create(mainFrame, TweenInfo.new(0.2), {
		Size = UDim2.new(0, 550, 0, 0)
	}):Play()
	
	task.wait(0.2)
	mainFrame.Visible = false
end

--------------------------------------------------------------------------------
-- EVENT HANDLERS
--------------------------------------------------------------------------------

BackpackUpdatedEvent.OnClientEvent:Connect(function(items, total, _capacity)
	currentBackpack = items or {}
	_backpackTotal = total or 0
	
	if isOpen then
		updateUI()
	end
end)

ItemSoldEvent.OnClientEvent:Connect(function(itemId, count, earned)
	-- Refresh backpack after sale
	refreshMarketData()
	
	if isOpen then
		updateUI()
	end
end)

-- Market rate updates
stockMarketFolder:GetAttributeChangedSignal("CurrentRate"):Connect(function()
	if isOpen then
		refreshMarketData()
		updateUI()
	end
end)

-- Keyboard toggle (M key)
UserInputService.InputBegan:Connect(function(input, processed)
	-- ALWAYS allow toggling via key even if processed? 
	-- Careful: Usually processed == true means typing in chat.
	-- But user says it's NOT working. Let's try removing processed check or debugging.
	if processed and input.KeyCode == Enum.KeyCode.M then
		-- If typing in chat, don't open market.
		-- Check if focusing a textbox.
		local focus = UserInputService:GetFocusedTextBox()
		if focus then return end
	end
	
	if input.KeyCode == Enum.KeyCode.M then
		if isOpen then
			closeUI()
		else
			openUI()
		end
	end
end)

-- ProximityPrompt connection
local function setupMarketPrompt()
	-- Wait for market building
	task.spawn(function()
		while true do
			local mainIsland = workspace:FindFirstChild("MainIsland")
			if mainIsland then
				local marketBuilding = mainIsland:FindFirstChild("MarketBuilding")
				if marketBuilding then
					local prompt = marketBuilding:FindFirstChild("MarketPrompt")
					if prompt then
						prompt.Triggered:Connect(function()
							openUI()
						end)
						print("MarketTerminalUI: Connected to Market prompt")
						break
					end
				end
			end
			task.wait(1)
		end
	end)
end

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

local function initialize()
	screenGui = createScreenGui()
	mainFrame = createMainFrame(screenGui)
	createHeader(mainFrame)
	createItemsPanel(mainFrame)
	createBottomBar(mainFrame)
	
	setupMarketPrompt()
	
	print("âœ“ MarketTerminalUI initialized - Press M to open, or use Market building")
end

initialize()


================================================================================
FILE: src\client\MewingUI.client.luau
================================================================================

--[[
	MewingUI Client Script
	
	Displays the player's Mewing streak status.
	Shows:
	- Current streak tier and emoji
	- Time in current streak
	- Income multiplier bonus
	- Visual feedback when streak breaks
]]

-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
-- RunService not needed for this UI
local TweenService = game:GetService("TweenService")
local SoundService = game:GetService("SoundService")

-- Player
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Configuration
local CONFIG = {
	TIER_COLORS = {
		[0] = Color3.fromRGB(100, 100, 100),
		[1] = Color3.fromRGB(180, 180, 255),
		[2] = Color3.fromRGB(100, 255, 100),
		[3] = Color3.fromRGB(255, 215, 0),
	},
	SOUNDS = {
		TIER_UP = "rbxassetid://6895079853",
		BREAK = "rbxassetid://5702385985",
	},
}

-- Wait for RemoteEvents
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local MewingUpdateEvent = RemoteEvents:WaitForChild("MewingUpdate", 30)
if not MewingUpdateEvent then
	warn("MewingUI: MewingUpdate event not found!")
	return
end

--------------------------------------------------------------------------------
-- UI CREATION
--------------------------------------------------------------------------------

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "MewingUI"
screenGui.ResetOnSpawn = false
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.Parent = playerGui

-- Main container (left side, below center)
local container = Instance.new("Frame")
container.Name = "MewingContainer"
container.Size = UDim2.new(0, 160, 0, 60)
container.Position = UDim2.new(0, 20, 0.6, 0)
container.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
container.BackgroundTransparency = 0.3
container.BorderSizePixel = 0
container.Visible = false -- Hidden until streak starts
container.Parent = screenGui

local containerCorner = Instance.new("UICorner")
containerCorner.CornerRadius = UDim.new(0, 10)
containerCorner.Parent = container

local containerStroke = Instance.new("UIStroke")
containerStroke.Thickness = 2
containerStroke.Color = Color3.fromRGB(60, 60, 80)
containerStroke.Parent = container

-- Emoji / Icon
local emojiLabel = Instance.new("TextLabel")
emojiLabel.Name = "Emoji"
emojiLabel.Size = UDim2.new(0, 50, 1, 0)
emojiLabel.Position = UDim2.new(0, 0, 0, 0)
emojiLabel.BackgroundTransparency = 1
emojiLabel.Text = "ðŸ¤«"
emojiLabel.TextSize = 32
emojiLabel.Font = Enum.Font.GothamBold
emojiLabel.Parent = container

-- Status text container
local textContainer = Instance.new("Frame")
textContainer.Name = "TextContainer"
textContainer.Size = UDim2.new(1, -55, 1, 0)
textContainer.Position = UDim2.new(0, 55, 0, 0)
textContainer.BackgroundTransparency = 1
textContainer.Parent = container

-- Tier name
local tierLabel = Instance.new("TextLabel")
tierLabel.Name = "TierLabel"
tierLabel.Size = UDim2.new(1, 0, 0.5, 0)
tierLabel.Position = UDim2.new(0, 0, 0, 5)
tierLabel.BackgroundTransparency = 1
tierLabel.Text = "Mewing..."
tierLabel.TextColor3 = Color3.fromRGB(200, 200, 220)
tierLabel.TextSize = 14
tierLabel.Font = Enum.Font.GothamBold
tierLabel.TextXAlignment = Enum.TextXAlignment.Left
tierLabel.Parent = textContainer

-- Bonus label
local bonusLabel = Instance.new("TextLabel")
bonusLabel.Name = "BonusLabel"
bonusLabel.Size = UDim2.new(1, 0, 0.5, 0)
bonusLabel.Position = UDim2.new(0, 0, 0.5, -5)
bonusLabel.BackgroundTransparency = 1
bonusLabel.Text = "+0%"
bonusLabel.TextColor3 = Color3.fromRGB(150, 255, 150)
bonusLabel.TextSize = 12
bonusLabel.Font = Enum.Font.GothamMedium
bonusLabel.TextXAlignment = Enum.TextXAlignment.Left
bonusLabel.Parent = textContainer

--------------------------------------------------------------------------------
-- SOUND SETUP
--------------------------------------------------------------------------------

local tierUpSound = Instance.new("Sound")
tierUpSound.SoundId = CONFIG.SOUNDS.TIER_UP
tierUpSound.Volume = 0.6
tierUpSound.Parent = SoundService

local breakSound = Instance.new("Sound")
breakSound.SoundId = CONFIG.SOUNDS.BREAK
breakSound.Volume = 0.7
breakSound.Parent = SoundService

--------------------------------------------------------------------------------
-- UPDATE LOGIC
--------------------------------------------------------------------------------

local function showUI()
	if not container.Visible then
		container.Visible = true
		container.Position = UDim2.new(0, -160, 0.6, 0)
		local tween = TweenService:Create(container, TweenInfo.new(0.3, Enum.EasingStyle.Back), {
			Position = UDim2.new(0, 20, 0.6, 0)
		})
		tween:Play()
	end
end

local function hideUI()
	if container.Visible then
		local tween = TweenService:Create(container, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
			Position = UDim2.new(0, -160, 0.6, 0)
		})
		tween:Play()
		tween.Completed:Wait()
		container.Visible = false
	end
end

local function onMewingUpdate(data)
	if data.type == "tier_up" then
		showUI()
		
		-- Update visuals
		emojiLabel.Text = data.emoji or "ðŸ¤«"
		tierLabel.Text = data.name or "Mewing"
		bonusLabel.Text = string.format("+%.0f%%", (data.multiplier - 1) * 100)
		
		-- Color
		local color = CONFIG.TIER_COLORS[data.tier] or CONFIG.TIER_COLORS[1]
		containerStroke.Color = color
		tierLabel.TextColor3 = color
		
		-- Play sound
		tierUpSound:Play()
		
		-- Animate
		emojiLabel.TextSize = 24
		local tween = TweenService:Create(emojiLabel, TweenInfo.new(0.3, Enum.EasingStyle.Back), {
			TextSize = 32
		})
		tween:Play()
		
	elseif data.type == "break" then
		-- Play break sound
		breakSound:Play()
		
		-- Flash red
		local _originalColor = containerStroke.Color
		containerStroke.Color = Color3.fromRGB(255, 50, 50)
		task.wait(0.3)
		
		-- Hide UI
		hideUI()
	end
end

-- Connect event
MewingUpdateEvent.OnClientEvent:Connect(onMewingUpdate)

-- Check initial state (in case player rejoins mid-streak)
local function checkInitialState()
	local tier = player:GetAttribute("MewingTier") or 0
	local multiplier = player:GetAttribute("MewingMultiplier") or 1.0
	
	if tier > 0 then
		local tierNames = {"Streak Started", "Locked In", "GigaChad"}
		local emojis = {"ðŸ¤«", "ðŸ”’", "ðŸ—¿"}
		onMewingUpdate({
			type = "tier_up",
			tier = tier,
			name = tierNames[tier] or "Mewing",
			emoji = emojis[tier] or "ðŸ¤«",
			multiplier = multiplier,
		})
	end
end

-- Wait a bit for attributes to load
task.delay(2, checkInitialState)

print("âœ“ MewingUI initialized")


================================================================================
FILE: src\client\MoneyHUD.client.luau
================================================================================

--[[
	MoneyHUD LocalScript (Reworked)
	
	Right-side HUD:
	  â€¢ Money + MPS display
	  â€¢ Storage bar
	  â€¢ "Your Top Holdings" from storage items
	  â€¢ "View Full Portfolio" button
	  â€¢ Bottom-center action bar with 6 quick-access buttons
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local HttpService = game:GetService("HttpService")

-- Player reference
local Player = Players.LocalPlayer
local PlayerGui = Player:WaitForChild("PlayerGui")

-- Wait for shared modules and remotes
local Shared = ReplicatedStorage:WaitForChild("Shared")
local ShopConfig = require(Shared:WaitForChild("ShopConfig"))
local ItemConfig = require(Shared:WaitForChild("ItemConfig"))
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local RemoteFunctions = ReplicatedStorage:WaitForChild("RemoteFunctions")
local GetOwnershipRemote = RemoteEvents:WaitForChild("GetOwnership")
local OwnershipChangedEvent = RemoteEvents:WaitForChild("OwnershipChanged")
local StorageUpdatedEvent = RemoteEvents:FindFirstChild("StorageUpdated")
local GetStorageFunction = RemoteFunctions:WaitForChild("GetStorage")

-- Brainrots folder for preview
local BrainrotsFolder = ReplicatedStorage:WaitForChild("Brainrots")

-- Stock Market folder (for sector rates)
local StockMarketFolder = ReplicatedStorage:FindFirstChild("StockMarket")

--------------------------------------------------------------------------------
-- UI CONFIGURATION
--------------------------------------------------------------------------------

local UI_CONFIG = {
	-- Panel positioning and size
	PANEL_WIDTH = 220,
	PANEL_HEIGHT = 400,
	PANEL_MARGIN = 20,
	CORNER_RADIUS = 16,
	
	-- Holdings
	MAX_HOLDINGS_ROWS = 5,
	ROW_HEIGHT = 22,
	
	-- Colors
	BACKGROUND_COLOR = Color3.fromRGB(20, 20, 30),
	STROKE_COLOR = Color3.fromRGB(50, 50, 70),
	MONEY_COLOR = Color3.fromRGB(100, 255, 100),
	MPS_COLOR = Color3.fromRGB(180, 180, 180),
	LABEL_COLOR = Color3.fromRGB(120, 120, 140),
	ITEMS_BG_COLOR = Color3.fromRGB(40, 40, 50),
	ITEMS_FILL_COLOR = Color3.fromRGB(100, 180, 255),
	ITEMS_FULL_COLOR = Color3.fromRGB(255, 100, 100),
	
	-- Holdings colors
	HOLDINGS_TITLE_COLOR = Color3.fromRGB(200, 200, 220),
	HOLDINGS_NAME_COLOR = Color3.fromRGB(230, 230, 240),
	HOLDINGS_COUNT_COLOR = Color3.fromRGB(160, 160, 180),
	HOLDINGS_VALUE_COLOR = Color3.fromRGB(100, 255, 100),
	ARROW_UP_COLOR = Color3.fromRGB(80, 220, 120),
	ARROW_DOWN_COLOR = Color3.fromRGB(255, 80, 80),
	
	-- Animation
	TWEEN_TIME = 0.2,
	
	-- Theme
	THEME_BG = Color3.fromRGB(20, 20, 30),
	THEME_STROKE = Color3.fromRGB(50, 50, 70),
	THEME_ACCENT_PURPLE = Color3.fromRGB(80, 60, 140),
	THEME_ACCENT_PINK = Color3.fromRGB(140, 80, 160),
	THEME_ACCENT_GOLD = Color3.fromRGB(200, 150, 60),
	THEME_ACCENT_BLUE = Color3.fromRGB(60, 120, 200),
	THEME_TEXT_PRIMARY = Color3.fromRGB(255, 255, 255),
	THEME_TEXT_SECONDARY = Color3.fromRGB(180, 180, 180),
	
	-- Bottom bar
	BOTTOM_BAR_BTN_SIZE = 42,
	BOTTOM_BAR_PADDING = 10,
}

--------------------------------------------------------------------------------
-- HELPER FUNCTIONS
--------------------------------------------------------------------------------

local function formatMoney(amount: number): string
	if amount >= 1000000000 then
		return string.format("$%.2fB", amount / 1000000000)
	elseif amount >= 1000000 then
		return string.format("$%.2fM", amount / 1000000)
	elseif amount >= 1000 then
		return string.format("$%.1fK", amount / 1000)
	else
		return "$" .. tostring(math.floor(amount))
	end
end

local function addCorner(parent: GuiObject, radius: number)
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, radius)
	corner.Parent = parent
	return corner
end

local function addStroke(parent: GuiObject, color: Color3, thickness: number)
	local stroke = Instance.new("UIStroke")
	stroke.Color = color
	stroke.Thickness = thickness
	stroke.Transparency = 0.5
	stroke.Parent = parent
	return stroke
end

-- Get current sector rates from StockMarket folder
local function getSectorRates(): {[string]: number}
	local rates = {}
	if not StockMarketFolder then
		StockMarketFolder = ReplicatedStorage:FindFirstChild("StockMarket")
	end
	if StockMarketFolder then
		local ratesStr = StockMarketFolder:GetAttribute("SectorRates")
		if ratesStr then
			local ok, parsed = pcall(function() return HttpService:JSONDecode(ratesStr) end)
			if ok and parsed then
				rates = parsed
			end
		end
	end
	return rates
end

--------------------------------------------------------------------------------
-- STATE
--------------------------------------------------------------------------------

local StorageItems: {[string]: number} = {} -- Current storage item map

--------------------------------------------------------------------------------
-- UI CREATION
--------------------------------------------------------------------------------

local function createMoneyHUD(): ScreenGui
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "MoneyHUD"
	screenGui.ResetOnSpawn = false
	screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	
	----------------------------------------------------------------------
	-- RIGHT PANEL (Money, Storage, Holdings)
	----------------------------------------------------------------------
	local hudPanel = Instance.new("Frame")
	hudPanel.Name = "HUDPanel"
	hudPanel.Size = UDim2.new(0, UI_CONFIG.PANEL_WIDTH, 0, UI_CONFIG.PANEL_HEIGHT)
	hudPanel.Position = UDim2.new(1, -UI_CONFIG.PANEL_WIDTH - UI_CONFIG.PANEL_MARGIN, 0, 60)
	hudPanel.BackgroundColor3 = UI_CONFIG.THEME_BG
	hudPanel.BackgroundTransparency = 0.1
	hudPanel.BorderSizePixel = 0
	hudPanel.Parent = screenGui
	addCorner(hudPanel, UI_CONFIG.CORNER_RADIUS)
	addStroke(hudPanel, UI_CONFIG.THEME_STROKE, 2)
	
	local padding = Instance.new("UIPadding")
	padding.PaddingLeft = UDim.new(0, 16)
	padding.PaddingRight = UDim.new(0, 16)
	padding.PaddingTop = UDim.new(0, 16)
	padding.PaddingBottom = UDim.new(0, 16)
	padding.Parent = hudPanel
	
	-- Money icon and label container
	local moneyContainer = Instance.new("Frame")
	moneyContainer.Name = "MoneyContainer"
	moneyContainer.Size = UDim2.new(1, 0, 0, 32)
	moneyContainer.Position = UDim2.new(0, 0, 0, 0)
	moneyContainer.BackgroundTransparency = 1
	moneyContainer.Parent = hudPanel
	
	local moneyIcon = Instance.new("TextLabel")
	moneyIcon.Name = "MoneyIcon"
	moneyIcon.Size = UDim2.new(0, 32, 0, 32)
	moneyIcon.Position = UDim2.new(0, 0, 0, 0)
	moneyIcon.BackgroundTransparency = 1
	moneyIcon.Text = "ðŸ’°"
	moneyIcon.TextSize = 24
	moneyIcon.Font = Enum.Font.GothamBold
	moneyIcon.Parent = moneyContainer
	
	local moneyLabel = Instance.new("TextLabel")
	moneyLabel.Name = "MoneyLabel"
	moneyLabel.Size = UDim2.new(1, -40, 0, 32)
	moneyLabel.Position = UDim2.new(0, 40, 0, 0)
	moneyLabel.BackgroundTransparency = 1
	moneyLabel.Text = "$0"
	moneyLabel.TextColor3 = UI_CONFIG.MONEY_COLOR
	moneyLabel.TextSize = 28
	moneyLabel.Font = Enum.Font.GothamBold
	moneyLabel.TextXAlignment = Enum.TextXAlignment.Left
	moneyLabel.Parent = moneyContainer
	
	-- Money per second
	local mpsLabel = Instance.new("TextLabel")
	mpsLabel.Name = "MPSLabel"
	mpsLabel.Size = UDim2.new(1, 0, 0, 18)
	mpsLabel.Position = UDim2.new(0, 40, 0, 32)
	mpsLabel.BackgroundTransparency = 1
	mpsLabel.Text = "+$0/s"
	mpsLabel.TextColor3 = UI_CONFIG.MPS_COLOR
	mpsLabel.TextSize = 14
	mpsLabel.Font = Enum.Font.Gotham
	mpsLabel.TextXAlignment = Enum.TextXAlignment.Left
	mpsLabel.Parent = hudPanel
	
	-- Storage Section
	local storageContainer = Instance.new("Frame")
	storageContainer.Name = "ItemsContainer"
	storageContainer.Size = UDim2.new(1, -20, 0, 50)
	storageContainer.Position = UDim2.new(0, 15, 0, 60)
	storageContainer.BackgroundTransparency = 1
	storageContainer.Parent = hudPanel
	
	local storageTitle = Instance.new("TextLabel")
	storageTitle.Name = "ItemsAmount"
	storageTitle.Size = UDim2.new(1, 0, 0, 20)
	storageTitle.BackgroundTransparency = 1
	storageTitle.Text = "ðŸ“¦ ITEMS: 0 / 0"
	storageTitle.TextColor3 = UI_CONFIG.THEME_TEXT_PRIMARY
	storageTitle.TextSize = 12
	storageTitle.Font = Enum.Font.GothamBold
	storageTitle.TextXAlignment = Enum.TextXAlignment.Left
	storageTitle.Parent = storageContainer
	
	local itemsBarBg = Instance.new("Frame")
	itemsBarBg.Name = "ItemsBarBg"
	itemsBarBg.Size = UDim2.new(1, 0, 0, 12)
	itemsBarBg.Position = UDim2.new(0, 0, 0, 25)
	itemsBarBg.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
	itemsBarBg.BorderSizePixel = 0
	itemsBarBg.Parent = storageContainer
	addCorner(itemsBarBg, 4)
	
	local itemsBarFill = Instance.new("Frame")
	itemsBarFill.Name = "ItemsBarFill"
	itemsBarFill.Size = UDim2.new(0, 0, 1, 0)
	itemsBarFill.BackgroundColor3 = UI_CONFIG.THEME_ACCENT_BLUE
	itemsBarFill.BorderSizePixel = 0
	itemsBarFill.Parent = itemsBarBg
	addCorner(itemsBarFill, 4)
	
	----------------------------------------------------------------------
	-- YOUR TOP HOLDINGS SECTION
	----------------------------------------------------------------------
	local holdingsY = 105
	
	-- Thin divider
	local div = Instance.new("Frame")
	div.Name = "HoldingsDivider"
	div.Size = UDim2.new(1, -10, 0, 1)
	div.Position = UDim2.new(0, 5, 0, holdingsY)
	div.BackgroundColor3 = UI_CONFIG.THEME_STROKE
	div.BackgroundTransparency = 0.4
	div.BorderSizePixel = 0
	div.Parent = hudPanel
	
	holdingsY += 8
	
	local holdingsTitle = Instance.new("TextLabel")
	holdingsTitle.Name = "HoldingsTitle"
	holdingsTitle.Size = UDim2.new(1, 0, 0, 16)
	holdingsTitle.Position = UDim2.new(0, 0, 0, holdingsY)
	holdingsTitle.BackgroundTransparency = 1
	holdingsTitle.Text = "Your Top Holdings"
	holdingsTitle.TextColor3 = UI_CONFIG.HOLDINGS_TITLE_COLOR
	holdingsTitle.TextSize = 13
	holdingsTitle.Font = Enum.Font.GothamBold
	holdingsTitle.TextXAlignment = Enum.TextXAlignment.Left
	holdingsTitle.Parent = hudPanel
	
	holdingsY += 20
	
	-- Holdings list container
	local holdingsList = Instance.new("Frame")
	holdingsList.Name = "HoldingsList"
	holdingsList.Size = UDim2.new(1, 0, 0, UI_CONFIG.MAX_HOLDINGS_ROWS * UI_CONFIG.ROW_HEIGHT)
	holdingsList.Position = UDim2.new(0, 0, 0, holdingsY)
	holdingsList.BackgroundTransparency = 1
	holdingsList.ClipsDescendants = true
	holdingsList.Parent = hudPanel
	
	local listLayout = Instance.new("UIListLayout")
	listLayout.Padding = UDim.new(0, 2)
	listLayout.SortOrder = Enum.SortOrder.LayoutOrder
	listLayout.Parent = holdingsList
	
	holdingsY += UI_CONFIG.MAX_HOLDINGS_ROWS * UI_CONFIG.ROW_HEIGHT + 10
	
	-- Empty state label
	local emptyLabel = Instance.new("TextLabel")
	emptyLabel.Name = "EmptyLabel"
	emptyLabel.Size = UDim2.new(1, 0, 1, 0)
	emptyLabel.BackgroundTransparency = 1
	emptyLabel.Text = "No items in storage"
	emptyLabel.TextColor3 = UI_CONFIG.LABEL_COLOR
	emptyLabel.TextSize = 11
	emptyLabel.Font = Enum.Font.Gotham
	emptyLabel.Visible = true
	emptyLabel.Parent = holdingsList
	
	-- View Full Portfolio button
	local portfolioBtn = Instance.new("TextButton")
	portfolioBtn.Name = "PortfolioButton"
	portfolioBtn.Size = UDim2.new(1, 0, 0, 30)
	portfolioBtn.Position = UDim2.new(0, 0, 0, holdingsY)
	portfolioBtn.BackgroundColor3 = Color3.fromRGB(40, 45, 60)
	portfolioBtn.Text = "ðŸ“‹ View Full Portfolio"
	portfolioBtn.TextColor3 = UI_CONFIG.THEME_TEXT_PRIMARY
	portfolioBtn.TextSize = 12
	portfolioBtn.Font = Enum.Font.GothamBold
	portfolioBtn.BorderSizePixel = 0
	portfolioBtn.Parent = hudPanel
	addCorner(portfolioBtn, 8)
	addStroke(portfolioBtn, UI_CONFIG.THEME_STROKE, 1)
	
	----------------------------------------------------------------------
	-- BOTTOM CENTER ACTION BAR (6 buttons in a row)
	----------------------------------------------------------------------
	local btnSize = UI_CONFIG.BOTTOM_BAR_BTN_SIZE
	local btnPad = UI_CONFIG.BOTTOM_BAR_PADDING
	local totalBarWidth = 6 * btnSize + 5 * btnPad + 24 -- + side padding
	
	local bottomBar = Instance.new("Frame")
	bottomBar.Name = "BottomBar"
	bottomBar.Size = UDim2.new(0, totalBarWidth, 0, btnSize + 20)
	bottomBar.Position = UDim2.new(0.5, -totalBarWidth / 2, 1, -(btnSize + 30))
	bottomBar.BackgroundColor3 = UI_CONFIG.THEME_BG
	bottomBar.BackgroundTransparency = 0.15
	bottomBar.BorderSizePixel = 0
	bottomBar.Parent = screenGui
	addCorner(bottomBar, 14)
	addStroke(bottomBar, UI_CONFIG.THEME_STROKE, 2)
	
	local barPadding = Instance.new("UIPadding")
	barPadding.PaddingLeft = UDim.new(0, 12)
	barPadding.PaddingRight = UDim.new(0, 12)
	barPadding.PaddingTop = UDim.new(0, 10)
	barPadding.PaddingBottom = UDim.new(0, 10)
	barPadding.Parent = bottomBar
	
	local barLayout = Instance.new("UIListLayout")
	barLayout.FillDirection = Enum.FillDirection.Horizontal
	barLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	barLayout.VerticalAlignment = Enum.VerticalAlignment.Center
	barLayout.Padding = UDim.new(0, btnPad)
	barLayout.SortOrder = Enum.SortOrder.LayoutOrder
	barLayout.Parent = bottomBar
	
	local function createBarButton(name, textIcon, color, order)
		local btn = Instance.new("TextButton")
		btn.Name = name
		btn.Size = UDim2.new(0, btnSize, 0, btnSize)
		btn.BackgroundColor3 = color
		btn.LayoutOrder = order
		btn.Text = textIcon
		btn.TextSize = 20
		btn.TextColor3 = UI_CONFIG.THEME_TEXT_PRIMARY
		btn.Font = Enum.Font.GothamBold
		btn.Parent = bottomBar
		addCorner(btn, 10)
		addStroke(btn, UI_CONFIG.THEME_STROKE, 1.5)
		return btn
	end
	
	-- 1. Shop
	createBarButton("ShopButton", "ðŸ›’", UI_CONFIG.THEME_ACCENT_PURPLE, 1)
	
	-- 2. Brainrots (with 3D preview + badge)
	local brainrotsBtn = createBarButton("BrainrotsButton", "", UI_CONFIG.THEME_ACCENT_PINK, 2)
	
	local viewport = Instance.new("ViewportFrame")
	viewport.Size = UDim2.new(1, -6, 1, -6)
	viewport.Position = UDim2.new(0, 3, 0, 3)
	viewport.BackgroundTransparency = 1
	viewport.Parent = brainrotsBtn
	
	local countBadge = Instance.new("TextLabel")
	countBadge.Name = "CountBadge"
	countBadge.Size = UDim2.new(0, 20, 0, 16)
	countBadge.Position = UDim2.new(1, -18, 1, -14)
	countBadge.BackgroundColor3 = Color3.fromRGB(60, 180, 100)
	countBadge.Text = "0"
	countBadge.TextColor3 = Color3.new(1, 1, 1)
	countBadge.TextSize = 11
	countBadge.Font = Enum.Font.GothamBold
	countBadge.ZIndex = 10
	countBadge.Parent = brainrotsBtn
	addCorner(countBadge, 8)
	
	task.spawn(function()
		local allModels = {}
		if BrainrotsFolder then
			for _, m in BrainrotsFolder:GetChildren() do
				if m:IsA("Model") then table.insert(allModels, m) end
			end
		end
		if #allModels > 0 then
			local randomModel = allModels[math.random(1, #allModels)]:Clone()
			randomModel.Parent = viewport
			local cam = Instance.new("Camera")
			cam.Parent = viewport
			viewport.CurrentCamera = cam
			local cf, size = randomModel:GetBoundingBox()
			local maxDim = math.max(size.X, size.Y, size.Z)
			local dist = maxDim * 1.5
			cam.CFrame = CFrame.new(cf.Position + Vector3.new(dist, dist*0.5, dist), cf.Position)
		end
	end)
	
	-- 3. Synergies
	createBarButton("SynergiesButton", "ðŸ“–", UI_CONFIG.THEME_ACCENT_GOLD, 3)
	-- 4. Backpack
	createBarButton("BackpackButton", "ðŸŽ’", UI_CONFIG.THEME_ACCENT_BLUE, 4)
	-- 5. Storage
	createBarButton("StorageButton", "ðŸ“¦", Color3.fromRGB(255, 100, 50), 5)
	-- 6. Stock Market
	createBarButton("StockButton", "ðŸ“ˆ", Color3.fromRGB(80, 200, 100), 6)
	
	return screenGui
end

--------------------------------------------------------------------------------
-- MONEY TRACKING
--------------------------------------------------------------------------------

local MoneyHUDGui: ScreenGui
local MoneyLabel: TextLabel
local MPSLabel: TextLabel
local ItemsBarFill: Frame
local ItemsAmountLabel: TextLabel

local previousMoney: number = 0
local OwnedCounts: {[string]: number} = {}

local function calculateMPS(): number
	local totalMPS = 0
	for unitName, count in OwnedCounts do
		if count > 0 then
			local config = ShopConfig.GetConfig(unitName)
			if config then
				local incomePerSecond = (config.BaseIncome / config.CycleTime) * count
				totalMPS = totalMPS + incomePerSecond
			end
		end
	end
	return totalMPS
end

local function updateMPSDisplay()
	if not MPSLabel then return end
	local mps = calculateMPS()
	if mps >= 1000 then
		MPSLabel.Text = string.format("+$%.1fK/s", mps / 1000)
	else
		MPSLabel.Text = string.format("+$%.1f/s", mps)
	end
end

local function updateBrainrotCount()
	if not MoneyHUDGui then return end
	
	local bottomBar = MoneyHUDGui:FindFirstChild("BottomBar")
	if not bottomBar then return end
	
	local brainrotsBtn = bottomBar:FindFirstChild("BrainrotsButton")
	if not brainrotsBtn then return end
	
	local badge = brainrotsBtn:FindFirstChild("CountBadge")
	if not badge then return end
	
	local totalCount = 0
	for _, count in OwnedCounts do
		totalCount = totalCount + count
	end
	
	badge.Text = tostring(totalCount)
	if totalCount > 0 then
		badge.BackgroundColor3 = Color3.fromRGB(60, 180, 100)
	else
		badge.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
	end
end

local function updateMoneyDisplay(newMoney: number)
	if not MoneyLabel then return end
	
	local formattedMoney = formatMoney(newMoney)
	MoneyLabel.Text = formattedMoney
	
	if newMoney > previousMoney then
		MoneyLabel.TextColor3 = Color3.fromRGB(150, 255, 150)
		TweenService:Create(MoneyLabel, TweenInfo.new(UI_CONFIG.TWEEN_TIME), {
			TextColor3 = UI_CONFIG.MONEY_COLOR
		}):Play()
	elseif newMoney < previousMoney then
		MoneyLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
		TweenService:Create(MoneyLabel, TweenInfo.new(UI_CONFIG.TWEEN_TIME), {
			TextColor3 = UI_CONFIG.MONEY_COLOR
		}):Play()
	end
	
	previousMoney = newMoney
end

local function updateItemsDisplay(currentItems: number, maxItems: number)
	if not ItemsBarFill or not ItemsAmountLabel then return end
	
	local fillPercent = math.clamp(currentItems / math.max(1, maxItems), 0, 1)
	
	TweenService:Create(ItemsBarFill, TweenInfo.new(0.3, Enum.EasingStyle.Quad), {
		Size = UDim2.new(fillPercent, 0, 1, 0)
	}):Play()
	
	ItemsAmountLabel.Text = string.format("ðŸ“¦ ITEMS: %d / %d", currentItems, maxItems)
	
	local targetColor
	if fillPercent >= 1 then
		targetColor = UI_CONFIG.ITEMS_FULL_COLOR
	elseif fillPercent >= 0.75 then
		targetColor = UI_CONFIG.ITEMS_FILL_COLOR:Lerp(UI_CONFIG.ITEMS_FULL_COLOR, (fillPercent - 0.75) / 0.25)
	else
		targetColor = UI_CONFIG.ITEMS_FILL_COLOR
	end
	
	TweenService:Create(ItemsBarFill, TweenInfo.new(0.2), {
		BackgroundColor3 = targetColor
	}):Play()
end

--------------------------------------------------------------------------------
-- HOLDINGS DISPLAY
--------------------------------------------------------------------------------

local function updateHoldingsDisplay()
	if not MoneyHUDGui then return end
	
	local hudPanel = MoneyHUDGui:FindFirstChild("HUDPanel")
	if not hudPanel then return end
	local holdingsList = hudPanel:FindFirstChild("HoldingsList")
	if not holdingsList then return end
	
	-- Clear old rows (keep EmptyLabel)
	for _, child in holdingsList:GetChildren() do
		if child:IsA("Frame") then child:Destroy() end
	end
	
	local emptyLabel = holdingsList:FindFirstChild("EmptyLabel")
	
	-- Get sector rates
	local sectorRates = getSectorRates()
	
	-- Build sorted list by total value
	local sortedItems = {}
	for itemId, count in pairs(StorageItems) do
		if count > 0 then
			local itemDef = ItemConfig.Items[itemId]
			if itemDef then
				local sector = ItemConfig.GetSector(itemId) -- item-level lookup
				local rate = sectorRates[sector] or 1.0
				local totalValue = count * itemDef.basePrice * rate
				table.insert(sortedItems, {
					id = itemId,
					count = count,
					icon = itemDef.icon or "ðŸ“¦",
					name = itemDef.displayName or itemId,
					value = totalValue,
					rate = rate,
				})
			end
		end
	end
	
	table.sort(sortedItems, function(a, b) return a.value > b.value end)
	
	if emptyLabel then
		emptyLabel.Visible = #sortedItems == 0
	end
	
	for i = 1, math.min(UI_CONFIG.MAX_HOLDINGS_ROWS, #sortedItems) do
		local data = sortedItems[i]
		
		local row = Instance.new("Frame")
		row.Name = "Row" .. i
		row.Size = UDim2.new(1, 0, 0, UI_CONFIG.ROW_HEIGHT)
		row.BackgroundTransparency = 1
		row.LayoutOrder = i
		row.Parent = holdingsList
		
		-- Icon
		local iconLabel = Instance.new("TextLabel")
		iconLabel.Size = UDim2.new(0, 18, 1, 0)
		iconLabel.Position = UDim2.new(0, 0, 0, 0)
		iconLabel.BackgroundTransparency = 1
		iconLabel.Text = data.icon
		iconLabel.TextSize = 12
		iconLabel.Font = Enum.Font.Gotham
		iconLabel.Parent = row
		
		-- Name (truncated)
		local displayName = data.name
		if #displayName > 10 then
			displayName = string.sub(displayName, 1, 9) .. "â€¦"
		end
		local nameLabel = Instance.new("TextLabel")
		nameLabel.Size = UDim2.new(0, 60, 1, 0)
		nameLabel.Position = UDim2.new(0, 20, 0, 0)
		nameLabel.BackgroundTransparency = 1
		nameLabel.Text = displayName
		nameLabel.TextColor3 = UI_CONFIG.HOLDINGS_NAME_COLOR
		nameLabel.TextSize = 10
		nameLabel.Font = Enum.Font.Gotham
		nameLabel.TextXAlignment = Enum.TextXAlignment.Left
		nameLabel.TextTruncate = Enum.TextTruncate.AtEnd
		nameLabel.Parent = row
		
		-- Count
		local countLabel = Instance.new("TextLabel")
		countLabel.Size = UDim2.new(0, 30, 1, 0)
		countLabel.Position = UDim2.new(0, 82, 0, 0)
		countLabel.BackgroundTransparency = 1
		countLabel.Text = "x" .. tostring(data.count)
		countLabel.TextColor3 = UI_CONFIG.HOLDINGS_COUNT_COLOR
		countLabel.TextSize = 10
		countLabel.Font = Enum.Font.Gotham
		countLabel.TextXAlignment = Enum.TextXAlignment.Right
		countLabel.Parent = row
		
		-- Value
		local valueLabel = Instance.new("TextLabel")
		valueLabel.Size = UDim2.new(0, 50, 1, 0)
		valueLabel.Position = UDim2.new(0, 115, 0, 0)
		valueLabel.BackgroundTransparency = 1
		valueLabel.Text = formatMoney(data.value)
		valueLabel.TextColor3 = UI_CONFIG.HOLDINGS_VALUE_COLOR
		valueLabel.TextSize = 10
		valueLabel.Font = Enum.Font.GothamBold
		valueLabel.TextXAlignment = Enum.TextXAlignment.Right
		valueLabel.Parent = row
		
		-- Arrow (â–² if rate >= 1, â–¼ if < 1)
		local arrowLabel = Instance.new("TextLabel")
		arrowLabel.Size = UDim2.new(0, 14, 1, 0)
		arrowLabel.Position = UDim2.new(0, 168, 0, 0)
		arrowLabel.BackgroundTransparency = 1
		if data.rate >= 1.0 then
			arrowLabel.Text = "â–²"
			arrowLabel.TextColor3 = UI_CONFIG.ARROW_UP_COLOR
		else
			arrowLabel.Text = "â–¼"
			arrowLabel.TextColor3 = UI_CONFIG.ARROW_DOWN_COLOR
		end
		arrowLabel.TextSize = 10
		arrowLabel.Font = Enum.Font.GothamBold
		arrowLabel.Parent = row
	end
end

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

local function initialize()
	print("MoneyHUD: Initializing...")
	
	MoneyHUDGui = createMoneyHUD()
	MoneyHUDGui.Parent = PlayerGui
	
	-- Get references
	local hudPanel = MoneyHUDGui:FindFirstChild("HUDPanel")
	if hudPanel then
		local moneyContainer = hudPanel:FindFirstChild("MoneyContainer")
		if moneyContainer then
			MoneyLabel = moneyContainer:FindFirstChild("MoneyLabel")
		end
		MPSLabel = hudPanel:FindFirstChild("MPSLabel")
		
		local itemsContainer = hudPanel:FindFirstChild("ItemsContainer")
		if itemsContainer then
			ItemsAmountLabel = itemsContainer:FindFirstChild("ItemsAmount")
			local itemsBarBg = itemsContainer:FindFirstChild("ItemsBarBg")
			if itemsBarBg then
				ItemsBarFill = itemsBarBg:FindFirstChild("ItemsBarFill")
			end
		end
	end
	
	----------------------------------------------------------------------
	-- BUTTON CONNECTIONS (Bottom Bar)
	----------------------------------------------------------------------
	local bottomBar = MoneyHUDGui:FindFirstChild("BottomBar")
	if bottomBar then
		local function setupBtn(btnName, eventName, filterArg, baseColor, hoverColor)
			local btn = bottomBar:FindFirstChild(btnName)
			if not btn then return end
			
			local toggleEvent = ReplicatedStorage:FindFirstChild(eventName)
			if not toggleEvent then
				toggleEvent = Instance.new("BindableEvent")
				toggleEvent.Name = eventName
				toggleEvent.Parent = ReplicatedStorage
			end
			
			btn.MouseButton1Click:Connect(function()
				if filterArg then
					toggleEvent:Fire(filterArg)
				else
					toggleEvent:Fire()
				end
			end)
			
			btn.MouseEnter:Connect(function()
				TweenService:Create(btn, TweenInfo.new(0.1), {
					BackgroundColor3 = hoverColor,
					Size = UDim2.new(0, UI_CONFIG.BOTTOM_BAR_BTN_SIZE + 6, 0, UI_CONFIG.BOTTOM_BAR_BTN_SIZE + 6)
				}):Play()
			end)
			btn.MouseLeave:Connect(function()
				TweenService:Create(btn, TweenInfo.new(0.1), {
					BackgroundColor3 = baseColor,
					Size = UDim2.new(0, UI_CONFIG.BOTTOM_BAR_BTN_SIZE, 0, UI_CONFIG.BOTTOM_BAR_BTN_SIZE)
				}):Play()
			end)
		end
		
		setupBtn("ShopButton", "ShopToggleEvent", nil,
			UI_CONFIG.THEME_ACCENT_PURPLE, Color3.fromRGB(100, 80, 170))
		setupBtn("BrainrotsButton", "BackpackToggleEvent", "Unit",
			UI_CONFIG.THEME_ACCENT_PINK, Color3.fromRGB(170, 100, 190))
		setupBtn("SynergiesButton", "SynergyToggleEvent", nil,
			UI_CONFIG.THEME_ACCENT_GOLD, Color3.fromRGB(230, 180, 80))
		setupBtn("BackpackButton", "BackpackToggleEvent", nil,
			UI_CONFIG.THEME_ACCENT_BLUE, Color3.fromRGB(100, 150, 255))
		setupBtn("StorageButton", "StorageToggleEvent", nil,
			Color3.fromRGB(255, 100, 50), Color3.fromRGB(255, 140, 100))
		setupBtn("StockButton", "StockToggleEvent", nil,
			Color3.fromRGB(80, 200, 100), Color3.fromRGB(100, 230, 130))
	end
	
	-- Portfolio button
	local portfolioBtn = hudPanel and hudPanel:FindFirstChild("PortfolioButton")
	if portfolioBtn then
		local backpackToggle = ReplicatedStorage:FindFirstChild("BackpackToggleEvent")
		if not backpackToggle then
			backpackToggle = Instance.new("BindableEvent")
			backpackToggle.Name = "BackpackToggleEvent"
			backpackToggle.Parent = ReplicatedStorage
		end
		
		portfolioBtn.MouseButton1Click:Connect(function()
			backpackToggle:Fire()
		end)
		
		portfolioBtn.MouseEnter:Connect(function()
			TweenService:Create(portfolioBtn, TweenInfo.new(0.1), {
				BackgroundColor3 = Color3.fromRGB(55, 60, 80)
			}):Play()
		end)
		portfolioBtn.MouseLeave:Connect(function()
			TweenService:Create(portfolioBtn, TweenInfo.new(0.1), {
				BackgroundColor3 = Color3.fromRGB(40, 45, 60)
			}):Play()
		end)
	end
	
	----------------------------------------------------------------------
	-- OWNERSHIP / MPS (unchanged logic)
	----------------------------------------------------------------------
	local ownershipData = GetOwnershipRemote:InvokeServer()
	if ownershipData and ownershipData.units then
		for unitName, data in ownershipData.units do
			OwnedCounts[unitName] = data.count
		end
		updateMPSDisplay()
		updateBrainrotCount()
	end
	
	OwnershipChangedEvent.OnClientEvent:Connect(function(unitName: string, newCount: number)
		OwnedCounts[unitName] = newCount
		updateMPSDisplay()
		updateBrainrotCount()
	end)
	
	----------------------------------------------------------------------
	-- MONEY TRACKING
	----------------------------------------------------------------------
	local leaderstats = Player:WaitForChild("leaderstats", 10)
	if leaderstats then
		local money = leaderstats:WaitForChild("Money", 5)
		if money then
			previousMoney = money.Value
			updateMoneyDisplay(money.Value)
			money:GetPropertyChangedSignal("Value"):Connect(function()
				updateMoneyDisplay(money.Value)
			end)
			print("MoneyHUD: Connected to money value")
		else
			warn("MoneyHUD: Could not find Money value")
		end
	else
		warn("MoneyHUD: Could not find leaderstats")
	end
	
	----------------------------------------------------------------------
	-- STORAGE + HOLDINGS
	----------------------------------------------------------------------
	local function refreshFromAttribute()
		local items, total, cap = GetStorageFunction:InvokeServer()
		StorageItems = items or {}
		updateItemsDisplay(total or 0, Player:GetAttribute("StorageCapacity") or cap or 0)
		updateHoldingsDisplay()
	end
	
	if StorageUpdatedEvent then
		StorageUpdatedEvent.OnClientEvent:Connect(function(items, total, capacity)
			StorageItems = items or {}
			updateItemsDisplay(total or 0, Player:GetAttribute("StorageCapacity") or capacity or 0)
			updateHoldingsDisplay()
		end)
	end
	
	Player:GetAttributeChangedSignal("StorageCapacity"):Connect(function()
		local cur = 0
		if ItemsAmountLabel then
			local txt = ItemsAmountLabel.Text
			local val = txt:match("ITEMS: (%d+)")
			cur = tonumber(val) or 0
		end
		updateItemsDisplay(cur, Player:GetAttribute("StorageCapacity") or 0)
	end)
	
	-- Listen for stock market rate changes to refresh holdings values
	if not StockMarketFolder then
		StockMarketFolder = ReplicatedStorage:FindFirstChild("StockMarket")
	end
	if StockMarketFolder then
		StockMarketFolder:GetAttributeChangedSignal("SectorRates"):Connect(function()
			updateHoldingsDisplay()
		end)
	end
	
	-- Initial fetch
	task.spawn(refreshFromAttribute)
	
	print("MoneyHUD: Ready!")
end

-- Start
initialize()


================================================================================
FILE: src\client\NotificationManager.client.luau
================================================================================

--[[
	NotificationManager Client Script
	
	Handles visual notifications and alerts for the player.
	
	Features:
	- Toast notifications (bottom-right corner)
	- Full-width banners for important events
	- Market ticker for price changes
	- Storage full warnings
	
	Part of the "Sell a Brainrot" system.
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

-- Get player
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- Wait for events
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local StorageUpdatedEvent = RemoteEvents:WaitForChild("StorageUpdated")
local ItemSoldEvent = RemoteEvents:WaitForChild("ItemSold")
local BackpackLoadedEvent = RemoteEvents:WaitForChild("BackpackLoaded")

-- Stock market for events
local stockMarketFolder = ReplicatedStorage:WaitForChild("StockMarket")

-- UI Colors
local COLORS = {
	toast = Color3.fromRGB(30, 35, 50),
	success = Color3.fromRGB(50, 200, 100),
	warning = Color3.fromRGB(255, 180, 50),
	error = Color3.fromRGB(255, 80, 80),
	info = Color3.fromRGB(100, 180, 255),
	gold = Color3.fromRGB(255, 200, 50),
	text = Color3.fromRGB(255, 255, 255),
	textMuted = Color3.fromRGB(180, 180, 200),
}

-- Constants
local TOAST_DURATION = 3
local TOAST_WIDTH = 280
local TOAST_HEIGHT = 60
local MAX_TOASTS = 4

-- State
local activeToasts = {}
local screenGui = nil
local toastContainer = nil
local bannerFrame = nil

--------------------------------------------------------------------------------
-- TOAST NOTIFICATIONS
--------------------------------------------------------------------------------

local function createToastContainer()
	local container = Instance.new("Frame")
	container.Name = "ToastContainer"
	container.Size = UDim2.new(0, TOAST_WIDTH + 20, 1, 0)
	container.Position = UDim2.new(1, -TOAST_WIDTH - 30, 0, 0)
	container.BackgroundTransparency = 1
	container.Parent = screenGui
	
	return container
end

local function showToast(message, toastType, duration)
	toastType = toastType or "info"
	duration = duration or TOAST_DURATION
	
	local color = COLORS[toastType] or COLORS.info
	local emoji = {
		success = "âœ“",
		warning = "âš ",
		error = "âœ•",
		info = "â„¹",
		gold = "ðŸ’°",
	}
	
	-- Create toast
	local toast = Instance.new("Frame")
	toast.Name = "Toast"
	toast.Size = UDim2.new(0, TOAST_WIDTH, 0, TOAST_HEIGHT)
	toast.Position = UDim2.new(0, TOAST_WIDTH + 20, 1, -10 - (#activeToasts * (TOAST_HEIGHT + 10)))
	toast.BackgroundColor3 = COLORS.toast
	toast.BackgroundTransparency = 0.1
	toast.Parent = toastContainer
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 10)
	corner.Parent = toast
	
	local stroke = Instance.new("UIStroke")
	stroke.Color = color
	stroke.Thickness = 2
	stroke.Transparency = 0.3
	stroke.Parent = toast
	
	-- Icon
	local icon = Instance.new("TextLabel")
	icon.Size = UDim2.new(0, 40, 1, 0)
	icon.BackgroundTransparency = 1
	icon.Text = emoji[toastType] or "â„¹"
	icon.TextColor3 = color
	icon.TextSize = 22
	icon.Font = Enum.Font.GothamBold
	icon.Parent = toast
	
	-- Message
	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, -50, 1, 0)
	label.Position = UDim2.new(0, 40, 0, 0)
	label.BackgroundTransparency = 1
	label.Text = message
	label.TextColor3 = COLORS.text
	label.TextSize = 14
	label.Font = Enum.Font.Gotham
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.TextWrapped = true
	label.Parent = toast
	
	-- Slide in
	table.insert(activeToasts, toast)
	TweenService:Create(toast, TweenInfo.new(0.3, Enum.EasingStyle.Back), {
		Position = UDim2.new(0, 0, 1, -10 - ((#activeToasts - 1) * (TOAST_HEIGHT + 10)))
	}):Play()
	
	-- Auto-remove after duration
	task.delay(duration, function()
		-- Fade out
		TweenService:Create(toast, TweenInfo.new(0.3), {
			Position = UDim2.new(0, TOAST_WIDTH + 20, toast.Position.Y.Scale, toast.Position.Y.Offset)
		}):Play()
		
		task.wait(0.3)
		
		-- Remove from list and destroy
		local index = table.find(activeToasts, toast)
		if index then
			table.remove(activeToasts, index)
		end
		toast:Destroy()
		
		-- Reposition remaining toasts
		for i, t in ipairs(activeToasts) do
			TweenService:Create(t, TweenInfo.new(0.2), {
				Position = UDim2.new(0, 0, 1, -10 - ((i - 1) * (TOAST_HEIGHT + 10)))
			}):Play()
		end
	end)
	
	-- Limit max toasts
	while #activeToasts > MAX_TOASTS do
		local oldest = table.remove(activeToasts, 1)
		if oldest then oldest:Destroy() end
	end
end

--------------------------------------------------------------------------------
-- BANNER NOTIFICATIONS
--------------------------------------------------------------------------------

local function createBannerFrame()
	local banner = Instance.new("Frame")
	banner.Name = "BannerFrame"
	banner.Size = UDim2.new(1, 0, 0, 60)
	banner.Position = UDim2.new(0, 0, 0, -60)
	banner.BackgroundColor3 = COLORS.gold
	banner.BackgroundTransparency = 0.1
	banner.Visible = false
	banner.ZIndex = 10
	banner.Parent = screenGui
	
	local label = Instance.new("TextLabel")
	label.Name = "Message"
	label.Size = UDim2.new(1, -40, 1, 0)
	label.Position = UDim2.new(0, 20, 0, 0)
	label.BackgroundTransparency = 1
	label.Text = ""
	label.TextColor3 = Color3.fromRGB(20, 20, 30)
	label.TextSize = 24
	label.Font = Enum.Font.GothamBold
	label.ZIndex = 11
	label.Parent = banner
	
	return banner
end

local function showBanner(message, color, duration)
	color = color or COLORS.gold
	duration = duration or 4
	
	bannerFrame.BackgroundColor3 = color
	bannerFrame:FindFirstChild("Message").Text = message
	bannerFrame.Visible = true
	
	-- Slide down
	bannerFrame.Position = UDim2.new(0, 0, 0, -60)
	TweenService:Create(bannerFrame, TweenInfo.new(0.4, Enum.EasingStyle.Back), {
		Position = UDim2.new(0, 0, 0, 0)
	}):Play()
	
	-- Auto hide
	task.delay(duration, function()
		TweenService:Create(bannerFrame, TweenInfo.new(0.3), {
			Position = UDim2.new(0, 0, 0, -60)
		}):Play()
		
		task.wait(0.3)
		bannerFrame.Visible = false
	end)
end

--------------------------------------------------------------------------------
-- EVENT HANDLERS
--------------------------------------------------------------------------------

-- Storage full warning
StorageUpdatedEvent.OnClientEvent:Connect(function(items, total, capacity)
	if total >= capacity then
		showToast("Storage is FULL! Brainrots are sleeping.", "warning")
	elseif total >= capacity * 0.9 then
		showToast("Storage almost full (" .. total .. "/" .. capacity .. ")", "warning")
	end
end)

-- Item sold notification
ItemSoldEvent.OnClientEvent:Connect(function(itemId, count, earned)
	if earned > 0 then
		local msg = string.format("+$%d for %dx %s", earned, count, itemId or "items")
		showToast(msg, "gold", 2)
	end
end)

-- Backpack loaded notification
BackpackLoadedEvent.OnClientEvent:Connect(function(itemId, count)
	if count > 0 then
		local msg = itemId and string.format("Loaded %dx %s", count, itemId) or string.format("Loaded %d items", count)
		showToast(msg, "info", 2)
	end
end)

-- Market rate changes
local lastRate = 1.0
stockMarketFolder:GetAttributeChangedSignal("CurrentRate"):Connect(function()
	local newRate = stockMarketFolder:GetAttribute("CurrentRate") or 1.0
	
	if newRate >= 2.5 and lastRate < 2.5 then
		showBanner("ðŸ“ˆ HYPER INFLATION! Sell now for 2.5x+ prices!", COLORS.success, 5)
	elseif newRate <= 0.6 and lastRate > 0.6 then
		showBanner("ðŸ“‰ MARKET CRASH! Prices at historic lows!", COLORS.error, 5)
	end
	
	lastRate = newRate
end)

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

local function initialize()
	-- Create screen gui
	screenGui = Instance.new("ScreenGui")
	screenGui.Name = "NotificationUI"
	screenGui.ResetOnSpawn = false
	screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	screenGui.Parent = PlayerGui
	
	-- Create containers
	toastContainer = createToastContainer()
	bannerFrame = createBannerFrame()
	
	print("âœ“ NotificationManager initialized")
end

initialize()

-- Export for other scripts
_G.NotificationManager = {
	ShowToast = showToast,
	ShowBanner = showBanner,
}


================================================================================
FILE: src\client\PhysicalInventoryHUD.client.luau
================================================================================

--[[
	PhysicalInventoryHUD Client Script
	
	Displays contents/capacity HUDs above physical Storage Boxes and Transport Carts.
	Uses BillboardGuis to show top 3 items and a progress bar for capacity.
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")
local TweenService = game:GetService("TweenService")

local Player = Players.LocalPlayer
local Shared = ReplicatedStorage:WaitForChild("Shared")
local ItemConfig = require(Shared:WaitForChild("ItemConfig"))

-- Remotes
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local RemoteFunctions = ReplicatedStorage:WaitForChild("RemoteFunctions")

local StorageUpdatedEvent = RemoteEvents:WaitForChild("StorageUpdated")
local CartUpdateEvent = RemoteEvents:WaitForChild("CartUpdate")
local GetStorageFunction = RemoteFunctions:WaitForChild("GetStorage")
local GetVehicleInfoFunction = RemoteFunctions:WaitForChild("GetVehicleInfo")

-- Configuration (Linked styling with UnitHUD)
local HUD_CONFIG = {
	BILLBOARD_SIZE = UDim2.new(0, 140, 0, 80),
	MAX_DISTANCE = 100,
	CARD_BACKGROUND = Color3.fromRGB(25, 25, 35),
	CARD_STROKE_COLOR = Color3.fromRGB(80, 80, 100),
	CORNER_RADIUS = 8,
	BAR_HEIGHT = 6,
	BAR_BACKGROUND_COLOR = Color3.fromRGB(40, 40, 50),
	BAR_FILL_STORAGE = Color3.fromRGB(100, 200, 255),
	BAR_FILL_CART = Color3.fromRGB(100, 255, 150),
	TEXT_COLOR = Color3.fromRGB(255, 255, 255),
	SUBTEXT_COLOR = Color3.fromRGB(180, 180, 200),
}

local STORAGE_TAG = "PhysicalStorageHUD"
local CART_TAG = "PhysicalCartHUD"

-- State tracking
local ActiveHUDs: {[Instance]: {billboard: BillboardGui, type: string}} = {}

--------------------------------------------------------------------------------
-- UI CREATION
--------------------------------------------------------------------------------

local function createBillboard(target: Instance, title: string, fillCol: Color3)
	local billboard = Instance.new("BillboardGui")
	billboard.Name = "InventoryHUD"
	billboard.Size = HUD_CONFIG.BILLBOARD_SIZE
	billboard.StudsOffset = Vector3.new(0, 7, 0)
	billboard.AlwaysOnTop = false
	billboard.MaxDistance = HUD_CONFIG.MAX_DISTANCE
	billboard.LightInfluence = 0
	billboard.Adornee = target
	
	-- Main card
	local card = Instance.new("Frame")
	card.Name = "Card"
	card.Size = UDim2.new(1, 0, 1, 0)
	card.BackgroundColor3 = HUD_CONFIG.CARD_BACKGROUND
	card.BackgroundTransparency = 0.15
	card.BorderSizePixel = 0
	card.Parent = billboard
	
	local cardCorner = Instance.new("UICorner")
	cardCorner.CornerRadius = UDim.new(0, HUD_CONFIG.CORNER_RADIUS)
	cardCorner.Parent = card
	
	local cardStroke = Instance.new("UIStroke")
	cardStroke.Color = HUD_CONFIG.CARD_STROKE_COLOR
	cardStroke.Thickness = 1
	cardStroke.Transparency = 0.3
	cardStroke.Parent = card
	
	local padding = Instance.new("UIPadding")
	padding.PaddingLeft = UDim.new(0, 6)
	padding.PaddingRight = UDim.new(0, 6)
	padding.PaddingTop = UDim.new(0, 4)
	padding.PaddingBottom = UDim.new(0, 6)
	padding.Parent = card
	
	-- Title
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "Title"
	titleLabel.Size = UDim2.new(1, 0, 0, 14)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Text = title
	titleLabel.TextColor3 = fillCol
	titleLabel.TextSize = 12
	titleLabel.Font = Enum.Font.GothamBold
	titleLabel.Parent = card
	
	-- Item List Container
	local list = Instance.new("Frame")
	list.Name = "ItemList"
	list.Size = UDim2.new(1, 0, 1, -34)
	list.Position = UDim2.new(0, 0, 0, 16)
	list.BackgroundTransparency = 1
	list.Parent = card
	
	local layout = Instance.new("UIListLayout")
	layout.Padding = UDim.new(0, 2)
	layout.SortOrder = Enum.SortOrder.LayoutOrder
	layout.Parent = list
	
	-- Capacity Bar
	local barBg = Instance.new("Frame")
	barBg.Name = "BarBackground"
	barBg.Size = UDim2.new(1, 0, 0, HUD_CONFIG.BAR_HEIGHT)
	barBg.Position = UDim2.new(0, 0, 1, -HUD_CONFIG.BAR_HEIGHT)
	barBg.BackgroundColor3 = HUD_CONFIG.BAR_BACKGROUND_COLOR
	barBg.BorderSizePixel = 0
	barBg.Parent = card
	
	local barFill = Instance.new("Frame")
	barFill.Name = "Fill"
	barFill.Size = UDim2.new(0, 0, 1, 0)
	barFill.BackgroundColor3 = fillCol
	barFill.BorderSizePixel = 0
	barFill.Parent = barBg
	
	local capLabel = Instance.new("TextLabel")
	capLabel.Name = "CapLabel"
	capLabel.Size = UDim2.new(1, 0, 1, 0)
	capLabel.BackgroundTransparency = 1
	capLabel.Text = "0 / 0"
	capLabel.TextColor3 = HUD_CONFIG.TEXT_COLOR
	capLabel.TextSize = 8
	capLabel.Font = Enum.Font.GothamBold
	capLabel.Parent = barBg
	
	billboard.Parent = target
	return billboard
end

local function updateHUD(billboard: BillboardGui, inventory: {[string]: number}, current: number, max: number)
	local card = billboard:FindFirstChild("Card")
	if not card then return end
	
	-- Update Bar
	local barBg = card:FindFirstChild("BarBackground")
	if barBg then
		local fill = barBg:FindFirstChild("Fill")
		local capLabel = barBg:FindFirstChild("CapLabel")
		local ratio = math.clamp(current / math.max(1, max), 0, 1)
		
		if fill then
			TweenService:Create(fill, TweenInfo.new(0.3), {Size = UDim2.new(ratio, 0, 1, 0)}):Play()
		end
		if capLabel then
			capLabel.Text = string.format("%d / %d", current, max)
		end
	end
	
	-- Update Items (Top 3)
	local list = card:FindFirstChild("ItemList")
	if list then
		for _, child in list:GetChildren() do
			if child:IsA("TextLabel") then child:Destroy() end
		end
		
		local sortedItems = {}
		for id, count in pairs(inventory) do
			if count > 0 then
				table.insert(sortedItems, {id = id, count = count})
			end
		end
		table.sort(sortedItems, function(a, b) return a.count > b.count end)
		
		for i = 1, math.min(3, #sortedItems) do
			local data = sortedItems[i]
			local itemInfo = ItemConfig.Items[data.id]
			local icon = itemInfo and itemInfo.icon or "ðŸ“¦"
			
			local itemLabel = Instance.new("TextLabel")
			itemLabel.Size = UDim2.new(1, 0, 0, 12)
			itemLabel.BackgroundTransparency = 1
			itemLabel.Text = string.format("%s x%d", icon, data.count)
			itemLabel.TextColor3 = HUD_CONFIG.TEXT_COLOR
			itemLabel.TextSize = 10
			itemLabel.Font = Enum.Font.Gotham
			itemLabel.TextXAlignment = Enum.TextXAlignment.Center
			itemLabel.Parent = list
		end
		
		if #sortedItems == 0 then
			local emptyLabel = Instance.new("TextLabel")
			emptyLabel.Size = UDim2.new(1, 0, 1, 0)
			emptyLabel.BackgroundTransparency = 1
			emptyLabel.Text = "Empty"
			emptyLabel.TextColor3 = HUD_CONFIG.SUBTEXT_COLOR
			emptyLabel.TextSize = 10
			emptyLabel.Font = Enum.Font.Gotham
			emptyLabel.Parent = list
		end
	end
end

--------------------------------------------------------------------------------
-- SYNC LOGIC
--------------------------------------------------------------------------------

local function isPlayerPlot(instance: Instance)
	local plot = instance:FindFirstAncestor("Plot") or instance:FindFirstAncestorWhichIsA("Model")
	if plot and plot:GetAttribute("OwnerId") == Player.UserId then
		return true
	end
	-- Check parent name pattern Cart_Username
	if instance.Name:find("Cart_") and instance.Name:find(Player.Name) then
		return true
	end
	return false
end

local function setupStorageHUD(part: Instance)
	if not isPlayerPlot(part) then return end
	if ActiveHUDs[part] then return end
	
	local bb = createBillboard(part, "ðŸ“¦ PLOT STORAGE", HUD_CONFIG.BAR_FILL_STORAGE)
	ActiveHUDs[part] = {billboard = bb, type = "storage"}
	
	-- Initial sync
	task.spawn(function()
		local items, current, max = GetStorageFunction:InvokeServer()
		if ActiveHUDs[part] then
			updateHUD(bb, items or {}, current or 0, Player:GetAttribute("StorageCapacity") or max or 0)
		end
	end)
end

local function setupCartHUD(model: Instance)
	if not isPlayerPlot(model) then return end
	if ActiveHUDs[model] then return end
	
	local primary = model:IsA("Model") and model.PrimaryPart or model
	local bb = createBillboard(primary, "ðŸ›’ TRANSPORT CART", HUD_CONFIG.BAR_FILL_CART)
	ActiveHUDs[model] = {billboard = bb, type = "cart"}
	
	-- Initial sync
	task.spawn(function()
		local info = GetVehicleInfoFunction:InvokeServer()
		if info and ActiveHUDs[model] then
			local current = 0
			for _, c in pairs(info.inventory or {}) do current += c end
			updateHUD(bb, info.inventory or {}, current, Player:GetAttribute("CartCapacity") or info.capacity or 0)
		end
	end)
end

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

StorageUpdatedEvent.OnClientEvent:Connect(function(items, current, max)
	for obj, data in pairs(ActiveHUDs) do
		if data.type == "storage" then
			updateHUD(data.billboard, items, current, Player:GetAttribute("StorageCapacity") or max or 0)
		end
	end
end)

CartUpdateEvent.OnClientEvent:Connect(function(state, inventory, max)
	for obj, data in pairs(ActiveHUDs) do
		if data.type == "cart" then
			local current = 0
			for _, c in pairs(inventory or {}) do current += c end
			updateHUD(data.billboard, inventory or {}, current, Player:GetAttribute("CartCapacity") or max or 0)
		end
	end
end)

CollectionService:GetInstanceAddedSignal(STORAGE_TAG):Connect(setupStorageHUD)
CollectionService:GetInstanceAddedSignal(CART_TAG):Connect(setupCartHUD)

for _, inst in CollectionService:GetTagged(STORAGE_TAG) do task.spawn(setupStorageHUD, inst) end
for _, inst in CollectionService:GetTagged(CART_TAG) do task.spawn(setupCartHUD, inst) end

print("âœ“ PhysicalInventoryHUD initialized")


================================================================================
FILE: src\client\PrestigeUI.client.luau
================================================================================

--[[
	PrestigeUI Client Script
	
	Handles the Golden Meatball Altar UI and Shop.
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Wait for shared modules
local PrestigeConfig = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("PrestigeConfig"))

-- Remote Events
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local PrestigeEvent = RemoteEvents:WaitForChild("PrestigeEvent")

-- State
local currentData = {
	totalMeatballs = 0,
	spentMeatballs = 0,
	pendingMeatballs = 0,
	lifetimeEarnings = 0,
	upgrades = {}
}

--------------------------------------------------------------------------------
-- UI CREATION
--------------------------------------------------------------------------------

local function createPrestigeUI()
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "PrestigeUI"
	screenGui.ResetOnSpawn = false
	screenGui.Enabled = false
	screenGui.Parent = playerGui
	
	-- Main Frame
	local mainFrame = Instance.new("Frame")
	mainFrame.Name = "MainFrame"
	mainFrame.Size = UDim2.new(0, 800, 0, 600)
	mainFrame.Position = UDim2.new(0.5, -400, 0.5, -300)
	mainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
	mainFrame.BorderSizePixel = 0
	mainFrame.Parent = screenGui
	
	local uiCorner = Instance.new("UICorner")
	uiCorner.CornerRadius = UDim.new(0, 12)
	uiCorner.Parent = mainFrame
	
	-- Header
	local header = Instance.new("Frame")
	header.Name = "Header"
	header.Size = UDim2.new(1, 0, 0, 80)
	header.BackgroundColor3 = Color3.fromRGB(255, 215, 0) -- Gold
	header.BorderSizePixel = 0
	header.Parent = mainFrame
	
	local headerCorner = Instance.new("UICorner")
	headerCorner.CornerRadius = UDim.new(0, 12)
	headerCorner.Parent = header
	
	-- Fix bottom corners of header
	local headerCover = Instance.new("Frame")
	headerCover.Size = UDim2.new(1, 0, 0, 20)
	headerCover.Position = UDim2.new(0, 0, 1, -20)
	headerCover.BackgroundColor3 = Color3.fromRGB(255, 215, 0)
	headerCover.BorderSizePixel = 0
	headerCover.Parent = header
	
	local title = Instance.new("TextLabel")
	title.Text = "GOLDEN MEATBALL ALTAR"
	title.Font = Enum.Font.FredokaOne
	title.TextSize = 40
	title.TextColor3 = Color3.fromRGB(100, 80, 0)
	title.Size = UDim2.new(1, 0, 1, 0)
	title.BackgroundTransparency = 1
	title.Parent = header
	
	-- Close Button
	local closeBtn = Instance.new("TextButton")
	closeBtn.Text = "X"
	closeBtn.Font = Enum.Font.FredokaOne
	closeBtn.TextSize = 24
	closeBtn.TextColor3 = Color3.fromRGB(100, 80, 0)
	closeBtn.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	closeBtn.Size = UDim2.new(0, 40, 0, 40)
	closeBtn.Position = UDim2.new(1, -50, 0.5, -20)
	closeBtn.Parent = header
	
	local closeCorner = Instance.new("UICorner")
	closeCorner.CornerRadius = UDim.new(0, 8)
	closeCorner.Parent = closeBtn
	
	closeBtn.MouseButton1Click:Connect(function()
		screenGui.Enabled = false
	end)
	
	-- Content Container
	local content = Instance.new("Frame")
	content.Name = "Content"
	content.Size = UDim2.new(1, -40, 1, -140)
	content.Position = UDim2.new(0, 20, 0, 100)
	content.BackgroundTransparency = 1
	content.Parent = mainFrame
	
	-- Left Panel: Stats & Prestige
	local leftPanel = Instance.new("Frame")
	leftPanel.Name = "LeftPanel"
	leftPanel.Size = UDim2.new(0.4, -10, 1, 0)
	leftPanel.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
	leftPanel.Parent = content
	
	local leftCorner = Instance.new("UICorner")
	leftCorner.CornerRadius = UDim.new(0, 8)
	leftCorner.Parent = leftPanel
	
	-- Stats Display
	local statsList = Instance.new("UIListLayout")
	statsList.Padding = UDim.new(0, 10)
	statsList.HorizontalAlignment = Enum.HorizontalAlignment.Center
	statsList.SortOrder = Enum.SortOrder.LayoutOrder
	statsList.Parent = leftPanel
	
	local padding = Instance.new("UIPadding")
	padding.PaddingTop = UDim.new(0, 20)
	padding.PaddingBottom = UDim.new(0, 20)
	padding.PaddingLeft = UDim.new(0, 10)
	padding.PaddingRight = UDim.new(0, 10)
	padding.Parent = leftPanel
	
	-- Current Meatballs
	local currentLabel = Instance.new("TextLabel")
	currentLabel.Name = "CurrentLabel"
	currentLabel.Text = "Your Golden Meatballs"
	currentLabel.Font = Enum.Font.GothamBold
	currentLabel.TextSize = 18
	currentLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
	currentLabel.Size = UDim2.new(1, 0, 0, 30)
	currentLabel.BackgroundTransparency = 1
	currentLabel.LayoutOrder = 1
	currentLabel.Parent = leftPanel
	
	local meatballCount = Instance.new("TextLabel")
	meatballCount.Name = "MeatballCount"
	meatballCount.Text = "0"
	meatballCount.Font = Enum.Font.FredokaOne
	meatballCount.TextSize = 48
	meatballCount.TextColor3 = Color3.fromRGB(255, 215, 0)
	meatballCount.Size = UDim2.new(1, 0, 0, 60)
	meatballCount.BackgroundTransparency = 1
	meatballCount.LayoutOrder = 2
	meatballCount.Parent = leftPanel
	
	-- Bonus Display
	local bonusLabel = Instance.new("TextLabel")
	bonusLabel.Name = "BonusLabel"
	bonusLabel.Text = "+0% Income Bonus"
	bonusLabel.Font = Enum.Font.GothamBold
	bonusLabel.TextSize = 20
	bonusLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
	bonusLabel.Size = UDim2.new(1, 0, 0, 30)
	bonusLabel.BackgroundTransparency = 1
	bonusLabel.LayoutOrder = 3
	bonusLabel.Parent = leftPanel
	
	-- Divider
	local divider = Instance.new("Frame")
	divider.Size = UDim2.new(1, 0, 0, 2)
	divider.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
	divider.BorderSizePixel = 0
	divider.LayoutOrder = 4
	divider.Parent = leftPanel
	
	-- Pending Section
	local pendingTitle = Instance.new("TextLabel")
	pendingTitle.Text = "Prestige Now To Gain:"
	pendingTitle.Font = Enum.Font.GothamBold
	pendingTitle.TextSize = 16
	pendingTitle.TextColor3 = Color3.fromRGB(200, 200, 200)
	pendingTitle.Size = UDim2.new(1, 0, 0, 30)
	pendingTitle.BackgroundTransparency = 1
	pendingTitle.LayoutOrder = 5
	pendingTitle.Parent = leftPanel
	
	local pendingCount = Instance.new("TextLabel")
	pendingCount.Name = "PendingCount"
	pendingCount.Text = "+0"
	pendingCount.Font = Enum.Font.FredokaOne
	pendingCount.TextSize = 36
	pendingCount.TextColor3 = Color3.fromRGB(255, 255, 255)
	pendingCount.Size = UDim2.new(1, 0, 0, 50)
	pendingCount.BackgroundTransparency = 1
	pendingCount.LayoutOrder = 6
	pendingCount.Parent = leftPanel
	
	-- Prestige Button
	local prestigeBtn = Instance.new("TextButton")
	prestigeBtn.Name = "PrestigeButton"
	prestigeBtn.Text = "PRESTIGE RESET"
	prestigeBtn.Font = Enum.Font.FredokaOne
	prestigeBtn.TextSize = 24
	prestigeBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
	prestigeBtn.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
	prestigeBtn.Size = UDim2.new(1, 0, 0, 60)
	prestigeBtn.LayoutOrder = 7
	prestigeBtn.Parent = leftPanel
	
	local btnCorner = Instance.new("UICorner")
	btnCorner.CornerRadius = UDim.new(0, 8)
	btnCorner.Parent = prestigeBtn
	
	local warningLabel = Instance.new("TextLabel")
	warningLabel.Text = "Resets Money, Units & Upgrades!"
	warningLabel.Font = Enum.Font.Gotham
	warningLabel.TextSize = 12
	warningLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
	warningLabel.Size = UDim2.new(1, 0, 0, 20)
	warningLabel.BackgroundTransparency = 1
	warningLabel.LayoutOrder = 8
	warningLabel.Parent = leftPanel
	
	prestigeBtn.MouseButton1Click:Connect(function()
		if currentData.pendingMeatballs >= PrestigeConfig.MINIMUM_PRESTIGE_GAIN then
			PrestigeEvent:FireServer("Prestige")
			screenGui.Enabled = false
		end
	end)
	
	-- Right Panel: Shop
	local rightPanel = Instance.new("ScrollingFrame")
	rightPanel.Name = "ShopPanel"
	rightPanel.Size = UDim2.new(0.6, -10, 1, 0)
	rightPanel.Position = UDim2.new(0.4, 10, 0, 0)
	rightPanel.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
	rightPanel.ScrollBarThickness = 6
	rightPanel.Parent = content
	
	local rightCorner = Instance.new("UICorner")
	rightCorner.CornerRadius = UDim.new(0, 8)
	rightCorner.Parent = rightPanel
	
	local shopLayout = Instance.new("UIListLayout")
	shopLayout.Padding = UDim.new(0, 10)
	shopLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	shopLayout.SortOrder = Enum.SortOrder.LayoutOrder
	shopLayout.Parent = rightPanel
	
	local shopPadding = Instance.new("UIPadding")
	shopPadding.PaddingTop = UDim.new(0, 10)
	shopPadding.PaddingBottom = UDim.new(0, 10)
	shopPadding.PaddingLeft = UDim.new(0, 10)
	shopPadding.PaddingRight = UDim.new(0, 10)
	shopPadding.Parent = rightPanel
	
	return screenGui
end

local function createShopItem(parent, item, isOwned, isLocked)
	local frame = Instance.new("Frame")
	frame.Name = item.Id
	frame.Size = UDim2.new(1, 0, 0, 80)
	frame.BackgroundColor3 = Color3.fromRGB(50, 50, 60)
	frame.Parent = parent
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 8)
	corner.Parent = frame
	
	-- Name
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Text = item.Name
	nameLabel.Font = Enum.Font.GothamBold
	nameLabel.TextSize = 16
	nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	nameLabel.Size = UDim2.new(0.6, 0, 0, 25)
	nameLabel.Position = UDim2.new(0, 10, 0, 5)
	nameLabel.TextXAlignment = Enum.TextXAlignment.Left
	nameLabel.BackgroundTransparency = 1
	nameLabel.Parent = frame
	
	-- Description
	local descLabel = Instance.new("TextLabel")
	descLabel.Text = item.Description
	descLabel.Font = Enum.Font.Gotham
	descLabel.TextSize = 12
	descLabel.TextColor3 = Color3.fromRGB(180, 180, 180)
	descLabel.Size = UDim2.new(0.6, 0, 0, 40)
	descLabel.Position = UDim2.new(0, 10, 0, 30)
	descLabel.TextXAlignment = Enum.TextXAlignment.Left
	descLabel.TextWrapped = true
	descLabel.BackgroundTransparency = 1
	descLabel.Parent = frame
	
	-- Buy Button
	local buyBtn = Instance.new("TextButton")
	buyBtn.Size = UDim2.new(0.35, 0, 0.8, 0)
	buyBtn.Position = UDim2.new(0.63, 0, 0.1, 0)
	buyBtn.Font = Enum.Font.GothamBold
	buyBtn.TextSize = 14
	buyBtn.Parent = frame
	
	local btnCorner = Instance.new("UICorner")
	btnCorner.CornerRadius = UDim.new(0, 6)
	btnCorner.Parent = buyBtn
	
	if isOwned then
		buyBtn.Text = "OWNED"
		buyBtn.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
		buyBtn.TextColor3 = Color3.fromRGB(200, 200, 200)
		buyBtn.AutoButtonColor = false
	elseif isLocked then
		buyBtn.Text = "LOCKED\nNeed " .. item.UnlockAt .. " Meatballs"
		buyBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
		buyBtn.TextColor3 = Color3.fromRGB(150, 150, 150)
		buyBtn.AutoButtonColor = false
	else
		buyBtn.Text = "BUY\n" .. item.Price .. " Meatballs"
		buyBtn.BackgroundColor3 = Color3.fromRGB(255, 215, 0)
		buyBtn.TextColor3 = Color3.fromRGB(50, 40, 0)
		
		buyBtn.MouseButton1Click:Connect(function()
			PrestigeEvent:FireServer("PurchaseUpgrade", item.Id)
		end)
	end
end

local function updateUI(gui)
	local leftPanel = gui.MainFrame.Content.LeftPanel
	local shopPanel = gui.MainFrame.Content.ShopPanel
	
	-- Update Stats
	leftPanel.MeatballCount.Text = tostring(currentData.totalMeatballs)
	
	-- Calculate bonus (unspent * 2%)
	local unspent = currentData.totalMeatballs - currentData.spentMeatballs
	local bonus = math.floor(unspent * PrestigeConfig.MEATBALL_BONUS_RATE * 100)
	leftPanel.BonusLabel.Text = "+" .. bonus .. "% Income Bonus"
	
	-- Update Pending
	leftPanel.PendingCount.Text = "+" .. currentData.pendingMeatballs
	
	-- Update Button
	local prestigeBtn = leftPanel.PrestigeButton
	if currentData.pendingMeatballs >= PrestigeConfig.MINIMUM_PRESTIGE_GAIN then
		prestigeBtn.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
		prestigeBtn.Text = "PRESTIGE RESET"
		prestigeBtn.AutoButtonColor = true
	else
		prestigeBtn.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
		prestigeBtn.Text = "Need " .. PrestigeConfig.MINIMUM_PRESTIGE_GAIN .. " to Prestige"
		prestigeBtn.AutoButtonColor = false
	end
	
	-- Update Shop
	-- Clear old items
	for _, child in shopPanel:GetChildren() do
		if child:IsA("Frame") then child:Destroy() end
	end
	
	-- Add items
	for _, item in ipairs(PrestigeConfig.SHOP_ITEMS) do
		local isOwned = false
		for _, ownedId in ipairs(currentData.upgrades) do
			if ownedId == item.Id then
				isOwned = true
				break
			end
		end
		
		local isLocked = currentData.totalMeatballs < item.UnlockAt
		
		createShopItem(shopPanel, item, isOwned, isLocked)
	end
end

--------------------------------------------------------------------------------
-- MAIN LOGIC
--------------------------------------------------------------------------------

local ui = createPrestigeUI()

PrestigeEvent.OnClientEvent:Connect(function(action, data)
	if action == "OpenMenu" then
		currentData = data
		updateUI(ui)
		ui.Enabled = true
	elseif action == "UpdateData" then
		currentData = data
		if ui.Enabled then
			updateUI(ui)
		end
	elseif action == "PrestigeCompleted" then
		-- Play cool effect?
		print("Prestige completed! Gained " .. data.gained .. " meatballs.")
	end
end)

-- HUD Integration (Optional: Add meatball counter to main HUD)
-- For now, we rely on the Altar UI.


================================================================================
FILE: src\client\ProjectileVisuals.client.luau
================================================================================

--[[
	ProjectileVisuals Client Script
	
	Handles visual projectile effects for brainrot units.
	Units "throw" projectiles at their island's Storage container every income cycle.
	
	This is purely visual - the server handles actual money logic.
	Inspired by The Gnorp Apologue.
	
	Features:
	- CollectionService detection for "ActiveBrainrot" tagged units
	- Per-unit coroutine loops based on CycleTime
	- Bezier curve projectile arcs
	- Storage impact effects (squash animation + particles)
	- Multi-island support
]]

-- Services
local Players = game:GetService("Players")
local CollectionService = game:GetService("CollectionService")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Get player
local LocalPlayer = Players.LocalPlayer

-- Configuration
local ShopConfig = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("ShopConfig"))

-- Tags
local BRAINROT_TAG = "ActiveBrainrot"

-- ============================================================================
-- PROJECTILE CONFIGURATION
-- Change these values to customize projectile behavior
-- ============================================================================
local PROJECTILE_CONFIG = {
	-- Projectile flight settings
	FLIGHT_TIME = 0.5,              -- Seconds to reach Storage (LOWER = FASTER)
	ARC_HEIGHT = 8,                 -- Studs above midpoint for arc peak
	STEPS = 30,                     -- Number of bezier curve samples (smoothness)
	
	-- Projectile appearance
	SIZE = Vector3.new(0.8, 0.8, 0.8),
	MATERIAL = Enum.Material.Neon,
	SHAPE = Enum.PartType.Ball,
	DEFAULT_COLOR = Color3.fromRGB(255, 255, 255), -- White fallback
	TRANSPARENCY = 0,
	
	-- Impact effects
	SQUASH_SCALE = 1.15,            -- Storage scales up by 15%
	SQUASH_DURATION = 0.1,          -- Seconds for squash animation
	PARTICLE_COUNT = 8,             -- Number of particles on impact
	PARTICLE_LIFETIME = 0.5,        -- Seconds particles last
	PARTICLE_SPEED = 15,            -- Particle velocity
	
	-- Performance
	MAX_PROJECTILES = 100,          -- Max concurrent projectiles (prevents lag)
}

-- Track active projectiles for performance limiting
local activeProjectileCount = 0

-- Track unit loops (to clean up when units are removed)
local unitLoops: {[Instance]: thread} = {}

-- Cache true original sizes for storage parts to prevent size drift
local storageOriginalSizes: {[BasePart]: Vector3} = {}

-- ============================================================================
-- MATH HELPER: BEZIER CURVE
-- ============================================================================

--[[
	Samples a point on a quadratic Bezier curve.
	Creates a natural arc from start to end with a peak in the middle.
	
	@param startPos Vector3 - Starting position (unit)
	@param endPos Vector3 - Ending position (storage)
	@param height number - Peak height of the arc above midpoint
	@param t number - Parameter from 0 to 1 (0 = start, 1 = end)
	@return Vector3 - The interpolated position on the curve
]]
local function sampleBezier(startPos: Vector3, endPos: Vector3, height: number, t: number): Vector3
	-- Control point is at the midpoint, elevated by height
	local midPoint = (startPos + endPos) / 2 + Vector3.new(0, height, 0)
	
	-- Quadratic Bezier: B(t) = (1-t)Â²P0 + 2(1-t)tP1 + tÂ²P2
	-- Simplified using nested lerps for readability:
	local p0 = startPos:Lerp(midPoint, t)
	local p1 = midPoint:Lerp(endPos, t)
	return p0:Lerp(p1, t)
end

--[[
	Calculates dynamic arc height based on distance and elevation.
	For brainrots on higher-tier islands, this creates a high-arcing trajectory
	that rises above intermediate islands before landing in the storage.
	
	@param startPos Vector3 - Starting position (brainrot unit)
	@param endPos Vector3 - Ending position (storage tank)
	@return number - The calculated arc height above the midpoint
]]
local function calculateDynamicArcHeight(startPos: Vector3, endPos: Vector3): number
	-- Calculate horizontal distance (ignoring Y)
	local horizontalDistance = (Vector3.new(endPos.X, 0, endPos.Z) - Vector3.new(startPos.X, 0, startPos.Z)).Magnitude
	
	-- Calculate elevation difference (positive if brainrot is higher than storage)
	local elevationDiff = startPos.Y - endPos.Y
	
	-- Base arc height scales with horizontal distance
	-- A projectile traveling 100 studs should arc ~25 studs high
	local distanceBasedArc = horizontalDistance * 0.25
	
	-- If brainrot is higher than storage, add extra height to create a nice lob
	-- The projectile should go UP first, then come DOWN gracefully to the storage
	local elevationBoost = math.max(0, elevationDiff * 0.5)
	
	-- Use the configured minimum as the floor
	return math.max(PROJECTILE_CONFIG.ARC_HEIGHT, distanceBasedArc + elevationBoost)
end

-- ============================================================================
-- STORAGE FINDER
-- ============================================================================

--[[
	Finds the Storage part for a given brainrot unit.
	Supports multi-island by looking at the unit's parent hierarchy.
	
	@param brainrot Instance - The brainrot unit
	@return BasePart? - The Storage part, or nil if not found
]]
local function findStorageForUnit(brainrot: Instance): BasePart?
	-- Get the unit's TierIndex to find the correct island's storage
	local _tierIndex = brainrot:GetAttribute("TierIndex")
	
	-- Walk up to find the plot/island model
	local parent = brainrot.Parent
	while parent and parent.Name ~= "Brainrots" do
		parent = parent.Parent
	end
	
	-- Go up one more level to get the plot/island
	if parent then
		local plot = parent.Parent
		if plot then
			local storage = plot:FindFirstChild("Storage")
			if storage and storage:IsA("BasePart") then
				return storage
			end
		end
	end
	
	-- Fallback: search all plots for player's storage
	local ownerId = brainrot:GetAttribute("OwnerId")
	if not ownerId then return nil end
	
	local plotsFolder = workspace:FindFirstChild("Plots")
	if plotsFolder then
		for _, plot in plotsFolder:GetChildren() do
			local plotOwnerId = plot:GetAttribute("OwnerId")
			if plotOwnerId == ownerId then
				local storage = plot:FindFirstChild("Storage")
				if storage and storage:IsA("BasePart") then
					return storage
				end
			end
		end
	end
	
	return nil
end

-- ============================================================================
-- UNIT POSITION HELPER
-- ============================================================================

--[[
	Gets the position of a brainrot unit.
	Handles both Model and Part-based units.
	
	@param brainrot Instance - The brainrot unit
	@return Vector3? - The position, or nil if not found
]]
local function getUnitPosition(brainrot: Instance): Vector3?
	if brainrot:IsA("Model") then
		if brainrot.PrimaryPart then
			return brainrot.PrimaryPart.Position
		else
			-- Try to get bounding box center
			local success, cf = pcall(function()
				return brainrot:GetPivot()
			end)
			if success then
				return cf.Position
			end
		end
	elseif brainrot:IsA("BasePart") then
		return brainrot.Position
	end
	return nil
end

-- ============================================================================
-- IMPACT EFFECTS
-- ============================================================================

--[[
	Plays a squash animation on the storage part.
	Scales up briefly then returns to normal.
	Uses cached original size to prevent compounding growth.
	
	@param storage BasePart - The storage part to animate
]]
local function playSquashAnimation(storage: BasePart)
	-- Cache the true original size on first impact (prevents size drift)
	if not storageOriginalSizes[storage] then
		storageOriginalSizes[storage] = storage.Size
	end
	
	local originalSize = storageOriginalSizes[storage]
	local squashedSize = originalSize * PROJECTILE_CONFIG.SQUASH_SCALE
	
	-- Scale up
	local squashTween = TweenService:Create(
		storage,
		TweenInfo.new(PROJECTILE_CONFIG.SQUASH_DURATION, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{Size = squashedSize}
	)
	
	-- Scale back down to the CACHED original size (not current size)
	local returnTween = TweenService:Create(
		storage,
		TweenInfo.new(PROJECTILE_CONFIG.SQUASH_DURATION, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
		{Size = originalSize}
	)
	
	squashTween:Play()
	squashTween.Completed:Wait()
	returnTween:Play()
end

--[[
	Spawns impact particles at the collision point.
	
	@param position Vector3 - Where to spawn particles
	@param color Color3 - Color of the particles
]]
local function spawnImpactParticles(position: Vector3, color: Color3)
	-- Create a temporary part for the particle emitter
	local particlePart = Instance.new("Part")
	particlePart.Size = Vector3.new(0.1, 0.1, 0.1)
	particlePart.Position = position
	particlePart.Anchored = true
	particlePart.CanCollide = false
	particlePart.Transparency = 1
	particlePart.Parent = workspace
	
	-- Create particle emitter
	local emitter = Instance.new("ParticleEmitter")
	emitter.Color = ColorSequence.new(color)
	emitter.Size = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.5),
		NumberSequenceKeypoint.new(1, 0)
	})
	emitter.Lifetime = NumberRange.new(PROJECTILE_CONFIG.PARTICLE_LIFETIME * 0.5, PROJECTILE_CONFIG.PARTICLE_LIFETIME)
	emitter.Speed = NumberRange.new(PROJECTILE_CONFIG.PARTICLE_SPEED * 0.5, PROJECTILE_CONFIG.PARTICLE_SPEED)
	emitter.SpreadAngle = Vector2.new(360, 360)
	emitter.Acceleration = Vector3.new(0, -30, 0) -- Gravity
	emitter.Rate = 0 -- We'll use Emit() instead
	emitter.Parent = particlePart
	
	-- Burst particles
	emitter:Emit(PROJECTILE_CONFIG.PARTICLE_COUNT)
	
	-- Clean up after particles fade
	task.delay(PROJECTILE_CONFIG.PARTICLE_LIFETIME + 0.1, function()
		particlePart:Destroy()
	end)
end

-- ============================================================================
-- PROJECTILE CREATION AND ANIMATION
-- ============================================================================

--[[
	Creates and animates a projectile from a unit to its storage.
	
	@param startPos Vector3 - Starting position (unit)
	@param endPos Vector3 - Ending position (storage)
	@param color Color3 - Projectile color
	@param storage BasePart - The storage part (for impact effects)
]]
local function fireProjectile(startPos: Vector3, endPos: Vector3, color: Color3, storage: BasePart)
	-- Performance check
	if activeProjectileCount >= PROJECTILE_CONFIG.MAX_PROJECTILES then
		return
	end
	
	-- Calculate dynamic arc height based on distance and elevation
	local arcHeight = calculateDynamicArcHeight(startPos, endPos)
	
	activeProjectileCount = activeProjectileCount + 1
	
	-- Create the projectile part
	local projectile = Instance.new("Part")
	projectile.Name = "IncomeProjectile"
	projectile.Size = PROJECTILE_CONFIG.SIZE
	projectile.Shape = PROJECTILE_CONFIG.SHAPE
	projectile.Material = PROJECTILE_CONFIG.MATERIAL
	projectile.Color = color
	projectile.Transparency = PROJECTILE_CONFIG.TRANSPARENCY
	projectile.Anchored = true
	projectile.CanCollide = false
	projectile.CastShadow = false
	projectile.Position = startPos
	projectile.Parent = workspace
	
	-- Add a subtle glow effect
	local pointLight = Instance.new("PointLight")
	pointLight.Color = color
	pointLight.Range = 3
	pointLight.Brightness = 0.5
	pointLight.Parent = projectile
	
	-- Animate along bezier curve
	local stepTime = PROJECTILE_CONFIG.FLIGHT_TIME / PROJECTILE_CONFIG.STEPS
	
	task.spawn(function()
		for i = 1, PROJECTILE_CONFIG.STEPS do
			local t = i / PROJECTILE_CONFIG.STEPS
			local newPos = sampleBezier(startPos, endPos, arcHeight, t)
			
			-- Use TweenService for smooth interpolation between steps
			local tween = TweenService:Create(
				projectile,
				TweenInfo.new(stepTime, Enum.EasingStyle.Linear),
				{Position = newPos}
			)
			tween:Play()
			tween.Completed:Wait()
		end
		
		-- Projectile reached storage - play impact effects
		task.spawn(function()
			playSquashAnimation(storage)
		end)
		spawnImpactParticles(endPos, color)
		
		-- Cleanup
		projectile:Destroy()
		activeProjectileCount = activeProjectileCount - 1
	end)
end

-- ============================================================================
-- UNIT LOOP MANAGEMENT
-- ============================================================================

--[[
	Gets the unit type name from a brainrot instance.
	The unit type is stored in the UnitType attribute or derived from name.
	
	@param brainrot Instance - The brainrot unit
	@return string - The unit type name
]]
local function getUnitTypeName(brainrot: Instance): string
	-- Check for UnitType attribute first
	local unitType = brainrot:GetAttribute("UnitType")
	if unitType then
		return unitType
	end
	
	-- Parse from name (format: "UnitName_UserId_Timestamp")
	local name = brainrot.Name
	local underscorePos = name:find("_[%d]+_[%d]+$")
	if underscorePos then
		return name:sub(1, underscorePos - 1)
	end
	
	return name
end

--[[
	Starts the projectile loop for a brainrot unit.
	Fires projectiles at the unit's CycleTime interval.
	
	@param brainrot Instance - The brainrot unit
]]
local function startUnitLoop(brainrot: Instance)
	-- Only process units owned by local player
	local ownerId = brainrot:GetAttribute("OwnerId")
	if not ownerId or ownerId ~= LocalPlayer.UserId then
		return
	end
	
	-- Don't start if already running
	if unitLoops[brainrot] then
		return
	end
	
	-- Get unit configuration
	local unitTypeName = getUnitTypeName(brainrot)
	local unitConfig = ShopConfig.Units[unitTypeName]
	
	-- Default values if config not found
	local cycleTime = brainrot:GetAttribute("IncomeInterval") or (unitConfig and unitConfig.CycleTime) or 3
	local projectileColor = (unitConfig and unitConfig.ProjectileColor) or PROJECTILE_CONFIG.DEFAULT_COLOR
	
	-- Start the loop
	local loopThread = task.spawn(function()
		-- Small initial delay to stagger projectiles from units spawned together
		task.wait(math.random() * 0.5)
		
		while brainrot and brainrot.Parent do
			-- Wait for cycle time
			task.wait(cycleTime)
			
			-- Get current positions
			local startPos = getUnitPosition(brainrot)
			local storage = findStorageForUnit(brainrot)
			
			if startPos and storage then
				local endPos = storage.Position
				fireProjectile(startPos, endPos, projectileColor, storage)
			end
		end
	end)
	
	unitLoops[brainrot] = loopThread
end

--[[
	Stops the projectile loop for a brainrot unit.
	
	@param brainrot Instance - The brainrot unit
]]
local function stopUnitLoop(brainrot: Instance)
	local loopThread = unitLoops[brainrot]
	if loopThread then
		task.cancel(loopThread)
		unitLoops[brainrot] = nil
	end
end

-- ============================================================================
-- INITIALIZATION
-- ============================================================================

local function initialize()
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	print("   ProjectileVisuals - Initializing")
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	
	-- Handle existing brainrots
	for _, brainrot in CollectionService:GetTagged(BRAINROT_TAG) do
		task.spawn(startUnitLoop, brainrot)
	end
	
	-- Handle new brainrots added
	CollectionService:GetInstanceAddedSignal(BRAINROT_TAG):Connect(function(brainrot)
		task.spawn(startUnitLoop, brainrot)
	end)
	
	-- Handle brainrots removed
	CollectionService:GetInstanceRemovedSignal(BRAINROT_TAG):Connect(function(brainrot)
		stopUnitLoop(brainrot)
	end)
	
	print("âœ“ ProjectileVisuals initialized")
	print(string.format("  - Flight Time: %.2fs (change FLIGHT_TIME to adjust speed)", PROJECTILE_CONFIG.FLIGHT_TIME))
	print(string.format("  - Arc Height: %d studs", PROJECTILE_CONFIG.ARC_HEIGHT))
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
end

-- Start the system
initialize()


================================================================================
FILE: src\client\ShopUI.client.luau
================================================================================

--[[
	ShopUI LocalScript
	
	Creates a Cookie Clicker style shop interface on the right side of the screen.
	Features progressive unlocking system.
	
	Features:
	- Scrolling shop panel
	- Live price updates
	- Ownership count display
	- Locked unit preview (blacked out)
	- Purchase sound effects
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local SoundService = game:GetService("SoundService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

-- Player reference
local Player = Players.LocalPlayer
local PlayerGui = Player:WaitForChild("PlayerGui")

-- Wait for shared modules and remotes
local ShopConfig = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("ShopConfig"))
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local BuyUnitRemote = RemoteEvents:WaitForChild("BuyUnit")
local GetOwnershipRemote = RemoteEvents:WaitForChild("GetOwnership")
local OwnershipChangedEvent = RemoteEvents:WaitForChild("OwnershipChanged")
local UnlockProgressChangedEvent = RemoteEvents:WaitForChild("UnlockProgressChanged")

--------------------------------------------------------------------------------
-- UI CONFIGURATION
--------------------------------------------------------------------------------

local UI_CONFIG = {
	-- Shop Panel
	SHOP_WIDTH = 280,
	SHOP_PADDING = 10,
	
	-- Button styling
	BUTTON_HEIGHT = 130, -- Increased to fit milestone + item cost
	BUTTON_SPACING = 8,
	CORNER_RADIUS = 12,
	
	-- Colors
	BACKGROUND_COLOR = Color3.fromRGB(25, 25, 35),
	PANEL_COLOR = Color3.fromRGB(35, 35, 50),
	BUTTON_COLOR = Color3.fromRGB(50, 50, 70),
	BUTTON_HOVER_COLOR = Color3.fromRGB(65, 65, 90),
	BUTTON_DISABLED_COLOR = Color3.fromRGB(40, 40, 50),
	LOCKED_COLOR = Color3.fromRGB(20, 20, 25),
	LOCKED_OVERLAY_COLOR = Color3.fromRGB(0, 0, 0),
	ACCENT_COLOR = Color3.fromRGB(100, 220, 100),
	TEXT_COLOR = Color3.fromRGB(255, 255, 255),
	SECONDARY_TEXT_COLOR = Color3.fromRGB(180, 180, 180),
	LOCKED_TEXT_COLOR = Color3.fromRGB(100, 100, 100),
	PRICE_COLOR = Color3.fromRGB(255, 215, 0),
	ITEM_COST_COLOR = Color3.fromRGB(255, 170, 60), -- Orange for item requirements
	
	-- Animation
	TWEEN_TIME = 0.15,
}

--------------------------------------------------------------------------------
-- SOUNDS
--------------------------------------------------------------------------------

-- Create sounds
local function createSound(id: string, volume: number): Sound
	local sound = Instance.new("Sound")
	sound.SoundId = id
	sound.Volume = volume
	sound.Parent = SoundService
	return sound
end

local ChachingSound = createSound("rbxassetid://138081500", 0.5) -- Cash register sound
local ErrorSound = createSound("rbxassetid://138090596", 0.3) -- Error/deny sound

--------------------------------------------------------------------------------
-- LOCAL STATE
--------------------------------------------------------------------------------

-- Track ownership locally for UI updates
local OwnedCounts: {[string]: number} = {}
local ShopButtons: {[string]: Frame} = {}
local UnlockProgress: number = ShopConfig.INITIAL_UNLOCKED
local ShopGui: ScreenGui? = nil
local ScrollFrame: ScrollingFrame? = nil
local IsOnMainIsland: boolean = false

--------------------------------------------------------------------------------
-- UI CREATION HELPERS
--------------------------------------------------------------------------------

local function addCorner(parent: GuiObject, radius: number)
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, radius)
	corner.Parent = parent
	return corner
end

local function addStroke(parent: GuiObject, color: Color3, thickness: number)
	local stroke = Instance.new("UIStroke")
	stroke.Color = color
	stroke.Thickness = thickness
	stroke.Parent = parent
	return stroke
end

local function formatMoney(amount: number): string
	local suffixes = {"K", "M", "B", "T", "Qa", "Qi", "Sx", "Sp", "Oc", "No", "Dc"}
	
	if amount < 1000 then
		return "$" .. tostring(math.floor(amount))
	end
	
	-- Calculate the magnitude (power of 1000)
	local magnitude = math.floor(math.log(amount, 1000))
	
	-- Cap at the largest suffix
	if magnitude > #suffixes then
		magnitude = #suffixes
	end
	
	local value = amount / (1000 ^ magnitude)
	
	-- Format with 1 decimal place if < 100, otherwise no decimals
	if value < 100 and value % 1 ~= 0 then
		return string.format("$%.1f%s", value, suffixes[magnitude])
	else
		return string.format("$%.0f%s", value, suffixes[magnitude])
	end
end

--------------------------------------------------------------------------------
-- SHOP UI CREATION
--------------------------------------------------------------------------------

local function createShopGui(): ScreenGui
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "ShopUI"
	screenGui.ResetOnSpawn = false
	screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	
	-- Main shop panel (right side) - starts HIDDEN (off-screen)
	local shopPanel = Instance.new("Frame")
	shopPanel.Name = "ShopPanel"
	shopPanel.Size = UDim2.new(0, UI_CONFIG.SHOP_WIDTH, 1, -20)
	shopPanel.Position = UDim2.new(1, 10, 0, 10) -- Start off-screen
	shopPanel.BackgroundColor3 = UI_CONFIG.PANEL_COLOR
	shopPanel.BorderSizePixel = 0
	shopPanel.Parent = screenGui
	addCorner(shopPanel, UI_CONFIG.CORNER_RADIUS)
	addStroke(shopPanel, Color3.fromRGB(60, 60, 80), 2)
	
	-- Shop title
	local titleBar = Instance.new("Frame")
	titleBar.Name = "TitleBar"
	titleBar.Size = UDim2.new(1, 0, 0, 50)
	titleBar.BackgroundColor3 = UI_CONFIG.BACKGROUND_COLOR
	titleBar.BorderSizePixel = 0
	titleBar.Parent = shopPanel
	
	local titleCorner = Instance.new("UICorner")
	titleCorner.CornerRadius = UDim.new(0, UI_CONFIG.CORNER_RADIUS)
	titleCorner.Parent = titleBar
	
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "Title"
	titleLabel.Size = UDim2.new(1, -40, 1, 0)
	titleLabel.Position = UDim2.new(0, 0, 0, 0)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Text = "ðŸ§  BRAINROT SHOP"
	titleLabel.TextColor3 = UI_CONFIG.TEXT_COLOR
	titleLabel.TextSize = 20
	titleLabel.Font = Enum.Font.GothamBold
	titleLabel.Parent = titleBar
	
	-- Close button (X)
	local closeButton = Instance.new("TextButton")
	closeButton.Name = "CloseButton"
	closeButton.Size = UDim2.new(0, 36, 0, 36)
	closeButton.Position = UDim2.new(1, -42, 0.5, -18)
	closeButton.BackgroundColor3 = Color3.fromRGB(200, 60, 60)
	closeButton.Text = "âœ•"
	closeButton.TextColor3 = UI_CONFIG.TEXT_COLOR
	closeButton.TextSize = 18
	closeButton.Font = Enum.Font.GothamBold
	closeButton.Parent = titleBar
	addCorner(closeButton, 8)
	
	-- Warning banner for off-island (initially hidden)
	local warningBanner = Instance.new("Frame")
	warningBanner.Name = "WarningBanner"
	warningBanner.Size = UDim2.new(1, 0, 0, 24)
	warningBanner.Position = UDim2.new(0, 0, 0, 50)
	warningBanner.BackgroundColor3 = Color3.fromRGB(180, 80, 30)
	warningBanner.BorderSizePixel = 0
	warningBanner.Visible = false
	warningBanner.Parent = shopPanel
	
	local warningLabel = Instance.new("TextLabel")
	warningLabel.Name = "WarningText"
	warningLabel.Size = UDim2.new(1, 0, 1, 0)
	warningLabel.BackgroundTransparency = 1
	warningLabel.Text = "âš ï¸ Visit Main Island to purchase"
	warningLabel.TextColor3 = Color3.fromRGB(255, 255, 200)
	warningLabel.TextSize = 12
	warningLabel.Font = Enum.Font.GothamBold
	warningLabel.Parent = warningBanner
	
	-- Scrolling frame for items
	local scrollFrame = Instance.new("ScrollingFrame")
	scrollFrame.Name = "ItemList"
	scrollFrame.Size = UDim2.new(1, -UI_CONFIG.SHOP_PADDING * 2, 1, -60)
	scrollFrame.Position = UDim2.new(0, UI_CONFIG.SHOP_PADDING, 0, 55)
	scrollFrame.BackgroundTransparency = 1
	scrollFrame.BorderSizePixel = 0
	scrollFrame.ScrollBarThickness = 6
	scrollFrame.ScrollBarImageColor3 = UI_CONFIG.ACCENT_COLOR
	scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0) -- Will be set dynamically
	scrollFrame.Parent = shopPanel
	
	-- Layout for items
	local listLayout = Instance.new("UIListLayout")
	listLayout.Name = "Layout"
	listLayout.SortOrder = Enum.SortOrder.LayoutOrder
	listLayout.Padding = UDim.new(0, UI_CONFIG.BUTTON_SPACING)
	listLayout.Parent = scrollFrame
	
	-- Auto-resize canvas
	listLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
		scrollFrame.CanvasSize = UDim2.new(0, 0, 0, listLayout.AbsoluteContentSize.Y + 10)
	end)
	
	return screenGui
end

local function createShopButton(unitName: string, config: any, layoutOrder: number, isLocked: boolean): Frame
	local button = Instance.new("Frame")
	button.Name = unitName
	button.Size = UDim2.new(1, 0, 0, UI_CONFIG.BUTTON_HEIGHT)
	button.BackgroundColor3 = isLocked and UI_CONFIG.LOCKED_COLOR or UI_CONFIG.BUTTON_COLOR
	button.BorderSizePixel = 0
	button.LayoutOrder = layoutOrder
	addCorner(button, 8)
	
	-- Clickable button overlay (only if not locked)
	local clickButton = Instance.new("TextButton")
	clickButton.Name = "ClickArea"
	clickButton.Size = UDim2.new(1, 0, 1, 0)
	clickButton.BackgroundTransparency = 1
	clickButton.Text = ""
	clickButton.Active = not isLocked
	clickButton.Parent = button
	
	-- Left side: Icon/emoji placeholder
	local iconLabel = Instance.new("TextLabel")
	iconLabel.Name = "Icon"
	iconLabel.Size = UDim2.new(0, 50, 0, 50)
	iconLabel.Position = UDim2.new(0, 10, 0.5, -25)
	iconLabel.BackgroundColor3 = isLocked and UI_CONFIG.LOCKED_COLOR or UI_CONFIG.BACKGROUND_COLOR
	iconLabel.Text = isLocked and "ðŸ”’" or "ðŸ§ "
	iconLabel.TextSize = 28
	iconLabel.Font = Enum.Font.GothamBold
	iconLabel.Parent = button
	
	-- Unit name
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Name = "UnitName"
	nameLabel.Size = UDim2.new(1, -130, 0, 24)
	nameLabel.Position = UDim2.new(0, 70, 0, 8)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = isLocked and "???" or unitName
	nameLabel.TextColor3 = isLocked and UI_CONFIG.LOCKED_TEXT_COLOR or UI_CONFIG.TEXT_COLOR
	nameLabel.TextSize = 16
	nameLabel.Font = Enum.Font.GothamBold
	nameLabel.TextXAlignment = Enum.TextXAlignment.Left
	nameLabel.TextTruncate = Enum.TextTruncate.AtEnd
	nameLabel.Parent = button
	
	-- Owned count badge (only for unlocked)
	local ownedBadge = Instance.new("TextLabel")
	ownedBadge.Name = "OwnedBadge"
	ownedBadge.Size = UDim2.new(0, 40, 0, 22)
	ownedBadge.Position = UDim2.new(1, -50, 0, 8)
	ownedBadge.BackgroundColor3 = isLocked and UI_CONFIG.LOCKED_COLOR or UI_CONFIG.ACCENT_COLOR
	ownedBadge.Text = isLocked and "ðŸ”’" or "0"
	ownedBadge.TextColor3 = isLocked and UI_CONFIG.LOCKED_TEXT_COLOR or Color3.fromRGB(0, 0, 0)
	ownedBadge.TextSize = 14
	ownedBadge.Font = Enum.Font.GothamBold
	ownedBadge.Parent = button
	addCorner(ownedBadge, 6)
	
	-- Income info or locked message
	local incomeLabel = Instance.new("TextLabel")
	incomeLabel.Name = "Income"
	incomeLabel.Size = UDim2.new(1, -80, 0, 18)
	incomeLabel.Position = UDim2.new(0, 70, 0, 32)
	incomeLabel.BackgroundTransparency = 1
	incomeLabel.Text = isLocked and "Purchase units to unlock!" or string.format("+$%d every %ds", config.BaseIncome, config.CycleTime)
	incomeLabel.TextColor3 = isLocked and UI_CONFIG.LOCKED_TEXT_COLOR or UI_CONFIG.SECONDARY_TEXT_COLOR
	incomeLabel.TextSize = 12
	incomeLabel.Font = Enum.Font.Gotham
	incomeLabel.TextXAlignment = Enum.TextXAlignment.Left
	incomeLabel.Parent = button
	
	-- Milestone progress label (only for unlocked)
	local milestoneLabel = Instance.new("TextLabel")
	milestoneLabel.Name = "MilestoneProgress"
	milestoneLabel.Size = UDim2.new(1, -80, 0, 16)
	milestoneLabel.Position = UDim2.new(0, 70, 0, 50)
	milestoneLabel.BackgroundTransparency = 1
	milestoneLabel.Text = isLocked and "" or "0/10 to x2 Speed"
	milestoneLabel.TextColor3 = isLocked and UI_CONFIG.LOCKED_TEXT_COLOR or Color3.fromRGB(150, 200, 255)
	milestoneLabel.TextSize = 11
	milestoneLabel.Font = Enum.Font.GothamBold
	milestoneLabel.TextXAlignment = Enum.TextXAlignment.Left
	milestoneLabel.Parent = button
	
	-- Price display
	local priceLabel = Instance.new("TextLabel")
	priceLabel.Name = "Price"
	priceLabel.Size = UDim2.new(1, -80, 0, 24)
	priceLabel.Position = UDim2.new(0, 70, 1, -48)
	priceLabel.BackgroundTransparency = 1
	priceLabel.Text = isLocked and "LOCKED" or formatMoney(config.BasePrice)
	priceLabel.TextColor3 = isLocked and UI_CONFIG.LOCKED_TEXT_COLOR or UI_CONFIG.PRICE_COLOR
	priceLabel.TextSize = 18
	priceLabel.Font = Enum.Font.GothamBold
	priceLabel.TextXAlignment = Enum.TextXAlignment.Left
	priceLabel.Parent = button
	
	-- Item cost display (shows required items for high-tier units)
	local itemCostLabel = Instance.new("TextLabel")
	itemCostLabel.Name = "ItemCost"
	itemCostLabel.Size = UDim2.new(1, -80, 0, 16)
	itemCostLabel.Position = UDim2.new(0, 70, 1, -22)
	itemCostLabel.BackgroundTransparency = 1
	itemCostLabel.Text = ""
	itemCostLabel.TextColor3 = UI_CONFIG.ITEM_COST_COLOR
	itemCostLabel.TextSize = 11
	itemCostLabel.Font = Enum.Font.Gotham
	itemCostLabel.TextXAlignment = Enum.TextXAlignment.Left
	itemCostLabel.TextTruncate = Enum.TextTruncate.AtEnd
	itemCostLabel.Visible = false
	itemCostLabel.Parent = button
	
	-- Populate item cost text if unit has item requirements
	if not isLocked then
		local itemCost = ShopConfig.GetItemCost(unitName)
		if itemCost then
			local parts = {}
			for itemId, qty in pairs(itemCost) do
				table.insert(parts, qty .. "x " .. itemId)
			end
			itemCostLabel.Text = "ðŸ“¦ " .. table.concat(parts, " + ")
			itemCostLabel.Visible = true
		end
	end
	
	-- Buy indicator (only for unlocked)
	local buyIndicator = Instance.new("TextLabel")
	buyIndicator.Name = "BuyIndicator"
	buyIndicator.Size = UDim2.new(0, 80, 0, 30) -- Wider for text
	buyIndicator.Position = UDim2.new(1, -90, 1, -38)
	buyIndicator.BackgroundTransparency = 1
	local ownedCount = config.count or 0
	local buttonText = "BUY"
	if ownedCount > 0 then
		buttonText = "UPGRADE"
	end
	
	buyIndicator.Text = isLocked and "" or buttonText
	buyIndicator.TextColor3 = UI_CONFIG.ACCENT_COLOR
	buyIndicator.TextSize = 14
	buyIndicator.Font = Enum.Font.GothamBold
	buyIndicator.Parent = button
	
	-- Locked overlay effect
	if isLocked then
		local overlay = Instance.new("Frame")
		overlay.Name = "LockedOverlay"
		overlay.Size = UDim2.new(1, 0, 1, 0)
		overlay.BackgroundColor3 = UI_CONFIG.LOCKED_OVERLAY_COLOR
		overlay.BackgroundTransparency = 0.5
		overlay.ZIndex = 2
		overlay.Parent = button
		addCorner(overlay, 8)
	end
	
	return button
end

--------------------------------------------------------------------------------
-- UI LOGIC
--------------------------------------------------------------------------------

local function updateButtonPrice(unitName: string, newCount: number)
	local button = ShopButtons[unitName]
	if not button then return end
	
	local config = ShopConfig.GetConfig(unitName)
	if not config then return end
	
	local newPrice = ShopConfig.CalculatePrice(unitName, newCount)
	
	-- Update price label
	local priceLabel = button:FindFirstChild("Price")
	if priceLabel then
		priceLabel.Text = formatMoney(newPrice)
	end
	
	-- Update owned badge
	local ownedBadge = button:FindFirstChild("OwnedBadge")
	if ownedBadge then
		ownedBadge.Text = tostring(newCount)
	end
	
	-- Update income display with milestone bonuses
	local incomeLabel = button:FindFirstChild("Income")
	if incomeLabel then
		local effectiveIncome = ShopConfig.CalculateEffectiveIncome(unitName, newCount)
		local effectiveCycleTime = ShopConfig.CalculateEffectiveCycleTime(unitName, newCount)
		incomeLabel.Text = string.format("+$%d every %.1fs", effectiveIncome, effectiveCycleTime)
	end
	
	-- Update milestone progress
	local milestoneLabel = button:FindFirstChild("MilestoneProgress")
	if milestoneLabel then
		local nextMilestone, currentProgress = ShopConfig.GetNextMilestone(newCount)
		if nextMilestone then
			local bonusType = nextMilestone.milestoneType == "speed" and "x2 Speed âš¡" or string.format("x%d Profit ðŸ’°", nextMilestone.multiplier)
			milestoneLabel.Text = string.format("%d/%d to %s", currentProgress, nextMilestone.quantity, bonusType)
			milestoneLabel.TextColor3 = Color3.fromRGB(150, 200, 255)
		else
			milestoneLabel.Text = "âœ… All milestones reached!"
			milestoneLabel.TextColor3 = Color3.fromRGB(100, 255, 150)
		end
	end
	
	-- Update item cost display
	local itemCostLabel = button:FindFirstChild("ItemCost")
	if itemCostLabel then
		local itemCost = ShopConfig.GetItemCost(unitName)
		if itemCost then
			local parts = {}
			for itemId, qty in pairs(itemCost) do
				table.insert(parts, qty .. "x " .. itemId)
			end
			itemCostLabel.Text = "ðŸ“¦ " .. table.concat(parts, " + ")
			itemCostLabel.Visible = true
		else
			itemCostLabel.Visible = false
		end
	end
	
	OwnedCounts[unitName] = newCount
end

local function canAfford(unitName: string): boolean
	local leaderstats = Player:FindFirstChild("leaderstats")
	if not leaderstats then return false end
	
	local money = leaderstats:FindFirstChild("Money")
	if not money then return false end
	
	local count = OwnedCounts[unitName] or 0
	local price = ShopConfig.CalculatePrice(unitName, count)
	
	return money.Value >= price
end

local function updateButtonAffordability()
	for unitName, button in ShopButtons do
		-- Skip locked buttons (they don't have proper styling)
		local overlay = button:FindFirstChild("LockedOverlay")
		if overlay then continue end
		
		local affordable = canAfford(unitName)
		button.BackgroundColor3 = affordable and UI_CONFIG.BUTTON_COLOR or UI_CONFIG.BUTTON_DISABLED_COLOR
		
		local buyIndicator = button:FindFirstChild("BuyIndicator")
		if buyIndicator then
			buyIndicator.TextTransparency = affordable and 0 or 0.7
		end
	end
end

local function animatePurchase(button: Frame, success: boolean)
	if success then
		-- Success animation - quick scale pop
		local originalSize = button.Size
		
		local popTween = TweenService:Create(button, TweenInfo.new(0.1), {
			Size = UDim2.new(originalSize.X.Scale, originalSize.X.Offset + 6, originalSize.Y.Scale, originalSize.Y.Offset + 4)
		})
		
		local returnTween = TweenService:Create(button, TweenInfo.new(0.15, Enum.EasingStyle.Elastic), {
			Size = originalSize
		})
		
		popTween:Play()
		popTween.Completed:Connect(function()
			returnTween:Play()
		end)
		
		-- Flash green
		local originalColor = button.BackgroundColor3
		button.BackgroundColor3 = UI_CONFIG.ACCENT_COLOR
		task.delay(0.1, function()
			TweenService:Create(button, TweenInfo.new(0.2), {BackgroundColor3 = originalColor}):Play()
		end)
		
		ChachingSound:Play()
	else
		-- Shake animation for failure
		local originalPos = button.Position
		
		for i = 1, 3 do
			local offset = i % 2 == 0 and 5 or -5
			TweenService:Create(button, TweenInfo.new(0.05), {
				Position = UDim2.new(originalPos.X.Scale, originalPos.X.Offset + offset, originalPos.Y.Scale, originalPos.Y.Offset)
			}):Play()
			task.wait(0.05)
		end
		
		button.Position = originalPos
		ErrorSound:Play()
	end
end

local function setupButtonClick(button: Frame, unitName: string)
	local clickArea = button:FindFirstChild("ClickArea")
	if not clickArea then return end
	
	local debounce = false
	
	-- Hover effects
	clickArea.MouseEnter:Connect(function()
		if canAfford(unitName) then
			TweenService:Create(button, TweenInfo.new(UI_CONFIG.TWEEN_TIME), {
				BackgroundColor3 = UI_CONFIG.BUTTON_HOVER_COLOR
			}):Play()
		end
	end)
	
	clickArea.MouseLeave:Connect(function()
		local targetColor = canAfford(unitName) and UI_CONFIG.BUTTON_COLOR or UI_CONFIG.BUTTON_DISABLED_COLOR
		TweenService:Create(button, TweenInfo.new(UI_CONFIG.TWEEN_TIME), {
			BackgroundColor3 = targetColor
		}):Play()
	end)
	
	-- Click to buy
	clickArea.MouseButton1Click:Connect(function()
		if debounce then return end
		
		-- REMOVED: Main island check - players can buy from anywhere
		-- Selling still requires visiting the Market on Main Island
		
		debounce = true
		
		local success, message = BuyUnitRemote:InvokeServer(unitName)
		animatePurchase(button, success)
		
		if not success then
			warn("Purchase failed: " .. tostring(message))
		end
		
		task.wait(0.3)
		debounce = false
	end)
end

--[[
	Refreshes the shop UI to show visible units based on unlock progress.
]]
local function refreshShopUI()
	if not ScrollFrame then return end
	
	-- Clear existing buttons
	for _, child in ScrollFrame:GetChildren() do
		if child:IsA("Frame") then
			child:Destroy()
		end
	end
	ShopButtons = {}
	
	-- Get visible units based on unlock progress
	local visibleUnits = ShopConfig.GetVisibleUnits(UnlockProgress)
	
	for i, unitData in visibleUnits do
		local unitName = unitData.name
		local config = unitData.config
		local isLocked = unitData.isLocked
		
		-- Create button
		local button = createShopButton(unitName, config, i, isLocked)
		button.Parent = ScrollFrame
		
		if not isLocked then
			ShopButtons[unitName] = button
			
			-- Update with actual owned count and price
			local count = OwnedCounts[unitName] or 0
			updateButtonPrice(unitName, count)
			
			-- Setup click handler
			setupButtonClick(button, unitName)
		end
	end
	
	-- Update affordability
	updateButtonAffordability()
end

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

local function initialize()
	print("ShopUI: Initializing...")
	
	-- Create the shop GUI
	ShopGui = createShopGui()
	if not ShopGui then return end
	local shopPanel = ShopGui:FindFirstChild("ShopPanel")
	ScrollFrame = shopPanel and shopPanel:FindFirstChild("ItemList")
	
	-- Get initial ownership data from server
	local ownershipData = GetOwnershipRemote:InvokeServer()
	
	-- Set unlock progress
	if ownershipData and ownershipData.unlockProgress then
		UnlockProgress = ownershipData.unlockProgress
	end
	
	-- Initialize owned counts
	if ownershipData and ownershipData.units then
		for unitName, data in ownershipData.units do
			OwnedCounts[unitName] = data.count
		end
	end
	
	-- Build initial shop UI
	refreshShopUI()
	
	-- Parent GUI
	ShopGui.Parent = PlayerGui
	
	-- Listen for ownership updates from server
	OwnershipChangedEvent.OnClientEvent:Connect(function(unitName: string, newCount: number, newPrice: number)
		OwnedCounts[unitName] = newCount
		updateButtonPrice(unitName, newCount)
		updateButtonAffordability()
	end)
	
	-- Listen for unlock progress updates
	UnlockProgressChangedEvent.OnClientEvent:Connect(function(newProgress: number)
		print(string.format("ShopUI: Unlock progress updated to %d", newProgress))
		UnlockProgress = newProgress
		refreshShopUI()
	end)
	
	-- Update affordability when money changes
	local leaderstats = Player:WaitForChild("leaderstats", 10)
	if leaderstats then
		local money = leaderstats:WaitForChild("Money", 5)
		if money then
			money:GetPropertyChangedSignal("Value"):Connect(updateButtonAffordability)
			updateButtonAffordability() -- Initial update
		end
	end
	
	print(string.format("ShopUI: Ready! (%d units unlocked, %d total)", UnlockProgress, ShopConfig.GetTotalUnits()))
end

-- Start
initialize()

--------------------------------------------------------------------------------
-- SHOP VISIBILITY (Controlled by B key, HUD button, or ProximityPrompt)
--------------------------------------------------------------------------------

local ShopVisible = false
local SHOP_OPEN_POSITION = UDim2.new(1, -UI_CONFIG.SHOP_WIDTH - 10, 0, 10)
local SHOP_CLOSED_POSITION = UDim2.new(1, 10, 0, 10)

--[[
	Updates the warning banner visibility based on main island status.
]]
local function updateWarningBanner()
	if not ShopGui then return end
	local shopPanel = ShopGui:FindFirstChild("ShopPanel")
	if not shopPanel then return end
	
	local warningBanner = shopPanel:FindFirstChild("WarningBanner")
	if warningBanner then
		warningBanner.Visible = not IsOnMainIsland
	end
end

local function openShop()
	if ShopVisible then return end
	if not ShopGui then return end
	local shopPanel = ShopGui:FindFirstChild("ShopPanel")
	if not shopPanel then return end
	
	ShopVisible = true
	updateWarningBanner()
	TweenService:Create(shopPanel, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Position = SHOP_OPEN_POSITION
	}):Play()
	print("ShopUI: Opened")
end

local function closeShop()
	if not ShopVisible then return end
	if not ShopGui then return end
	local shopPanel = ShopGui:FindFirstChild("ShopPanel")
	if not shopPanel then return end
	
	ShopVisible = false
	TweenService:Create(shopPanel, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Position = SHOP_CLOSED_POSITION
	}):Play()
	print("ShopUI: Closed")
end

local function toggleShop()
	if ShopVisible then
		closeShop()
	else
		openShop()
	end
end

-- Setup ProximityPrompt listener for ShopVendor on Main Island
local function setupShopVendorPrompt()
	local mainIsland = workspace:WaitForChild("MainIsland", 30)
	if not mainIsland then
		warn("ShopUI: MainIsland not found")
		return
	end
	
	-- Wait for or create ShopVendor
	local shopVendor = mainIsland:FindFirstChild("ShopVendor")
	if not shopVendor then
		-- Create ShopVendor part if it doesn't exist
		shopVendor = Instance.new("Part")
		shopVendor.Name = "ShopVendor"
		shopVendor.Size = Vector3.new(6, 8, 6)
		shopVendor.BrickColor = BrickColor.new("Bright violet")
		shopVendor.Material = Enum.Material.Neon
		shopVendor.Anchored = true
		shopVendor.CanCollide = true
		-- Position on main island (adjust as needed)
		local primaryPart = mainIsland.PrimaryPart or mainIsland:FindFirstChildWhichIsA("BasePart")
		if primaryPart then
			shopVendor.Position = primaryPart.Position + Vector3.new(20, 10, 0)
		else
			-- Fallback: main island is at height 30, so position at 40
			shopVendor.Position = Vector3.new(20, 40, 0)
		end
		shopVendor.Parent = mainIsland
		
		-- Add visual label
		local billboard = Instance.new("BillboardGui")
		billboard.Size = UDim2.new(4, 0, 2, 0)
		billboard.StudsOffset = Vector3.new(0, 6, 0)
		billboard.Parent = shopVendor
		
		local label = Instance.new("TextLabel")
		label.Size = UDim2.new(1, 0, 1, 0)
		label.BackgroundTransparency = 1
		label.Text = "ðŸ›’ SHOP"
		label.TextColor3 = Color3.fromRGB(255, 255, 255)
		label.TextScaled = true
		label.Font = Enum.Font.GothamBold
		label.Parent = billboard
	end
	
	-- Create or get ProximityPrompt
	local prompt = shopVendor:FindFirstChild("ShopPrompt")
	if not prompt then
		prompt = Instance.new("ProximityPrompt")
		prompt.Name = "ShopPrompt"
		prompt.ActionText = "Open Shop"
		prompt.ObjectText = "Shop"
		prompt.KeyboardKeyCode = Enum.KeyCode.E
		prompt.HoldDuration = 0
		prompt.MaxActivationDistance = 10
		prompt.RequiresLineOfSight = false
		prompt.Parent = shopVendor
	end
	
	-- Open shop when prompt triggered
	prompt.Triggered:Connect(function(playerWhoTriggered)
		if playerWhoTriggered == Player then
			openShop()
		end
	end)
	
	print("ShopUI: ShopVendor ProximityPrompt setup complete")
end

-- Track if player is on main island for purchase permissions
local function setupMainIslandCheck()
	local mainIsland = workspace:WaitForChild("MainIsland", 30)
	if not mainIsland then
		warn("ShopUI: MainIsland not found for proximity check")
		return
	end
	
	local primaryPart = mainIsland.PrimaryPart or mainIsland:FindFirstChildWhichIsA("BasePart")
	if not primaryPart then
		warn("ShopUI: MainIsland has no primary part")
		return
	end
	
	-- Get the island bounds (approximate based on size)
	local islandSize = primaryPart.Size
	local islandCenter = primaryPart.Position
	
	RunService.Heartbeat:Connect(function()
		local character = Player.Character
		local hrp = character and character:FindFirstChild("HumanoidRootPart")
		if not hrp then return end
		
		-- Check if player is within horizontal distance of main island
		local playerPos = hrp.Position
		local horizontalDist = math.sqrt(
			(playerPos.X - islandCenter.X)^2 + 
			(playerPos.Z - islandCenter.Z)^2
		)
		
		-- Consider player on main island if within reasonable radius (island half-size + margin)
		local islandRadius = math.max(islandSize.X, islandSize.Z) / 2 + 20
		local wasOnMainIsland = IsOnMainIsland
		IsOnMainIsland = horizontalDist <= islandRadius and playerPos.Y >= islandCenter.Y - 20
		
		-- Update warning banner if status changed while shop is open
		if wasOnMainIsland ~= IsOnMainIsland and ShopVisible then
			updateWarningBanner()
		end
	end)
end

-- Setup 'B' key to toggle shop
local function setupKeyboardToggle()
	UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed then return end
		
		if input.KeyCode == Enum.KeyCode.B then
			toggleShop()
		end
	end)
	print("ShopUI: B key toggle enabled")
end

-- Setup close button on shop panel
local function setupCloseButton()
	if not ShopGui then return end
	local shopPanel = ShopGui:FindFirstChild("ShopPanel")
	if not shopPanel then return end
	
	local titleBar = shopPanel:FindFirstChild("TitleBar")
	if not titleBar then return end
	
	local closeButton = titleBar:FindFirstChild("CloseButton")
	if closeButton then
		closeButton.MouseButton1Click:Connect(function()
			closeShop()
		end)
		
		-- Hover effects
		closeButton.MouseEnter:Connect(function()
			TweenService:Create(closeButton, TweenInfo.new(0.1), {
				BackgroundColor3 = Color3.fromRGB(255, 80, 80)
			}):Play()
		end)
		
		closeButton.MouseLeave:Connect(function()
			TweenService:Create(closeButton, TweenInfo.new(0.1), {
				BackgroundColor3 = Color3.fromRGB(200, 60, 60)
			}):Play()
		end)
	end
end

-- Setup BindableEvent listener for MoneyHUD shop button
local function setupBindableEventListener()
	-- Wait a bit for MoneyHUD to potentially create the event
	task.wait(0.5)
	
	local shopToggleEvent = ReplicatedStorage:FindFirstChild("ShopToggleEvent")
	if not shopToggleEvent then
		-- Create it ourselves if MoneyHUD hasn't yet
		shopToggleEvent = Instance.new("BindableEvent")
		shopToggleEvent.Name = "ShopToggleEvent"
		shopToggleEvent.Parent = ReplicatedStorage
	end
	
	shopToggleEvent.Event:Connect(function()
		toggleShop()
	end)
	
	print("ShopUI: BindableEvent listener setup complete")
end

-- Initialize shop vendor prompt
task.spawn(setupShopVendorPrompt)
task.spawn(setupMainIslandCheck)
task.spawn(setupCloseButton)
task.spawn(setupBindableEventListener)
setupKeyboardToggle()


================================================================================
FILE: src\client\StockMarketGraph.client.luau
================================================================================

--!strict
--[[
	StockMarketGraph Client Script
	
	Procedural Geometry Architecture using EditableImage with scanline-based rendering.
	Renders multiple category stock lines with unique colors.
	
	Classes:
	- DataBuffer: Circular buffer for rate history
	- GraphViewport: Coordinate transformation (rate/time to pixels)
	- MeshRenderer: Scanline-based rendering for filled quads and thick lines
	
	Uses modern EditableImage API:
	- AssetService:CreateEditableImage()
	- Content.fromObject() for ImageLabel binding
	- DrawLine() and DrawCircle() for geometry
]]

-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local AssetService = game:GetService("AssetService")
local HttpService = game:GetService("HttpService")

-- Configuration
local CONFIG = {
	-- Canvas size (EditableImage max is 1024x1024, using 1024x512 for 2:1 aspect)
	CANVAS_WIDTH = 1024,
	CANVAS_HEIGHT = 512,
	PADDING = 28,
	
	-- Graph appearance
	LINE_THICKNESS = 4,   -- Thinner for multiple lines
	GLOW_THICKNESS = 10,
	GLOW_OPACITY = 0.5,
	
	-- Colors per sector (from server config)
	SECTOR_COLORS = {
		Food = Color3.fromRGB(227, 119, 194),          -- Pink
		Animals = Color3.fromRGB(44, 160, 44),       -- Green
		Entertainment = Color3.fromRGB(255, 127, 14), -- Orange
		Mystic = Color3.fromRGB(148, 103, 189),      -- Purple
		Tech = Color3.fromRGB(31, 119, 180),        -- Blue
		Action = Color3.fromRGB(214, 39, 40),        -- Red
	},
	
	FILL_OPACITY = 0.15,  -- Much lower for multiple overlapping fills
	
	-- Buffer
	MAX_HISTORY = 60,
}

-- Sector order for consistent rendering
local SECTOR_ORDER = {"Food", "Animals", "Entertainment", "Mystic", "Tech", "Action"}

--------------------------------------------------------------------------------
-- DataBuffer Class: Circular buffer for rate history
--------------------------------------------------------------------------------

export type DataBufferImpl = {
	buffer: {number},
	capacity: number,
	count: number,
}

local DataBuffer = {}
DataBuffer.__index = DataBuffer

function DataBuffer.new(capacity: number): DataBufferImpl
	local self = setmetatable({}, DataBuffer) :: any
	self.buffer = table.create(capacity, 1.0)
	self.capacity = capacity
	self.count = 0
	return self :: DataBufferImpl
end

function DataBuffer.ParseAndUpdate(self: DataBufferImpl, historyStr: string)
	if not historyStr or historyStr == "" then
		return
	end
	
	local index = 0
	for value in string.gmatch(historyStr, "[^,]+") do
		index += 1
		local num = tonumber(value)
		if num and index <= self.capacity then
			self.buffer[index] = num
		end
	end
	self.count = index
end

function DataBuffer.GetPoints(self: DataBufferImpl): {number}
	local result = {}
	for i = 1, self.count do
		result[i] = self.buffer[i]
	end
	return result
end

function DataBuffer.GetCount(self: DataBufferImpl): number
	return self.count
end

--------------------------------------------------------------------------------
-- GraphViewport Class: Coordinate transformation
--------------------------------------------------------------------------------

export type ViewportImpl = {
	width: number,
	height: number,
	paddingX: number,
	paddingY: number,
	minRate: number,
	maxRate: number,
	pointCount: number,
}

local GraphViewport = {}
GraphViewport.__index = GraphViewport

function GraphViewport.new(width: number, height: number, paddingX: number, paddingY: number): ViewportImpl
	local self = setmetatable({}, GraphViewport) :: any
	self.width = width
	self.height = height
	self.paddingX = paddingX
	self.paddingY = paddingY
	self.minRate = 0.5
	self.maxRate = 3.0
	self.pointCount = 60
	return self :: ViewportImpl
end

function GraphViewport.SetBounds(self: ViewportImpl, minRate: number, maxRate: number, pointCount: number)
	self.minRate = minRate
	self.maxRate = maxRate
	self.pointCount = math.max(2, pointCount)
end

function GraphViewport.GetUsableWidth(self: ViewportImpl): number
	return self.width - self.paddingX * 2
end

function GraphViewport.GetUsableHeight(self: ViewportImpl): number
	return self.height - self.paddingY * 2
end

function GraphViewport.GetBottomY(self: ViewportImpl): number
	return self.height - self.paddingY
end

function GraphViewport.RateToY(self: ViewportImpl, rate: number): number
	local usableHeight = GraphViewport.GetUsableHeight(self)
	local normalized = (rate - self.minRate) / (self.maxRate - self.minRate)
	return self.paddingY + (1 - normalized) * usableHeight
end

function GraphViewport.IndexToX(self: ViewportImpl, index: number): number
	local usableWidth = GraphViewport.GetUsableWidth(self)
	local spacing = usableWidth / math.max(1, self.pointCount - 1)
	return self.paddingX + (index - 1) * spacing
end

function GraphViewport.ToPixelCoords(self: ViewportImpl, index: number, rate: number): Vector2
	return Vector2.new(
		GraphViewport.IndexToX(self, index),
		GraphViewport.RateToY(self, rate)
	)
end

--------------------------------------------------------------------------------
-- MeshRenderer Class: Scanline-based EditableImage rendering
--------------------------------------------------------------------------------

export type RendererImpl = {
	image: EditableImage?,
	viewport: ViewportImpl,
	width: number,
	height: number,
}

local MeshRenderer = {}
MeshRenderer.__index = MeshRenderer

function MeshRenderer.new(viewport: ViewportImpl, width: number, height: number): RendererImpl
	local self = setmetatable({}, MeshRenderer) :: any
	self.viewport = viewport
	self.width = width
	self.height = height
	self.image = nil
	return self :: RendererImpl
end

function MeshRenderer.Initialize(self: RendererImpl): boolean
	local success, result = pcall(function()
		return AssetService:CreateEditableImage({
			Size = Vector2.new(self.width, self.height)
		})
	end)
	
	if not success then
		warn("MeshRenderer: Failed to create EditableImage:", result)
		return false
	end
	
	self.image = result :: EditableImage
	return true
end

function MeshRenderer.Clear(self: RendererImpl)
	if not self.image then return end
	
	-- Fill with transparent black
	self.image:DrawRectangle(
		Vector2.new(0, 0),
		Vector2.new(self.width, self.height),
		Color3.new(0, 0, 0),
		1, -- Fully transparent
		Enum.ImageCombineType.Overwrite
	)
end

--[[
	Calculates the perpendicular normal vector for a line segment.
]]
local function calculateNormal(p1: Vector2, p2: Vector2): Vector2
	local dx = p2.X - p1.X
	local dy = p2.Y - p1.Y
	local length = math.sqrt(dx * dx + dy * dy)
	
	if length < 0.001 then
		return Vector2.new(0, 1)
	end
	
	return Vector2.new(-dy / length, dx / length)
end

--[[
	Draws a filled quad using horizontal lines (scanline approach).
]]
function MeshRenderer.DrawQuad(
	self: RendererImpl,
	p1: Vector2,
	p2: Vector2,
	p3: Vector2,
	p4: Vector2,
	color: Color3,
	transparency: number
)
	if not self.image then return end
	
	local minY = math.floor(math.min(p1.Y, p2.Y, p3.Y, p4.Y))
	local maxY = math.ceil(math.max(p1.Y, p2.Y, p3.Y, p4.Y))
	
	minY = math.max(0, minY)
	maxY = math.min(self.height - 1, maxY)
	
	local edges = {
		{p1, p2},
		{p2, p3},
		{p3, p4},
		{p4, p1}
	}
	
	for y = minY, maxY do
		local intersections: {number} = {}
		
		for _, edge in edges do
			local a, b = edge[1], edge[2]
			if (a.Y <= y and b.Y > y) or (b.Y <= y and a.Y > y) then
				local t = (y - a.Y) / (b.Y - a.Y)
				local x = a.X + t * (b.X - a.X)
				table.insert(intersections, x)
			end
		end
		
		table.sort(intersections)
		
		for i = 1, #intersections - 1, 2 do
			local x1 = math.floor(intersections[i])
			local x2 = math.ceil(intersections[i + 1])
			
			x1 = math.max(0, x1)
			x2 = math.min(self.width - 1, x2)
			
			if x2 > x1 then
				self.image:DrawLine(
					Vector2.new(x1, y),
					Vector2.new(x2, y),
					color,
					transparency,
					Enum.ImageCombineType.AlphaBlend
				)
			end
		end
	end
end

--[[
	Draws a thick line segment as a quad.
]]
function MeshRenderer.DrawThickLine(
	self: RendererImpl,
	p1: Vector2,
	p2: Vector2,
	color: Color3,
	thickness: number,
	transparency: number
)
	if not self.image then return end
	
	local normal = calculateNormal(p1, p2)
	local halfThickness = thickness / 2
	local offset = normal * halfThickness
	
	local c1 = p1 + offset
	local c2 = p2 + offset
	local c3 = p2 - offset
	local c4 = p1 - offset
	
	MeshRenderer.DrawQuad(self, c1, c2, c3, c4, color, transparency)
end

--[[
	Draws a single sector's polyline with specified color.
]]
function MeshRenderer.DrawSectorLine(self: RendererImpl, points: {Vector2}, color: Color3, drawFill: boolean)
	if not self.image or #points < 2 then return end
	
	local bottomY = GraphViewport.GetBottomY(self.viewport)
	
	-- Layer 1: Optional gradient fill (bottom layer)
	if drawFill then
		for i = 1, #points - 1 do
			local p1 = points[i]
			local p2 = points[i + 1]
			local bottom1 = Vector2.new(p1.X, bottomY)
			local bottom2 = Vector2.new(p2.X, bottomY)
			MeshRenderer.DrawQuad(self, p1, p2, bottom2, bottom1, color, CONFIG.FILL_OPACITY)
		end
	end
	
	-- Layer 2: Glow
	for i = 1, #points - 1 do
		MeshRenderer.DrawThickLine(self, points[i], points[i + 1], color, CONFIG.GLOW_THICKNESS, CONFIG.GLOW_OPACITY)
	end
	
	-- Layer 3: Main stroke
	for i = 1, #points - 1 do
		MeshRenderer.DrawThickLine(self, points[i], points[i + 1], color, CONFIG.LINE_THICKNESS, 0)
	end
end

--[[
	Draws a highlighted dot at the current position.
]]
function MeshRenderer.DrawCurrentDot(self: RendererImpl, pos: Vector2, color: Color3)
	if not self.image then return end
	
	-- Draw glow circle
	self.image:DrawCircle(pos, 10, color, 0.5, Enum.ImageCombineType.AlphaBlend)
	-- Draw main circle
	self.image:DrawCircle(pos, 6, color, 0, Enum.ImageCombineType.AlphaBlend)
	-- Draw white center
	self.image:DrawCircle(pos, 3, Color3.new(1, 1, 1), 0, Enum.ImageCombineType.AlphaBlend)
end

function MeshRenderer.GetImage(self: RendererImpl): EditableImage?
	return self.image
end

--------------------------------------------------------------------------------
-- Billboard Display Management
--------------------------------------------------------------------------------

type BillboardDisplay = {
	container: Frame,
	graphImageLabel: ImageLabel?,
	rateDisplay: TextLabel?,
	rateName: TextLabel?,
	timerDisplay: TextLabel?,
	renderer: RendererImpl?,
}

local billboardDisplays: {BillboardDisplay} = {}
local sectorBuffers: {[string]: DataBufferImpl} = {}
local stockMarketFolder: Folder? = nil

-- Initialize buffers for each sector
for _, sector in SECTOR_ORDER do
	sectorBuffers[sector] = DataBuffer.new(CONFIG.MAX_HISTORY)
end

--[[
	Creates an ImageLabel for the EditableImage and attaches it.
]]
local function setupImageLabel(graphLines: Frame, renderer: RendererImpl): ImageLabel?
	local existing = graphLines:FindFirstChildOfClass("ImageLabel")
	if existing then
		existing:Destroy()
	end
	
	local imageLabel = Instance.new("ImageLabel")
	imageLabel.Name = "GraphImage"
	imageLabel.Size = UDim2.new(1, 0, 1, 0)
	imageLabel.BackgroundTransparency = 1
	imageLabel.ScaleType = Enum.ScaleType.Stretch
	imageLabel.Parent = graphLines
	
	local editableImage = renderer.image
	if editableImage then
		imageLabel.ImageContent = Content.fromObject(editableImage)
	end
	
	return imageLabel
end

--[[
	Finds all billboard displays and sets up EditableImage rendering.
]]
local function findBillboards()
	billboardDisplays = {}
	
	local billboardsFolder = Workspace:WaitForChild("StockMarketBillboards", 30)
	if not billboardsFolder then
		warn("StockMarketGraph: Billboards folder not found!")
		return
	end
	
	for _, billboard in billboardsFolder:GetChildren() do
		local screen = billboard:FindFirstChild("Screen")
		if not screen then continue end
		
		local surfaceGui = screen:FindFirstChild("StockMarketDisplay")
		if not surfaceGui then continue end
		
		local container = surfaceGui:FindFirstChild("Container")
		if not container then continue end
		
		local graphContainer = container:FindFirstChild("GraphContainer")
		if not graphContainer then continue end
		
		local graphLines = graphContainer:FindFirstChild("GraphLines") :: Frame?
		if not graphLines then continue end
		
		local viewport = GraphViewport.new(CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT, CONFIG.PADDING, CONFIG.PADDING)
		local renderer = MeshRenderer.new(viewport, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT)
		
		local graphImageLabel: ImageLabel? = nil
		
		if MeshRenderer.Initialize(renderer) then
			graphImageLabel = setupImageLabel(graphLines, renderer)
			print("StockMarketGraph: Initialized EditableImage for billboard")
		else
			warn("StockMarketGraph: Failed to initialize renderer for billboard")
		end
		
		local display: BillboardDisplay = {
			container = container :: Frame,
			graphImageLabel = graphImageLabel,
			rateDisplay = container:FindFirstChild("RateDisplay") :: TextLabel?,
			rateName = container:FindFirstChild("RateName") :: TextLabel?,
			timerDisplay = container:FindFirstChild("TimerDisplay") :: TextLabel?,
			renderer = renderer,
		}
		
		table.insert(billboardDisplays, display)
	end
	
	print(string.format("StockMarketGraph: Found %d billboard displays", #billboardDisplays))
end

--[[
	Gets rate color for text labels based on rate value.
]]
local function getRateColor(rate: number): Color3
	if rate >= 2.0 then
		return Color3.fromRGB(255, 215, 0)  -- Gold
	elseif rate >= 1.0 then
		return Color3.fromRGB(100, 255, 100)  -- Green
	else
		return Color3.fromRGB(255, 70, 70)  -- Red
	end
end

--[[
	Redraws the graph on a single billboard with all category lines.
]]
local function drawGraph(display: BillboardDisplay)
	local renderer = display.renderer
	if not renderer or not renderer.image then return end
	if not stockMarketFolder then return end
	
	local minRate = stockMarketFolder:GetAttribute("MinRate") :: number? or 0.5
	local maxRate = stockMarketFolder:GetAttribute("MaxRate") :: number? or 3.0
	
	-- Find point count (use first sector's count)
	local firstBuffer = sectorBuffers[SECTOR_ORDER[1]]
	local pointCount = DataBuffer.GetCount(firstBuffer)
	
	if pointCount < 2 then return end
	
	-- Update viewport bounds
	GraphViewport.SetBounds(renderer.viewport, minRate, maxRate, pointCount)
	
	-- Clear and start drawing
	MeshRenderer.Clear(renderer)
	
	-- Track best performing sector
	local bestSector = SECTOR_ORDER[1]
	local bestRate = 0
	
	-- Draw each sector line
	for i, sector in SECTOR_ORDER do
		local buffer = sectorBuffers[sector]
		local rates = DataBuffer.GetPoints(buffer)
		local count = DataBuffer.GetCount(buffer)
		
		if count >= 2 then
			-- Convert rates to pixel coordinates
			local points: {Vector2} = {}
			for j = 1, count do
				points[j] = GraphViewport.ToPixelCoords(renderer.viewport, j, rates[j])
			end
			
			-- Get color for this sector
			local color = CONFIG.SECTOR_COLORS[sector] or Color3.fromRGB(200, 200, 200)
			
			-- Draw the line (first sector gets fill, others don't)
			MeshRenderer.DrawSectorLine(renderer, points, color, i == 1)
			
			-- Draw current dot
			if #points > 0 then
				local lastPoint = points[#points]
				MeshRenderer.DrawCurrentDot(renderer, lastPoint, color)
			end
			
			-- Track best rate
			local currentRate = rates[count] or 1.0
			if currentRate > bestRate then
				bestRate = currentRate
				bestSector = sector
			end
		end
	end
	
	-- Update text labels
	if display.rateDisplay then
		display.rateDisplay.Text = string.format("BEST: %.2fx", bestRate)
		display.rateDisplay.TextColor3 = CONFIG.SECTOR_COLORS[bestSector] or getRateColor(bestRate)
	end
	
	if display.rateName then
		display.rateName.Text = bestSector:upper()
		display.rateName.TextColor3 = CONFIG.SECTOR_COLORS[bestSector] or getRateColor(bestRate)
	end
end

--[[
	Updates all billboard graphs.
]]
local function updateAllGraphs()
	for _, display in billboardDisplays do
		drawGraph(display)
	end
end

--[[
	Updates the timer display on all billboards.
]]
local function updateTimer()
	if not stockMarketFolder then return end
	
	local nextUpdate = stockMarketFolder:GetAttribute("NextUpdate") :: number? or 0
	local now = os.time()
	local remaining = math.max(0, nextUpdate - now)
	
	for _, display in billboardDisplays do
		if display.timerDisplay then
			display.timerDisplay.Text = string.format("Next update: %ds", remaining)
		end
	end
end

--[[
	Parses sector histories from JSON attribute.
]]
local function parseHistories()
	if not stockMarketFolder then return end
	
	local historiesJson = stockMarketFolder:GetAttribute("SectorHistories") :: string?
	if not historiesJson then return end
	
	local success, histories = pcall(function()
		return HttpService:JSONDecode(historiesJson)
	end)
	
	if not success or not histories then return end
	
	for sector, historyStr in pairs(histories) do
		local buffer = sectorBuffers[sector]
		if buffer then
			DataBuffer.ParseAndUpdate(buffer, historyStr)
		end
	end
end

--[[
	Handles rate history updates from the server.
]]
local function onHistoryChanged()
	parseHistories()
	updateAllGraphs()
end

--------------------------------------------------------------------------------
-- Initialization
--------------------------------------------------------------------------------

local function initialize()
	print("StockMarketGraph: Initializing multi-category stock display...")
	
	-- Wait for StockMarket folder
	stockMarketFolder = ReplicatedStorage:WaitForChild("StockMarket", 30) :: Folder?
	if not stockMarketFolder then
		warn("StockMarketGraph: StockMarket folder not found!")
		return
	end
	
	-- Wait for billboards to be created
	task.wait(4)
	
	-- Find and setup billboard displays
	findBillboards()
	
	if #billboardDisplays == 0 then
		warn("StockMarketGraph: No billboard displays found!")
		return
	end
	
	-- Initial parse and draw
	parseHistories()
	updateAllGraphs()
	
	-- Listen for sector history changes
	stockMarketFolder:GetAttributeChangedSignal("SectorHistories"):Connect(onHistoryChanged)
	
	-- Also listen to legacy attribute for backwards compatibility
	stockMarketFolder:GetAttributeChangedSignal("RateHistory"):Connect(onHistoryChanged)
	
	-- Timer update loop
	RunService.Heartbeat:Connect(updateTimer)
	
	print("âœ“ StockMarketGraph initialized with 6 sector lines")
end

-- Start
task.spawn(initialize)


================================================================================
FILE: src\client\StockMarketUI.client.luau
================================================================================

--[[
	StockMarketUI Client Script
	
	DISABLED: Stock market is now displayed on billboards instead of HUD.
	See: StockMarketGraph.client.luau and StockMarketBillboards.server.luau
	
	RE-ENABLED: Now togglable via HUD button.
]]

-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local SoundService = game:GetService("SoundService")

-- Player
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Configuration
local CONFIG = {
	COLORS = {
		CRASH = Color3.fromRGB(255, 80, 80),
		NORMAL = Color3.fromRGB(255, 255, 255),
		STONKS = Color3.fromRGB(80, 255, 80),
		["HYPER INFLATION"] = Color3.fromRGB(255, 215, 0),
	},
	SOUNDS = {
		CRASH = "rbxassetid://15656647153",
		HYPER = "rbxassetid://1837756993",
	},
	UPDATE_INTERVAL = 30,
}

-- Wait for StockMarket folder
local stockMarketFolder = ReplicatedStorage:WaitForChild("StockMarket", 30)
if not stockMarketFolder then
	warn("StockMarketUI: StockMarket folder not found!")
	return
end

--------------------------------------------------------------------------------
-- UI CREATION
--------------------------------------------------------------------------------

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "StockMarketUI"
screenGui.ResetOnSpawn = false
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.Parent = playerGui

-- Main container (top-right corner, below the leaderboard area)
local container = Instance.new("Frame")
container.Name = "StockMarketContainer"
container.Size = UDim2.new(0, 200, 0, 100)
container.Position = UDim2.new(1, -220, 0, 120) -- Top right, below leaderboard
container.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
container.BackgroundTransparency = 0.2
container.BorderSizePixel = 0
container.Parent = screenGui

local containerCorner = Instance.new("UICorner")
containerCorner.CornerRadius = UDim.new(0, 12)
containerCorner.Parent = container

local containerStroke = Instance.new("UIStroke")
containerStroke.Thickness = 2
containerStroke.Color = Color3.fromRGB(60, 60, 80)
containerStroke.Parent = container

-- Header
local header = Instance.new("TextLabel")
header.Name = "Header"
header.Size = UDim2.new(1, 0, 0, 24)
header.Position = UDim2.new(0, 0, 0, 4)
header.BackgroundTransparency = 1
header.Text = "ðŸ“ˆ STOCK MARKET"
header.TextColor3 = Color3.fromRGB(200, 200, 220)
header.TextSize = 14
header.Font = Enum.Font.GothamBold
header.Parent = container

-- Rate Display
local rateLabel = Instance.new("TextLabel")
rateLabel.Name = "RateLabel"
rateLabel.Size = UDim2.new(1, 0, 0, 40)
rateLabel.Position = UDim2.new(0, 0, 0, 28)
rateLabel.BackgroundTransparency = 1
rateLabel.Text = "1.0x"
rateLabel.TextColor3 = CONFIG.COLORS.NORMAL
rateLabel.TextSize = 36
rateLabel.Font = Enum.Font.GothamBlack
rateLabel.Parent = container

-- Rate Name
local rateNameLabel = Instance.new("TextLabel")
rateNameLabel.Name = "RateNameLabel"
rateNameLabel.Size = UDim2.new(1, 0, 0, 18)
rateNameLabel.Position = UDim2.new(0, 0, 0, 68)
rateNameLabel.BackgroundTransparency = 1
rateNameLabel.Text = "NORMAL"
rateNameLabel.TextColor3 = Color3.fromRGB(150, 150, 170)
rateNameLabel.TextSize = 12
rateNameLabel.Font = Enum.Font.GothamMedium
rateNameLabel.Parent = container

-- Timer (bottom)
local timerLabel = Instance.new("TextLabel")
timerLabel.Name = "TimerLabel"
timerLabel.Size = UDim2.new(1, 0, 0, 16)
timerLabel.Position = UDim2.new(0, 0, 1, -18)
timerLabel.BackgroundTransparency = 1
timerLabel.Text = "Next: 30s"
timerLabel.TextColor3 = Color3.fromRGB(120, 120, 140)
timerLabel.TextSize = 11
timerLabel.Font = Enum.Font.Gotham
timerLabel.Parent = container

--------------------------------------------------------------------------------
-- SOUND SETUP
--------------------------------------------------------------------------------

local crashSound = Instance.new("Sound")
crashSound.SoundId = CONFIG.SOUNDS.CRASH
crashSound.Volume = 0.7
crashSound.Parent = SoundService

local hyperSound = Instance.new("Sound")
hyperSound.SoundId = CONFIG.SOUNDS.HYPER
hyperSound.Volume = 0.8
hyperSound.Parent = SoundService

--------------------------------------------------------------------------------
-- UPDATE LOGIC
--------------------------------------------------------------------------------

local lastRateName = "NORMAL"

local function updateDisplay()
	local currentRate = stockMarketFolder:GetAttribute("CurrentRate") or 1.0
	local rateName = stockMarketFolder:GetAttribute("RateName") or "NORMAL"
	
	-- Update text
	rateLabel.Text = string.format("%.1fx", currentRate)
	rateNameLabel.Text = rateName
	
	-- Update colors
	local color = CONFIG.COLORS[rateName] or CONFIG.COLORS.NORMAL
	rateLabel.TextColor3 = color
	containerStroke.Color = color
	
	-- Play sounds on rate change
	if rateName ~= lastRateName then
		if rateName == "CRASH" then
			crashSound:Play()
		elseif rateName == "HYPER INFLATION" then
			hyperSound:Play()
		end
		
		-- Animate the rate label
		local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
		rateLabel.TextSize = 24
		local tween = TweenService:Create(rateLabel, tweenInfo, {TextSize = 36})
		tween:Play()
		
		lastRateName = rateName
	end
end

local function updateTimer()
	local nextUpdate = stockMarketFolder:GetAttribute("NextUpdate") or 0
	local now = os.time()
	local remaining = math.max(0, nextUpdate - now)
	timerLabel.Text = string.format("Next: %ds", remaining)
end

-- Initial update
updateDisplay()

-- Listen for rate changes
stockMarketFolder:GetAttributeChangedSignal("CurrentRate"):Connect(updateDisplay)
stockMarketFolder:GetAttributeChangedSignal("RateName"):Connect(updateDisplay)

-- Timer update loop
RunService.Heartbeat:Connect(function()
	updateTimer()
end)

-- Toggle Visibility
container.Visible = false -- Start hidden

local stockToggleEvent = ReplicatedStorage:WaitForChild("StockToggleEvent", 5)
if stockToggleEvent then
	stockToggleEvent.Event:Connect(function()
		container.Visible = not container.Visible
		if container.Visible then
			updateDisplay()
		end
	end)
else
	warn("StockMarketUI: StockToggleEvent not found")
end

print("âœ“ StockMarketUI initialized")


================================================================================
FILE: src\client\StockTickerHUD.client.luau
================================================================================

--[[
	StockTickerHUD Client Script
	
	A continuously scrolling stock ticker bar at the top of the screen.
	Shows each sector's current rate multiplier with trend arrows and % change.
	Clicking a sector opens a detail popup with a mini price-history graph.
	
	Data source: ReplicatedStorage.StockMarket attributes (published by StockMarketManager)
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local HttpService = game:GetService("HttpService")

local Player = Players.LocalPlayer
local PlayerGui = Player:WaitForChild("PlayerGui")

-- Wait for StockMarket folder
local stockMarketFolder = ReplicatedStorage:WaitForChild("StockMarket", 30)
if not stockMarketFolder then
	warn("StockTickerHUD: StockMarket folder not found!")
	return
end

--------------------------------------------------------------------------------
-- CONFIGURATION
--------------------------------------------------------------------------------

local CONFIG = {
	-- Bar
	BAR_HEIGHT = 28,
	BAR_COLOR = Color3.fromRGB(12, 12, 20),
	BAR_TRANSPARENCY = 0.15,
	
	-- Scrolling
	SCROLL_SPEED = 50, -- pixels per second
	ITEM_SPACING = 30, -- px between sector entries
	SEPARATOR = "  â”‚  ",
	
	-- Colors
	UP_COLOR = Color3.fromRGB(80, 255, 120),
	DOWN_COLOR = Color3.fromRGB(255, 80, 80),
	NEUTRAL_COLOR = Color3.fromRGB(180, 180, 200),
	TEXT_COLOR = Color3.fromRGB(220, 220, 240),
	
	-- Popup
	POPUP_WIDTH = 280,
	POPUP_HEIGHT = 220,
	POPUP_BG = Color3.fromRGB(20, 20, 35),
	POPUP_STROKE = Color3.fromRGB(60, 60, 90),
	
	-- Graph (inside popup)
	GRAPH_HEIGHT = 100,
	GRAPH_LINE_COLOR_DEFAULT = Color3.fromRGB(100, 200, 255),
	
	-- Sector icons
	SECTOR_ICONS = {
		Food = "ðŸ•",
		Animals = "ðŸ¾",
		Entertainment = "ðŸŽ­",
		Mystic = "ðŸ”®",
		Tech = "âš¡",
		Action = "ðŸ’¥",
	},
}

local SECTOR_COLORS = {
	Food = Color3.fromRGB(227, 119, 194),
	Animals = Color3.fromRGB(44, 160, 44),
	Entertainment = Color3.fromRGB(255, 127, 14),
	Mystic = Color3.fromRGB(148, 103, 189),
	Tech = Color3.fromRGB(31, 119, 180),
	Action = Color3.fromRGB(214, 39, 40),
}

--------------------------------------------------------------------------------
-- STATE
--------------------------------------------------------------------------------

local sectorOrder = {"Food", "Animals", "Entertainment", "Mystic", "Tech", "Action"}
local sectorRates: {[string]: number} = {}
local sectorHistories: {[string]: {number}} = {}
local previousRates: {[string]: number} = {} -- for % change calculation

local scrollOffset = 0
local isHovered = false
local activePopupSector: string? = nil

--------------------------------------------------------------------------------
-- UI CREATION
--------------------------------------------------------------------------------

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "StockTickerHUD"
screenGui.ResetOnSpawn = false
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.DisplayOrder = 5
screenGui.Parent = PlayerGui

-- Top bar
local tickerBar = Instance.new("Frame")
tickerBar.Name = "TickerBar"
tickerBar.Size = UDim2.new(1, 0, 0, CONFIG.BAR_HEIGHT)
tickerBar.Position = UDim2.new(0, 0, 0, 0)
tickerBar.BackgroundColor3 = CONFIG.BAR_COLOR
tickerBar.BackgroundTransparency = CONFIG.BAR_TRANSPARENCY
tickerBar.BorderSizePixel = 0
tickerBar.ClipsDescendants = true
tickerBar.Parent = screenGui

-- Subtle bottom border
local borderLine = Instance.new("Frame")
borderLine.Name = "Border"
borderLine.Size = UDim2.new(1, 0, 0, 1)
borderLine.Position = UDim2.new(0, 0, 1, -1)
borderLine.BackgroundColor3 = Color3.fromRGB(60, 60, 90)
borderLine.BackgroundTransparency = 0.5
borderLine.BorderSizePixel = 0
borderLine.Parent = tickerBar

-- Scrolling content frame (will be wider than the bar, shifted left over time)
local scrollFrame = Instance.new("Frame")
scrollFrame.Name = "ScrollContent"
scrollFrame.Size = UDim2.new(0, 2000, 1, 0) -- Will be resized after building labels
scrollFrame.Position = UDim2.new(0, 0, 0, 0)
scrollFrame.BackgroundTransparency = 1
scrollFrame.Parent = tickerBar

-- Detail popup (hidden by default)
local popupFrame = Instance.new("Frame")
popupFrame.Name = "DetailPopup"
popupFrame.Size = UDim2.new(0, CONFIG.POPUP_WIDTH, 0, CONFIG.POPUP_HEIGHT)
popupFrame.Position = UDim2.new(0, 100, 0, CONFIG.BAR_HEIGHT + 4)
popupFrame.BackgroundColor3 = CONFIG.POPUP_BG
popupFrame.BackgroundTransparency = 0.05
popupFrame.BorderSizePixel = 0
popupFrame.Visible = false
popupFrame.ZIndex = 10
popupFrame.Parent = screenGui

local popupCorner = Instance.new("UICorner")
popupCorner.CornerRadius = UDim.new(0, 10)
popupCorner.Parent = popupFrame

local popupStroke = Instance.new("UIStroke")
popupStroke.Color = CONFIG.POPUP_STROKE
popupStroke.Thickness = 1.5
popupStroke.Transparency = 0.3
popupStroke.Parent = popupFrame

local popupPadding = Instance.new("UIPadding")
popupPadding.PaddingLeft = UDim.new(0, 10)
popupPadding.PaddingRight = UDim.new(0, 10)
popupPadding.PaddingTop = UDim.new(0, 8)
popupPadding.PaddingBottom = UDim.new(0, 8)
popupPadding.Parent = popupFrame

-- Popup: Title
local popupTitle = Instance.new("TextLabel")
popupTitle.Name = "Title"
popupTitle.Size = UDim2.new(1, 0, 0, 20)
popupTitle.BackgroundTransparency = 1
popupTitle.Text = "ðŸ“ˆ SECTOR"
popupTitle.TextColor3 = CONFIG.TEXT_COLOR
popupTitle.TextSize = 14
popupTitle.Font = Enum.Font.GothamBold
popupTitle.TextXAlignment = Enum.TextXAlignment.Left
popupTitle.ZIndex = 11
popupTitle.Parent = popupFrame

-- Popup: Rate
local popupRate = Instance.new("TextLabel")
popupRate.Name = "Rate"
popupRate.Size = UDim2.new(1, 0, 0, 30)
popupRate.Position = UDim2.new(0, 0, 0, 22)
popupRate.BackgroundTransparency = 1
popupRate.Text = "1.00x"
popupRate.TextColor3 = CONFIG.UP_COLOR
popupRate.TextSize = 26
popupRate.Font = Enum.Font.GothamBlack
popupRate.TextXAlignment = Enum.TextXAlignment.Left
popupRate.ZIndex = 11
popupRate.Parent = popupFrame

-- Popup: Change info
local popupChange = Instance.new("TextLabel")
popupChange.Name = "Change"
popupChange.Size = UDim2.new(1, 0, 0, 16)
popupChange.Position = UDim2.new(0, 0, 0, 54)
popupChange.BackgroundTransparency = 1
popupChange.Text = "â–² +5.0% from 5 ticks ago"
popupChange.TextColor3 = CONFIG.NEUTRAL_COLOR
popupChange.TextSize = 11
popupChange.Font = Enum.Font.Gotham
popupChange.TextXAlignment = Enum.TextXAlignment.Left
popupChange.ZIndex = 11
popupChange.Parent = popupFrame

-- Popup: Graph container
local graphContainer = Instance.new("Frame")
graphContainer.Name = "GraphContainer"
graphContainer.Size = UDim2.new(1, 0, 0, CONFIG.GRAPH_HEIGHT)
graphContainer.Position = UDim2.new(0, 0, 0, 76)
graphContainer.BackgroundColor3 = Color3.fromRGB(15, 15, 25)
graphContainer.BackgroundTransparency = 0.3
graphContainer.BorderSizePixel = 0
graphContainer.ZIndex = 11
graphContainer.Parent = popupFrame

local graphCorner = Instance.new("UICorner")
graphCorner.CornerRadius = UDim.new(0, 6)
graphCorner.Parent = graphContainer

-- Popup: Close button
local closeBtn = Instance.new("TextButton")
closeBtn.Name = "CloseBtn"
closeBtn.Size = UDim2.new(0, 20, 0, 20)
closeBtn.Position = UDim2.new(1, -10, 0, 0)
closeBtn.BackgroundTransparency = 1
closeBtn.Text = "âœ•"
closeBtn.TextColor3 = CONFIG.NEUTRAL_COLOR
closeBtn.TextSize = 14
closeBtn.Font = Enum.Font.GothamBold
closeBtn.ZIndex = 12
closeBtn.Parent = popupFrame

closeBtn.Activated:Connect(function()
	popupFrame.Visible = false
	activePopupSector = nil
end)

--------------------------------------------------------------------------------
-- DATA PARSING
--------------------------------------------------------------------------------

local function parseSectorRates()
	local json = stockMarketFolder:GetAttribute("SectorRates")
	if not json then return end
	local ok, data = pcall(HttpService.JSONDecode, HttpService, json)
	if ok and data then
		-- Save previous for % change
		for k, v in pairs(sectorRates) do
			previousRates[k] = v
		end
		sectorRates = data
	end
end

local function parseSectorHistories()
	local json = stockMarketFolder:GetAttribute("SectorHistories")
	if not json then return end
	local ok, data = pcall(HttpService.JSONDecode, HttpService, json)
	if not ok or not data then return end
	
	for sector, csv in pairs(data) do
		local history = {}
		for val in string.gmatch(csv, "[^,]+") do
			local n = tonumber(val)
			if n then table.insert(history, n) end
		end
		sectorHistories[sector] = history
	end
end

local function getPercentChange(sector: string): (number, number)
	-- Returns (percentChange, previousRate)
	local history = sectorHistories[sector]
	if not history or #history < 6 then
		return 0, sectorRates[sector] or 1.0
	end
	local current = history[#history]
	local previous = history[#history - 5] -- 5 ticks ago
	if previous == 0 then return 0, previous end
	local pct = ((current - previous) / previous) * 100
	return pct, previous
end

--------------------------------------------------------------------------------
-- TICKER LABEL BUILDING
--------------------------------------------------------------------------------

local sectorButtons: {[string]: TextButton} = {}
local totalContentWidth = 0

local function buildTickerContent()
	-- Clear old
	for _, child in scrollFrame:GetChildren() do
		child:Destroy()
	end
	sectorButtons = {}
	
	local xPos = 0
	
	for i, sector in ipairs(sectorOrder) do
		local rate = sectorRates[sector] or 1.0
		local pct, _ = getPercentChange(sector)
		local icon = CONFIG.SECTOR_ICONS[sector] or "ðŸ“Š"
		
		-- Determine trend
		local arrow, arrowColor
		if pct > 0.5 then
			arrow = "â–²"
			arrowColor = CONFIG.UP_COLOR
		elseif pct < -0.5 then
			arrow = "â–¼"
			arrowColor = CONFIG.DOWN_COLOR
		else
			arrow = "â€”"
			arrowColor = CONFIG.NEUTRAL_COLOR
		end
		
		local text = string.format("%s %s %.2fx %s%.0f%%", icon, sector, rate, arrow, math.abs(pct))
		
		local btn = Instance.new("TextButton")
		btn.Name = "Sector_" .. sector
		btn.Size = UDim2.new(0, 0, 1, 0) -- auto-sized below
		btn.Position = UDim2.new(0, xPos, 0, 0)
		btn.BackgroundTransparency = 1
		btn.Text = text
		btn.TextColor3 = arrowColor
		btn.TextSize = 13
		btn.Font = Enum.Font.GothamMedium
		btn.AutomaticSize = Enum.AutomaticSize.X
		btn.Parent = scrollFrame
		
		-- Add padding inside button
		local btnPadding = Instance.new("UIPadding")
		btnPadding.PaddingLeft = UDim.new(0, 8)
		btnPadding.PaddingRight = UDim.new(0, 8)
		btnPadding.Parent = btn
		
		-- Click handler
		btn.Activated:Connect(function()
			if activePopupSector == sector then
				popupFrame.Visible = false
				activePopupSector = nil
			else
				showPopup(sector, btn)
			end
		end)
		
		-- Hover
		btn.MouseEnter:Connect(function()
			isHovered = true
			btn.TextColor3 = Color3.new(1, 1, 1)
		end)
		btn.MouseLeave:Connect(function()
			isHovered = false
			-- Restore color on next update
		end)
		
		sectorButtons[sector] = btn
		
		-- Measure width (estimate based on text length, will be refined by AutomaticSize)
		local estimatedWidth = #text * 8 + 16
		xPos += estimatedWidth
		
		-- Add separator (except after last)
		if i < #sectorOrder then
			local sep = Instance.new("TextLabel")
			sep.Name = "Sep_" .. i
			sep.Size = UDim2.new(0, 20, 1, 0)
			sep.Position = UDim2.new(0, xPos, 0, 0)
			sep.BackgroundTransparency = 1
			sep.Text = "â”‚"
			sep.TextColor3 = Color3.fromRGB(60, 60, 90)
			sep.TextSize = 13
			sep.Font = Enum.Font.Gotham
			sep.Parent = scrollFrame
			xPos += 20
		end
	end
	
	totalContentWidth = xPos + 40 -- extra padding for seamless wrap
	scrollFrame.Size = UDim2.new(0, totalContentWidth * 2, 1, 0) -- double for seamless loop
	
	-- Duplicate labels for seamless scrolling
	for _, child in scrollFrame:GetChildren() do
		if child:IsA("GuiBase2d") and not child.Name:find("_dup") then
			local dup = child:Clone()
			dup.Name = child.Name .. "_dup"
			dup.Position = UDim2.new(0, child.Position.X.Offset + totalContentWidth, 0, 0)
			dup.Parent = scrollFrame
		end
	end
end

local function updateTickerLabels()
	for sector, btn in pairs(sectorButtons) do
		if btn.Name:find("_dup") then continue end
		local rate = sectorRates[sector] or 1.0
		local pct, _ = getPercentChange(sector)
		local icon = CONFIG.SECTOR_ICONS[sector] or "ðŸ“Š"
		
		local arrow, arrowColor
		if pct > 0.5 then
			arrow = "â–²"
			arrowColor = CONFIG.UP_COLOR
		elseif pct < -0.5 then
			arrow = "â–¼"
			arrowColor = CONFIG.DOWN_COLOR
		else
			arrow = "â€”"
			arrowColor = CONFIG.NEUTRAL_COLOR
		end
		
		btn.Text = string.format("%s %s %.2fx %s%.0f%%", icon, sector, rate, arrow, math.abs(pct))
		if not isHovered then
			btn.TextColor3 = arrowColor
		end
		
		-- Update duplicate
		local dup = scrollFrame:FindFirstChild(btn.Name .. "_dup")
		if dup then
			dup.Text = btn.Text
			if not isHovered then
				dup.TextColor3 = arrowColor
			end
		end
	end
end

--------------------------------------------------------------------------------
-- POPUP / DETAIL VIEW
--------------------------------------------------------------------------------

local graphLines: {Frame} = {}

local function clearGraph()
	for _, line in graphLines do
		line:Destroy()
	end
	graphLines = {}
end

local function drawMiniGraph(sector: string)
	clearGraph()
	
	local history = sectorHistories[sector]
	if not history or #history < 2 then return end
	
	local color = SECTOR_COLORS[sector] or CONFIG.GRAPH_LINE_COLOR_DEFAULT
	
	-- Find min/max for scaling
	local minVal, maxVal = math.huge, -math.huge
	for _, v in ipairs(history) do
		minVal = math.min(minVal, v)
		maxVal = math.max(maxVal, v)
	end
	local range = maxVal - minVal
	if range < 0.01 then range = 0.1 end -- avoid division by zero
	
	-- Add some padding to the range
	minVal = minVal - range * 0.1
	maxVal = maxVal + range * 0.1
	range = maxVal - minVal
	
	local graphWidth = CONFIG.POPUP_WIDTH - 20 -- accounting for padding
	local graphHeight = CONFIG.GRAPH_HEIGHT - 10
	
	-- Draw line segments
	for i = 1, #history - 1 do
		local x1 = ((i - 1) / (#history - 1)) * graphWidth
		local y1 = (1 - (history[i] - minVal) / range) * graphHeight + 5
		local x2 = (i / (#history - 1)) * graphWidth
		local y2 = (1 - (history[i + 1] - minVal) / range) * graphHeight + 5
		
		-- Calculate line properties
		local dx = x2 - x1
		local dy = y2 - y1
		local length = math.sqrt(dx * dx + dy * dy)
		local angle = math.atan2(dy, dx)
		
		local line = Instance.new("Frame")
		line.Name = "Line_" .. i
		line.Size = UDim2.new(0, math.ceil(length), 0, 2)
		line.Position = UDim2.new(0, math.floor(x1), 0, math.floor(y1))
		line.Rotation = math.deg(angle)
		line.AnchorPoint = Vector2.new(0, 0.5)
		line.BackgroundColor3 = color
		line.BackgroundTransparency = 0.1
		line.BorderSizePixel = 0
		line.ZIndex = 12
		line.Parent = graphContainer
		
		table.insert(graphLines, line)
	end
	
	-- Draw current dot at end
	local lastX = graphWidth
	local lastY = (1 - (history[#history] - minVal) / range) * graphHeight + 5
	
	local dot = Instance.new("Frame")
	dot.Name = "CurrentDot"
	dot.Size = UDim2.new(0, 8, 0, 8)
	dot.Position = UDim2.new(0, math.floor(lastX) - 4, 0, math.floor(lastY) - 4)
	dot.BackgroundColor3 = Color3.new(1, 1, 1)
	dot.BorderSizePixel = 0
	dot.ZIndex = 13
	dot.Parent = graphContainer
	
	local dotCorner = Instance.new("UICorner")
	dotCorner.CornerRadius = UDim.new(1, 0)
	dotCorner.Parent = dot
	
	table.insert(graphLines, dot)
	
	-- Glow behind dot
	local glow = Instance.new("Frame")
	glow.Name = "Glow"
	glow.Size = UDim2.new(0, 16, 0, 16)
	glow.Position = UDim2.new(0, math.floor(lastX) - 8, 0, math.floor(lastY) - 8)
	glow.BackgroundColor3 = color
	glow.BackgroundTransparency = 0.6
	glow.BorderSizePixel = 0
	glow.ZIndex = 12
	glow.Parent = graphContainer
	
	local glowCorner = Instance.new("UICorner")
	glowCorner.CornerRadius = UDim.new(1, 0)
	glowCorner.Parent = glow
	
	table.insert(graphLines, glow)
end

function showPopup(sector: string, btn: TextButton)
	activePopupSector = sector
	
	local rate = sectorRates[sector] or 1.0
	local pct, prevRate = getPercentChange(sector)
	local icon = CONFIG.SECTOR_ICONS[sector] or "ðŸ“Š"
	local color = SECTOR_COLORS[sector] or CONFIG.GRAPH_LINE_COLOR_DEFAULT
	
	-- Trend text
	local arrow, arrowColor
	if pct > 0.5 then
		arrow = "â–²"
		arrowColor = CONFIG.UP_COLOR
	elseif pct < -0.5 then
		arrow = "â–¼"
		arrowColor = CONFIG.DOWN_COLOR
	else
		arrow = "â€”"
		arrowColor = CONFIG.NEUTRAL_COLOR
	end
	
	popupTitle.Text = string.format("%s %s Sector", icon, sector)
	popupTitle.TextColor3 = color
	
	popupRate.Text = string.format("%.2fx", rate)
	popupRate.TextColor3 = arrowColor
	
	popupChange.Text = string.format("%s %s%.1f%% from 5 ticks ago", arrow, pct >= 0 and "+" or "", pct)
	popupChange.TextColor3 = arrowColor
	
	popupStroke.Color = color
	
	-- Position popup near the button
	local btnPos = btn.AbsolutePosition.X
	local popupX = math.clamp(btnPos, 10, tickerBar.AbsoluteSize.X - CONFIG.POPUP_WIDTH - 10)
	popupFrame.Position = UDim2.new(0, popupX, 0, CONFIG.BAR_HEIGHT + 4)
	
	-- Draw graph
	drawMiniGraph(sector)
	
	-- Show with animation
	popupFrame.Visible = true
	popupFrame.BackgroundTransparency = 1
	TweenService:Create(popupFrame, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		BackgroundTransparency = 0.05
	}):Play()
end

--------------------------------------------------------------------------------
-- SCROLLING ANIMATION
--------------------------------------------------------------------------------

RunService.Heartbeat:Connect(function(dt)
	if not isHovered and totalContentWidth > 0 then
		scrollOffset += CONFIG.SCROLL_SPEED * dt
		if scrollOffset >= totalContentWidth then
			scrollOffset -= totalContentWidth
		end
		scrollFrame.Position = UDim2.new(0, -scrollOffset, 0, 0)
	end
end)

--------------------------------------------------------------------------------
-- PRICING MODE INDICATOR
--------------------------------------------------------------------------------

-- Small GLOBAL/LOCAL indicator on right side of ticker bar
local modeIndicator = Instance.new("TextLabel")
modeIndicator.Name = "ModeIndicator"
modeIndicator.Size = UDim2.new(0, 80, 1, 0)
modeIndicator.Position = UDim2.new(1, -85, 0, 0)
modeIndicator.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
modeIndicator.BackgroundTransparency = 0.3
modeIndicator.Text = "ðŸ“¡ GLOBAL"
modeIndicator.TextColor3 = CONFIG.UP_COLOR
modeIndicator.TextSize = 10
modeIndicator.Font = Enum.Font.GothamBold
modeIndicator.ZIndex = 3
modeIndicator.Parent = tickerBar

local modeCorner = Instance.new("UICorner")
modeCorner.CornerRadius = UDim.new(0, 4)
modeCorner.Parent = modeIndicator

local function updateModeIndicator()
	local globalActive = stockMarketFolder:GetAttribute("GlobalPricingActive")
	if globalActive then
		modeIndicator.Text = "ðŸ“¡ GLOBAL"
		modeIndicator.TextColor3 = CONFIG.UP_COLOR
	else
		modeIndicator.Text = "ðŸ’» LOCAL"
		modeIndicator.TextColor3 = Color3.fromRGB(255, 200, 60)
	end
end

--------------------------------------------------------------------------------
-- DATA UPDATES
--------------------------------------------------------------------------------

local function onMarketUpdate()
	parseSectorRates()
	parseSectorHistories()
	updateTickerLabels()
	updateModeIndicator()
	
	-- Refresh popup if open
	if activePopupSector and popupFrame.Visible then
		local btn = sectorButtons[activePopupSector]
		if btn then
			showPopup(activePopupSector, btn)
		end
	end
end

-- Initial load
parseSectorRates()
parseSectorHistories()
buildTickerContent()
updateModeIndicator()

-- Listen for updates
stockMarketFolder:GetAttributeChangedSignal("SectorRates"):Connect(onMarketUpdate)
stockMarketFolder:GetAttributeChangedSignal("SectorHistories"):Connect(onMarketUpdate)

-- Close popup when clicking outside
tickerBar.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		-- Don't close here â€” let sector buttons handle their own clicks
	end
end)

print("âœ“ StockTickerHUD initialized")


================================================================================
FILE: src\client\StorageMarketGlow.client.luau
================================================================================

--[[
	StorageMarketGlow Client Script
	
	Updates the Storage tank display to show the current market rate multiplier
	and adds a Highlight glow effect based on the rate.
	
	Features:
	- Shows "(1.2x)" multiplier on storage display
	- Green glow when rate >= 1.5x (good time to sell)
	- Yellow glow when rate 1.0x-1.5x (neutral)
	- Red glow when rate < 1.0x (bad time to sell)
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

-- Configuration
local CONFIG = {
	-- Glow colors
	HIGH_RATE_COLOR = Color3.fromRGB(50, 255, 100),    -- Green (>=1.5x)
	NEUTRAL_RATE_COLOR = Color3.fromRGB(255, 215, 0), -- Yellow (1.0x-1.5x)
	LOW_RATE_COLOR = Color3.fromRGB(255, 70, 70),     -- Red (<1.0x)
	
	-- Thresholds
	HIGH_RATE_THRESHOLD = 1.5,
	NEUTRAL_RATE_THRESHOLD = 1.0,
	
	-- Glow intensity
	BASE_FILL_TRANSPARENCY = 0.7,
	BASE_OUTLINE_TRANSPARENCY = 0.3,
}

-- References
local player = Players.LocalPlayer
local stockMarketFolder: Folder? = nil
local currentHighlight: Highlight? = nil
local storagePart: BasePart? = nil
local rateLabel: TextLabel? = nil

--------------------------------------------------------------------------------
-- HELPER FUNCTIONS
--------------------------------------------------------------------------------

--[[
	Gets the color based on the current market rate.
]]
local function getRateColor(rate: number): Color3
	if rate >= CONFIG.HIGH_RATE_THRESHOLD then
		return CONFIG.HIGH_RATE_COLOR
	elseif rate >= CONFIG.NEUTRAL_RATE_THRESHOLD then
		return CONFIG.NEUTRAL_RATE_COLOR
	else
		return CONFIG.LOW_RATE_COLOR
	end
end

--[[
	Finds the player's storage part by looking for their plot.
]]
local function findPlayerStorage(): BasePart?
	local plotsFolder = workspace:FindFirstChild("Plots")
	if not plotsFolder then return nil end
	
	for _, plot in plotsFolder:GetChildren() do
		local ownerId = plot:GetAttribute("OwnerId")
		if ownerId and ownerId == player.UserId then
			local storage = plot:FindFirstChild("Storage")
			if storage and storage:IsA("BasePart") then
				return storage
			end
		end
	end
	
	return nil
end

--[[
	Creates or updates the rate label on the storage BillboardGui.
]]
local function ensureRateLabel(storage: BasePart): TextLabel?
	local billboard = storage:FindFirstChild("StorageDisplay")
	if not billboard then return nil end
	
	local bgFrame = billboard:FindFirstChild("Background")
	if not bgFrame then return nil end
	
	-- Check if rate label already exists
	local existingLabel = bgFrame:FindFirstChild("RateLabel")
	if existingLabel then
		return existingLabel :: TextLabel
	end
	
	-- Create new rate label
	local label = Instance.new("TextLabel")
	label.Name = "RateLabel"
	label.Size = UDim2.new(0.4, 0, 0.3, 0)
	label.Position = UDim2.new(0.6, 0, 0.05, 0)
	label.BackgroundTransparency = 1
	label.Text = "(1.0x)"
	label.TextColor3 = CONFIG.NEUTRAL_RATE_COLOR
	label.TextScaled = true
	label.Font = Enum.Font.GothamBold
	label.Parent = bgFrame
	
	return label
end

--[[
	Creates or updates the Highlight effect on the storage.
]]
local function ensureHighlight(storage: BasePart): Highlight?
	-- Check if highlight already exists
	local existingHighlight = storage:FindFirstChild("MarketHighlight")
	if existingHighlight and existingHighlight:IsA("Highlight") then
		return existingHighlight
	end
	
	-- Create new highlight
	local highlight = Instance.new("Highlight")
	highlight.Name = "MarketHighlight"
	highlight.FillTransparency = CONFIG.BASE_FILL_TRANSPARENCY
	highlight.OutlineTransparency = CONFIG.BASE_OUTLINE_TRANSPARENCY
	highlight.FillColor = CONFIG.NEUTRAL_RATE_COLOR
	highlight.OutlineColor = CONFIG.NEUTRAL_RATE_COLOR
	highlight.Adornee = storage
	highlight.Parent = storage
	
	return highlight
end

--[[
	Updates the storage visual based on current market rate.
]]
local function updateStorageVisual()
	if not stockMarketFolder then return end
	if not storagePart then
		-- Try to find storage again
		storagePart = findPlayerStorage()
		if not storagePart then return end
		
		-- Ensure rate label exists
		rateLabel = ensureRateLabel(storagePart)
		
		-- Ensure highlight exists
		currentHighlight = ensureHighlight(storagePart)
	end
	
	-- Get current rate
	local currentRate = stockMarketFolder:GetAttribute("CurrentRate") :: number? or 1.0
	local color = getRateColor(currentRate)
	
	-- Update rate label
	if rateLabel then
		rateLabel.Text = string.format("(%.2fx)", currentRate)
		rateLabel.TextColor3 = color
	end
	
	-- Update highlight
	if currentHighlight then
		currentHighlight.FillColor = color
		currentHighlight.OutlineColor = color
		
		-- Pulse intensity based on how far from 1.0x
		local intensity = math.abs(currentRate - 1.0)
		local fillTransparency = math.clamp(0.9 - intensity * 0.3, 0.5, 0.95)
		local outlineTransparency = math.clamp(0.5 - intensity * 0.2, 0.1, 0.7)
		
		currentHighlight.FillTransparency = fillTransparency
		currentHighlight.OutlineTransparency = outlineTransparency
	end
end

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

local function initialize()
	print("StorageMarketGlow: Initializing...")
	
	-- Wait for StockMarket folder
	stockMarketFolder = ReplicatedStorage:WaitForChild("StockMarket", 30) :: Folder?
	if not stockMarketFolder then
		warn("StorageMarketGlow: StockMarket folder not found!")
		return
	end
	
	-- Wait a moment for plot to be assigned
	task.wait(2)
	
	-- Find player's storage
	storagePart = findPlayerStorage()
	if storagePart then
		rateLabel = ensureRateLabel(storagePart)
		currentHighlight = ensureHighlight(storagePart)
		print("StorageMarketGlow: Found storage, added rate display and glow")
	else
		print("StorageMarketGlow: No storage found yet, will check on rate updates")
	end
	
	-- Initial update
	updateStorageVisual()
	
	-- Listen for rate changes
	stockMarketFolder:GetAttributeChangedSignal("CurrentRate"):Connect(updateStorageVisual)
	
	-- Also poll periodically in case storage wasn't found initially
	task.spawn(function()
		while true do
			task.wait(2)
			if not storagePart then
				storagePart = findPlayerStorage()
				if storagePart then
					rateLabel = ensureRateLabel(storagePart)
					currentHighlight = ensureHighlight(storagePart)
					updateStorageVisual()
					print("StorageMarketGlow: Found storage on poll")
				end
			end
		end
	end)
	
	print("âœ“ StorageMarketGlow initialized")
end

-- Start
task.spawn(initialize)


================================================================================
FILE: src\client\StorageUpgradeUI.client.luau
================================================================================

--[[
	StorageUpgradeUI LocalScript
	
	Creates a storage upgrade shop interface triggered by StorageVendor.
	Shows current storage, upgrade cost, and new storage after upgrade.
	
	Features:
	- ProximityPrompt-triggered panel
	- Live price and storage level display
	- Animated purchase feedback
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local SoundService = game:GetService("SoundService")

-- Player reference
local Player = Players.LocalPlayer
local PlayerGui = Player:WaitForChild("PlayerGui")

-- Wait for remotes
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local UpgradeStorageRemote = RemoteEvents:WaitForChild("UpgradeStorage")
local GetStorageInfoRemote = RemoteEvents:WaitForChild("GetStorageInfo")
local StorageUpgradedEvent = RemoteEvents:WaitForChild("StorageUpgraded")

--------------------------------------------------------------------------------
-- UI CONFIGURATION
--------------------------------------------------------------------------------

local UI_CONFIG = {
	-- Panel dimensions
	PANEL_WIDTH = 320,
	PANEL_HEIGHT = 280,
	CORNER_RADIUS = 16,
	
	-- Colors
	BACKGROUND_COLOR = Color3.fromRGB(35, 35, 50),
	ACCENT_COLOR = Color3.fromRGB(255, 180, 50), -- Orange for storage
	BUTTON_COLOR = Color3.fromRGB(255, 180, 50),
	BUTTON_HOVER_COLOR = Color3.fromRGB(255, 200, 100),
	BUTTON_DISABLED_COLOR = Color3.fromRGB(100, 100, 100),
	TEXT_COLOR = Color3.fromRGB(255, 255, 255),
	SECONDARY_TEXT_COLOR = Color3.fromRGB(180, 180, 180),
	PRICE_COLOR = Color3.fromRGB(255, 215, 0),
	
	-- Animation
	TWEEN_TIME = 0.25,
}

--------------------------------------------------------------------------------
-- SOUNDS
--------------------------------------------------------------------------------

local function createSound(id: string, volume: number): Sound
	local sound = Instance.new("Sound")
	sound.SoundId = id
	sound.Volume = volume
	sound.Parent = SoundService
	return sound
end

local UpgradeSound = createSound("rbxassetid://138081500", 0.5) -- Cash register
local ErrorSound = createSound("rbxassetid://138090596", 0.3) -- Error

--------------------------------------------------------------------------------
-- LOCAL STATE
--------------------------------------------------------------------------------

local StorageGui: ScreenGui? = nil
local StoragePanel: Frame? = nil
local PanelVisible = false
local CurrentStorageInfo = {
	currentMax = 500,
	upgradeLevel = 0,
	nextPrice = 100,
	nextMaxStorage = 1000,
}

--------------------------------------------------------------------------------
-- UI HELPERS
--------------------------------------------------------------------------------

local function addCorner(parent: GuiObject, radius: number)
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, radius)
	corner.Parent = parent
	return corner
end

local function addStroke(parent: GuiObject, color: Color3, thickness: number)
	local stroke = Instance.new("UIStroke")
	stroke.Color = color
	stroke.Thickness = thickness
	stroke.Parent = parent
	return stroke
end

local function formatMoney(amount: number): string
	if amount >= 1000000 then
		return string.format("$%.1fM", amount / 1000000)
	elseif amount >= 1000 then
		return string.format("$%.1fK", amount / 1000)
	else
		return "$" .. tostring(math.floor(amount))
	end
end

local function formatStorage(amount: number): string
	if amount >= 1000000 then
		return string.format("%.1fM", amount / 1000000)
	elseif amount >= 1000 then
		return string.format("%.1fK", amount / 1000)
	else
		return tostring(amount)
	end
end

local function canAfford(): boolean
	local leaderstats = Player:FindFirstChild("leaderstats")
	if not leaderstats then return false end
	
	local money = leaderstats:FindFirstChild("Money")
	if not money then return false end
	
	return money.Value >= CurrentStorageInfo.nextPrice
end

--------------------------------------------------------------------------------
-- UI CREATION
--------------------------------------------------------------------------------

local function createStorageUpgradeGui(): ScreenGui
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "StorageUpgradeUI"
	screenGui.ResetOnSpawn = false
	screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	
	-- Main panel (starts hidden in center)
	local panel = Instance.new("Frame")
	panel.Name = "StoragePanel"
	panel.Size = UDim2.new(0, UI_CONFIG.PANEL_WIDTH, 0, UI_CONFIG.PANEL_HEIGHT)
	panel.Position = UDim2.new(0.5, -UI_CONFIG.PANEL_WIDTH / 2, 0.5, -UI_CONFIG.PANEL_HEIGHT / 2)
	panel.BackgroundColor3 = UI_CONFIG.BACKGROUND_COLOR
	panel.BorderSizePixel = 0
	panel.Visible = false
	panel.Parent = screenGui
	addCorner(panel, UI_CONFIG.CORNER_RADIUS)
	addStroke(panel, UI_CONFIG.ACCENT_COLOR, 3)
	
	-- Title
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "Title"
	titleLabel.Size = UDim2.new(1, 0, 0, 50)
	titleLabel.Position = UDim2.new(0, 0, 0, 0)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Text = "ðŸ“¦ STORAGE UPGRADE"
	titleLabel.TextColor3 = UI_CONFIG.ACCENT_COLOR
	titleLabel.TextSize = 24
	titleLabel.Font = Enum.Font.GothamBold
	titleLabel.Parent = panel
	
	-- Close button
	local closeButton = Instance.new("TextButton")
	closeButton.Name = "CloseButton"
	closeButton.Size = UDim2.new(0, 36, 0, 36)
	closeButton.Position = UDim2.new(1, -44, 0, 8)
	closeButton.BackgroundColor3 = Color3.fromRGB(200, 80, 80)
	closeButton.Text = "âœ•"
	closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	closeButton.TextSize = 20
	closeButton.Font = Enum.Font.GothamBold
	closeButton.Parent = panel
	addCorner(closeButton, 8)
	
	-- Current storage display
	local currentFrame = Instance.new("Frame")
	currentFrame.Name = "CurrentFrame"
	currentFrame.Size = UDim2.new(1, -40, 0, 50)
	currentFrame.Position = UDim2.new(0, 20, 0, 55)
	currentFrame.BackgroundColor3 = Color3.fromRGB(50, 50, 70)
	currentFrame.Parent = panel
	addCorner(currentFrame, 10)
	
	local currentLabel = Instance.new("TextLabel")
	currentLabel.Name = "Label"
	currentLabel.Size = UDim2.new(0.5, 0, 1, 0)
	currentLabel.BackgroundTransparency = 1
	currentLabel.Text = "Current Storage:"
	currentLabel.TextColor3 = UI_CONFIG.SECONDARY_TEXT_COLOR
	currentLabel.TextSize = 16
	currentLabel.Font = Enum.Font.Gotham
	currentLabel.TextXAlignment = Enum.TextXAlignment.Left
	currentLabel.Parent = currentFrame
	
	local currentPadding = Instance.new("UIPadding")
	currentPadding.PaddingLeft = UDim.new(0, 15)
	currentPadding.Parent = currentLabel
	
	local currentValue = Instance.new("TextLabel")
	currentValue.Name = "Value"
	currentValue.Size = UDim2.new(0.5, -15, 1, 0)
	currentValue.Position = UDim2.new(0.5, 0, 0, 0)
	currentValue.BackgroundTransparency = 1
	currentValue.Text = "500"
	currentValue.TextColor3 = UI_CONFIG.TEXT_COLOR
	currentValue.TextSize = 22
	currentValue.Font = Enum.Font.GothamBold
	currentValue.TextXAlignment = Enum.TextXAlignment.Right
	currentValue.Parent = currentFrame
	
	-- Arrow and new storage
	local upgradeFrame = Instance.new("Frame")
	upgradeFrame.Name = "UpgradeFrame"
	upgradeFrame.Size = UDim2.new(1, -40, 0, 60)
	upgradeFrame.Position = UDim2.new(0, 20, 0, 115)
	upgradeFrame.BackgroundColor3 = Color3.fromRGB(60, 80, 60)
	upgradeFrame.Parent = panel
	addCorner(upgradeFrame, 10)
	addStroke(upgradeFrame, UI_CONFIG.ACCENT_COLOR, 2)
	
	local upgradeLabel = Instance.new("TextLabel")
	upgradeLabel.Name = "Label"
	upgradeLabel.Size = UDim2.new(1, 0, 0.4, 0)
	upgradeLabel.BackgroundTransparency = 1
	upgradeLabel.Text = "Upgrade to:"
	upgradeLabel.TextColor3 = UI_CONFIG.SECONDARY_TEXT_COLOR
	upgradeLabel.TextSize = 14
	upgradeLabel.Font = Enum.Font.Gotham
	upgradeLabel.Parent = upgradeFrame
	
	local newStorageValue = Instance.new("TextLabel")
	newStorageValue.Name = "NewValue"
	newStorageValue.Size = UDim2.new(1, 0, 0.6, 0)
	newStorageValue.Position = UDim2.new(0, 0, 0.4, 0)
	newStorageValue.BackgroundTransparency = 1
	newStorageValue.Text = "1,000 (+100%)"
	newStorageValue.TextColor3 = Color3.fromRGB(100, 255, 100)
	newStorageValue.TextSize = 24
	newStorageValue.Font = Enum.Font.GothamBold
	newStorageValue.Parent = upgradeFrame
	
	-- Price and buy button
	local buyFrame = Instance.new("Frame")
	buyFrame.Name = "BuyFrame"
	buyFrame.Size = UDim2.new(1, -40, 0, 60)
	buyFrame.Position = UDim2.new(0, 20, 0, 190)
	buyFrame.BackgroundTransparency = 1
	buyFrame.Parent = panel
	
	local priceLabel = Instance.new("TextLabel")
	priceLabel.Name = "Price"
	priceLabel.Size = UDim2.new(0.5, 0, 1, 0)
	priceLabel.BackgroundTransparency = 1
	priceLabel.Text = "$100"
	priceLabel.TextColor3 = UI_CONFIG.PRICE_COLOR
	priceLabel.TextSize = 28
	priceLabel.Font = Enum.Font.GothamBold
	priceLabel.TextXAlignment = Enum.TextXAlignment.Left
	priceLabel.Parent = buyFrame
	
	local buyButton = Instance.new("TextButton")
	buyButton.Name = "BuyButton"
	buyButton.Size = UDim2.new(0.45, 0, 1, 0)
	buyButton.Position = UDim2.new(0.55, 0, 0, 0)
	buyButton.BackgroundColor3 = UI_CONFIG.BUTTON_COLOR
	buyButton.Text = "UPGRADE"
	buyButton.TextColor3 = Color3.fromRGB(0, 0, 0)
	buyButton.TextSize = 18
	buyButton.Font = Enum.Font.GothamBold
	buyButton.Parent = buyFrame
	addCorner(buyButton, 12)
	
	-- Level indicator
	local levelLabel = Instance.new("TextLabel")
	levelLabel.Name = "Level"
	levelLabel.Size = UDim2.new(1, 0, 0, 25)
	levelLabel.Position = UDim2.new(0, 0, 1, -30)
	levelLabel.BackgroundTransparency = 1
	levelLabel.Text = "Level 0"
	levelLabel.TextColor3 = UI_CONFIG.SECONDARY_TEXT_COLOR
	levelLabel.TextSize = 14
	levelLabel.Font = Enum.Font.Gotham
	levelLabel.Parent = panel
	
	return screenGui
end

--------------------------------------------------------------------------------
-- UI LOGIC
--------------------------------------------------------------------------------

local function updateUI()
	if not StoragePanel then return end
	
	-- Update current storage
	local currentFrame = StoragePanel:FindFirstChild("CurrentFrame")
	if currentFrame then
		local valueLabel = currentFrame:FindFirstChild("Value")
		if valueLabel then
			valueLabel.Text = formatStorage(CurrentStorageInfo.currentMax)
		end
	end
	
	-- Update upgrade target
	local upgradeFrame = StoragePanel:FindFirstChild("UpgradeFrame")
	if upgradeFrame then
		local newValueLabel = upgradeFrame:FindFirstChild("NewValue")
		if newValueLabel then
			local percentIncrease = math.floor((CurrentStorageInfo.nextMaxStorage / CurrentStorageInfo.currentMax - 1) * 100)
			newValueLabel.Text = string.format("%s (+%d%%)", formatStorage(CurrentStorageInfo.nextMaxStorage), percentIncrease)
		end
	end
	
	-- Update price and button
	local buyFrame = StoragePanel:FindFirstChild("BuyFrame")
	if buyFrame then
		local priceLabel = buyFrame:FindFirstChild("Price")
		if priceLabel then
			priceLabel.Text = formatMoney(CurrentStorageInfo.nextPrice)
		end
		
		local buyButton = buyFrame:FindFirstChild("BuyButton")
		if buyButton then
			local affordable = canAfford()
			buyButton.BackgroundColor3 = affordable and UI_CONFIG.BUTTON_COLOR or UI_CONFIG.BUTTON_DISABLED_COLOR
		end
	end
	
	-- Update level
	local levelLabel = StoragePanel:FindFirstChild("Level")
	if levelLabel then
		levelLabel.Text = string.format("Level %d", CurrentStorageInfo.upgradeLevel)
	end
end

local function showPanel()
	if PanelVisible then return end
	if not StoragePanel then return end
	
	-- Get fresh data from server
	local info = GetStorageInfoRemote:InvokeServer()
	if info then
		CurrentStorageInfo = info
	end
	
	updateUI()
	
	PanelVisible = true
	StoragePanel.Visible = true
	StoragePanel.BackgroundTransparency = 1
	
	TweenService:Create(StoragePanel, TweenInfo.new(UI_CONFIG.TWEEN_TIME, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		BackgroundTransparency = 0
	}):Play()
	
	print("StorageUpgradeUI: Opened")
end

local function hidePanel()
	if not PanelVisible then return end
	if not StoragePanel then return end
	
	PanelVisible = false
	
	local tween = TweenService:Create(StoragePanel, TweenInfo.new(UI_CONFIG.TWEEN_TIME, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
		BackgroundTransparency = 1
	})
	
	tween:Play()
	tween.Completed:Connect(function()
		if not PanelVisible then
			StoragePanel.Visible = false
		end
	end)
	
	print("StorageUpgradeUI: Closed")
end

local function handleUpgrade()
	if not canAfford() then
		ErrorSound:Play()
		return
	end
	
	local success, message = UpgradeStorageRemote:InvokeServer()
	
	if success then
		UpgradeSound:Play()
		
		-- Visual feedback - flash the panel green
		if StoragePanel then
			local originalColor = StoragePanel.BackgroundColor3
			StoragePanel.BackgroundColor3 = Color3.fromRGB(80, 150, 80)
			task.delay(0.2, function()
				TweenService:Create(StoragePanel, TweenInfo.new(0.3), {BackgroundColor3 = originalColor}):Play()
			end)
		end
		
		print("StorageUpgradeUI: Upgrade successful!")
	else
		ErrorSound:Play()
		warn("StorageUpgradeUI: Upgrade failed - " .. tostring(message))
	end
end

--------------------------------------------------------------------------------
-- SETUP CONNECTIONS
--------------------------------------------------------------------------------

local function setupConnections()
	if not StoragePanel then return end
	
	-- Close button
	local closeButton = StoragePanel:FindFirstChild("CloseButton")
	if closeButton then
		closeButton.MouseButton1Click:Connect(hidePanel)
	end
	
	-- Buy button
	local buyFrame = StoragePanel:FindFirstChild("BuyFrame")
	if buyFrame then
		local buyButton = buyFrame:FindFirstChild("BuyButton")
		if buyButton then
			buyButton.MouseButton1Click:Connect(handleUpgrade)
			
			-- Hover effects
			buyButton.MouseEnter:Connect(function()
				if canAfford() then
					TweenService:Create(buyButton, TweenInfo.new(0.1), {
						BackgroundColor3 = UI_CONFIG.BUTTON_HOVER_COLOR
					}):Play()
				end
			end)
			
			buyButton.MouseLeave:Connect(function()
				local color = canAfford() and UI_CONFIG.BUTTON_COLOR or UI_CONFIG.BUTTON_DISABLED_COLOR
				TweenService:Create(buyButton, TweenInfo.new(0.1), {
					BackgroundColor3 = color
				}):Play()
			end)
		end
	end
	
	-- Listen for storage upgraded event
	StorageUpgradedEvent.OnClientEvent:Connect(function(newInfo)
		CurrentStorageInfo = newInfo
		updateUI()
	end)
	
	-- Update affordability when money changes
	local leaderstats = Player:WaitForChild("leaderstats", 10)
	if leaderstats then
		local money = leaderstats:WaitForChild("Money", 5)
		if money then
			money:GetPropertyChangedSignal("Value"):Connect(updateUI)
		end
	end
end

local function setupStorageVendorPrompt()
	local mainIsland = workspace:WaitForChild("MainIsland", 30)
	if not mainIsland then
		warn("StorageUpgradeUI: MainIsland not found")
		return
	end
	
	local storageVendor = mainIsland:WaitForChild("StorageVendor", 30)
	if not storageVendor then
		warn("StorageUpgradeUI: StorageVendor not found")
		return
	end
	
	local prompt = storageVendor:WaitForChild("StoragePrompt", 10)
	if prompt then
		prompt.Triggered:Connect(function(playerWhoTriggered)
			if playerWhoTriggered == Player then
				showPanel()
			end
		end)
		print("StorageUpgradeUI: Connected to StorageVendor prompt")
	end
end

-- Close when walking away
local function setupDistanceCheck()
	local RunService = game:GetService("RunService")
	
	RunService.Heartbeat:Connect(function()
		if not PanelVisible then return end
		
		local character = Player.Character
		local hrp = character and character:FindFirstChild("HumanoidRootPart")
		if not hrp then return end
		
		local mainIsland = workspace:FindFirstChild("MainIsland")
		local storageVendor = mainIsland and mainIsland:FindFirstChild("StorageVendor")
		if not storageVendor then return end
		
		local distance = (hrp.Position - storageVendor.Position).Magnitude
		if distance > 20 then
			hidePanel()
		end
	end)
end

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

local function initialize()
	print("StorageUpgradeUI: Initializing...")
	
	-- Create the UI
	StorageGui = createStorageUpgradeGui()
	if not StorageGui then return end
	
	StoragePanel = StorageGui:FindFirstChild("StoragePanel") :: Frame?
	
	-- Setup connections
	setupConnections()
	
	-- Parent GUI
	StorageGui.Parent = PlayerGui
	
	-- Setup vendor prompt listener
	task.spawn(setupStorageVendorPrompt)
	setupDistanceCheck()
	
	print("StorageUpgradeUI: Ready!")
end

-- Start
initialize()


================================================================================
FILE: src\client\SynergyHUD.client.luau
================================================================================

--[[
	SynergyHUD LocalScript
	
	Displays synergy requirements and progress in a dedicated HUD panel.
	Shows required brainrots with current/required counts and the resulting bonuses.
	
	Features:
	- Visual display of synergy requirements
	- Progress indicators (X/Y) in corner of each requirement
	- Active/Inactive synergy state
	- Effect descriptions when synergy is active
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

-- Player reference
local Player = Players.LocalPlayer
local PlayerGui = Player:WaitForChild("PlayerGui")

-- Wait for shared modules and remotes
local SynergyConfig = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("SynergyConfig"))
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local GetInventoryRemote = RemoteEvents:WaitForChild("GetInventory")
local InventoryChangedEvent = RemoteEvents:WaitForChild("InventoryChanged")

--------------------------------------------------------------------------------
-- UI CONFIGURATION
--------------------------------------------------------------------------------

local UI_CONFIG = {
	-- Panel styling
	PANEL_WIDTH = 300,
	PANEL_MARGIN = 20,
	CORNER_RADIUS = 12,
	
	-- Synergy card styling
	CARD_HEIGHT = 140,
	REQUIREMENT_SIZE = 60,
	
	-- Colors
	BACKGROUND_COLOR = Color3.fromRGB(30, 25, 45),
	PANEL_COLOR = Color3.fromRGB(45, 35, 60),
	CARD_COLOR = Color3.fromRGB(55, 45, 75),
	ACCENT_COLOR = Color3.fromRGB(255, 200, 100),
	ACTIVE_COLOR = Color3.fromRGB(100, 255, 100),
	INACTIVE_COLOR = Color3.fromRGB(150, 150, 150),
	TEXT_COLOR = Color3.fromRGB(255, 255, 255),
	SECONDARY_TEXT_COLOR = Color3.fromRGB(180, 180, 180),
	REQUIREMENT_MET_COLOR = Color3.fromRGB(80, 180, 80),
	REQUIREMENT_UNMET_COLOR = Color3.fromRGB(100, 80, 120),
	
	-- Rarity colors for requirement boxes
	RARITY_COLORS = {
		Normal = Color3.fromRGB(180, 180, 180),
		Spicy = Color3.fromRGB(255, 80, 80),
		Galaxy = Color3.fromRGB(180, 100, 255),
	},
}

--------------------------------------------------------------------------------
-- LOCAL STATE
--------------------------------------------------------------------------------

local SynergyGui: ScreenGui? = nil
local SynergyCards: {[string]: Frame} = {}
local InventoryData: {[string]: {[string]: {total: number, active: number}}} = {}
local SynergyVisible = false

--------------------------------------------------------------------------------
-- UI CREATION HELPERS
--------------------------------------------------------------------------------

local function addCorner(parent: GuiObject, radius: number)
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, radius)
	corner.Parent = parent
	return corner
end

local function addStroke(parent: GuiObject, color: Color3, thickness: number)
	local stroke = Instance.new("UIStroke")
	stroke.Color = color
	stroke.Thickness = thickness
	stroke.Parent = parent
	return stroke
end

--------------------------------------------------------------------------------
-- SYNERGY CARD CREATION
--------------------------------------------------------------------------------

local function createRequirementBox(req: SynergyConfig.SynergyRequirement, current: number): Frame
	local isMet = current >= req.MinCount
	local rarityColor = req.Rarity and UI_CONFIG.RARITY_COLORS[req.Rarity] or UI_CONFIG.TEXT_COLOR
	
	local box = Instance.new("Frame")
	box.Name = req.UnitName
	box.Size = UDim2.new(0, UI_CONFIG.REQUIREMENT_SIZE, 0, UI_CONFIG.REQUIREMENT_SIZE + 16)
	box.BackgroundTransparency = 1
	
	-- Icon box
	local iconFrame = Instance.new("Frame")
	iconFrame.Name = "IconFrame"
	iconFrame.Size = UDim2.new(0, UI_CONFIG.REQUIREMENT_SIZE, 0, UI_CONFIG.REQUIREMENT_SIZE)
	iconFrame.BackgroundColor3 = isMet and UI_CONFIG.REQUIREMENT_MET_COLOR or UI_CONFIG.REQUIREMENT_UNMET_COLOR
	iconFrame.Parent = box
	addCorner(iconFrame, 8)
	addStroke(iconFrame, rarityColor, req.Rarity and 2 or 1)
	
	-- Brainrot icon
	local iconLabel = Instance.new("TextLabel")
	iconLabel.Name = "Icon"
	iconLabel.Size = UDim2.new(1, 0, 1, -20)
	iconLabel.Position = UDim2.new(0, 0, 0, 0)
	iconLabel.BackgroundTransparency = 1
	iconLabel.Text = "ðŸ§ "
	iconLabel.TextSize = 28
	iconLabel.Font = Enum.Font.GothamBold
	iconLabel.TextColor3 = rarityColor
	iconLabel.Parent = iconFrame
	
	-- Count badge (bottom right corner)
	local countBadge = Instance.new("Frame")
	countBadge.Name = "CountBadge"
	countBadge.Size = UDim2.new(0, 36, 0, 18)
	countBadge.Position = UDim2.new(1, -38, 1, -20)
	countBadge.BackgroundColor3 = isMet and UI_CONFIG.ACTIVE_COLOR or UI_CONFIG.BACKGROUND_COLOR
	countBadge.Parent = iconFrame
	addCorner(countBadge, 4)
	
	local countLabel = Instance.new("TextLabel")
	countLabel.Name = "Count"
	countLabel.Size = UDim2.new(1, 0, 1, 0)
	countLabel.BackgroundTransparency = 1
	countLabel.Text = string.format("%d/%d", current, req.MinCount)
	countLabel.TextColor3 = UI_CONFIG.TEXT_COLOR
	countLabel.TextSize = 10
	countLabel.Font = Enum.Font.GothamBold
	countLabel.Parent = countBadge
	
	-- Unit name label below
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Name = "UnitName"
	nameLabel.Size = UDim2.new(1, 0, 0, 16)
	nameLabel.Position = UDim2.new(0, 0, 1, -14)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = req.UnitName:sub(1, 10) .. (req.UnitName:len() > 10 and "..." or "")
	nameLabel.TextColor3 = UI_CONFIG.SECONDARY_TEXT_COLOR
	nameLabel.TextSize = 8
	nameLabel.Font = Enum.Font.Gotham
	nameLabel.TextTruncate = Enum.TextTruncate.AtEnd
	nameLabel.Parent = box
	
	-- Rarity label if applicable
	if req.Rarity then
		local rarityLabel = Instance.new("TextLabel")
		rarityLabel.Name = "Rarity"
		rarityLabel.Size = UDim2.new(1, 0, 0, 12)
		rarityLabel.Position = UDim2.new(0, 0, 0, 2)
		rarityLabel.BackgroundTransparency = 1
		rarityLabel.Text = req.Rarity
		rarityLabel.TextColor3 = rarityColor
		rarityLabel.TextSize = 9
		rarityLabel.Font = Enum.Font.GothamBold
		rarityLabel.Parent = iconFrame
	end
	
	return box
end

local function createSynergyCard(synergy: SynergyConfig.SynergyDefinition): Frame
	local card = Instance.new("Frame")
	card.Name = synergy.Id
	card.Size = UDim2.new(1, 0, 0, UI_CONFIG.CARD_HEIGHT)
	card.BackgroundColor3 = UI_CONFIG.CARD_COLOR
	card.BorderSizePixel = 0
	addCorner(card, 10)
	
	-- Header with icon and name
	local header = Instance.new("Frame")
	header.Name = "Header"
	header.Size = UDim2.new(1, 0, 0, 30)
	header.BackgroundTransparency = 1
	header.Parent = card
	
	local iconLabel = Instance.new("TextLabel")
	iconLabel.Name = "Icon"
	iconLabel.Size = UDim2.new(0, 30, 1, 0)
	iconLabel.Position = UDim2.new(0, 8, 0, 0)
	iconLabel.BackgroundTransparency = 1
	iconLabel.Text = synergy.Icon
	iconLabel.TextSize = 20
	iconLabel.Font = Enum.Font.GothamBold
	iconLabel.Parent = header
	
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Name = "Name"
	nameLabel.Size = UDim2.new(1, -100, 1, 0)
	nameLabel.Position = UDim2.new(0, 40, 0, 0)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = synergy.Name
	nameLabel.TextColor3 = UI_CONFIG.ACCENT_COLOR
	nameLabel.TextSize = 14
	nameLabel.Font = Enum.Font.GothamBold
	nameLabel.TextXAlignment = Enum.TextXAlignment.Left
	nameLabel.Parent = header
	
	-- Status badge
	local statusBadge = Instance.new("Frame")
	statusBadge.Name = "StatusBadge"
	statusBadge.Size = UDim2.new(0, 60, 0, 20)
	statusBadge.Position = UDim2.new(1, -68, 0.5, -10)
	statusBadge.BackgroundColor3 = UI_CONFIG.INACTIVE_COLOR
	statusBadge.Parent = header
	addCorner(statusBadge, 4)
	
	local statusLabel = Instance.new("TextLabel")
	statusLabel.Name = "StatusText"
	statusLabel.Size = UDim2.new(1, 0, 1, 0)
	statusLabel.BackgroundTransparency = 1
	statusLabel.Text = "LOCKED"
	statusLabel.TextColor3 = UI_CONFIG.TEXT_COLOR
	statusLabel.TextSize = 10
	statusLabel.Font = Enum.Font.GothamBold
	statusLabel.Parent = statusBadge
	
	-- Requirements container
	local reqContainer = Instance.new("Frame")
	reqContainer.Name = "Requirements"
	reqContainer.Size = UDim2.new(1, -16, 0, UI_CONFIG.REQUIREMENT_SIZE + 20)
	reqContainer.Position = UDim2.new(0, 8, 0, 32)
	reqContainer.BackgroundTransparency = 1
	reqContainer.Parent = card
	
	local reqLayout = Instance.new("UIListLayout")
	reqLayout.FillDirection = Enum.FillDirection.Horizontal
	reqLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	reqLayout.Padding = UDim.new(0, 20)
	reqLayout.Parent = reqContainer
	
	-- Add "+" sign between requirements
	for i, req in synergy.Requirements do
		if i > 1 then
			local plusLabel = Instance.new("TextLabel")
			plusLabel.Name = "Plus" .. i
			plusLabel.Size = UDim2.new(0, 20, 0, UI_CONFIG.REQUIREMENT_SIZE)
			plusLabel.BackgroundTransparency = 1
			plusLabel.Text = "+"
			plusLabel.TextColor3 = UI_CONFIG.SECONDARY_TEXT_COLOR
			plusLabel.TextSize = 24
			plusLabel.Font = Enum.Font.GothamBold
			plusLabel.LayoutOrder = (i - 1) * 2
			plusLabel.Parent = reqContainer
		end
		
		local reqBox = createRequirementBox(req, 0)
		reqBox.LayoutOrder = i * 2
		reqBox.Parent = reqContainer
	end
	
	-- Effect description
	local effectLabel = Instance.new("TextLabel")
	effectLabel.Name = "Effect"
	effectLabel.Size = UDim2.new(1, -16, 0, 28)
	effectLabel.Position = UDim2.new(0, 8, 1, -32)
	effectLabel.BackgroundColor3 = UI_CONFIG.BACKGROUND_COLOR
	effectLabel.Text = "â–¶ " .. synergy.Description
	effectLabel.TextColor3 = UI_CONFIG.SECONDARY_TEXT_COLOR
	effectLabel.TextSize = 11
	effectLabel.Font = Enum.Font.GothamMedium
	effectLabel.Parent = card
	addCorner(effectLabel, 4)
	
	return card
end

--------------------------------------------------------------------------------
-- UPDATE LOGIC
--------------------------------------------------------------------------------

local function updateSynergyCard(synergyId: string)
	local card = SynergyCards[synergyId]
	if not card then return end
	
	local synergy = SynergyConfig.GetSynergy(synergyId)
	if not synergy then return end
	
	local isActive, progress = SynergyConfig.CheckSynergyProgress(synergyId, InventoryData)
	
	-- Update status badge
	local header = card:FindFirstChild("Header")
	if header then
		local statusBadge = header:FindFirstChild("StatusBadge")
		if statusBadge then
			statusBadge.BackgroundColor3 = isActive and UI_CONFIG.ACTIVE_COLOR or UI_CONFIG.INACTIVE_COLOR
			local statusText = statusBadge:FindFirstChild("StatusText")
			if statusText then
				statusText.Text = isActive and "ACTIVE" or "LOCKED"
			end
		end
	end
	
	-- Update requirement boxes
	local reqContainer = card:FindFirstChild("Requirements")
	if reqContainer then
		for _, req in synergy.Requirements do
			local key = req.UnitName .. (req.Rarity and ("_" .. req.Rarity) or "")
			local progData = progress[key]
			local current = progData and progData.current or 0
			local isMet = current >= req.MinCount
			
			-- Find the requirement box
			for _, child in reqContainer:GetChildren() do
				if child.Name == req.UnitName then
					local iconFrame = child:FindFirstChild("IconFrame")
					if iconFrame then
						-- Update background color
						iconFrame.BackgroundColor3 = isMet and UI_CONFIG.REQUIREMENT_MET_COLOR or UI_CONFIG.REQUIREMENT_UNMET_COLOR
						
						-- Update count badge
						local countBadge = iconFrame:FindFirstChild("CountBadge")
						if countBadge then
							countBadge.BackgroundColor3 = isMet and UI_CONFIG.ACTIVE_COLOR or UI_CONFIG.BACKGROUND_COLOR
							local countLabel = countBadge:FindFirstChild("Count")
							if countLabel then
								countLabel.Text = string.format("%d/%d", current, req.MinCount)
							end
						end
					end
					break
				end
			end
		end
	end
	
	-- Update effect label style
	local effectLabel = card:FindFirstChild("Effect")
	if effectLabel then
		effectLabel.TextColor3 = isActive and UI_CONFIG.ACTIVE_COLOR or UI_CONFIG.SECONDARY_TEXT_COLOR
	end
	
	-- Add glow effect when active
	local existingStroke = card:FindFirstChildOfClass("UIStroke")
	if existingStroke then
		existingStroke:Destroy()
	end
	if isActive then
		addStroke(card, UI_CONFIG.ACTIVE_COLOR, 2)
	end
end

local function updateAllSynergies()
	for synergyId, _ in SynergyCards do
		updateSynergyCard(synergyId)
	end
end

--------------------------------------------------------------------------------
-- SYNERGY HUD CREATION
--------------------------------------------------------------------------------

local function createSynergyHUD(): ScreenGui
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "SynergyHUD"
	screenGui.ResetOnSpawn = false
	screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	
	-- Main panel (bottom left)
	local panel = Instance.new("Frame")
	panel.Name = "SynergyPanel"
	panel.Size = UDim2.new(0, UI_CONFIG.PANEL_WIDTH, 0, 0) -- Height auto-calculated
	panel.Position = UDim2.new(0, UI_CONFIG.PANEL_MARGIN, 1, -UI_CONFIG.PANEL_MARGIN)
	panel.AnchorPoint = Vector2.new(0, 1)
	panel.BackgroundColor3 = UI_CONFIG.PANEL_COLOR
	panel.BackgroundTransparency = 0.1
	panel.BorderSizePixel = 0
	panel.Visible = false
	panel.Parent = screenGui
	addCorner(panel, UI_CONFIG.CORNER_RADIUS)
	addStroke(panel, UI_CONFIG.ACCENT_COLOR, 2)
	
	-- Title
	local titleBar = Instance.new("Frame")
	titleBar.Name = "TitleBar"
	titleBar.Size = UDim2.new(1, 0, 0, 36)
	titleBar.BackgroundColor3 = UI_CONFIG.BACKGROUND_COLOR
	titleBar.BorderSizePixel = 0
	titleBar.Parent = panel
	addCorner(titleBar, UI_CONFIG.CORNER_RADIUS)
	
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "Title"
	titleLabel.Size = UDim2.new(1, -50, 1, 0)
	titleLabel.Position = UDim2.new(0, 12, 0, 0)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Text = "âš¡ SYNERGIES"
	titleLabel.TextColor3 = UI_CONFIG.ACCENT_COLOR
	titleLabel.TextSize = 16
	titleLabel.Font = Enum.Font.GothamBold
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	titleLabel.Parent = titleBar
	
	-- Close button
	local closeButton = Instance.new("TextButton")
	closeButton.Name = "CloseButton"
	closeButton.Size = UDim2.new(0, 28, 0, 28)
	closeButton.Position = UDim2.new(1, -34, 0.5, -14)
	closeButton.BackgroundColor3 = Color3.fromRGB(180, 80, 80)
	closeButton.Text = "âœ•"
	closeButton.TextColor3 = UI_CONFIG.TEXT_COLOR
	closeButton.TextSize = 14
	closeButton.Font = Enum.Font.GothamBold
	closeButton.Parent = titleBar
	addCorner(closeButton, 6)
	
	-- Content container
	local content = Instance.new("Frame")
	content.Name = "Content"
	content.Size = UDim2.new(1, -16, 1, -44)
	content.Position = UDim2.new(0, 8, 0, 40)
	content.BackgroundTransparency = 1
	content.Parent = panel
	
	local layout = Instance.new("UIListLayout")
	layout.SortOrder = Enum.SortOrder.LayoutOrder
	layout.Padding = UDim.new(0, 8)
	layout.Parent = content
	
	-- Create synergy cards
	local synergies = SynergyConfig.GetAllSynergies()
	for i, synergy in synergies do
		local card = createSynergyCard(synergy)
		card.LayoutOrder = i
		card.Parent = content
		SynergyCards[synergy.Id] = card
	end
	
	-- Calculate panel height
	local totalHeight = 44 + 8 -- Title + padding
	for _, synergy in synergies do
		totalHeight = totalHeight + UI_CONFIG.CARD_HEIGHT + 8
	end
	panel.Size = UDim2.new(0, UI_CONFIG.PANEL_WIDTH, 0, totalHeight)
	
	return screenGui
end

--------------------------------------------------------------------------------
-- VISIBILITY CONTROL
--------------------------------------------------------------------------------

local function openSynergyHUD()
	if SynergyVisible then return end
	if not SynergyGui then return end
	local panel = SynergyGui:FindFirstChild("SynergyPanel")
	if not panel then return end
	
	SynergyVisible = true
	
	-- Refresh inventory data
	local inventoryResult = GetInventoryRemote:InvokeServer()
	if inventoryResult then
		-- Handle both new format {[unitName]: {level, rarity, status}} and old format
		if inventoryResult.units then
			local convertedInventory = {}
			for unitName, unitData in pairs(inventoryResult.units) do
				if type(unitData) == "table" then
					-- New format: {level, rarity, status}
					if unitData.level then
						local rarity = unitData.rarity or "Normal"
						if not convertedInventory[unitName] then
							convertedInventory[unitName] = {}
						end
						convertedInventory[unitName][rarity] = {
							total = unitData.level, -- Level = how many times purchased
							active = unitData.status == "placed" and 1 or 0,
						}
					else
						-- Old format, use as-is
						convertedInventory[unitName] = unitData
					end
				end
			end
			InventoryData = convertedInventory
		else
			-- Direct inventory data (old format)
			InventoryData = inventoryResult
		end
		updateAllSynergies()
	end
	
	panel.Visible = true
	panel.Position = UDim2.new(0, -UI_CONFIG.PANEL_WIDTH, 1, -UI_CONFIG.PANEL_MARGIN)
	TweenService:Create(panel, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Position = UDim2.new(0, UI_CONFIG.PANEL_MARGIN, 1, -UI_CONFIG.PANEL_MARGIN)
	}):Play()
end

local function closeSynergyHUD()
	if not SynergyVisible then return end
	if not SynergyGui then return end
	local panel = SynergyGui:FindFirstChild("SynergyPanel")
	if not panel then return end
	
	SynergyVisible = false
	
	local tween = TweenService:Create(panel, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Position = UDim2.new(0, -UI_CONFIG.PANEL_WIDTH, 1, -UI_CONFIG.PANEL_MARGIN)
	})
	tween:Play()
	tween.Completed:Connect(function()
		if not SynergyVisible then
			panel.Visible = false
		end
	end)
end

local function toggleSynergyHUD()
	if SynergyVisible then
		closeSynergyHUD()
	else
		openSynergyHUD()
	end
end

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

local function initialize()
	print("SynergyHUD: Initializing...")
	
	-- Create the HUD
	SynergyGui = createSynergyHUD()
	if not SynergyGui then return end
	SynergyGui.Parent = PlayerGui
	
	-- Setup close button
	local panel = SynergyGui:FindFirstChild("SynergyPanel")
	if panel then
		local titleBar = panel:FindFirstChild("TitleBar")
		if titleBar then
			local closeButton = titleBar:FindFirstChild("CloseButton")
			if closeButton then
				closeButton.MouseButton1Click:Connect(closeSynergyHUD)
				
				closeButton.MouseEnter:Connect(function()
					TweenService:Create(closeButton, TweenInfo.new(0.1), {
						BackgroundColor3 = Color3.fromRGB(220, 100, 100)
					}):Play()
				end)
				
				closeButton.MouseLeave:Connect(function()
					TweenService:Create(closeButton, TweenInfo.new(0.1), {
						BackgroundColor3 = Color3.fromRGB(180, 80, 80)
					}):Play()
				end)
			end
		end
	end
	
	-- Listen for inventory changes to update synergy progress
	-- The new system fires with no arguments, so we re-fetch inventory when notified
	InventoryChangedEvent.OnClientEvent:Connect(function()
		-- Re-fetch inventory from server
		local inventoryResult = GetInventoryRemote:InvokeServer()
		if inventoryResult then
			-- Handle both new format {[unitName]: {level, rarity, status}} and old format
			if inventoryResult.units then
				-- Convert new format to old format for synergy compatibility
				local convertedInventory = {}
				for unitName, unitData in pairs(inventoryResult.units) do
					if type(unitData) == "table" then
						-- New format: {level, rarity, status}
						if unitData.level then
							local rarity = unitData.rarity or "Normal"
							if not convertedInventory[unitName] then
								convertedInventory[unitName] = {}
							end
							convertedInventory[unitName][rarity] = {
								total = unitData.level, -- Level = how many times purchased
								active = unitData.status == "placed" and 1 or 0,
							}
						else
							-- Old format, use as-is
							convertedInventory[unitName] = unitData
						end
					end
				end
				InventoryData = convertedInventory
			else
				-- Direct inventory data (old format)
				InventoryData = inventoryResult
			end
		end
		
		if SynergyVisible then
			updateAllSynergies()
		end
	end)
	
	-- Setup 'Y' key toggle
	UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed then return end
		
		if input.KeyCode == Enum.KeyCode.Y then
			toggleSynergyHUD()
		end
	end)
	
	-- Setup BindableEvent listener
	task.wait(0.5)
	
	local synergyToggleEvent = ReplicatedStorage:FindFirstChild("SynergyToggleEvent")
	if not synergyToggleEvent then
		synergyToggleEvent = Instance.new("BindableEvent")
		synergyToggleEvent.Name = "SynergyToggleEvent"
		synergyToggleEvent.Parent = ReplicatedStorage
	end
	
	synergyToggleEvent.Event:Connect(toggleSynergyHUD)
	
	print("SynergyHUD: Ready! Press 'Y' to toggle.")
end

-- Start
initialize()


================================================================================
FILE: src\client\TransportUI.client.luau
================================================================================

--[[
	TransportUI Client Script
	
	Handles the storage loading UI for the physical Cart system.
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

-- Get player
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- Wait for remotes
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local RemoteFunctions = ReplicatedStorage:WaitForChild("RemoteFunctions")

-- Storage events
local StorageUpdatedEvent = RemoteEvents:WaitForChild("StorageUpdated")
local CartUpdateEvent = RemoteEvents:WaitForChild("CartUpdate") -- Changed from BackpackUpdated
local GetStorageFunction = RemoteFunctions:WaitForChild("GetStorage")

-- Transport events
local LoadFromStorageFunction = RemoteFunctions:WaitForChild("LoadFromStorage")
local LoadMaxFromStorageFunction = RemoteFunctions:WaitForChild("LoadMaxFromStorage")

-- Wait for ItemConfig
local Shared = ReplicatedStorage:WaitForChild("Shared")
local ItemConfig = require(Shared:WaitForChild("ItemConfig"))

-- UI Colors (glassmorphism theme)
local COLORS = {
	background = Color3.fromRGB(15, 15, 25),
	panel = Color3.fromRGB(25, 25, 40),
	accent = Color3.fromRGB(100, 200, 255),
	accentDark = Color3.fromRGB(60, 140, 200),
	text = Color3.fromRGB(255, 255, 255),
	textMuted = Color3.fromRGB(150, 150, 170),
	success = Color3.fromRGB(100, 255, 150),
	warning = Color3.fromRGB(255, 200, 100),
	danger = Color3.fromRGB(255, 100, 100),
	itemBg = Color3.fromRGB(35, 35, 55),
}

-- State
local isOpen = false
local currentStorage = {}
local currentCart = {} -- Changed from Backpack
local storageCapacity = 0 -- Updated via Player Attribute
local storageUsage = 0
local cartCapacity = 0 -- Updated via Player Attribute
local cartState = "idle"

-- UI References
local screenGui = nil
local mainFrame = nil

--------------------------------------------------------------------------------
-- UI CREATION
--------------------------------------------------------------------------------

local function createScreenGui()
	local gui = Instance.new("ScreenGui")
	gui.Name = "TransportUI"
	gui.ResetOnSpawn = false
	gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	gui.Parent = PlayerGui
	return gui
end

local function createMainFrame(parent)
	local frame = Instance.new("Frame")
	frame.Name = "MainFrame"
	frame.Size = UDim2.new(0, 700, 0, 500)
	frame.Position = UDim2.new(0.5, -350, 0.5, -250)
	frame.BackgroundColor3 = COLORS.background
	frame.BackgroundTransparency = 0.1
	frame.BorderSizePixel = 0
	frame.Visible = false
	frame.Parent = parent
	
	-- Corner rounding
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 16)
	corner.Parent = frame
	
	-- Stroke
	local stroke = Instance.new("UIStroke")
	stroke.Color = COLORS.accent
	stroke.Thickness = 2
	stroke.Transparency = 0.5
	stroke.Parent = frame
	
	return frame
end

local function createHeader(parent)
	local header = Instance.new("Frame")
	header.Name = "Header"
	header.Size = UDim2.new(1, 0, 0, 50)
	header.BackgroundColor3 = COLORS.panel
	header.BackgroundTransparency = 0.3
	header.BorderSizePixel = 0
	header.Parent = parent
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 16)
	corner.Parent = header
	
	-- Title
	local title = Instance.new("TextLabel")
	title.Name = "Title"
	title.Size = UDim2.new(1, -60, 1, 0)
	title.Position = UDim2.new(0, 20, 0, 0)
	title.BackgroundTransparency = 1
	title.Text = "ðŸ“¦ STORAGE & LOADING"
	title.TextColor3 = COLORS.text
	title.TextSize = 22
	title.Font = Enum.Font.GothamBold
	title.TextXAlignment = Enum.TextXAlignment.Left
	title.Parent = header
	
	-- Close button
	local closeBtn = Instance.new("TextButton")
	closeBtn.Name = "CloseButton"
	closeBtn.Size = UDim2.new(0, 40, 0, 40)
	closeBtn.Position = UDim2.new(1, -45, 0, 5)
	closeBtn.BackgroundColor3 = COLORS.danger
	closeBtn.BackgroundTransparency = 0.7
	closeBtn.Text = "âœ•"
	closeBtn.TextColor3 = COLORS.text
	closeBtn.TextSize = 18
	closeBtn.Font = Enum.Font.GothamBold
	closeBtn.Parent = header
	
	local closeCorner = Instance.new("UICorner")
	closeCorner.CornerRadius = UDim.new(0, 8)
	closeCorner.Parent = closeBtn
	
	closeBtn.MouseButton1Click:Connect(function()
		closeUI()
	end)
	
	return header
end

local function createStoragePanel(parent)
	local panel = Instance.new("Frame")
	panel.Name = "StoragePanel"
	panel.Size = UDim2.new(0.5, -15, 1, -120)
	panel.Position = UDim2.new(0, 10, 0, 60)
	panel.BackgroundColor3 = COLORS.panel
	panel.BackgroundTransparency = 0.5
	panel.BorderSizePixel = 0
	panel.Parent = parent
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 12)
	corner.Parent = panel
	
	-- Panel title
	local title = Instance.new("TextLabel")
	title.Name = "Title"
	title.Size = UDim2.new(1, -20, 0, 30)
	title.Position = UDim2.new(0, 10, 0, 10)
	title.BackgroundTransparency = 1
	title.Text = "ðŸ­ PLOT STORAGE"
	title.TextColor3 = COLORS.accent
	title.TextSize = 16
	title.Font = Enum.Font.GothamBold
	title.TextXAlignment = Enum.TextXAlignment.Left
	title.Parent = panel
	
	-- Capacity bar
	local capacityBar = Instance.new("Frame")
	capacityBar.Name = "CapacityBar"
	capacityBar.Size = UDim2.new(1, -20, 0, 20)
	capacityBar.Position = UDim2.new(0, 10, 0, 45)
	capacityBar.BackgroundColor3 = COLORS.itemBg
	capacityBar.BorderSizePixel = 0
	capacityBar.Parent = panel
	
	local capCorner = Instance.new("UICorner")
	capCorner.CornerRadius = UDim.new(0, 6)
	capCorner.Parent = capacityBar
	
	local capacityFill = Instance.new("Frame")
	capacityFill.Name = "Fill"
	capacityFill.Size = UDim2.new(0, 0, 1, 0)
	capacityFill.BackgroundColor3 = COLORS.accent
	capacityFill.BorderSizePixel = 0
	capacityFill.Parent = capacityBar
	
	local fillCorner = Instance.new("UICorner")
	fillCorner.CornerRadius = UDim.new(0, 6)
	fillCorner.Parent = capacityFill
	
	local capacityText = Instance.new("TextLabel")
	capacityText.Name = "Text"
	capacityText.Size = UDim2.new(1, 0, 1, 0)
	capacityText.BackgroundTransparency = 1
	capacityText.Text = "0 / 0"
	capacityText.TextColor3 = COLORS.text
	capacityText.TextSize = 12
	capacityText.Font = Enum.Font.GothamBold
	capacityText.Parent = capacityBar
	
	-- Item list scroll
	local scrollFrame = Instance.new("ScrollingFrame")
	scrollFrame.Name = "ItemList"
	scrollFrame.Size = UDim2.new(1, -20, 1, -80)
	scrollFrame.Position = UDim2.new(0, 10, 0, 75)
	scrollFrame.BackgroundTransparency = 1
	scrollFrame.ScrollBarThickness = 4
	scrollFrame.ScrollBarImageColor3 = COLORS.accent
	scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
	scrollFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
	scrollFrame.Parent = panel
	
	local listLayout = Instance.new("UIListLayout")
	listLayout.Padding = UDim.new(0, 5)
	listLayout.Parent = scrollFrame
	
	return panel
end

local function createCartPanel(parent)
	local panel = Instance.new("Frame")
	panel.Name = "CartPanel"
	panel.Size = UDim2.new(0.5, -15, 1, -120)
	panel.Position = UDim2.new(0.5, 5, 0, 60)
	panel.BackgroundColor3 = COLORS.panel
	panel.BackgroundTransparency = 0.5
	panel.BorderSizePixel = 0
	panel.Parent = parent
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 12)
	corner.Parent = panel
	
	-- Panel title
	local title = Instance.new("TextLabel")
	title.Name = "Title"
	title.Size = UDim2.new(1, -20, 0, 30)
	title.Position = UDim2.new(0, 10, 0, 10)
	title.BackgroundTransparency = 1
	title.Text = "ðŸ›’ TRANSPORT CART"
	title.TextColor3 = COLORS.success
	title.TextSize = 16
	title.Font = Enum.Font.GothamBold
	title.TextXAlignment = Enum.TextXAlignment.Left
	title.Parent = panel
	
	-- Capacity bar
	local capacityBar = Instance.new("Frame")
	capacityBar.Name = "CapacityBar"
	capacityBar.Size = UDim2.new(1, -20, 0, 20)
	capacityBar.Position = UDim2.new(0, 10, 0, 45)
	capacityBar.BackgroundColor3 = COLORS.itemBg
	capacityBar.BorderSizePixel = 0
	capacityBar.Parent = panel
	
	local capCorner = Instance.new("UICorner")
	capCorner.CornerRadius = UDim.new(0, 6)
	capCorner.Parent = capacityBar
	
	local capacityFill = Instance.new("Frame")
	capacityFill.Name = "Fill"
	capacityFill.Size = UDim2.new(0, 0, 1, 0)
	capacityFill.BackgroundColor3 = COLORS.success
	capacityFill.BorderSizePixel = 0
	capacityFill.Parent = capacityBar
	
	local fillCorner = Instance.new("UICorner")
	fillCorner.CornerRadius = UDim.new(0, 6)
	fillCorner.Parent = capacityFill
	
	local capacityText = Instance.new("TextLabel")
	capacityText.Name = "Text"
	capacityText.Size = UDim2.new(1, 0, 1, 0)
	capacityText.BackgroundTransparency = 1
	capacityText.Text = "0 / 0"
	capacityText.TextColor3 = COLORS.text
	capacityText.TextSize = 12
	capacityText.Font = Enum.Font.GothamBold
	capacityText.Parent = capacityBar
	
	-- Action Button (Push/Return)
	local actionBtn = Instance.new("TextButton")
	actionBtn.Name = "ActionButton"
	actionBtn.Size = UDim2.new(1, -20, 0, 35)
	actionBtn.Position = UDim2.new(0, 10, 1, -45)
	actionBtn.BackgroundColor3 = COLORS.warning
	actionBtn.Text = "PUSH TO MARKET"
	actionBtn.TextColor3 = COLORS.background
	actionBtn.TextSize = 14
	actionBtn.Font = Enum.Font.GothamBold
	actionBtn.Visible = false
	actionBtn.Parent = panel
	
	local btnCorner = Instance.new("UICorner")
	btnCorner.CornerRadius = UDim.new(0, 8)
	btnCorner.Parent = actionBtn
	
	-- Connect Event
	actionBtn.MouseButton1Click:Connect(function()
		local PushCartRemote = RemoteEvents:FindFirstChild("PushCart")
		local ReturnCartRemote = RemoteEvents:FindFirstChild("ReturnCart")
		
		if cartState == "idle" and PushCartRemote then
			PushCartRemote:FireServer()
		elseif cartState == "at_market" and ReturnCartRemote then
			ReturnCartRemote:FireServer()
		end
		-- Close UI on action?
		closeUI()
	end)
	
	-- Item list scroll
	local scrollFrame = Instance.new("ScrollingFrame")
	scrollFrame.Name = "ItemList"
	scrollFrame.Size = UDim2.new(1, -20, 1, -135) -- Adjusted for button
	scrollFrame.Position = UDim2.new(0, 10, 0, 75)
	scrollFrame.BackgroundTransparency = 1
	scrollFrame.ScrollBarThickness = 4
	scrollFrame.ScrollBarImageColor3 = COLORS.success
	scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
	scrollFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
	scrollFrame.Parent = panel
	
	local listLayout = Instance.new("UIListLayout")
	listLayout.Padding = UDim.new(0, 5)
	listLayout.Parent = scrollFrame
	
	return panel
end

local function createBottomBar(parent)
	local bar = Instance.new("Frame")
	bar.Name = "BottomBar"
	bar.Size = UDim2.new(1, -20, 0, 50)
	bar.Position = UDim2.new(0, 10, 1, -55)
	bar.BackgroundColor3 = COLORS.panel
	bar.BackgroundTransparency = 0.5
	bar.BorderSizePixel = 0
	bar.Parent = parent
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 12)
	corner.Parent = bar
	
	-- Load Max button
	local loadMaxBtn = Instance.new("TextButton")
	loadMaxBtn.Name = "LoadMaxButton"
	loadMaxBtn.Size = UDim2.new(0, 200, 0, 40)
	loadMaxBtn.Position = UDim2.new(0.5, -100, 0.5, -20)
	loadMaxBtn.BackgroundColor3 = COLORS.accent
	loadMaxBtn.Text = "ðŸ“¦ LOAD TO CART"
	loadMaxBtn.TextColor3 = COLORS.text
	loadMaxBtn.TextSize = 16
	loadMaxBtn.Font = Enum.Font.GothamBold
	loadMaxBtn.Parent = bar
	
	local btnCorner = Instance.new("UICorner")
	btnCorner.CornerRadius = UDim.new(0, 8)
	btnCorner.Parent = loadMaxBtn
	
	loadMaxBtn.MouseButton1Click:Connect(function()
		LoadMaxFromStorageFunction:InvokeServer()
	end)
	
	-- Hover effect
	loadMaxBtn.MouseEnter:Connect(function()
		TweenService:Create(loadMaxBtn, TweenInfo.new(0.2), {BackgroundColor3 = COLORS.accentDark}):Play()
	end)
	
	loadMaxBtn.MouseLeave:Connect(function()
		TweenService:Create(loadMaxBtn, TweenInfo.new(0.2), {BackgroundColor3 = COLORS.accent}):Play()
	end)
	
	return bar
end

local function createItemRow(parent, itemId, count, isStorage)
	local itemInfo = ItemConfig.Items[itemId] or {}
	local tierEmoji = {"âšª", "ðŸŸ¡", "ðŸŸ ", "ðŸ’Ž"}
	local emoji = tierEmoji[itemInfo.tier or 1] or "âšª"
	
	local row = Instance.new("Frame")
	row.Name = "Item_" .. itemId
	row.Size = UDim2.new(1, 0, 0, 40)
	row.BackgroundColor3 = COLORS.itemBg
	row.BackgroundTransparency = 0.3
	row.BorderSizePixel = 0
	row.Parent = parent
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 8)
	corner.Parent = row
	
	-- Item name
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Name = "Name"
	nameLabel.Size = UDim2.new(0.5, -10, 1, 0)
	nameLabel.Position = UDim2.new(0, 10, 0, 0)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = emoji .. " " .. itemId
	nameLabel.TextColor3 = COLORS.text
	nameLabel.TextSize = 14
	nameLabel.Font = Enum.Font.Gotham
	nameLabel.TextXAlignment = Enum.TextXAlignment.Left
	nameLabel.TextTruncate = Enum.TextTruncate.AtEnd
	nameLabel.Parent = row
	
	-- Count
	local countLabel = Instance.new("TextLabel")
	countLabel.Name = "Count"
	countLabel.Size = UDim2.new(0, 60, 1, 0)
	countLabel.Position = UDim2.new(0.5, 0, 0, 0)
	countLabel.BackgroundTransparency = 1
	countLabel.Text = "x" .. count
	countLabel.TextColor3 = COLORS.textMuted
	countLabel.TextSize = 14
	countLabel.Font = Enum.Font.GothamBold
	countLabel.Parent = row
	
	-- Load button (only for storage items)
	if isStorage then
		local loadBtn = Instance.new("TextButton")
		loadBtn.Name = "LoadButton"
		loadBtn.Size = UDim2.new(0, 60, 0, 28)
		loadBtn.Position = UDim2.new(1, -70, 0.5, -14)
		loadBtn.BackgroundColor3 = COLORS.accent
		loadBtn.Text = "LOAD"
		loadBtn.TextColor3 = COLORS.text
		loadBtn.TextSize = 12
		loadBtn.Font = Enum.Font.GothamBold
		loadBtn.Parent = row
		
		local btnCorner = Instance.new("UICorner")
		btnCorner.CornerRadius = UDim.new(0, 6)
		btnCorner.Parent = loadBtn
		
		loadBtn.MouseButton1Click:Connect(function()
			LoadFromStorageFunction:InvokeServer(itemId, 10) -- Load 10 at a time
		end)
	end
	
	return row
end

--------------------------------------------------------------------------------
-- UI UPDATE
--------------------------------------------------------------------------------

local function updateStoragePanel()
	if not mainFrame then return end
	
	local panel = mainFrame:FindFirstChild("StoragePanel")
	if not panel then return end
	
	local scrollFrame = panel:FindFirstChild("ItemList")
	if not scrollFrame then return end
	
	-- Clear existing items
	for _, child in scrollFrame:GetChildren() do
		if child:IsA("Frame") then
			child:Destroy()
		end
	end
	
	-- Add items
	for itemId, count in pairs(currentStorage) do
		if count > 0 then
			createItemRow(scrollFrame, itemId, count, true)
		end
	end
	
	-- Update capacity bar
	local capacityBar = panel:FindFirstChild("CapacityBar")
	if capacityBar then
		local fill = capacityBar:FindFirstChild("Fill")
		local text = capacityBar:FindFirstChild("Text")
		
		local ratio = math.clamp(storageUsage / math.max(1, storageCapacity), 0, 1)
		
		if fill then
			TweenService:Create(fill, TweenInfo.new(0.3), {Size = UDim2.new(ratio, 0, 1, 0)}):Play()
			
			-- Color based on fullness
			local color = COLORS.accent
			if ratio > 0.9 then
				color = COLORS.danger
			elseif ratio > 0.7 then
				color = COLORS.warning
				end
			fill.BackgroundColor3 = color
		end
		
		if text then
			text.Text = string.format("%d / %d", storageUsage, storageCapacity)
		end
	end
end

local function updateCartPanel()
	if not mainFrame then return end
	
	local panel = mainFrame:FindFirstChild("CartPanel")
	if not panel then return end
	
	local scrollFrame = panel:FindFirstChild("ItemList")
	if not scrollFrame then return end
	
	-- Clear existing items
	for _, child in scrollFrame:GetChildren() do
		if child:IsA("Frame") then
			child:Destroy()
		end
	end
	
	-- Add items
	local hasItems = false
	for itemId, count in pairs(currentCart) do
		if count > 0 then
			createItemRow(scrollFrame, itemId, count, false)
			hasItems = true
		end
	end
	
	-- Update capacity bar
	local capacityBar = panel:FindFirstChild("CapacityBar")
	if capacityBar then
		local fill = capacityBar:FindFirstChild("Fill")
		local text = capacityBar:FindFirstChild("Text")
		
		local usage = 0
		for _, c in pairs(currentCart) do usage += c end
		
		local ratio = math.clamp(usage / math.max(1, cartCapacity), 0, 1)
		
		if fill then
			TweenService:Create(fill, TweenInfo.new(0.3), {Size = UDim2.new(ratio, 0, 1, 0)}):Play()
			
			-- Color based on fullness
			local color = COLORS.success
			if ratio > 0.9 then
				color = COLORS.danger
			elseif ratio > 0.7 then
				color = COLORS.warning
			end
			fill.BackgroundColor3 = color
		end
		
		if text then
			text.Text = string.format("%d / %d", usage, cartCapacity)
		end
	end
	
	-- Update Action Button
	local actionBtn = panel:FindFirstChild("ActionButton")
	if actionBtn then
		if cartState == "idle" then
			actionBtn.Visible = hasItems
			actionBtn.Text = "ðŸš¶ PUSH TO MARKET"
			actionBtn.BackgroundColor3 = COLORS.success
		elseif cartState == "at_market" then
			actionBtn.Visible = true
			actionBtn.Text = "ðŸ  RETURN CART"
			actionBtn.BackgroundColor3 = COLORS.warning
		else
			actionBtn.Visible = false
		end
	end
	
	-- Update title with cart state
	local title = panel:FindFirstChild("Title")
	if title then
		local stateText = "IDLE"
		if cartState == "rolling_to_market" then stateText = "ROLLING..."
		elseif cartState == "at_market" then stateText = "AT MARKET" 
		elseif cartState == "rolling_to_plot" then stateText = "RETURNING..." end
		title.Text = "ðŸ›’ CART: " .. stateText
	end
end

--------------------------------------------------------------------------------
-- OPEN/CLOSE
--------------------------------------------------------------------------------

local GetVehicleInfoFunction = RemoteFunctions:WaitForChild("GetVehicleInfo")

local function openUI()
	if isOpen then return end
	isOpen = true
	
	-- Fetch latest storage data
	local storageItems, storageTotal, storageCap = GetStorageFunction:InvokeServer()
	currentStorage = storageItems or {}
	storageUsage = storageTotal or 0
	storageCapacity = LocalPlayer:GetAttribute("StorageCapacity") or storageCap or 0
	
	-- Fetch cart data
	local vInfo = GetVehicleInfoFunction:InvokeServer()
	if vInfo then
		currentCart = vInfo.inventory or {}
		cartCapacity = LocalPlayer:GetAttribute("CartCapacity") or vInfo.capacity or 0
		local usage = 0
		for _, c in pairs(currentCart) do usage += c end
		-- cartUsage removed, dealt with locally
	end
	
	-- Update UI
	updateStoragePanel()
	updateCartPanel()
	
	-- Show with animation
	mainFrame.Visible = true
	mainFrame.Size = UDim2.new(0, 700, 0, 0)
	TweenService:Create(mainFrame, TweenInfo.new(0.3, Enum.EasingStyle.Back), {
		Size = UDim2.new(0, 700, 0, 500)
	}):Play()
end

function closeUI()
	if not isOpen then return end
	isOpen = false
	
	TweenService:Create(mainFrame, TweenInfo.new(0.2), {
		Size = UDim2.new(0, 700, 0, 0)
	}):Play()
	
	task.wait(0.2)
	mainFrame.Visible = false
end

--------------------------------------------------------------------------------
-- EVENT HANDLERS
--------------------------------------------------------------------------------

StorageUpdatedEvent.OnClientEvent:Connect(function(items, total, capacity)
	currentStorage = items or {}
	storageUsage = total or 0
	storageCapacity = LocalPlayer:GetAttribute("StorageCapacity") or capacity or 0
	
	if isOpen then
		updateStoragePanel()
	end
end)

CartUpdateEvent.OnClientEvent:Connect(function(state, inventory, capacity)
	cartState = state or "idle"
	currentCart = inventory or {}
	cartCapacity = LocalPlayer:GetAttribute("CartCapacity") or capacity or 0
	
	if isOpen then
		updateCartPanel()
	end
end)

-- Keyboard toggle (T key)
UserInputService.InputBegan:Connect(function(input, processed)
	if processed then return end
	
	if input.KeyCode == Enum.KeyCode.T then
		if isOpen then
			closeUI()
		else
			openUI()
		end
	end
end)

-- Toggle via HUD button
local StorageToggleEvent = ReplicatedStorage:WaitForChild("StorageToggleEvent", 5)
if StorageToggleEvent then
	StorageToggleEvent.Event:Connect(function()
		if isOpen then
			closeUI()
		else
			openUI()
		end
	end)
end

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

local function initialize()
	-- Create UI
	screenGui = createScreenGui()
	mainFrame = createMainFrame(screenGui)
	createHeader(mainFrame)
	createStoragePanel(mainFrame)
	createCartPanel(mainFrame) -- Changed from createBackpackPanel
	createBottomBar(mainFrame)
	
	print("âœ“ TransportUI initialized - Press T to open")
end

initialize()


================================================================================
FILE: src\client\UnitEquipmentUI.client.luau
================================================================================

--[[
	UnitEquipmentUI Client Script
	
	Equipment management interface for brainrot units.
	
	Features:
	- Opens when player interacts with a unit (ProximityPrompt)
	- Shows unit stats and equipment slots
	- Displays artifact inventory for equipping
	- Glassmorphism theme matching existing UI
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

-- Player
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- Wait for remotes
local RemoteFunctions = ReplicatedStorage:WaitForChild("RemoteFunctions")
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")

-- Artifact remotes
local GetArtifacts = RemoteFunctions:WaitForChild("GetArtifacts")
local EquipArtifact = RemoteFunctions:WaitForChild("EquipArtifact")
local UnequipArtifact = RemoteFunctions:WaitForChild("UnequipArtifact")

-- Events
local OpenUnitUIEvent = RemoteEvents:WaitForChild("OpenUnitUI")
local ArtifactDroppedEvent = RemoteEvents:WaitForChild("ArtifactDropped")
local ArtifactEquippedEvent = RemoteEvents:WaitForChild("ArtifactEquipped")

-- Shared configs
local Shared = ReplicatedStorage:WaitForChild("Shared")
local ArtifactConfig = require(Shared:WaitForChild("ArtifactConfig"))

-- Configuration
local CONFIG = {
	-- Theme (matching MoneyHUD / BuildModeUI style)
	THEME_BG = Color3.fromRGB(20, 20, 30),
	THEME_STROKE = Color3.fromRGB(50, 50, 70),
	THEME_ACCENT_PURPLE = Color3.fromRGB(80, 60, 140),
	THEME_ACCENT_PINK = Color3.fromRGB(140, 80, 160),
	THEME_ACCENT_GOLD = Color3.fromRGB(200, 150, 60),
	THEME_ACCENT_BLUE = Color3.fromRGB(80, 160, 200),
	THEME_TEXT_PRIMARY = Color3.fromRGB(255, 255, 255),
	THEME_TEXT_SECONDARY = Color3.fromRGB(180, 180, 180),
	THEME_PANEL_RADIUS = 16,
	THEME_BUTTON_RADIUS = 6,
	
	-- Panel dimensions
	PANEL_WIDTH = 500,
	PANEL_HEIGHT = 450,
}

-- State
local unitEquipmentGui = nil
local currentUnitData = nil  -- Current unit being inspected

-- Drag-and-drop state
local isDragging = false
local draggedArtifact = nil  -- {GUID, Name, Slot, Rarity, source = "inventory" | "slot"}
local dragGhost = nil  -- The floating visual

--------------------------------------------------------------------------------
-- HELPER FUNCTIONS
--------------------------------------------------------------------------------

--[[
	Styles a panel with the glassmorphism theme.
]]
local function stylePanel(frame, radius)
	frame.BackgroundColor3 = CONFIG.THEME_BG
	frame.BackgroundTransparency = 0.1
	frame.BorderSizePixel = 0
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, radius or CONFIG.THEME_PANEL_RADIUS)
	corner.Parent = frame
	
	local stroke = Instance.new("UIStroke")
	stroke.Color = CONFIG.THEME_STROKE
	stroke.Thickness = 2
	stroke.Parent = frame
	return frame
end

--[[
	Gets rarity color from ArtifactConfig.
]]
local function getRarityColor(rarity)
	return ArtifactConfig.RarityColors[rarity] or CONFIG.THEME_TEXT_SECONDARY
end

--------------------------------------------------------------------------------
-- DRAG-AND-DROP FUNCTIONS
--------------------------------------------------------------------------------

--[[
	Creates the floating ghost visual for dragging.
	@param artifact table - The artifact being dragged
	@return Frame - The ghost element
]]
local function createDragGhost(artifact)
	local ghost = Instance.new("Frame")
	ghost.Name = "DragGhost"
	ghost.Size = UDim2.new(0, 120, 0, 50)
	ghost.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
	ghost.BackgroundTransparency = 0.2
	ghost.BorderSizePixel = 0
	ghost.ZIndex = 100
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 8)
	corner.Parent = ghost
	
	local stroke = Instance.new("UIStroke")
	stroke.Color = getRarityColor(artifact.Rarity)
	stroke.Thickness = 2
	stroke.Parent = ghost
	
	-- Icon
	local icon = Instance.new("TextLabel")
	icon.Size = UDim2.new(0, 30, 0, 30)
	icon.Position = UDim2.new(0, 5, 0.5, -15)
	icon.BackgroundTransparency = 1
	icon.Text = artifact.BaseIcon or "ðŸ“¿"
	icon.TextSize = 20
	icon.ZIndex = 101
	icon.Parent = ghost
	
	-- Name
	local name = Instance.new("TextLabel")
	name.Size = UDim2.new(1, -40, 0, 20)
	name.Position = UDim2.new(0, 38, 0, 5)
	name.BackgroundTransparency = 1
	name.Text = artifact.Name or "Artifact"
	name.TextColor3 = getRarityColor(artifact.Rarity)
	name.TextSize = 11
	name.Font = Enum.Font.GothamBold
	name.TextXAlignment = Enum.TextXAlignment.Left
	name.TextTruncate = Enum.TextTruncate.AtEnd
	name.ZIndex = 101
	name.Parent = ghost
	
	-- Slot type
	local slotLabel = Instance.new("TextLabel")
	slotLabel.Size = UDim2.new(1, -40, 0, 14)
	slotLabel.Position = UDim2.new(0, 38, 0, 26)
	slotLabel.BackgroundTransparency = 1
	slotLabel.Text = (ArtifactConfig.SlotIcons[artifact.Slot] or "") .. " " .. (artifact.Slot or "?")
	slotLabel.TextColor3 = CONFIG.THEME_TEXT_SECONDARY
	slotLabel.TextSize = 10
	slotLabel.Font = Enum.Font.Gotham
	slotLabel.TextXAlignment = Enum.TextXAlignment.Left
	slotLabel.ZIndex = 101
	slotLabel.Parent = ghost
	
	return ghost
end

--[[
	Starts dragging an artifact.
	@param artifact table - The artifact data
	@param source string - "inventory" or slot name (e.g., "Head")
]]
local function startDrag(artifact, source)
	if isDragging then return end
	
	isDragging = true
	draggedArtifact = artifact
	draggedArtifact.source = source
	
	-- Create ghost
	dragGhost = createDragGhost(artifact)
	dragGhost.Parent = unitEquipmentGui
	
	-- Position at mouse
	local mouse = UserInputService:GetMouseLocation()
	dragGhost.Position = UDim2.new(0, mouse.X - 60, 0, mouse.Y - 25)
end

--[[
	Updates the drag ghost position.
]]
local function updateDragPosition()
	if not isDragging or not dragGhost then return end
	
	local mouse = UserInputService:GetMouseLocation()
	dragGhost.Position = UDim2.new(0, mouse.X - 60, 0, mouse.Y - 25)
end

--[[
	Ends dragging and performs action based on drop target.
	@param dropTarget string? - "inventory", slot name, or nil (cancel)
]]
local function endDrag(dropTarget)
	if not isDragging then return end
	
	local artifact = draggedArtifact
	local source = artifact and artifact.source
	
	-- Perform action based on drop
	if artifact and dropTarget and currentUnitData then
		if source == "inventory" and dropTarget ~= "inventory" then
			-- Equipping: from inventory to slot
			if artifact.Slot == dropTarget then
				local success, err = EquipArtifact:InvokeServer(
					currentUnitData.unitGUID,
					artifact.GUID,
					artifact.Slot
				)
				if not success then
					warn("Failed to equip artifact: " .. tostring(err))
				end
			end
		elseif source ~= "inventory" and dropTarget == "inventory" then
			-- Unequipping: from slot to inventory
			local success, err = UnequipArtifact:InvokeServer(currentUnitData.unitGUID, source)
			if not success then
				warn("Failed to unequip artifact: " .. tostring(err))
			end
		end
		-- Note: slot-to-slot swap would require unequip+equip, handled by slot logic
	end
	
	-- Cleanup
	if dragGhost then
		dragGhost:Destroy()
		dragGhost = nil
	end
	
	isDragging = false
	draggedArtifact = nil
end

--------------------------------------------------------------------------------
-- UI CREATION
--------------------------------------------------------------------------------

--[[
	Creates the main equipment UI panel.
]]
local function createEquipmentUI()
	-- Main ScreenGui
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "UnitEquipmentUI"
	screenGui.ResetOnSpawn = false
	screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	screenGui.DisplayOrder = 110
	screenGui.Enabled = false
	
	-- Main panel (centered)
	local mainPanel = Instance.new("Frame")
	mainPanel.Name = "MainPanel"
	mainPanel.Size = UDim2.new(0, CONFIG.PANEL_WIDTH, 0, CONFIG.PANEL_HEIGHT)
	mainPanel.Position = UDim2.new(0.5, -CONFIG.PANEL_WIDTH/2, 0.5, -CONFIG.PANEL_HEIGHT/2)
	stylePanel(mainPanel)
	mainPanel.Parent = screenGui
	
	-- Title bar
	local titleBar = Instance.new("Frame")
	titleBar.Name = "TitleBar"
	titleBar.Size = UDim2.new(1, 0, 0, 40)
	titleBar.BackgroundTransparency = 1
	titleBar.Parent = mainPanel
	
	local title = Instance.new("TextLabel")
	title.Name = "Title"
	title.Size = UDim2.new(1, -100, 1, 0)
	title.Position = UDim2.new(0, 15, 0, 0)
	title.BackgroundTransparency = 1
	title.Text = "âš”ï¸ UNIT EQUIPMENT"
	title.TextColor3 = CONFIG.THEME_ACCENT_PURPLE
	title.TextSize = 18
	title.Font = Enum.Font.GothamBold
	title.TextXAlignment = Enum.TextXAlignment.Left
	title.Parent = titleBar
	
	-- Close button
	local closeBtn = Instance.new("TextButton")
	closeBtn.Name = "CloseButton"
	closeBtn.Size = UDim2.new(0, 30, 0, 30)
	closeBtn.Position = UDim2.new(1, -40, 0, 5)
	closeBtn.BackgroundColor3 = CONFIG.THEME_ACCENT_PURPLE
	closeBtn.Text = "âœ•"
	closeBtn.TextColor3 = CONFIG.THEME_TEXT_PRIMARY
	closeBtn.TextSize = 16
	closeBtn.Font = Enum.Font.GothamBold
	closeBtn.Parent = titleBar
	
	local closeBtnCorner = Instance.new("UICorner")
	closeBtnCorner.CornerRadius = UDim.new(0, CONFIG.THEME_BUTTON_RADIUS)
	closeBtnCorner.Parent = closeBtn
	
	-- Left section: Unit Info
	local leftSection = Instance.new("Frame")
	leftSection.Name = "LeftSection"
	leftSection.Size = UDim2.new(0.5, -10, 1, -50)
	leftSection.Position = UDim2.new(0, 10, 0, 45)
	leftSection.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
	leftSection.BackgroundTransparency = 0.5
	leftSection.BorderSizePixel = 0
	leftSection.Parent = mainPanel
	
	local leftCorner = Instance.new("UICorner")
	leftCorner.CornerRadius = UDim.new(0, 10)
	leftCorner.Parent = leftSection
	
	-- Unit name label
	local unitName = Instance.new("TextLabel")
	unitName.Name = "UnitName"
	unitName.Size = UDim2.new(1, -20, 0, 30)
	unitName.Position = UDim2.new(0, 10, 0, 10)
	unitName.BackgroundTransparency = 1
	unitName.Text = "Unit Name"
	unitName.TextColor3 = CONFIG.THEME_TEXT_PRIMARY
	unitName.TextSize = 16
	unitName.Font = Enum.Font.GothamBold
	unitName.TextXAlignment = Enum.TextXAlignment.Left
	unitName.Parent = leftSection
	
	-- Stats panel (expanded for artifact bonuses)
	local statsPanel = Instance.new("Frame")
	statsPanel.Name = "StatsPanel"
	statsPanel.Size = UDim2.new(1, -20, 0, 120)
	statsPanel.Position = UDim2.new(0, 10, 0, 45)
	statsPanel.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
	statsPanel.BorderSizePixel = 0
	statsPanel.Parent = leftSection
	
	local statsCorner = Instance.new("UICorner")
	statsCorner.CornerRadius = UDim.new(0, 8)
	statsCorner.Parent = statsPanel
	
	local statsTitle = Instance.new("TextLabel")
	statsTitle.Size = UDim2.new(1, 0, 0, 20)
	statsTitle.BackgroundTransparency = 1
	statsTitle.Text = "ðŸ“Š STATS"
	statsTitle.TextColor3 = CONFIG.THEME_ACCENT_GOLD
	statsTitle.TextSize = 11
	statsTitle.Font = Enum.Font.GothamBold
	statsTitle.Parent = statsPanel
	
	local statsText = Instance.new("TextLabel")
	statsText.Name = "StatsText"
	statsText.Size = UDim2.new(0.5, -5, 0, 50)
	statsText.Position = UDim2.new(0, 5, 0, 22)
	statsText.BackgroundTransparency = 1
	statsText.Text = "Level: 1\nRarity: Normal\nGrid Slot: N/A"
	statsText.TextColor3 = CONFIG.THEME_TEXT_SECONDARY
	statsText.TextSize = 11
	statsText.Font = Enum.Font.Gotham
	statsText.TextXAlignment = Enum.TextXAlignment.Left
	statsText.TextYAlignment = Enum.TextYAlignment.Top
	statsText.Parent = statsPanel
	
	-- Artifact bonuses label
	local bonusText = Instance.new("TextLabel")
	bonusText.Name = "BonusText"
	bonusText.Size = UDim2.new(0.5, -5, 0, 70)
	bonusText.Position = UDim2.new(0.5, 0, 0, 22)
	bonusText.BackgroundTransparency = 1
	bonusText.Text = ""
	bonusText.TextColor3 = CONFIG.THEME_ACCENT_BLUE
	bonusText.TextSize = 10
	bonusText.Font = Enum.Font.Gotham
	bonusText.TextXAlignment = Enum.TextXAlignment.Left
	bonusText.TextYAlignment = Enum.TextYAlignment.Top
	bonusText.Parent = statsPanel
	
	-- Rarity bonus label (below main stats)
	local rarityBonusText = Instance.new("TextLabel")
	rarityBonusText.Name = "RarityBonusText"
	rarityBonusText.Size = UDim2.new(1, -10, 0, 16)
	rarityBonusText.Position = UDim2.new(0, 5, 0, 95)
	rarityBonusText.BackgroundTransparency = 1
	rarityBonusText.Text = ""
	rarityBonusText.TextColor3 = CONFIG.THEME_ACCENT_PINK
	rarityBonusText.TextSize = 10
	rarityBonusText.Font = Enum.Font.GothamBold
	rarityBonusText.TextXAlignment = Enum.TextXAlignment.Left
	rarityBonusText.Parent = statsPanel
	
	-- Equipment slots section
	local equipTitle = Instance.new("TextLabel")
	equipTitle.Name = "EquipTitle"
	equipTitle.Size = UDim2.new(1, -20, 0, 25)
	equipTitle.Position = UDim2.new(0, 10, 0, 175)
	equipTitle.BackgroundTransparency = 1
	equipTitle.Text = "âš™ï¸ EQUIPMENT SLOTS"
	equipTitle.TextColor3 = CONFIG.THEME_ACCENT_PURPLE
	equipTitle.TextSize = 12
	equipTitle.Font = Enum.Font.GothamBold
	equipTitle.TextXAlignment = Enum.TextXAlignment.Left
	equipTitle.Parent = leftSection
	
	-- Equipment slots container
	local slotsContainer = Instance.new("Frame")
	slotsContainer.Name = "SlotsContainer"
	slotsContainer.Size = UDim2.new(1, -20, 0, 180)
	slotsContainer.Position = UDim2.new(0, 10, 0, 200)
	slotsContainer.BackgroundTransparency = 1
	slotsContainer.Parent = leftSection
	
	-- Create 3 equipment slots
	local slots = {"Head", "Body", "Accessory"}
	local _slotIcons = ArtifactConfig.SlotIcons
	
	for i, slotName in ipairs(slots) do
		local slotFrame = Instance.new("Frame")
		slotFrame.Name = "Slot_" .. slotName
		slotFrame.Size = UDim2.new(1, 0, 0, 50)
		slotFrame.Position = UDim2.new(0, 0, 0, (i-1) * 58)
		slotFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
		slotFrame.BorderSizePixel = 0
		slotFrame.Parent = slotsContainer
		
		local slotCorner = Instance.new("UICorner")
		slotCorner.CornerRadius = UDim.new(0, 8)
		slotCorner.Parent = slotFrame
		
		-- Slot icon (empty by default, shows artifact icon when equipped)
		local icon = Instance.new("TextLabel")
		icon.Name = "Icon"
		icon.Size = UDim2.new(0, 40, 1, 0)
		icon.BackgroundTransparency = 1
		icon.Text = "â€”"  -- Empty placeholder
		icon.TextColor3 = CONFIG.THEME_TEXT_SECONDARY
		icon.TextSize = 24
		icon.Parent = slotFrame
		
		-- Slot name
		local name = Instance.new("TextLabel")
		name.Name = "SlotName"
		name.Size = UDim2.new(0, 70, 0, 20)
		name.Position = UDim2.new(0, 42, 0, 5)
		name.BackgroundTransparency = 1
		name.Text = slotName:upper()
		name.TextColor3 = CONFIG.THEME_TEXT_SECONDARY
		name.TextSize = 10
		name.Font = Enum.Font.GothamBold
		name.TextXAlignment = Enum.TextXAlignment.Left
		name.Parent = slotFrame
		
		-- Equipped artifact name (or "Empty")
		local artifactLabel = Instance.new("TextLabel")
		artifactLabel.Name = "ArtifactLabel"
		artifactLabel.Size = UDim2.new(1, -120, 0, 18)
		artifactLabel.Position = UDim2.new(0, 42, 0, 25)
		artifactLabel.BackgroundTransparency = 1
		artifactLabel.Text = "Empty"
		artifactLabel.TextColor3 = CONFIG.THEME_TEXT_SECONDARY
		artifactLabel.TextSize = 11
		artifactLabel.Font = Enum.Font.Gotham
		artifactLabel.TextXAlignment = Enum.TextXAlignment.Left
		artifactLabel.TextTruncate = Enum.TextTruncate.AtEnd
		artifactLabel.Parent = slotFrame
		
		-- Unequip button (hidden when empty)
		local unequipBtn = Instance.new("TextButton")
		unequipBtn.Name = "UnequipButton"
		unequipBtn.Size = UDim2.new(0, 60, 0, 30)
		unequipBtn.Position = UDim2.new(1, -70, 0.5, -15)
		unequipBtn.BackgroundColor3 = CONFIG.THEME_ACCENT_PURPLE
		unequipBtn.Text = "Remove"
		unequipBtn.TextColor3 = CONFIG.THEME_TEXT_PRIMARY
		unequipBtn.TextSize = 10
		unequipBtn.Font = Enum.Font.GothamBold
		unequipBtn.Visible = false
		unequipBtn.Parent = slotFrame
		
		local unequipCorner = Instance.new("UICorner")
		unequipCorner.CornerRadius = UDim.new(0, 4)
		unequipCorner.Parent = unequipBtn
		
		-- Unequip handler
		unequipBtn.MouseButton1Click:Connect(function()
			if currentUnitData and currentUnitData.unitGUID then
				UnequipArtifact:InvokeServer(currentUnitData.unitGUID, slotName)
			end
		end)
	end
	
	-- Right section: Artifact Inventory
	local rightSection = Instance.new("Frame")
	rightSection.Name = "RightSection"
	rightSection.Size = UDim2.new(0.5, -10, 1, -50)
	rightSection.Position = UDim2.new(0.5, 5, 0, 45)
	rightSection.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
	rightSection.BackgroundTransparency = 0.5
	rightSection.BorderSizePixel = 0
	rightSection.Parent = mainPanel
	
	local rightCorner = Instance.new("UICorner")
	rightCorner.CornerRadius = UDim.new(0, 10)
	rightCorner.Parent = rightSection
	
	-- Inventory title
	local invTitle = Instance.new("TextLabel")
	invTitle.Name = "InventoryTitle"
	invTitle.Size = UDim2.new(1, -20, 0, 30)
	invTitle.Position = UDim2.new(0, 10, 0, 10)
	invTitle.BackgroundTransparency = 1
	invTitle.Text = "ðŸ“¿ ARTIFACTS"
	invTitle.TextColor3 = CONFIG.THEME_ACCENT_PINK
	invTitle.TextSize = 14
	invTitle.Font = Enum.Font.GothamBold
	invTitle.TextXAlignment = Enum.TextXAlignment.Left
	invTitle.Parent = rightSection
	
	-- Scrolling inventory list
	local inventoryScroll = Instance.new("ScrollingFrame")
	inventoryScroll.Name = "InventoryList"
	inventoryScroll.Size = UDim2.new(1, -20, 1, -50)
	inventoryScroll.Position = UDim2.new(0, 10, 0, 45)
	inventoryScroll.BackgroundTransparency = 1
	inventoryScroll.BorderSizePixel = 0
	inventoryScroll.ScrollBarThickness = 4
	inventoryScroll.ScrollBarImageColor3 = CONFIG.THEME_ACCENT_PINK
	inventoryScroll.CanvasSize = UDim2.new(0, 0, 0, 0)
	inventoryScroll.Parent = rightSection
	
	local invLayout = Instance.new("UIListLayout")
	invLayout.SortOrder = Enum.SortOrder.Name
	invLayout.Padding = UDim.new(0, 6)
	invLayout.Parent = inventoryScroll
	
	invLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
		inventoryScroll.CanvasSize = UDim2.new(0, 0, 0, invLayout.AbsoluteContentSize.Y + 10)
	end)
	
	-- Close button handler
	closeBtn.MouseButton1Click:Connect(function()
		screenGui.Enabled = false
		currentUnitData = nil
	end)
	
	-- Hover effects for close button
	closeBtn.MouseEnter:Connect(function()
		TweenService:Create(closeBtn, TweenInfo.new(0.1), {
			BackgroundColor3 = CONFIG.THEME_ACCENT_PURPLE:Lerp(Color3.new(1,1,1), 0.15)
		}):Play()
	end)
	
	closeBtn.MouseLeave:Connect(function()
		TweenService:Create(closeBtn, TweenInfo.new(0.1), {
			BackgroundColor3 = CONFIG.THEME_ACCENT_PURPLE
		}):Play()
	end)
	
	screenGui.Parent = PlayerGui
	return screenGui
end

--------------------------------------------------------------------------------
-- UI UPDATES
--------------------------------------------------------------------------------

--[[
	Refreshes the equipment slots display.
]]
local function refreshEquipmentSlots()
	if not unitEquipmentGui or not currentUnitData then return end
	
	local leftSection = unitEquipmentGui.MainPanel.LeftSection
	local slotsContainer = leftSection.SlotsContainer
	
	-- Get equipped artifacts from server
	local success, data = pcall(function()
		return GetArtifacts:InvokeServer()
	end)
	
	if not success or not data then return end
	
	-- Get artifacts equipped to this unit
	local equippedToUnit = {}
	for guid, artifact in pairs(data.all or {}) do
		if artifact.EquippedTo == currentUnitData.unitGUID then
			equippedToUnit[artifact.Slot] = artifact
		end
	end
	
	-- Update each slot
	for _, slotName in ipairs({"Head", "Body", "Accessory"}) do
		local slotFrame = slotsContainer:FindFirstChild("Slot_" .. slotName)
		if slotFrame then
			local slotIcon = slotFrame:FindFirstChild("Icon")
			local artifactLabel = slotFrame:FindFirstChild("ArtifactLabel")
			local unequipBtn = slotFrame:FindFirstChild("UnequipButton")
			
			local artifact = equippedToUnit[slotName]
			if artifact then
				-- Show artifact icon and name
				if slotIcon then
					slotIcon.Text = artifact.BaseIcon or ArtifactConfig.SlotIcons[slotName] or "ðŸ“¿"
					slotIcon.TextColor3 = getRarityColor(artifact.Rarity)
				end
				artifactLabel.Text = artifact.Name
				artifactLabel.TextColor3 = getRarityColor(artifact.Rarity)
				unequipBtn.Visible = true
			else
				-- Show empty state
				if slotIcon then
					slotIcon.Text = "â€”"
					slotIcon.TextColor3 = CONFIG.THEME_TEXT_SECONDARY
				end
				artifactLabel.Text = "Empty"
				artifactLabel.TextColor3 = CONFIG.THEME_TEXT_SECONDARY
				unequipBtn.Visible = false
			end
		end
	end
	
	-- Calculate and display artifact bonuses
	local statsPanel = leftSection.StatsPanel
	local bonusText = statsPanel:FindFirstChild("BonusText")
	local rarityBonusText = statsPanel:FindFirstChild("RarityBonusText")
	
	-- Calculate combined bonuses from equipped artifacts
	local totalCycleTimeMult = 1
	local totalLuckBonus = 0
	local totalTierBonus = 0
	local totalSynergyBonus = 0
	local hasAnyArtifact = false
	
	for slot, artifact in pairs(equippedToUnit) do
		hasAnyArtifact = true
		local stats = ArtifactConfig.CalculateArtifactStats(artifact)
		totalCycleTimeMult = totalCycleTimeMult * stats.CycleTimeMult
		totalLuckBonus = totalLuckBonus + stats.LuckBonus
		totalTierBonus = totalTierBonus + stats.ItemTierBonus
		totalSynergyBonus = totalSynergyBonus + stats.SynergyRangeBonus
	end
	
	if bonusText then
		if hasAnyArtifact then
			local bonusLines = {}
			
			if totalCycleTimeMult < 1 then
				local speedBonus = math.floor((1 - totalCycleTimeMult) * 100)
				table.insert(bonusLines, "âš¡ Speed: +" .. speedBonus .. "%")
			end
			if totalLuckBonus > 0 then
				table.insert(bonusLines, "ðŸ€ Luck: +" .. math.floor(totalLuckBonus * 100) .. "%")
			end
			if totalTierBonus > 0 then
				table.insert(bonusLines, "ðŸ“ˆ Tier: +" .. totalTierBonus)
			end
			if totalSynergyBonus > 0 then
				table.insert(bonusLines, "ðŸ”— Synergy: +" .. totalSynergyBonus)
			end
			
			bonusText.Text = #bonusLines > 0 and table.concat(bonusLines, "\n") or "No bonuses"
		else
			bonusText.Text = ""
		end
	end
	
	-- Display rarity bonus
	if rarityBonusText and currentUnitData then
		local rarity = currentUnitData.rarity or "Normal"
		local Shared = ReplicatedStorage:FindFirstChild("Shared")
		if Shared then
			local RarityConfig = Shared:FindFirstChild("RarityConfig")
			if RarityConfig then
				local config = require(RarityConfig)
				local mult = config.GetMultiplier(rarity)
				if mult > 1 then
					rarityBonusText.Text = "âœ¨ Rarity Bonus: x" .. string.format("%.1f", mult) .. " income"
				else
					rarityBonusText.Text = ""
				end
			end
		end
	end
end

--[[
	Refreshes the artifact inventory list.
]]
local function refreshArtifactInventory()
	if not unitEquipmentGui or not currentUnitData then return end
	
	local inventoryList = unitEquipmentGui.MainPanel.RightSection.InventoryList
	
	-- Clear existing items
	for _, child in inventoryList:GetChildren() do
		if child:IsA("Frame") then
			child:Destroy()
		end
	end
	
	-- Get artifacts from server
	local success, data = pcall(function()
		return GetArtifacts:InvokeServer()
	end)
	
	if not success or not data then return end
	
	-- Display unequipped artifacts
	local unequipped = data.unequipped or {}
	
	if #unequipped == 0 then
		local emptyLabel = Instance.new("TextLabel")
		emptyLabel.Name = "EmptyLabel"
		emptyLabel.Size = UDim2.new(1, 0, 0, 40)
		emptyLabel.BackgroundTransparency = 1
		emptyLabel.Text = "No artifacts yet..."
		emptyLabel.TextColor3 = CONFIG.THEME_TEXT_SECONDARY
		emptyLabel.TextSize = 12
		emptyLabel.Font = Enum.Font.GothamBold
		emptyLabel.Parent = inventoryList
		return
	end
	
	for _, artifact in ipairs(unequipped) do
		local itemFrame = Instance.new("Frame")
		itemFrame.Name = "Artifact_" .. artifact.GUID:sub(1, 8)
		itemFrame.Size = UDim2.new(1, 0, 0, 55)
		itemFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
		itemFrame.BorderSizePixel = 0
		itemFrame.Parent = inventoryList
		
		local corner = Instance.new("UICorner")
		corner.CornerRadius = UDim.new(0, 6)
		corner.Parent = itemFrame
		
		-- Rarity colored side bar
		local rarityBar = Instance.new("Frame")
		rarityBar.Size = UDim2.new(0, 4, 1, -6)
		rarityBar.Position = UDim2.new(0, 3, 0, 3)
		rarityBar.BackgroundColor3 = getRarityColor(artifact.Rarity)
		rarityBar.BorderSizePixel = 0
		rarityBar.Parent = itemFrame
		
		local barCorner = Instance.new("UICorner")
		barCorner.CornerRadius = UDim.new(0, 2)
		barCorner.Parent = rarityBar
		
		-- Icon
		local icon = Instance.new("TextLabel")
		icon.Size = UDim2.new(0, 30, 0, 30)
		icon.Position = UDim2.new(0, 12, 0, 5)
		icon.BackgroundTransparency = 1
		local iconText = artifact.BaseIcon
		if not iconText or iconText == "" then
			-- Use slot default fallback
			iconText = ArtifactConfig.SlotIcons[artifact.Slot] or "ðŸ“¿"
		end
		icon.Text = iconText
		icon.TextColor3 = Color3.new(1, 1, 1) -- Ensure visible
		icon.TextSize = 25 -- Slightly larger
		icon.Parent = itemFrame
		
		-- Name
		local name = Instance.new("TextLabel")
		name.Size = UDim2.new(1, -100, 0, 18)
		name.Position = UDim2.new(0, 45, 0, 5)
		name.BackgroundTransparency = 1
		name.Text = artifact.Name
		name.TextColor3 = getRarityColor(artifact.Rarity)
		name.TextSize = 11
		name.Font = Enum.Font.GothamBold
		name.TextXAlignment = Enum.TextXAlignment.Left
		name.TextTruncate = Enum.TextTruncate.AtEnd
		name.Parent = itemFrame
		
		-- Slot type
		local slotLabel = Instance.new("TextLabel")
		slotLabel.Size = UDim2.new(1, -50, 0, 14)
		slotLabel.Position = UDim2.new(0, 45, 0, 24)
		slotLabel.BackgroundTransparency = 1
		slotLabel.Text = (ArtifactConfig.SlotIcons[artifact.Slot] or "") .. " " .. artifact.Slot
		slotLabel.TextColor3 = CONFIG.THEME_TEXT_SECONDARY
		slotLabel.TextSize = 10
		slotLabel.Font = Enum.Font.Gotham
		slotLabel.TextXAlignment = Enum.TextXAlignment.Left
		slotLabel.Parent = itemFrame
		
		-- Equip button
		local equipBtn = Instance.new("TextButton")
		equipBtn.Name = "EquipButton"
		equipBtn.Size = UDim2.new(0, 50, 0, 26)
		equipBtn.Position = UDim2.new(1, -58, 0.5, -13)
		equipBtn.BackgroundColor3 = CONFIG.THEME_ACCENT_BLUE
		equipBtn.Text = "Equip"
		equipBtn.TextColor3 = CONFIG.THEME_TEXT_PRIMARY
		equipBtn.TextSize = 10
		equipBtn.Font = Enum.Font.GothamBold
		equipBtn.Parent = itemFrame
		
		local btnCorner = Instance.new("UICorner")
		btnCorner.CornerRadius = UDim.new(0, 4)
		btnCorner.Parent = equipBtn
		
		-- Equip handler
		equipBtn.MouseButton1Click:Connect(function()
			if currentUnitData and currentUnitData.unitGUID then
				local success, err = EquipArtifact:InvokeServer(
					currentUnitData.unitGUID, 
					artifact.GUID, 
					artifact.Slot
				)
				if success then
					refreshEquipmentSlots()
					refreshArtifactInventory()
				else
					warn("Failed to equip artifact: " .. tostring(err))
				end
			end
		end)
		
		-- Hover effects
		equipBtn.MouseEnter:Connect(function()
			TweenService:Create(equipBtn, TweenInfo.new(0.1), {
				BackgroundColor3 = CONFIG.THEME_ACCENT_BLUE:Lerp(Color3.new(1,1,1), 0.1)
			}):Play()
		end)
		
		equipBtn.MouseLeave:Connect(function()
			TweenService:Create(equipBtn, TweenInfo.new(0.1), {
				BackgroundColor3 = CONFIG.THEME_ACCENT_BLUE
			}):Play()
		end)
		
		-- Drag-and-drop: start drag on mouse down (on the item frame, not button)
		itemFrame.InputBegan:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 then
				-- Small delay to distinguish from button click
				task.delay(0.1, function()
					if input.UserInputState ~= Enum.UserInputState.End then
						startDrag(artifact, "inventory")
					end
				end)
			end
		end)
		
		itemFrame.InputEnded:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 and isDragging then
				-- Check if we're over a slot
				local mouse = UserInputService:GetMouseLocation()
				local dropTarget = nil
				
				-- Check slots
				local slotsContainer = unitEquipmentGui.MainPanel.LeftSection.SlotsContainer
				for _, slotFrame in slotsContainer:GetChildren() do
					if slotFrame:IsA("Frame") and slotFrame.Name:sub(1, 5) == "Slot_" then
						local slotName = slotFrame.Name:sub(6)
						local absPos = slotFrame.AbsolutePosition
						local absSize = slotFrame.AbsoluteSize
						if mouse.X >= absPos.X and mouse.X <= absPos.X + absSize.X and
						   mouse.Y >= absPos.Y and mouse.Y <= absPos.Y + absSize.Y then
							dropTarget = slotName
							break
						end
					end
				end
				
				endDrag(dropTarget)
				refreshEquipmentSlots()
				refreshArtifactInventory()
			end
		end)
	end
end

--[[
	Opens the equipment UI for a unit.
	@param unitData table - Unit information from server
]]
local function openEquipmentUI(unitData)
	if not unitEquipmentGui then
		unitEquipmentGui = createEquipmentUI()
	end
	
	currentUnitData = unitData
	
	-- Update unit info
	local leftSection = unitEquipmentGui.MainPanel.LeftSection
	leftSection.UnitName.Text = unitData.unitType or "Unknown Unit"
	leftSection.StatsPanel.StatsText.Text = string.format(
		"Level: %d\nRarity: %s\nGrid Slot: %s",
		unitData.level or 1,
		unitData.rarity or "Normal",
		unitData.gridSlot and tostring(unitData.gridSlot) or "Not placed"
	)
	
	-- Refresh displays
	refreshEquipmentSlots()
	refreshArtifactInventory()
	
	-- Show UI
	unitEquipmentGui.Enabled = true
end

--------------------------------------------------------------------------------
-- EVENT HANDLERS
--------------------------------------------------------------------------------

-- Handle unit inspection
OpenUnitUIEvent.OnClientEvent:Connect(function(unitData)
	openEquipmentUI(unitData)
end)

-- Handle artifact drops (notification)
ArtifactDroppedEvent.OnClientEvent:Connect(function(artifact)
	print(string.format("ðŸ“¿ New artifact: %s (%s)", artifact.Name, artifact.Rarity))
	-- Refresh inventory if UI is open
	if unitEquipmentGui and unitEquipmentGui.Enabled then
		refreshArtifactInventory()
	end
end)

-- Handle equipment changes (refresh)
ArtifactEquippedEvent.OnClientEvent:Connect(function(artifactGUID, unitGUID, slot, equipped)
	if unitEquipmentGui and unitEquipmentGui.Enabled then
		refreshEquipmentSlots()
		refreshArtifactInventory()
	end
end)

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
print("   UnitEquipmentUI - Client Initialized")
print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")

-- Global mouse movement tracking for drag ghost
UserInputService.InputChanged:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseMovement then
		updateDragPosition()
	end
end)

-- Cancel drag on mouse button release anywhere
UserInputService.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 and isDragging then
		-- Check if over right section (inventory area) for unequip
		if unitEquipmentGui and unitEquipmentGui.Enabled then
			local mouse = UserInputService:GetMouseLocation()
			local rightSection = unitEquipmentGui.MainPanel.RightSection
			local absPos = rightSection.AbsolutePosition
			local absSize = rightSection.AbsoluteSize
			
			if mouse.X >= absPos.X and mouse.X <= absPos.X + absSize.X and
			   mouse.Y >= absPos.Y and mouse.Y <= absPos.Y + absSize.Y then
				endDrag("inventory")
			else
				-- Check slots for equip
				local dropTarget = nil
				local slotsContainer = unitEquipmentGui.MainPanel.LeftSection.SlotsContainer
				for _, slotFrame in slotsContainer:GetChildren() do
					if slotFrame:IsA("Frame") and slotFrame.Name:sub(1, 5) == "Slot_" then
						local slotName = slotFrame.Name:sub(6)
						local slotPos = slotFrame.AbsolutePosition
						local slotSize = slotFrame.AbsoluteSize
						if mouse.X >= slotPos.X and mouse.X <= slotPos.X + slotSize.X and
						   mouse.Y >= slotPos.Y and mouse.Y <= slotPos.Y + slotSize.Y then
							dropTarget = slotName
							break
						end
					end
				end
				endDrag(dropTarget)
			end
			
			refreshEquipmentSlots()
			refreshArtifactInventory()
		else
			endDrag(nil)
		end
	end
end)


================================================================================
FILE: src\client\UnitHUD.client.luau
================================================================================

--[[
	UnitHUD LocalScript
	
	Displays progress bars above brainrot units using BillboardGuis.
	Animates income cycles and shows floating "+$X" text on completion.
	
	Uses CollectionService to detect "ActiveBrainrot" tagged units.
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

-- Player reference
local Player = Players.LocalPlayer

-- Wait for ShopConfig (located in ReplicatedStorage.Shared per Rojo config)
local ShopConfig = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("ShopConfig"))
local ItemConfig = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("ItemConfig"))

-- Wait for RarityConfig to get colors
local RarityConfig = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("RarityConfig"))

-- Configuration
local HUD_CONFIG = {
	-- Billboard settings (bigger to fit all info)
	BILLBOARD_SIZE = UDim2.new(0, 140, 0, 65),
	MAX_DISTANCE = 100,
	
	-- Card styling (dark theme)
	CARD_BACKGROUND = Color3.fromRGB(25, 25, 35),
	CARD_STROKE_COLOR = Color3.fromRGB(80, 80, 100),
	CARD_STROKE_THICKNESS = 1,
	CORNER_RADIUS = 8,
	
	-- Progress bar
	BAR_HEIGHT = 6,
	BAR_BACKGROUND_COLOR = Color3.fromRGB(40, 40, 50),
	BAR_FILL_COLOR = Color3.fromRGB(100, 220, 100),
	BAR_COMPLETE_COLOR = Color3.fromRGB(255, 215, 0),
	
	-- Text
	TEXT_COLOR = Color3.fromRGB(255, 255, 255),
	SUBTEXT_COLOR = Color3.fromRGB(180, 180, 200),
	
	-- Floating text
	FLOAT_DISTANCE = 40,
	FLOAT_DURATION = 1.2,
	FLOAT_TEXT_COLOR = Color3.fromRGB(100, 200, 255),
	
	-- Item tier emojis
	TIER_EMOJI = {"âšª", "ðŸŸ¡", "ðŸŸ ", "ðŸ’Ž", "ðŸ’ "},
}

-- Tag
local BRAINROT_TAG = "ActiveBrainrot"

-- Track active HUDs
local ActiveHUDs: {[Instance]: {billboard: BillboardGui, startTime: number}} = {}

--------------------------------------------------------------------------------
-- HUD CREATION
--------------------------------------------------------------------------------

--[[
	Calculates the height offset needed to position HUD above model's top.
	Uses bounding box calculation similar to GridManager grounding approach.
]]
local function calculateHUDOffset(brainrot: Instance): Vector3
	local HUD_PADDING = 4 -- Extra studs above the model's top
	
	if brainrot:IsA("Model") then
		local success, boundsCF, boundsSize = pcall(function()
			return brainrot:GetBoundingBox()
		end)
		
		if success and boundsSize then
			-- Get model's pivot position and bounds center
			local pivotPos = brainrot:GetPivot().Position
			local boundsCenter = boundsCF.Position
			
			-- Model's top Y in world space
			local modelTopY = boundsCenter.Y + (boundsSize.Y / 2)
			
			-- How far above the pivot is the top of the model
			local pivotToTop = modelTopY - pivotPos.Y
			
			-- HUD should be at top + padding
			local offsetY = pivotToTop + HUD_PADDING
			
			return Vector3.new(0, offsetY, 0)
		end
	end
	
	-- Fallback for non-models or if bounding box fails
	return Vector3.new(0, 4.5, 0)
end

--[[
	Creates a unified BillboardGui with stats and progress bar for a brainrot unit.
]]
local function createProgressHUD(brainrot: Instance): BillboardGui
	local billboard = Instance.new("BillboardGui")
	billboard.Name = "UnitHUD"
	billboard.Size = HUD_CONFIG.BILLBOARD_SIZE
	billboard.StudsOffset = calculateHUDOffset(brainrot) -- Dynamic offset based on model height
	billboard.AlwaysOnTop = false
	billboard.MaxDistance = HUD_CONFIG.MAX_DISTANCE
	billboard.LightInfluence = 0
	
	-- Find adornee (the model's primary part or first part)
	if brainrot:IsA("Model") then
		billboard.Adornee = brainrot.PrimaryPart or brainrot:FindFirstChildWhichIsA("BasePart")
	elseif brainrot:IsA("BasePart") then
		billboard.Adornee = brainrot
	end
	
	-- Main card container with dark background
	local card = Instance.new("Frame")
	card.Name = "Card"
	card.Size = UDim2.new(1, 0, 1, 0)
	card.BackgroundColor3 = HUD_CONFIG.CARD_BACKGROUND
	card.BackgroundTransparency = 0.15
	card.BorderSizePixel = 0
	card.Parent = billboard
	
	-- Card rounded corners
	local cardCorner = Instance.new("UICorner")
	cardCorner.CornerRadius = UDim.new(0, HUD_CONFIG.CORNER_RADIUS)
	cardCorner.Parent = card
	
	-- Card stroke
	local cardStroke = Instance.new("UIStroke")
	cardStroke.Color = HUD_CONFIG.CARD_STROKE_COLOR
	cardStroke.Thickness = HUD_CONFIG.CARD_STROKE_THICKNESS
	cardStroke.Transparency = 0.3
	cardStroke.Parent = card
	
	-- Padding inside card
	local cardPadding = Instance.new("UIPadding")
	cardPadding.PaddingLeft = UDim.new(0, 6)
	cardPadding.PaddingRight = UDim.new(0, 6)
	cardPadding.PaddingTop = UDim.new(0, 4)
	cardPadding.PaddingBottom = UDim.new(0, 6)
	cardPadding.Parent = card
	
	-- Content container (transparent, for layout)
	local container = Instance.new("Frame")
	container.Name = "Container"
	container.Size = UDim2.new(1, 0, 1, 0)
	container.BackgroundTransparency = 1
	container.Parent = card
	
	-- Stats row (Level | Tier)
	local statsLabel = Instance.new("TextLabel")
	statsLabel.Name = "StatsLabel"
	statsLabel.Size = UDim2.new(1, 0, 0, 14)
	statsLabel.Position = UDim2.new(0, 0, 0, 0)
	statsLabel.BackgroundTransparency = 1
	statsLabel.Text = "Lvl 1 | Tier 1"
	statsLabel.TextColor3 = HUD_CONFIG.TEXT_COLOR
	statsLabel.TextSize = 12
	statsLabel.Font = Enum.Font.GothamBold
	statsLabel.TextXAlignment = Enum.TextXAlignment.Center
	statsLabel.Parent = container
	
	-- Rarity label
	local rarityLabel = Instance.new("TextLabel")
	rarityLabel.Name = "RarityLabel"
	rarityLabel.Size = UDim2.new(1, 0, 0, 12)
	rarityLabel.Position = UDim2.new(0, 0, 0, 14)
	rarityLabel.BackgroundTransparency = 1
	rarityLabel.Text = "Normal"
	rarityLabel.TextColor3 = HUD_CONFIG.SUBTEXT_COLOR
	rarityLabel.TextSize = 10
	rarityLabel.Font = Enum.Font.Gotham
	rarityLabel.TextXAlignment = Enum.TextXAlignment.Center
	rarityLabel.Parent = container

	-- Production label (What it makes)
	local prodLabel = Instance.new("TextLabel")
	prodLabel.Name = "ProductionLabel"
	prodLabel.Size = UDim2.new(1, 0, 0, 12)
	prodLabel.Position = UDim2.new(0, 0, 0, 26)
	prodLabel.BackgroundTransparency = 1
	prodLabel.Text = "Produces: Item"
	prodLabel.TextColor3 = HUD_CONFIG.FLOAT_TEXT_COLOR
	prodLabel.TextSize = 10
	prodLabel.Font = Enum.Font.GothamBold
	prodLabel.TextXAlignment = Enum.TextXAlignment.Center
	prodLabel.Parent = container
	
	-- Progress bar background (at bottom of card)
	local barBg = Instance.new("Frame")
	barBg.Name = "BarBackground"
	barBg.Size = UDim2.new(1, 0, 0, HUD_CONFIG.BAR_HEIGHT)
	barBg.Position = UDim2.new(0, 0, 1, -HUD_CONFIG.BAR_HEIGHT)
	barBg.BackgroundColor3 = HUD_CONFIG.BAR_BACKGROUND_COLOR
	barBg.BorderSizePixel = 0
	barBg.Parent = container
	
	local bgCorner = Instance.new("UICorner")
	bgCorner.CornerRadius = UDim.new(0, 3)
	bgCorner.Parent = barBg
	
	-- Progress bar fill
	local barFill = Instance.new("Frame")
	barFill.Name = "BarFill"
	barFill.Size = UDim2.new(0, 0, 1, 0) -- Starts at 0
	barFill.BackgroundColor3 = HUD_CONFIG.BAR_FILL_COLOR
	barFill.BorderSizePixel = 0
	barFill.Parent = barBg
	
	local fillCorner = Instance.new("UICorner")
	fillCorner.CornerRadius = UDim.new(0, 3)
	fillCorner.Parent = barFill
	
	-- Parent to brainrot
	billboard.Parent = brainrot
	
	return billboard
end

--[[
	Creates a floating item text that rises and fades.
]]
local function createFloatingText(billboard: BillboardGui, itemId: string)
	-- Navigate through new Card hierarchy
	local card = billboard:FindFirstChild("Card")
	if not card then return end
	local container = card:FindFirstChild("Container")
	if not container then return end
	
	-- Get item info for display
	local itemInfo = ItemConfig.Items[itemId]
	local tier = itemInfo and itemInfo.tier or 1
	local emoji = HUD_CONFIG.TIER_EMOJI[tier] or "âšª"
	
	local floatText = Instance.new("TextLabel")
	floatText.Name = "FloatText"
	floatText.Size = UDim2.new(1, 0, 0, 20)
	floatText.Position = UDim2.new(0, 0, 0.5, -10)
	floatText.BackgroundTransparency = 1
	floatText.Text = emoji .. " +1"
	floatText.TextColor3 = HUD_CONFIG.FLOAT_TEXT_COLOR
	floatText.TextSize = 16
	floatText.Font = Enum.Font.GothamBold
	floatText.TextStrokeTransparency = 0
	floatText.TextStrokeColor3 = Color3.new(0, 0, 0)
	floatText.Parent = container
	
	-- Animate rising and fading
	local riseTween = TweenService:Create(floatText, TweenInfo.new(HUD_CONFIG.FLOAT_DURATION, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Position = UDim2.new(0, 0, -0.5, 0),
		TextTransparency = 1,
		TextStrokeTransparency = 1,
	})
	
	riseTween:Play()
	riseTween.Completed:Connect(function()
		floatText:Destroy()
	end)
	
	-- Scale pop animation
	local originalSize = floatText.TextSize
	floatText.TextSize = originalSize * 1.5
	TweenService:Create(floatText, TweenInfo.new(0.2, Enum.EasingStyle.Elastic), {
		TextSize = originalSize
	}):Play()
end

--[[
	Pulses the progress bar when complete.
]]
local function pulseComplete(barFill: Frame)
	barFill.BackgroundColor3 = HUD_CONFIG.BAR_COMPLETE_COLOR
	
	TweenService:Create(barFill, TweenInfo.new(0.3), {
		BackgroundColor3 = HUD_CONFIG.BAR_FILL_COLOR
	}):Play()
end

--------------------------------------------------------------------------------
-- HUD LOGIC
--------------------------------------------------------------------------------

--[[
	Gets the cycle time for a brainrot from its attributes or ShopConfig.
]]
local function getCycleTime(brainrot: Instance): number
	-- First try attribute (set by server)
	local cycleTime = brainrot:GetAttribute("IncomeInterval")
	if cycleTime then
		return cycleTime
	end
	
	-- Fall back to ShopConfig based on name
	local unitType = brainrot:GetAttribute("UnitType")
	if unitType then
		local config = ShopConfig.GetConfig(unitType)
		if config then
			return config.CycleTime
		end
	end
	
	-- Default fallback
	return 3
end

--[[
	Gets the item produced by a brainrot based on its model type.
]]
--[[
	Gets the item produced by a brainrot based on its model type.
	Returns { icon: string, name: string, id: string }
]]
local function getProducedItemInfo(brainrot: Instance)
	local unitType = brainrot:GetAttribute("UnitType")
	if unitType then
		local mapping = ItemConfig.BrainrotItems[unitType]
		if mapping then
			local itemId = mapping.tier1 -- Always show tier 1 as baseline
			local item = ItemConfig.Items[itemId]
			if item then
				return {
					icon = item.icon or "ðŸ“¦",
					name = item.displayName or "Item",
					id = itemId
				}
			end
		end
	end
	return { icon = "ðŸ“¦", name = "Item", id = "" }
end

--[[
	Checks if this brainrot belongs to the local player.
]]
local function isOwnedByPlayer(brainrot: Instance): boolean
	local ownerId = brainrot:GetAttribute("OwnerId")
	return ownerId == Player.UserId
end

--[[
	Updates HUD labels from brainrot attributes.
]]
local function updateHUDLabels(brainrot: Instance, billboard: BillboardGui)
	local card = billboard:FindFirstChild("Card")
	if not card then return end
	local container = card:FindFirstChild("Container")
	if not container then return end
	
	local level = brainrot:GetAttribute("Level") or 1
	local tier = brainrot:GetAttribute("ItemTier") or 1
	local rarity = brainrot:GetAttribute("Rarity") or "Normal"
	
	-- Update stats label
	local statsLabel = container:FindFirstChild("StatsLabel")
	if statsLabel then
		statsLabel.Text = string.format("Lvl %d | Tier %d", level, tier)
	end
	
	-- Update rarity label with color
	local rarityLabel = container:FindFirstChild("RarityLabel")
	if rarityLabel then
		rarityLabel.Text = rarity
		rarityLabel.TextColor3 = RarityConfig.GetColor(rarity)
	end

	-- Update production label
	local prodLabel = container:FindFirstChild("ProductionLabel")
	if prodLabel then
		local info = getProducedItemInfo(brainrot)
		prodLabel.Text = string.format("Produces %s %s", info.icon, info.name)
	end
end

--[[
	Sets up a unified HUD for a brainrot.
]]
local function setupBrainrotHUD(brainrot: Instance)
	-- Only show HUD for player's own units
	if not isOwnedByPlayer(brainrot) then
		return
	end
	
	-- Skip if already has HUD
	if ActiveHUDs[brainrot] then
		return
	end
	
	-- Remove any server-created StatsDisplay to avoid duplicates
	local head = brainrot:FindFirstChild("Head") or (brainrot :: Model).PrimaryPart
	if head then
		local oldDisplay = head:FindFirstChild("StatsDisplay")
		if oldDisplay then
			oldDisplay:Destroy()
		end
	end
	
	local billboard = createProgressHUD(brainrot)
	
	-- Initial info
	local info = getProducedItemInfo(brainrot)
	
	ActiveHUDs[brainrot] = {
		billboard = billboard,
		startTime = os.clock(), -- Fallback
		cycleTime = getCycleTime(brainrot),
		producedItem = info.id,
		lastCycle = 0,
		lastProdTS = brainrot:GetAttribute("LastProductionTime") or 0,
	}
	
	-- Update stats/rarity labels from attributes
	updateHUDLabels(brainrot, billboard)
	
	-- Listen for attribute changes to keep HUD in sync
	brainrot.AttributeChanged:Connect(function(attributeName)
		if attributeName == "Level" or attributeName == "ItemTier" or attributeName == "Rarity" then
			updateHUDLabels(brainrot, billboard)
		end
		if attributeName == "IncomeInterval" then
			local hudData = ActiveHUDs[brainrot]
			if hudData then
				hudData.cycleTime = getCycleTime(brainrot)
			end
		end
		if attributeName == "LastProductionTime" then
			local hudData = ActiveHUDs[brainrot]
			if hudData then
				hudData.startTime = brainrot:GetAttribute("LastProductionTime")
			end
		end
	end)
end

--[[
	Removes HUD when brainrot is destroyed.
]]
local function cleanupBrainrotHUD(brainrot: Instance)
	local hudData = ActiveHUDs[brainrot]
	if hudData then
		if hudData.billboard then
			hudData.billboard:Destroy()
		end
		ActiveHUDs[brainrot] = nil
	end
end

--[[
	Updates all active progress bars.
]]
local function updateProgressBars()
	local currentTime = os.clock()
	
	for brainrot, hudData in ActiveHUDs do
		-- Check if brainrot still exists
		if not brainrot or not brainrot.Parent then
			cleanupBrainrotHUD(brainrot)
			continue
		end
		
		local billboard = hudData.billboard
		if not billboard or not billboard.Parent then
			continue
		end
		
		local card = billboard:FindFirstChild("Card")
		if not card then continue end
		local container = card:FindFirstChild("Container")
		if not container then continue end
		
		local barBg = container:FindFirstChild("BarBackground")
		if not barBg then continue end
		
		local barFill = barBg:FindFirstChild("BarFill")
		if not barFill then continue end
		
		-- Calculate progress
		local cycleTime = hudData.cycleTime
		-- Use server-synced LastProductionTime if available
		local lastProd = brainrot:GetAttribute("LastProductionTime") or hudData.startTime
		local elapsed = currentTime - lastProd
		
		local progress = math.clamp(elapsed / cycleTime, 0, 1)
		
		-- Update bar width
		barFill.Size = UDim2.new(progress, 0, 1, 0)
		
		-- Logic for effects is handled by the attribute change for perfectly sync'd pulse?
		-- No, we stick to the local tracking for the pulse/float text but triggered by the reset.
		if progress >= 1 then
			-- Wait for server to update LastProductionTime to reset.
			-- Or if we haven't seen an update in cycleTime * 1.5, we assume it's stuck/offline.
		end
		
		-- Pulse and floating text on reset (detected by a decrease in progress)
		if lastProd ~= hudData.lastProdTS then
			hudData.lastProdTS = lastProd
			pulseComplete(barFill)
			createFloatingText(billboard, hudData.producedItem)
		end
	end
end

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

local function initialize()
	print("UnitHUD: Initializing...")
	
	-- Setup existing brainrots
	for _, brainrot in CollectionService:GetTagged(BRAINROT_TAG) do
		task.spawn(setupBrainrotHUD, brainrot)
	end
	
	-- Listen for new brainrots
	CollectionService:GetInstanceAddedSignal(BRAINROT_TAG):Connect(setupBrainrotHUD)
	
	-- Listen for removed brainrots
	CollectionService:GetInstanceRemovedSignal(BRAINROT_TAG):Connect(cleanupBrainrotHUD)
	
	-- Update progress bars every frame
	RunService.RenderStepped:Connect(updateProgressBars)
	
	print("UnitHUD: Ready!")
end

-- Start
initialize()


================================================================================
FILE: src\server\AdminService.luau
================================================================================

--[[
	AdminService Server Module
	
	Handles admin commands for testing purposes.
	SECURED: Now requires admin permissions to execute.
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local RemoteEvents = ReplicatedStorage:FindFirstChild("RemoteEvents") or Instance.new("Folder")
RemoteEvents.Name = "RemoteEvents"
RemoteEvents.Parent = ReplicatedStorage

local AdminAction = RemoteEvents:FindFirstChild("AdminAction") or Instance.new("RemoteFunction")
AdminAction.Name = "AdminAction"
AdminAction.Parent = RemoteEvents

-- Security Configuration
local ADMIN_USER_IDS = {
	[1340966465] = true, -- Placeholder
}

local IS_STUDIO = RunService:IsStudio()

local AdminService = {}
local Services = {}
local handlers = {}

--------------------------------------------------------------------------------
-- HELPER
--------------------------------------------------------------------------------

local function isAdmin(player)
	if IS_STUDIO then return true end
	if ADMIN_USER_IDS[player.UserId] then return true end
	if player.UserId == game.CreatorId then return true end
	return false
end

--------------------------------------------------------------------------------
-- HANDLERS
--------------------------------------------------------------------------------

handlers.ResetPlot = function(player)
	local DataManager = rawget(Services, "DataManager")
	if DataManager and DataManager.ResetPlayerData then
		DataManager.ResetPlayerData(player, false)
		print("âœ“ Admin: Reset all DataStore data for " .. player.Name)
	end
	
	local MapSystem = rawget(Services, "MapSystem")
	if MapSystem and MapSystem.ResetPlayerPlot then
		MapSystem.ResetPlayerPlot(player)
		
		local ShopManager = rawget(Services, "ShopManager")
		if ShopManager and ShopManager.ResetPlayerData then
			ShopManager.ResetPlayerData(player)
		end
		
		-- Money Reset
		local ls = player:FindFirstChild("leaderstats")
		local m = ls and ls:FindFirstChild("Money")
		if m then m.Value = 100 end
		
		return true, "Full data reset complete!"
	end
	return false, "MapSystem not available"
end

handlers.WipeProfile = function(player)
	return false, "WipeProfile disabled"
end

handlers.AddMoney = function(player)
	local ls = player:FindFirstChild("leaderstats")
	local m = ls and ls:FindFirstChild("Money")
	if m then
		m.Value += 1000000
		return true, "Added $1,000,000"
	end
	return false, "No leaderstats"
end

handlers.ToggleFly = function(player)
	local isFlying = player:GetAttribute("IsFlying")
	local newState = not isFlying
	player:SetAttribute("IsFlying", newState)
	return true, newState and "Flight Enabled" or "Flight Disabled"
end

--------------------------------------------------------------------------------
-- API
--------------------------------------------------------------------------------

function AdminService.Init(services)
	print("   AdminService (Module) - Initializing")
	Services = services or {}
	
	AdminAction.OnServerInvoke = function(player, action, ...)
		if not isAdmin(player) then
			warn(string.format("SECURITY: Unauthorized admin attempt by %s (%d) for action '%s'", player.Name, player.UserId, tostring(action)))
			return false, "Permission Denied"
		end
		
		local handler = handlers[action]
		if handler then
			return handler(player, ...)
		end
		return false, "Unknown action"
	end
	
	print("âœ“ AdminService Initialized")
end

return AdminService


================================================================================
FILE: src\server\ArtifactManager.luau
================================================================================

--[[
	ArtifactManager Server Module
	
	Handles artifact generation, inventory, and equipment.
]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
-- Lazy Config
local ArtifactConfig

local function getArtifactConfig()
	if not ArtifactConfig then
		local Shared = ReplicatedStorage:WaitForChild("Shared")
		ArtifactConfig = require(Shared:WaitForChild("ArtifactConfig"))
	end
	return ArtifactConfig
end
local DataService -- Will be set from Services.DataService

local RemoteEvents = ReplicatedStorage:FindFirstChild("RemoteEvents") or Instance.new("Folder")
RemoteEvents.Name = "RemoteEvents"
RemoteEvents.Parent = ReplicatedStorage

local RemoteFunctions = ReplicatedStorage:FindFirstChild("RemoteFunctions") or Instance.new("Folder")
RemoteFunctions.Name = "RemoteFunctions"
RemoteFunctions.Parent = ReplicatedStorage

local ArtifactDroppedEvent = RemoteEvents:FindFirstChild("ArtifactDropped") or Instance.new("RemoteEvent")
ArtifactDroppedEvent.Name = "ArtifactDropped"
ArtifactDroppedEvent.Parent = RemoteEvents

local ArtifactEquippedEvent = RemoteEvents:FindFirstChild("ArtifactEquipped") or Instance.new("RemoteEvent")
ArtifactEquippedEvent.Name = "ArtifactEquipped"
ArtifactEquippedEvent.Parent = RemoteEvents

local EquipArtifactFunction = RemoteFunctions:FindFirstChild("EquipArtifact") or Instance.new("RemoteFunction")
EquipArtifactFunction.Name = "EquipArtifact"
EquipArtifactFunction.Parent = RemoteFunctions

local UnequipArtifactFunction = RemoteFunctions:FindFirstChild("UnequipArtifact") or Instance.new("RemoteFunction")
UnequipArtifactFunction.Name = "UnequipArtifact"
UnequipArtifactFunction.Parent = RemoteFunctions

local GetArtifactsFunction = RemoteFunctions:FindFirstChild("GetArtifacts") or Instance.new("RemoteFunction")
GetArtifactsFunction.Name = "GetArtifacts"
GetArtifactsFunction.Parent = RemoteFunctions

local COMPONENT_KEY = "Artifacts"
local ArtifactManager = {}
local Services = {} 

-- Getter for DataService (to avoid circular require)
local function getDataService()
	if not DataService then
		-- Use rawget to avoid strict table metatable errors
		DataService = rawget(Services, "DataService")
	end
	return DataService
end

--------------------------------------------------------------------------------
-- HELPERS
--------------------------------------------------------------------------------

local function getPlayerArtifacts(player)
	local ds = getDataService()
	if not ds then return {} end
	
	local data = ds.GetComponentData(player, COMPONENT_KEY)
	if data then return data end
	if ds.IsLoaded(player) then
		ds.SetComponentData(player, COMPONENT_KEY, {})
		return ds.GetComponentData(player, COMPONENT_KEY)
	end
	return {}
end

local function generateGUID() return HttpService:GenerateGUID(false) end

local function generateArtifact(rarity, slot)
	local ac = getArtifactConfig()
	rarity = rarity or ac.RollRarity()
	slot = slot or ac.EquipmentSlots[math.random(#ac.EquipmentSlots)]
	local base = ac.GetRandomBase(slot)
	if not base then return nil end
	
	local numAffixes = ac.AffixCountByRarity[rarity] or 1
	local affixes = {}
	local used = {}
	
	for i = 1, math.ceil(numAffixes/2) do
		local pre = ac.GetRandomPrefix()
		if pre and not used[pre.key] then table.insert(affixes, pre.data); used[pre.key]=true end
	end
	for i = 1, math.floor(numAffixes/2) do
		local suf = ac.GetRandomSuffix()
		if suf and not used[suf.key] then table.insert(affixes, suf.data); used[suf.key]=true end
	end
	
	local name = ""
	for _, a in ipairs(affixes) do
		if a.Name:sub(1,2)=="of" then name = name.." "..a.Name else name = a.Name.." "..name end
	end
	name = name:gsub("^%s+", ""):gsub("%s+$", "") .. " " .. base.Name
	
	return {
		GUID = generateGUID(),
		Name = name,
		BaseId = base.Id,
		BaseName = base.Name,
		BaseIcon = base.Icon,
		Slot = slot,
		Rarity = rarity,
		Affixes = affixes,
		EquippedTo = nil,
		CreatedAt = os.time()
	}
end

--------------------------------------------------------------------------------
-- API
--------------------------------------------------------------------------------

function ArtifactManager.Init(services)
	print("   ArtifactManager (Module) - Initializing")
	Services = services or {}
	
	local ds = getDataService()
	if ds then
		ds.RegisterHandler(COMPONENT_KEY, {
			DefaultData = {},
			OnLoad = function(p, d) 
				-- No-op logging
			end,
			OnSave = function(p, d) return d end
		})
	else
		warn("ArtifactManager: DataService not available during Init")
	end
	
	EquipArtifactFunction.OnServerInvoke = ArtifactManager.EquipArtifact
	UnequipArtifactFunction.OnServerInvoke = ArtifactManager.UnequipArtifact
	GetArtifactsFunction.OnServerInvoke = function(player)
		local all = getPlayerArtifacts(player)
		local un = {}
		for _, a in pairs(all) do if not a.EquippedTo then table.insert(un, a) end end
		return { all = all, unequipped = un }
	end
	
	print("âœ“ ArtifactManager Initialized")
end

function ArtifactManager.AddArtifact(player, artifact)
	if not artifact or not artifact.GUID then return false end
	local inv = getPlayerArtifacts(player)
	inv[artifact.GUID] = artifact
	ArtifactDroppedEvent:FireClient(player, artifact)
	return true
end

function ArtifactManager.RemoveArtifact(player, guid)
	local inv = getPlayerArtifacts(player)
	if inv[guid] and not inv[guid].EquippedTo then
		inv[guid] = nil
		return true
	end
	return false
end

function ArtifactManager.EquipArtifact(player, unitGUID, artifactGUID, slot)
	local inv = getPlayerArtifacts(player)
	local art = inv[artifactGUID]
	if not art then return false, "Not found" end
	if art.Slot ~= slot then return false, "Wrong slot" end
	if art.EquippedTo then return false, "Equipped" end
	
	-- Check occupied
	for _, a in pairs(inv) do
		if a.EquippedTo == unitGUID and a.Slot == slot then return false, "Slot occupied" end
	end
	
	art.EquippedTo = unitGUID
	
	-- Update Unit Attr (Visual/Client sync)
	-- Need to find the physical unit if we want to replicate visual
	-- BrainrotManager used to help with this.
	-- We can skip visual sync attribute here if not critical or find unit manually.
	
	ArtifactEquippedEvent:FireClient(player, artifactGUID, unitGUID, slot, true)
	return true
end

function ArtifactManager.UnequipArtifact(player, unitGUID, slot)
	local inv = getPlayerArtifacts(player)
	local targetArt
	for _, a in pairs(inv) do
		if a.EquippedTo == unitGUID and a.Slot == slot then targetArt=a; break end
	end
	
	if not targetArt then return false, "No artifact" end
	
	targetArt.EquippedTo = nil
	
	ArtifactEquippedEvent:FireClient(player, targetArt.GUID, unitGUID, slot, false)
	return true
end

function ArtifactManager.CalculateUnitArtifactStats(player, unitGUID)
	local stats = { CycleTimeMult = 1, LuckBonus = 0, ItemTierBonus = 0, SynergyRangeBonus = 0 }
	local inv = getPlayerArtifacts(player)
	local ac = getArtifactConfig()
	for _, art in pairs(inv) do
		if art.EquippedTo == unitGUID then
			local s = ac.CalculateArtifactStats(art)
			stats.CycleTimeMult *= s.CycleTimeMult
			stats.LuckBonus += s.LuckBonus
			stats.ItemTierBonus += s.ItemTierBonus
			stats.SynergyRangeBonus += s.SynergyRangeBonus
		end
	end

	stats.CycleTimeMult = math.max(stats.CycleTimeMult, ac.StatLimits.CycleTimeMin)
	stats.LuckBonus = math.min(stats.LuckBonus, ac.StatLimits.MaxLuckBonus)
	return stats
end

ArtifactManager.GenerateArtifact = generateArtifact

return ArtifactManager


================================================================================
FILE: src\server\BrainrotManager.luau
================================================================================

--[[
	BrainrotManager Server Module (Simplified)
	
	Handles spawning and visual updates of units.
	Acts as a listener to InventoryManager and GridManager.
]]

local _Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")
local HttpService = game:GetService("HttpService")

-- Lazy Configs
local ShopConfig
local RarityConfig

local function getConfigs()
	if not ShopConfig then
		local Shared = ReplicatedStorage:WaitForChild("Shared")
		ShopConfig = require(Shared:WaitForChild("ShopConfig"))
		RarityConfig = require(Shared:WaitForChild("RarityConfig"))
	end
	return ShopConfig, RarityConfig
end

-- Configuration
local CONFIG = {
	TIER_MILESTONES = {
		[10] = 2,
		[25] = 3,
		[50] = 4,
		[100] = 5,
	}
}

local BRAINROT_TAG = "ActiveBrainrot"

-- References
local RemoteEvents = ReplicatedStorage:FindFirstChild("RemoteEvents")

-- Events
local InventoryChangedEvent = RemoteEvents:FindFirstChild("InventoryChanged") or Instance.new("RemoteEvent")
InventoryChangedEvent.Name = "InventoryChanged"
InventoryChangedEvent.Parent = RemoteEvents

local BuyBrainrotRemote = RemoteEvents:FindFirstChild("BuyBrainrot") or Instance.new("RemoteEvent")
BuyBrainrotRemote.Name = "BuyBrainrot"
BuyBrainrotRemote.Parent = RemoteEvents

-- References (Lazy Loaded)
local BrainrotsFolder
local PlotsFolder

-- Module Table
local BrainrotManager = {}
local Services = {}

--------------------------------------------------------------------------------
-- HELPER FUNCTIONS
--------------------------------------------------------------------------------

local function getPlayerPlot(player: Player): Instance?
	if not PlotsFolder then PlotsFolder = workspace:FindFirstChild("Plots") end
	if not PlotsFolder then return nil end
	
	for _, plot in PlotsFolder:GetChildren() do
		local ownerId = plot:GetAttribute("OwnerId")
		if ownerId and ownerId == player.UserId then return plot end
	end
	return nil
end

local function _calculateItemTier(level: number): number
	local currentTier = 1
	local milestones = {10, 25, 50, 100} 
	for _, reqLevel in ipairs(milestones) do
		if level >= reqLevel then
			currentTier = CONFIG.TIER_MILESTONES[reqLevel]
		end
	end
	return currentTier
end

local function updateVisuals(brainrot: Model)
	-- Client handles HUD via attributes
end

local function getBrainrotTemplate(unitName: string): Model?
	local assetsFolder = ReplicatedStorage:FindFirstChild("Assets")
	if assetsFolder then
		local brainrotsSubfolder = assetsFolder:FindFirstChild("Brainrots")
		if brainrotsSubfolder then
			local model = brainrotsSubfolder:FindFirstChild(unitName)
			if model then return model end
		end
	end
	
	local unitsFolder = ReplicatedStorage:FindFirstChild("Units")
	if unitsFolder then
		local model = unitsFolder:FindFirstChild(unitName)
		if model then return model end
	end
	
	if not BrainrotsFolder then BrainrotsFolder = ReplicatedStorage:FindFirstChild("Brainrots") end
	if BrainrotsFolder then
		local model = BrainrotsFolder:FindFirstChild(unitName)
		if model then return model end
	end
	
	return nil
end

--------------------------------------------------------------------------------
-- CORE LOGIC
--------------------------------------------------------------------------------

local function recalculateStats(unit: Instance)
	local unitName = unit:GetAttribute("UnitType")
	local level = unit:GetAttribute("Level") or 1
	local rarity = unit:GetAttribute("Rarity") or "Normal"

	if not unitName then return end
	
	local sc, rc = getConfigs()
	local effectiveIncome = sc.CalculateEffectiveIncome(unitName, level)
	local effectiveCycleTime = sc.CalculateEffectiveCycleTime(unitName, level)
	local rarityMult = rc.GetMultiplier(rarity)

	local finalIncome = math.floor(effectiveIncome * rarityMult)
	local finalInterval = math.max(0.1, effectiveCycleTime / rarityMult)

	unit:SetAttribute("IncomeAmount", finalIncome)
	unit:SetAttribute("IncomeInterval", finalInterval)
	unit:SetAttribute("ItemTier", _calculateItemTier(level))

	updateVisuals(unit :: Model)
end

--[[
	Spawns or updates the physical model based on authoritative data.
]]
local function spawnOrUpdateUnit(player: Player, unitName: string, data: any): Instance?
	local plot = getPlayerPlot(player)
	if not plot then return nil end

	local brainrotsContainer = plot:FindFirstChild("Brainrots") or Instance.new("Folder", plot)
	brainrotsContainer.Name = "Brainrots"

	-- Look for existing unit in the container
	local existingUnit
	for _, child in brainrotsContainer:GetChildren() do
		if child:GetAttribute("UnitType") == unitName then
			existingUnit = child
			break
		end
	end

	if existingUnit then
		-- Update existing
		local level = data.level or data.Level or 1
		local rarity = data.rarity or data.Rarity or "Normal"
		
		existingUnit:SetAttribute("Level", level)
		existingUnit:SetAttribute("Rarity", rarity)
		
		recalculateStats(existingUnit)
		return existingUnit
	else
		-- Spawn new
		local template = getBrainrotTemplate(unitName)
		if not template then return nil end
		
		local brainrot = template:Clone()
		brainrot.Name = unitName
		
		brainrot:SetAttribute("OwnerId", player.UserId)
		brainrot:SetAttribute("UnitType", unitName)
		
		local savedUnitId = data.unitId or data.UnitId or HttpService:GenerateGUID(false)
		brainrot:SetAttribute("UnitId", savedUnitId)
		
		local level = data.level or data.Level or 1
		local rarity = data.rarity or data.Rarity or "Normal"
		
		brainrot:SetAttribute("Level", level)
		brainrot:SetAttribute("Rarity", rarity)
		brainrot:SetAttribute("GridSlot", nil)
		brainrot:SetAttribute("IsStored", true)
		
		local plotCF = plot:GetPivot()
		if plot.PrimaryPart then plotCF = plot.PrimaryPart.CFrame end
		local spawnCF = plotCF * CFrame.new(0, -100, 0) -- Hidden underground
		brainrot:PivotTo(spawnCF)
		
		brainrot.Parent = brainrotsContainer
		CollectionService:AddTag(brainrot, BRAINROT_TAG)
		
		recalculateStats(brainrot)
		
		-- Ensure anchored
		for _, part in brainrot:GetDescendants() do
			if part:IsA("BasePart") then part.Anchored = true end
		end
		
		return brainrot
	end
end

--------------------------------------------------------------------------------
-- PUBLIC API
--------------------------------------------------------------------------------

function BrainrotManager.Init(services)
	print("   BrainrotManager (Module) - Initializing")
	Services = services or {}
	
	-- Preload Configs
	getConfigs()
	
	local InventoryManager = rawget(Services, "InventoryManager")
	
	-- Connect to Inventory
	if InventoryManager and InventoryManager.UnitChanged then
		InventoryManager.UnitChanged:Connect(function(player, unitName, newData)
			if not unitName then
				-- Full reload
				BrainrotManager.UpdateAllUnitStats(player)
			else
				-- Single update
				-- CRITICAL CHANGE: Only update if a physical model ALREADY exists!
				-- New units bought from shop stay in inventory (virtual) until placed.
				local plot = getPlayerPlot(player)
				if plot then
					local brainrotsContainer = plot:FindFirstChild("Brainrots")
					if brainrotsContainer then
						local existing = nil
						for _, child in brainrotsContainer:GetChildren() do
							if child:GetAttribute("UnitType") == unitName then
								existing = child
								break
							end
						end
						
						if existing then
							spawnOrUpdateUnit(player, unitName, newData)
						end
					end
				end
			end
		end)
	else
		warn("BrainrotManager: InventoryManager missing or UnitChanged signal not found.")
	end
	
	print("âœ“ BrainrotManager Initialized")
end

-- Exposed for GridManager to spawn units when placed from inventory
function BrainrotManager.SpawnForGrid(player: Player, unitName: string, data: any): Instance?
	return spawnOrUpdateUnit(player, unitName, data)
end

function BrainrotManager.AddUnit(player: Player, unitName: string, forceRarity: string?, forceLevel: number?): Instance?
	-- Delegate to InventoryManager
	local InventoryManager = rawget(Services, "InventoryManager")
	
	if InventoryManager then
		local newData = InventoryManager.AddUnit(player, unitName, forceRarity, forceLevel)
		if newData then
			return spawnOrUpdateUnit(player, unitName, newData)
		end
	end
	return nil
end


function BrainrotManager.StashBrainrot(player: Player, brainrot: Model)
	brainrot:SetAttribute("IsStored", true)
	brainrot:SetAttribute("GridSlot", nil)
	
	local currentCF = brainrot:GetPivot()
	brainrot:PivotTo(CFrame.new(currentCF.Position.X, -100, currentCF.Position.Z))
	
	InventoryChangedEvent:FireClient(player)
end

function BrainrotManager.GetPlacementData(player: Player)
	local GridManager = rawget(Services, "GridManager")
	local placements = {}
	
	if GridManager and GridManager.GetGridPositions then
		local gridPos = GridManager.GetGridPositions(player)
		for slot, data in pairs(gridPos) do
			if data.Unit then
				local entry = {}
				entry.slotIndex = tonumber(slot)
				
				local unitData = data.Unit
				entry.unitType = unitData.unitType
				entry.rarity = unitData.rarity
				entry.level = unitData.level
				
				table.insert(placements, entry)
			elseif data.unitType then
				local entry = table.clone(data)
				entry.slotIndex = tonumber(slot)
				table.insert(placements, entry)
			end
		end
	end
	return placements
end

function BrainrotManager.SpawnFromPlacement(player: Player, data: any)
	local GridManager = rawget(Services, "GridManager")
	
	local unitType = data.unitType or (data.Unit and data.Unit.unitType)
	local rarity = data.rarity or (data.Unit and data.Unit.rarity)
	local level = data.level or (data.Unit and data.Unit.level)
	local unitId = data.unitId or (data.Unit and data.Unit.unitId)
	
	if not unitType then return nil end
	
	local unit = spawnOrUpdateUnit(player, unitType, {
		level = level,
		rarity = rarity,
		unitId = unitId
	})
	
	if unit and GridManager and GridManager.PlaceUnit then
		GridManager.PlaceUnit(player, unit, data.slotIndex)
	end
	return unit
end

function BrainrotManager.SetInventoryData(player: Player, inventoryData: any)
	for unitName, rarityData in pairs(inventoryData) do
		for rarity, counts in pairs(rarityData) do
			if counts.total > 0 then
				BrainrotManager.AddUnit(player, unitName, rarity, counts.total)
			end
		end
	end
end

function BrainrotManager.UpdateAllUnitStats(player: Player)
	local plot = getPlayerPlot(player)
	if not plot then return end

	local brainrotsContainer = plot:FindFirstChild("Brainrots")
	if brainrotsContainer then
		for _, child in brainrotsContainer:GetChildren() do
			recalculateStats(child)
		end
	end
end

function BrainrotManager.GetPlayerPlot(player)
	return getPlayerPlot(player)
end

-- Spawn directly at slot (legacy wrapper)
function BrainrotManager.SpawnBrainrotAtSlot(player, unitName, slotIndex, rarity, level, unitId)
	local GridManager = rawget(Services, "GridManager")
	
	-- No more retry loop. If GridManager isn't there, we fail.
	if GridManager then
		local unit = spawnOrUpdateUnit(player, unitName, {
			level = level or 1,
			rarity = rarity or "Normal",
			unitId = unitId
		})
		
		if unit then
			GridManager.PlaceUnit(player, unit, slotIndex)
		end
	end
end

-- Compatibility Exports
BrainrotManager.SpawnBrainrot = BrainrotManager.AddUnit
BrainrotManager.RARITY_CONFIG = nil -- RarityConfig.CONFIG

--------------------------------------------------------------------------------
-- REMOTE HANDLERS
--------------------------------------------------------------------------------

BuyBrainrotRemote.OnServerEvent:Connect(function(player, unitName)
	-- Pass to ShopManager properly in future cleanup, for now delegate to internal AddUnit
	-- Or check money here if logic was embedded
	BrainrotManager.AddUnit(player, unitName)
end)

function BrainrotManager.ClearAllUnits(player)
	local plot = getPlayerPlot(player)
	if plot then
		local brainrotsContainer = plot:FindFirstChild("Brainrots")
		if brainrotsContainer then
			brainrotsContainer:ClearAllChildren()
		end
	end
end

return BrainrotManager


================================================================================
FILE: src\server\BuildModeManager.luau
================================================================================

--[[
	BuildModeManager Server Module
	
	Manages Build Mode state for players.
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local RemoteEvents = ReplicatedStorage:FindFirstChild("RemoteEvents") or Instance.new("Folder")
RemoteEvents.Name = "RemoteEvents"
RemoteEvents.Parent = ReplicatedStorage

local RemoteFunctions = ReplicatedStorage:FindFirstChild("RemoteFunctions") or Instance.new("Folder")
RemoteFunctions.Name = "RemoteFunctions"
RemoteFunctions.Parent = ReplicatedStorage

local BuildModeChangedEvent = RemoteEvents:FindFirstChild("BuildModeChanged") or Instance.new("RemoteEvent")
BuildModeChangedEvent.Name = "BuildModeChanged"
BuildModeChangedEvent.Parent = RemoteEvents

local EnterBuildModeFunction = RemoteFunctions:FindFirstChild("EnterBuildMode") or Instance.new("RemoteFunction")
EnterBuildModeFunction.Name = "EnterBuildMode"
EnterBuildModeFunction.Parent = RemoteFunctions

local ExitBuildModeFunction = RemoteFunctions:FindFirstChild("ExitBuildMode") or Instance.new("RemoteFunction")
ExitBuildModeFunction.Name = "ExitBuildMode"
ExitBuildModeFunction.Parent = RemoteFunctions

local GetBuildModeStateFunction = RemoteFunctions:FindFirstChild("GetBuildModeState") or Instance.new("RemoteFunction")
GetBuildModeStateFunction.Name = "GetBuildModeState"
GetBuildModeStateFunction.Parent = RemoteFunctions

local BuildModeManager = {}
local Services = {}
local PlayerBuildModeState = {}

--------------------------------------------------------------------------------
-- STATE
--------------------------------------------------------------------------------

local function getPlayerState(player)
	if not PlayerBuildModeState[player.UserId] then
		PlayerBuildModeState[player.UserId] = { inBuildMode = false, enterTime = 0 }
	end
	return PlayerBuildModeState[player.UserId]
end

local function isInBuildMode(player)
	return getPlayerState(player).inBuildMode
end

local function enterBuildMode(player)
	local state = getPlayerState(player)
	if state.inBuildMode then return false, "Already in Build Mode" end
	
	state.inBuildMode = true
	state.enterTime = os.clock()
	
	BuildModeChangedEvent:FireAllClients(player.UserId, true)
	return true
end

local function exitBuildMode(player)
	local state = getPlayerState(player)
	if not state.inBuildMode then return false, "Not in Build Mode" end
	state.inBuildMode = false
	BuildModeChangedEvent:FireAllClients(player.UserId, false)
	return true
end

--------------------------------------------------------------------------------
-- API
--------------------------------------------------------------------------------

function BuildModeManager.Init(services)
	print("   BuildModeManager (Module) - Initializing")
	Services = services or {}
	
	Players.PlayerRemoving:Connect(function(player)
		if isInBuildMode(player) then exitBuildMode(player) end
		PlayerBuildModeState[player.UserId] = nil
	end)
	
	EnterBuildModeFunction.OnServerInvoke = enterBuildMode
	ExitBuildModeFunction.OnServerInvoke = exitBuildMode
	GetBuildModeStateFunction.OnServerInvoke = function(player)
		local s = getPlayerState(player)
		return { inBuildMode = s.inBuildMode, enterTime = s.enterTime }
	end
	
	print("âœ“ BuildModeManager Initialized")
end

BuildModeManager.EnterBuildMode = enterBuildMode
BuildModeManager.ExitBuildMode = exitBuildMode
BuildModeManager.IsInBuildMode = isInBuildMode

return BuildModeManager


================================================================================
FILE: src\server\CartManager.luau
================================================================================

--[[
	CartManager Server Module
	
	Handles the physical transport cart system.
	- Spawns/Despawns carts for players
	- Manages cart inventory (distinct from backpack)
	- Handles rolling movement (Plot <-> Market)
	- Integrates with MarketManager for selling
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local TweenService = game:GetService("TweenService")

local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local RemoteFunctions = ReplicatedStorage:WaitForChild("RemoteFunctions")

-- Create specific remotes for Cart system
-- (Using existing Transport hooks where possible, but adding specific events for cart state)
local CartUpdateEvent = RemoteEvents:FindFirstChild("CartUpdate") or Instance.new("RemoteEvent")
CartUpdateEvent.Name = "CartUpdate"
CartUpdateEvent.Parent = RemoteEvents

local PushCartRemote = RemoteEvents:FindFirstChild("PushCart") or Instance.new("RemoteEvent")
PushCartRemote.Name = "PushCart"
PushCartRemote.Parent = RemoteEvents

local ReturnCartRemote = RemoteEvents:FindFirstChild("ReturnCart") or Instance.new("RemoteEvent")
ReturnCartRemote.Name = "ReturnCart"
ReturnCartRemote.Parent = RemoteEvents

local CartManager = {}
local Services = {}

-- State
local PlayerCarts = {} -- [Player] = { Model, State, Inventory, Capacity }
-- States: "idle" (at plot), "rolling_to_market", "at_market", "rolling_to_plot"

local CONFIG = {
	ROLL_SPEED = 40, -- Studs per second
	DEFAULT_CAPACITY = 200,
}

--------------------------------------------------------------------------------
-- HELPERS
--------------------------------------------------------------------------------

local function getMapSystem()
	return rawget(Services, "MapSystem")
end

local function getMarketManager()
	return rawget(Services, "MarketManager")
end

local function createPlaceholderCart()
	local m = Instance.new("Model")
	m.Name = "TransportCart"
	
	-- Base (Anchored, PrimaryPart)
	local base = Instance.new("Part")
	base.Name = "PrimaryPart"
	base.Size = Vector3.new(6, 2, 8)
	base.BrickColor = BrickColor.new("Brown")
	base.Material = Enum.Material.Wood
	base.TopSurface = Enum.SurfaceType.Smooth
	base.BottomSurface = Enum.SurfaceType.Smooth
	base.Anchored = true -- Driven by TweenService
	base.CanCollide = false -- Prevent sticking in geometry
	base.Parent = m
	m.PrimaryPart = base
	
	-- Wheels (Unanchored, Welded)
	local function addWheel(name, x, z)
		local w = Instance.new("Part")
		w.Name = name
		w.Size = Vector3.new(1, 2, 2)
		w.BrickColor = BrickColor.new("Really black")
		w.Material = Enum.Material.Metal
		w.Shape = Enum.PartType.Cylinder
		w.CFrame = base.CFrame * CFrame.new(x, -1, z) * CFrame.Angles(0, 0, math.pi/2)
		w.Anchored = false
		w.CanCollide = false
		w.Parent = m
		
		local weld = Instance.new("WeldConstraint")
		weld.Part0 = base
		weld.Part1 = w
		weld.Parent = base
	end
	addWheel("Wheel_FR", 3.5, 3)
	addWheel("Wheel_BR", 3.5, -3)
	addWheel("Wheel_FL", -3.5, 3)
	addWheel("Wheel_BL", -3.5, -3)
	
	-- Box (Unanchored, Welded)
	local box = Instance.new("Part")
	box.Name = "CartBox"
	box.Size = Vector3.new(5, 3, 7)
	box.Position = base.Position + Vector3.new(0, 2.5, 0)
	box.BrickColor = BrickColor.new("Dirt brown")
	box.Material = Enum.Material.WoodPlanks
	box.Anchored = false
	box.CanCollide = false
	box.Transparency = 0
	box.TopSurface = Enum.SurfaceType.Smooth
	box.Parent = m
	
	local boxWeld = Instance.new("WeldConstraint")
	boxWeld.Part0 = base
	boxWeld.Part1 = box
	boxWeld.Parent = base
	
	-- Capacity Bar (SurfaceGui)
	local sg = Instance.new("SurfaceGui")
	sg.Face = Enum.NormalId.Back
	sg.CanvasSize = Vector2.new(200, 50)
	sg.Parent = box
	
	local frame = Instance.new("Frame")
	frame.Size = UDim2.new(1, 0, 1, 0)
	frame.BackgroundColor3 = Color3.new(0, 0, 0)
	frame.Parent = sg
	
	local bar = Instance.new("Frame")
	bar.Name = "FillBar"
	bar.Size = UDim2.new(0, 0, 1, 0)
	bar.BackgroundColor3 = Color3.new(0, 1, 0)
	bar.BorderSizePixel = 0
	bar.Parent = frame
	
	-- Attachment for ProximityPrompt
	local att = Instance.new("Attachment")
	att.Name = "PromptAttachment"
	att.Position = Vector3.new(0, 2, -4)
	att.Parent = base
	
	return m
end

local function getCartTemplate()
	local t = ServerStorage:FindFirstChild("TransportCart")
	if not t then
		t = createPlaceholderCart()
		t.Parent = ServerStorage
	end
	return t
end

local function updateCartVisuals(cartData)
	local model = cartData.Model
	if not model then return end
	
	-- Update capacity bar
	local box = model:FindFirstChild("CartBox")
	if box and box:FindFirstChild("SurfaceGui") then
		local bar = box.SurfaceGui:FindFirstChild("Frame"):FindFirstChild("FillBar")
		local current = 0
		for _, c in pairs(cartData.Inventory) do current += c end
		local ratio = math.min(1, current / math.max(1, cartData.Capacity))
		if bar then
			bar.Size = UDim2.new(ratio, 0, 1, 0)
			bar.BackgroundColor3 = ratio >= 1 and Color3.new(1, 0, 0) or Color3.new(0, 1, 0)
		end
	end
	
	-- Position prompt
	local prompt = model.PrimaryPart:FindFirstChild("CartPrompt")
	if not prompt then
		prompt = Instance.new("ProximityPrompt")
		prompt.Name = "CartPrompt"
		prompt.ObjectText = "Transport Cart"
		prompt.RequiresLineOfSight = false
		prompt.HoldDuration = 0.5
		prompt.Parent = model.PrimaryPart
	end
	
	prompt.Enabled = (cartData.State == "idle" or cartData.State == "at_market")
	
	if cartData.State == "idle" then
		prompt.ActionText = "Push to Market"
		prompt.KeyboardKeyCode = Enum.KeyCode.E
	elseif cartData.State == "at_market" then
		prompt.ActionText = "Return Cart"
		prompt.KeyboardKeyCode = Enum.KeyCode.E
	else
		prompt.Enabled = false
	end
end

--------------------------------------------------------------------------------
-- LOGIC
--------------------------------------------------------------------------------

local function spawnCart(player)
	if PlayerCarts[player] then return PlayerCarts[player] end
	
	local MS = getMapSystem()
	local plot = MS.GetPlayerPlot(player)
	if not plot then return nil end
	
	local template = getCartTemplate()
	local model = template:Clone()
	model.Name = "Cart_" .. player.Name
	
	-- Initial Position (Start of bridge)
	local plotPos = plot:GetPivot().Position
	local mainPos = Vector3.new(0, MS.CONFIG.MAIN_ISLAND_HEIGHT + 6, 0)
	local dir = (mainPos - plotPos).Unit
	local spawnPos = plotPos + (dir * 35) -- Edge of plot
	spawnPos = Vector3.new(spawnPos.X, plotPos.Y + 10, spawnPos.Z) -- Higher up to avoid clipping ramp/bridge
	
	model:PivotTo(CFrame.new(spawnPos, spawnPos + dir))
	model.Parent = workspace
	
	local data = {
		Model = model,
		State = "idle",
		Inventory = {},
		Capacity = CONFIG.DEFAULT_CAPACITY,
		StartPos = spawnPos,
		EndPos = mainPos + (dir * -45), -- Edge of main island
		BridgeDir = dir
	}
	
	-- Tag for client-side HUD
	game:GetService("CollectionService"):AddTag(model, "PhysicalCartHUD")
	
	PlayerCarts[player] = data
	updateCartVisuals(data)
	
	-- Connect prompt locally
	local prompt = model.PrimaryPart:WaitForChild("CartPrompt")
	prompt.Triggered:Connect(function(triggerPlayer)
		if triggerPlayer == player then
			CartManager.HandlePrompt(player)
		end
	end)
	
	return data
end

local function moveCart(player, targetState)
	print("CartManager: moveCart called for", player.Name, "to", targetState)
	local data = PlayerCarts[player]
	if not data then 
		print("CartManager: No cart data found")
		return 
	end
	
	local startP, endP
	if targetState == "rolling_to_market" then
		startP = data.StartPos
		endP = data.EndPos
	else
		startP = data.EndPos
		endP = data.StartPos
	end
	
	data.State = targetState
	updateCartVisuals(data)
	CartUpdateEvent:FireClient(player, data.State, data.Inventory, data.Capacity)
	
	-- Calculate time
	local dist = (startP - endP).Magnitude
	local time = dist / CONFIG.ROLL_SPEED
	print("CartManager: Starting tween, time:", time, "dist:", dist)
	
	-- Correct orientation: Facing movement direction
	local lookCF = CFrame.new(startP, endP)
	data.Model:PivotTo(lookCF)
	
	-- Tween
	local tweenInfo = TweenInfo.new(time, Enum.EasingStyle.Linear)
	local tween = TweenService:Create(data.Model.PrimaryPart, tweenInfo, {
		CFrame = CFrame.new(endP, endP + (endP - startP).Unit) -- Maintain look direction approximately
	})
	
	tween:Play()
	tween.Completed:Connect(function()
		print("CartManager: Tween completed")
		if targetState == "rolling_to_market" then
			data.State = "at_market"
			-- Auto Sell
			local MM = getMarketManager()
			if MM and MM.SellCartContents then
				MM.SellCartContents(player, data.Inventory)
				data.Inventory = {} -- Clear after sell
			end
		else
			data.State = "idle"
		end
		updateCartVisuals(data)
		CartUpdateEvent:FireClient(player, data.State, data.Inventory, data.Capacity)
	end)
end

--------------------------------------------------------------------------------
-- API
--------------------------------------------------------------------------------

function CartManager.Init(services)
	Services = services
	print("   CartManager (Module) - Initializing")
	
	Players.PlayerAdded:Connect(function(player)
		task.wait(2) -- Wait for plot
		spawnCart(player)
	end)
	
	Players.PlayerRemoving:Connect(function(player)
		if PlayerCarts[player] then
			if PlayerCarts[player].Model then
				PlayerCarts[player].Model:Destroy()
			end
			PlayerCarts[player] = nil
		end
	end)
	
	PushCartRemote.OnServerEvent:Connect(function(player)
		print("CartManager: PushCart remote received")
		CartManager.HandlePrompt(player)
	end)
	
	ReturnCartRemote.OnServerEvent:Connect(function(player)
		print("CartManager: ReturnCart remote received")
		CartManager.HandlePrompt(player)
	end)
	
	-- Initial players
	for _, p in Players:GetPlayers() do
		task.spawn(function()
			task.wait(2)
			spawnCart(p)
		end)
	end
	
	print("âœ“ CartManager Initialized")
end

function CartManager.LoadItem(player, itemId, count)
	local data = PlayerCarts[player]
	if not data then return 0 end
	if data.State ~= "idle" then return 0 end
	
	local current = 0
	for _, c in pairs(data.Inventory) do current += c end
	
	local space = data.Capacity - current
	local toLoad = math.min(count, space)
	if toLoad <= 0 then return 0 end
	
	-- Assume items already deducted from source by caller
	data.Inventory[itemId] = (data.Inventory[itemId] or 0) + toLoad
	updateCartVisuals(data)
	CartUpdateEvent:FireClient(player, data.State, data.Inventory, data.Capacity)
	
	return toLoad
end

function CartManager.HandlePrompt(player)
	print("CartManager: HandlePrompt called for", player.Name)
	local data = PlayerCarts[player]
	if not data then 
		print("CartManager: No data found in HandlePrompt")
		return 
	end
	
	print("CartManager: Current State:", data.State)
	if data.State == "idle" then
		-- Pushing to market (allow even if empty for testing)
		moveCart(player, "rolling_to_market")
	elseif data.State == "at_market" then
		moveCart(player, "rolling_to_plot")
	end
end

function CartManager.GetCartState(player)
	return PlayerCarts[player]
end

function CartManager.SetCapacity(player, capacity)
	local data = PlayerCarts[player]
	if not data then return end
	data.Capacity = capacity
	updateCartVisuals(data)
	CartUpdateEvent:FireClient(player, data.State, data.Inventory, data.Capacity)
end

return CartManager


================================================================================
FILE: src\server\ConvenienceUpgradesManager.luau
================================================================================

--[[
	ConvenienceUpgradesManager Server Module
	
	Handles:
	1. Purchase of convenience upgrades
	2. Applying upgrade effects (walkspeed, income multipliers, etc.)
	3. Creating the Convenience Shop vendor on main island
	4. Spawning Auto-Collector bots
	5. Creating Speed Treadmill Bridge boost zones
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")
local Shared = ReplicatedStorage:WaitForChild("Shared")
local ConvenienceUpgradesConfig = require(Shared:WaitForChild("ConvenienceUpgradesConfig"))

-- Config
local SHOP_CONFIG = {
	VENDOR_SIZE = Vector3.new(6, 8, 6),
	VENDOR_POSITION_OFFSET = Vector3.new(30, 10, -30),
	BOT_SPEED = 30,
	BOT_COLLECT_INTERVAL = 5,
}

-- Remotes
local RemoteEvents = ReplicatedStorage:FindFirstChild("RemoteEvents") or Instance.new("Folder")
RemoteEvents.Name = "RemoteEvents"
RemoteEvents.Parent = ReplicatedStorage

local PurchaseUpgradeEvent = RemoteEvents:FindFirstChild("PurchaseConvenienceUpgrade") or Instance.new("RemoteEvent")
PurchaseUpgradeEvent.Name = "PurchaseConvenienceUpgrade"
PurchaseUpgradeEvent.Parent = RemoteEvents

local GetUpgradesInfoEvent = RemoteEvents:FindFirstChild("GetConvenienceUpgradesInfo") or Instance.new("RemoteFunction")
GetUpgradesInfoEvent.Name = "GetConvenienceUpgradesInfo"
GetUpgradesInfoEvent.Parent = RemoteEvents

-- State
local PlayerUpgrades = {} 
local PlayerCollectorBots = {}

local ConvenienceUpgradesManager = {}
local Services = {}

--------------------------------------------------------------------------------
-- CALCULATIONS
--------------------------------------------------------------------------------

local function calculateIncomeMultiplier(upgrades)
	local m = 1.0
	for _, name in upgrades do
		local c = ConvenienceUpgradesConfig.GetConfig(name)
		if c and c.EffectType == "IncomeMultiplier" then m += c.EffectValue end
	end
	return m
end

local function calculateCycleReduction(upgrades)
	local r = 0.0
	for _, name in upgrades do
		local c = ConvenienceUpgradesConfig.GetConfig(name)
		if c and c.EffectType == "CycleReduction" then r += c.EffectValue end
	end
	return math.min(r, 0.75)
end

local function calculateWalkspeedMultiplier(upgrades)
	local m = 1.0
	for _, name in upgrades do
		local c = ConvenienceUpgradesConfig.GetConfig(name)
		if c and c.EffectType == "Walkspeed" then m += c.EffectValue end
	end
	return m
end

local function getBridgeSpeedMultiplier(upgrades)
	local h = 1
	for _, name in upgrades do
		local c = ConvenienceUpgradesConfig.GetConfig(name)
		if c and c.EffectType == "BridgeSpeed" then h = math.max(h, c.EffectValue) end
	end
	return h
end

local function hasEffect(upgrades, effectType)
	for _, name in upgrades do
		local c = ConvenienceUpgradesConfig.GetConfig(name)
		if c and c.EffectType == effectType then return true end
	end
	return false
end

local function getLuckyChance(upgrades)
	for _, name in upgrades do
		local c = ConvenienceUpgradesConfig.GetConfig(name)
		if c and c.EffectType == "LuckyChance" then return c.EffectValue end
	end
	return 0
end

local function getCriticalChance(upgrades)
	for _, name in upgrades do
		local c = ConvenienceUpgradesConfig.GetConfig(name)
		if c and c.EffectType == "CriticalChance" then return c.EffectValue end
	end
	return 0
end

local function countAutoCollectorBots(upgrades)
	local c = 0
	for _, name in upgrades do
		local conf = ConvenienceUpgradesConfig.GetConfig(name)
		if conf and conf.EffectType == "AutoCollector" then c += conf.EffectValue end
	end
	return c
end

--------------------------------------------------------------------------------
-- APPLY EFFECTS
--------------------------------------------------------------------------------

local function applyCharacterEffects(player)
	local char = player.Character
	if not char then return end
	local hum = char:FindFirstChildOfClass("Humanoid")
	if not hum then return end
	
	local upgrades = PlayerUpgrades[player.UserId] or {}
	
	local wm = calculateWalkspeedMultiplier(upgrades)
	hum.WalkSpeed = 16 * wm
	
	local jm = 1.0
	for _, name in upgrades do
		local c = ConvenienceUpgradesConfig.GetConfig(name)
		if c and c.EffectType == "JumpPower" then jm += c.EffectValue end
	end
	hum.JumpPower = 50 * jm
end

function ConvenienceUpgradesManager.ApplyBrainrotUpgrades(player)
	local upgrades = PlayerUpgrades[player.UserId] or {}
	local inc = calculateIncomeMultiplier(upgrades)
	local cyc = calculateCycleReduction(upgrades)
	local luck = getLuckyChance(upgrades)
	local crit = getCriticalChance(upgrades)
	
	player:SetAttribute("IncomeMultiplier", inc)
	player:SetAttribute("CycleReduction", cyc)
	player:SetAttribute("LuckyChance", luck)
	player:SetAttribute("CriticalChance", crit)
end

--------------------------------------------------------------------------------
-- BOTS
--------------------------------------------------------------------------------

local function createCollectorBot(player, index)
	local bot = Instance.new("Model")
	bot.Name = "CollectorBot_" .. index
	
	local body = Instance.new("Part")
	body.Name = "Body"
	body.Size = Vector3.new(3, 3, 3)
	body.BrickColor = BrickColor.new("Bright blue")
	body.Material = Enum.Material.SmoothPlastic
	body.CanCollide = false
	body.Parent = bot
	
	local mesh = Instance.new("SpecialMesh")
	mesh.MeshType = Enum.MeshType.Sphere
	mesh.Parent = body
	
	-- Eyes
	local eye1 = Instance.new("Part")
	eye1.Size = Vector3.new(0.5, 0.5, 0.5)
	eye1.BrickColor = BrickColor.new("White")
	eye1.Material = Enum.Material.Neon
	eye1.CanCollide = false
	eye1.Parent = bot
	local em1 = Instance.new("SpecialMesh"); em1.MeshType = Enum.MeshType.Sphere; em1.Parent = eye1
	
	local eye2 = eye1:Clone()
	eye2.Parent = bot
	
	local w1 = Instance.new("WeldConstraint")
	w1.Part0 = body; w1.Part1 = eye1; w1.Parent = body
	eye1.CFrame = body.CFrame * CFrame.new(0.6, 0.5, -1.2)
	
	local w2 = Instance.new("WeldConstraint")
	w2.Part0 = body; w2.Part1 = eye2; w2.Parent = body
	eye2.CFrame = body.CFrame * CFrame.new(-0.6, 0.5, -1.2)
	
	-- Billboard
	local bb = Instance.new("BillboardGui")
	bb.Size = UDim2.new(3,0,1,0)
	bb.StudsOffset = Vector3.new(0, 2.5, 0)
	bb.Parent = body
	local lbl = Instance.new("TextLabel")
	lbl.Size = UDim2.new(1,0,1,0)
	lbl.BackgroundTransparency = 1
	lbl.Text = "ðŸ¤– Bot " .. index
	lbl.TextColor3 = Color3.new(1,1,1)
	lbl.TextScaled = true
	lbl.Parent = bb
	
	bot.PrimaryPart = body
	bot:SetAttribute("OwnerId", player.UserId)
	bot:SetAttribute("BotIndex", index)
	CollectionService:AddTag(bot, "CollectorBot")
	
	return bot
end

local function updateCollectorBots(player)
	local upgrades = PlayerUpgrades[player.UserId] or {}
	local needed = countAutoCollectorBots(upgrades)
	local current = PlayerCollectorBots[player.UserId] or {}
	
	local BM = rawget(Services, "BrainrotManager")
	local plot = BM and BM.GetPlayerPlot(player)
	if not plot then return end
	
	while #current < needed do
		local idx = #current + 1
		local bot = createCollectorBot(player, idx)
		local pp = plot:FindFirstChild("Island") or plot:FindFirstChildWhichIsA("BasePart")
		if pp then bot:PivotTo(pp.CFrame * CFrame.new(0, 10, 0)) end
		bot.Parent = plot
		table.insert(current, bot)
	end
	
	while #current > needed do
		local bot = table.remove(current)
		if bot then bot:Destroy() end
	end
	
	PlayerCollectorBots[player.UserId] = current
end

--------------------------------------------------------------------------------
-- VENDOR
--------------------------------------------------------------------------------

local function createConvenienceShopVendor()
	local mainIsland = workspace:WaitForChild("MainIsland", 10)
	if not mainIsland then return end
	if mainIsland:FindFirstChild("ConvenienceShopVendor") then return end
	
	local center = Vector3.new(0, 30, 0)
	local ip = mainIsland:FindFirstChild("Island") or mainIsland:FindFirstChildWhichIsA("BasePart")
	if ip then center = ip.Position end
	
	local part = Instance.new("Part")
	part.Name = "ConvenienceShopVendor"
	part.Size = SHOP_CONFIG.VENDOR_SIZE
	part.BrickColor = BrickColor.new("Bright orange")
	part.Material = Enum.Material.Neon
	part.Anchored = true
	part.Position = center + SHOP_CONFIG.VENDOR_POSITION_OFFSET
	
	local bb = Instance.new("BillboardGui")
	bb.Name = "ShopDisplay"
	bb.Size = UDim2.new(6,0,3,0)
	bb.StudsOffset = Vector3.new(0,6,0)
	bb.Parent = part
	
	local bg = Instance.new("Frame")
	bg.Size = UDim2.new(1,0,1,0)
	bg.BackgroundColor3 = Color3.fromRGB(60,40,20)
	bg.BackgroundTransparency = 0.2
	bg.Parent = bb
	Instance.new("UICorner", bg).CornerRadius = UDim.new(0.1,0)
	
	local t = Instance.new("TextLabel")
	t.Size = UDim2.new(1,0,0.4,0)
	t.BackgroundTransparency = 1
	t.Text = "âš¡ UPGRADES"
	t.TextColor3 = Color3.fromRGB(255,200,100)
	t.TextScaled = true
	t.Parent = bg
	
	local pp = Instance.new("ProximityPrompt")
	pp.ActionText = "Open Upgrades"
	pp.ObjectText = "Convenience Shop"
	pp.KeyboardKeyCode = Enum.KeyCode.E
	pp.Parent = part
	
	part.Parent = mainIsland
	CollectionService:AddTag(part, "ConvenienceShopVendor")
end

--------------------------------------------------------------------------------
-- PURCHASE
--------------------------------------------------------------------------------

function ConvenienceUpgradesManager.HandleUpgradePurchase(player, upgradeName)
	local owned = PlayerUpgrades[player.UserId] or {}
	local can, reason = ConvenienceUpgradesConfig.CanPurchase(upgradeName, owned)
	
	if not can then return false, reason or "Cannot purchase" end
	
	local conf = ConvenienceUpgradesConfig.GetConfig(upgradeName)
	if not conf then return false, "Upgrade not found" end
	
	local ls = player:FindFirstChild("leaderstats")
	local m = ls and ls:FindFirstChild("Money")
	if not m or m.Value < conf.Price then return false, "Not enough money" end
	
	m.Value -= conf.Price
	
	table.insert(owned, upgradeName)
	PlayerUpgrades[player.UserId] = owned
	
	applyCharacterEffects(player)
	updateCollectorBots(player)
	ConvenienceUpgradesManager.ApplyBrainrotUpgrades(player)
	
	return true, "Purchased!"
end

--------------------------------------------------------------------------------
-- API
--------------------------------------------------------------------------------

function ConvenienceUpgradesManager.Init(services)
	print("   ConvenienceUpgradesManager (Module) - Initializing")
	Services = services or {}
	
	Players.PlayerAdded:Connect(function(player)
		if not PlayerUpgrades[player.UserId] then PlayerUpgrades[player.UserId] = {} end
		player.CharacterAdded:Connect(function()
			task.wait(0.5)
			applyCharacterEffects(player)
		end)
		if player.Character then applyCharacterEffects(player) end
	end)
	
	Players.PlayerRemoving:Connect(function(player)
		local bots = PlayerCollectorBots[player.UserId]
		if bots then for _, b in bots do b:Destroy() end end
		PlayerCollectorBots[player.UserId] = nil
		PlayerUpgrades[player.UserId] = nil
	end)
	
	for _, p in Players:GetPlayers() do
		if not PlayerUpgrades[p.UserId] then PlayerUpgrades[p.UserId] = {} end
		if p.Character then applyCharacterEffects(p) end
	end
	
	task.spawn(createConvenienceShopVendor)
	
	PurchaseUpgradeEvent.OnServerEvent:Connect(function(player, name)
		local s, m = ConvenienceUpgradesManager.HandleUpgradePurchase(player, name)
		PurchaseUpgradeEvent:FireClient(player, s, m)
	end)
	
	GetUpgradesInfoEvent.OnServerInvoke = function(player)
		return {
			OwnedUpgrades = PlayerUpgrades[player.UserId] or {},
			AllUpgrades = ConvenienceUpgradesConfig.GetAllUpgradesSorted(),
			Categories = ConvenienceUpgradesConfig.GetCategories()
		}
	end
	
	print("âœ“ ConvenienceUpgradesManager Initialized")
end

-- Export API
ConvenienceUpgradesManager.GetPlayerUpgrades = function(player) return PlayerUpgrades[player.UserId] or {} end
ConvenienceUpgradesManager.SetPlayerUpgrades = function(player, upgs)
	PlayerUpgrades[player.UserId] = upgs
	applyCharacterEffects(player)
	updateCollectorBots(player)
	ConvenienceUpgradesManager.ApplyBrainrotUpgrades(player)
end

ConvenienceUpgradesManager.CalculateIncomeMultiplier = calculateIncomeMultiplier
ConvenienceUpgradesManager.CalculateCycleReduction = calculateCycleReduction
ConvenienceUpgradesManager.GetBridgeSpeedMultiplier = getBridgeSpeedMultiplier
ConvenienceUpgradesManager.HasTeleportHome = function(player) return hasEffect(PlayerUpgrades[player.UserId] or {}, "TeleportHome") end

ConvenienceUpgradesManager.ResetPlayerUpgrades = function(player)
	PlayerUpgrades[player.UserId] = {}
	local bots = PlayerCollectorBots[player.UserId]
	if bots then for _, b in bots do b:Destroy() end end
	PlayerCollectorBots[player.UserId] = nil
	applyCharacterEffects(player)
	player:SetAttribute("IncomeMultiplier", 1)
	player:SetAttribute("CycleReduction", 0)
	player:SetAttribute("LuckyChance", 0)
	player:SetAttribute("CriticalChance", 0)
end

return ConvenienceUpgradesManager


================================================================================
FILE: src\server\DataManager.luau
================================================================================

--[[
	DataManager Server Module
	
	Handles saving and loading player data.
	Acts as a bridge/adapter to the new DataService (ProfileService).
]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local DataService -- Will be set from Services.DataService

-- Module Table
local DataManager = {}
local Services = {}

-- Getter for DataService (to avoid circular require)
local function getDataService()
	if not DataService then
		DataService = rawget(Services, "DataService")
	end
	return DataService
end

-- Configuration
local CONFIG = {
	DEFAULT_MONEY = 100,
}

--------------------------------------------------------------------------------
-- DATA GATHERING (LEGACY)
--------------------------------------------------------------------------------

local function getDefaultData()
	return {
		money = CONFIG.DEFAULT_MONEY,
		ownedUnits = {},
		unlockProgress = 5,
		purchasedTiers = 1,
		convenienceUpgrades = {},
		brainrotPlacements = {},
		itemStorage = {},
		backpack = {},
		storageCapacity = 2000,
		selectedVehicle = "Sneakers",
		vehicleCapacities = {},
		gridPositions = {},
		discoveredSynergies = {},
	}
end

local function gatherPlayerData(player: Player): any
	-- Get money from leaderstats
	local money = CONFIG.DEFAULT_MONEY
	local leaderstats = player:FindFirstChild("leaderstats")
	if leaderstats then
		local moneyValue = leaderstats:FindFirstChild("Money")
		if moneyValue then
			money = moneyValue.Value
		end
	end
	
	-- Get owned units and unlock progress from ShopManager
	local ownedUnits = {}
	local unlockProgress = 5
	
	local ShopManager = rawget(Services, "ShopManager")
	if ShopManager then
		if ShopManager.GetUnlockProgress then
			unlockProgress = ShopManager.GetUnlockProgress(player)
		end
		
		local ownedFolder = player:FindFirstChild("OwnedUnits")
		if ownedFolder then
			for _, countValue in ownedFolder:GetChildren() do
				if countValue:IsA("IntValue") and countValue.Value > 0 then
					ownedUnits[countValue.Name] = countValue.Value
				end
			end
		end
	end
	
	-- Get tier data from MapSystem
	local purchasedTiers = 1
	local MapSystem = rawget(Services, "MapSystem")
	if MapSystem and MapSystem.GetPlayerTierSystem then
		local tierSystem = MapSystem.GetPlayerTierSystem(player)
		if tierSystem then
			purchasedTiers = #tierSystem.Tiers
		end
	end
	
	-- Get convenience upgrades
	local convenienceUpgrades = {}
	local ConvenienceUpgradesManager = rawget(Services, "ConvenienceUpgradesManager")
	if ConvenienceUpgradesManager and ConvenienceUpgradesManager.GetPlayerUpgrades then
		convenienceUpgrades = ConvenienceUpgradesManager.GetPlayerUpgrades(player)
	end
	
	-- Get item storage data
	local itemStorage = {}
	local backpack = {}
	local storageCapacity = 2000
	local selectedVehicle = "Sneakers"
	local vehicleCapacities = {}
	local gridPositions = {}
	local discoveredSynergies = {}
	
	local ItemStorageManager = rawget(Services, "ItemStorageManager")
	if ItemStorageManager then
		if ItemStorageManager.GetStorageContents then
			itemStorage = ItemStorageManager.GetStorageContents(player) or {}
		end
		if ItemStorageManager.GetBackpackContents then
			backpack = ItemStorageManager.GetBackpackContents(player) or {}
		end
		if ItemStorageManager.GetStorageCapacity then
			storageCapacity = ItemStorageManager.GetStorageCapacity(player) or 2000
		end
	end
	
	local TransportManager = rawget(Services, "TransportManager")
	if TransportManager then
		if TransportManager.GetSelectedVehicle then
			selectedVehicle = TransportManager.GetSelectedVehicle(player) or "Sneakers"
		end
		if TransportManager.GetVehicleCapacities then
			vehicleCapacities = TransportManager.GetVehicleCapacities(player) or {}
		end
	end
	
	local GridManager = rawget(Services, "GridManager")
	if GridManager then
		if GridManager.GetGridPositions then
			gridPositions = GridManager.GetGridPositions(player) or {}
		end
	end
	
	-- AdjacencySynergyManager not in core services yet, skipping or need check
	-- For simplicity, omitting optional synergy data gathering if manager is not critical
	
	return {
		money = money,
		lifetimeEarnings = 0,
		unlockProgress = unlockProgress,
		purchasedTiers = purchasedTiers,
		convenienceUpgrades = convenienceUpgrades,
		GridPlacements = gridPositions,
		ItemStorage = itemStorage,
		Backpack = backpack,
		storageCapacity = storageCapacity,
		selectedVehicle = selectedVehicle,
		vehicleCapacities = vehicleCapacities,
		discoveredSynergies = discoveredSynergies,
	}
end

--------------------------------------------------------------------------------
-- DATA LOADING (LEGACY)
--------------------------------------------------------------------------------

local function applyLegacyData(player: Player, data: any)
	if not data then
		warn("DataManager: No data to apply for " .. player.Name)
		return
	end
	
	-- Create leaderstats
	local leaderstats = player:FindFirstChild("leaderstats")
	if not leaderstats then
		leaderstats = Instance.new("Folder")
		leaderstats.Name = "leaderstats"
		leaderstats.Parent = player
		
		local money = Instance.new("IntValue")
		money.Name = "Money"
		money.Value = data.money or CONFIG.DEFAULT_MONEY
		money.Parent = leaderstats
	else
		local money = leaderstats:FindFirstChild("Money")
		if money then
			money.Value = data.money or CONFIG.DEFAULT_MONEY
		end
	end
	
	-- Early restore convenience upgrades
	local ConvenienceUpgradesManager = rawget(Services, "ConvenienceUpgradesManager")
	if data.convenienceUpgrades and next(data.convenienceUpgrades) ~= nil then
		if ConvenienceUpgradesManager and ConvenienceUpgradesManager.SetPlayerUpgrades then
			ConvenienceUpgradesManager.SetPlayerUpgrades(player, data.convenienceUpgrades)
		end
	end
	
	task.spawn(function()
		task.wait(1)
		
		-- MIGRATION: Restore Inventory from Legacy ownedUnits
		local InventoryManager = rawget(Services, "InventoryManager")
		if InventoryManager then
			local currentInv = InventoryManager.GetInventory(player)
			local isEmpty = true
			for _ in pairs(currentInv) do isEmpty = false; break end
			
			if isEmpty and data.ownedUnits then
				print("DataManager: Migrating legacy inventory for " .. player.Name)
				for unitName, count in pairs(data.ownedUnits) do
					if type(count) == "number" and count > 0 then
						InventoryManager.AddUnit(player, unitName, "Normal", count)
					end
				end
			end
		end
		
		-- Restore Grid / Brainrot Placements
		local gridData = data.GridPlacements or data.gridPositions
		
		local BrainrotManager = rawget(Services, "BrainrotManager")
		local GridManager = rawget(Services, "GridManager")
		if gridData and next(gridData) ~= nil and BrainrotManager and BrainrotManager.SpawnBrainrotAtSlot then
			for slotIndexStr, slotData in pairs(gridData) do
				local slotIndex = tonumber(slotIndexStr)
				if slotIndex and slotData.Unit then
					local unitInfo = slotData.Unit
					BrainrotManager.SpawnBrainrotAtSlot(
						player, 
						unitInfo.unitType, 
						slotIndex,
						unitInfo.rarity or "Normal",
						unitInfo.level or 1,
						unitInfo.unitId
					)
				end
				if slotData.Tile and GridManager and GridManager.PlaceTile then
					GridManager.PlaceTile(player, slotIndex, slotData.Tile)
				end
			end
		end
	end)
end

--------------------------------------------------------------------------------
-- PUBLIC API
--------------------------------------------------------------------------------

function DataManager.Init(services)
	print("   DataManager (Module) - Initializing")
	Services = services or {}
	
	local ds = getDataService()
	if not ds then
		warn("DataManager: DataService not available during Init")
		return
	end
	
	-- Register with DataService
	ds.RegisterHandler("Legacy", {
		DefaultData = getDefaultData(),
		OnLoad = applyLegacyData,
		OnSave = gatherPlayerData
	})
	
	-- Init DataService (starts loading)
	-- ds.Init()  <-- REMOVED: ServerMain already initializes DataService.

	
	print("âœ“ DataManager Initialized")
end

-- Legacy API Support
function DataManager.SavePlayerData(player)
	return true
end

function DataManager.LoadPlayerData(player)
	local ds = getDataService()
	return (ds and ds.GetData(player)) or getDefaultData()
end

function DataManager.GetCachedData(player)
	local ds = getDataService()
	return ds and ds.GetData(player)
end

function DataManager.ResetPlayerData(player, keepPrestigeData)
	local ds = getDataService()
	if not ds then return end
	
	local currentData = ds.GetData(player)
	if not currentData then return end
	
	local newData = getDefaultData()
	
	if keepPrestigeData then
		local startingMoney = CONFIG.DEFAULT_MONEY
		local PrestigeManager = rawget(Services, "PrestigeManager")
		if PrestigeManager and PrestigeManager.GetStartingMoneyBonus then
			startingMoney = startingMoney + PrestigeManager.GetStartingMoneyBonus(player)
		end
		newData.money = startingMoney
	else
		ds.SetComponentData(player, "Prestige", nil)
	end
	
	ds.SetComponentData(player, "Inventory", {})
	ds.SetComponentData(player, "Artifacts", {})
	
	-- Reset Item Storage (Silos and Backpack)
	local ItemStorageManager = rawget(Services, "ItemStorageManager")
	if ItemStorageManager and ItemStorageManager.ResetPlayerStorage then
		ItemStorageManager.ResetPlayerStorage(player)
	else
		-- Fallback if manager not available
		ds.SetComponentData(player, "ItemStorage", {})
		ds.SetComponentData(player, "Backpack", {})
	end

	-- Reset Grid (Units and Tiles)
	local GridManager = rawget(Services, "GridManager")
	local BrainrotManager = rawget(Services, "BrainrotManager")
	
	if GridManager and GridManager.ClearGrid then
		GridManager.ClearGrid(player)
	else
		ds.SetComponentData(player, "GridPlacements", {})
	end
	
	if BrainrotManager and BrainrotManager.ClearAllUnits then
		BrainrotManager.ClearAllUnits(player)
	end
	
	-- Clear legacy keys (those managed by the Legacy/Root adapter)
	local componentKeys = { 
		Inventory = true, 
		Prestige = true, 
		Artifacts = true, 
		ItemStorage = true, 
		Backpack = true,
		GridPlacements = true
	}
	for k, _ in pairs(currentData) do
		if not componentKeys[k] then
			currentData[k] = nil
		end
	end
	
	for k, v in pairs(newData) do
		currentData[k] = v
	end
	
	applyLegacyData(player, currentData)
	return currentData
end

return DataManager


================================================================================
FILE: src\server\DataService.luau
================================================================================

--[[
	DataService.luau

	A SOLID, modular data manager powered by ProfileService.
	Handles player data persistence and allows other systems to register
	data handlers without tightly coupling with the persistence layer.
]]

local Players = game:GetService("Players")
local DataStoreService = game:GetService("DataStoreService")

local ProfileService = require(script.Parent.ProfileService)

-- PlayerLifecycleManager (Lazy Loaded to avoid circular require at module load time)
local PlayerLifecycleManager
local function getPlayerLifecycleManager()
	if not PlayerLifecycleManager then
		PlayerLifecycleManager = require(script.Parent.PlayerLifecycleManager)
	end
	return PlayerLifecycleManager
end

-- Types
type Profile = {
	Data: {[string]: any},
	Release: (self: Profile) -> (),
	ListenToRelease: (self: Profile, callback: () -> ()) -> (),
	IsActive: (self: Profile) -> boolean,
	Reconcile: (self: Profile) -> ()
}

type DataHandler = {
	-- Called when data is loaded. Use this to apply data to the player.
	OnLoad: (player: Player, data: any) -> (),
	-- Called before save (optional). Use this if you need to update the table before saving.
	-- Note: ProfileService auto-saves the 'Data' table, so if you keep that table up-to-date,
	-- you don't technically need this. But for legacy adapters, it's useful.
	OnSave: (player: Player, data: any) -> (),
	-- Default data for this component (if structure is partitioned)
	DefaultData: any?
}

local DataService = {}
local Profiles: {[Player]: Profile} = {}
local Handlers: {[string]: DataHandler} = {}

-- The store used for the new system (V3 - Clean Start)
local DATA_VERSION = "BrainRotClickerData_v4"
local ProfileStore = ProfileService.GetProfileStore(
	DATA_VERSION,
	{
		-- V3 Clean Schema - No legacy migration needed
		money = 0,
		lifetimeEarnings = 0,
		
		-- Brainrot Inventory (owned but not placed)
		Inventory = {},
		
		-- Grid Placements (units on islands with tier info)
		GridPlacements = {},
		
		-- Artifacts (all owned, with equipment links)
		Artifacts = {},
		
		-- Item Storage & Backpack
		ItemStorage = {},
		Backpack = {},
		
		-- Prestige System
		Prestige = {
			totalMeatballs = 0,
			spentMeatballs = 0,
			prestigeCount = 0,
			meatballUpgrades = {}
		},
		
		-- Upgrades & Progress
		storageCapacity = 2000,
		purchasedTiers = 1,
		unlockProgress = 5,
		selectedVehicle = "Sneakers",
		vehicleCapacities = {},
		convenienceUpgrades = {},
		discoveredSynergies = {}
	}
)

--------------------------------------------------------------------------------
-- PUBLIC API
--------------------------------------------------------------------------------

--[[
	Registers a handler for a specific data component.
	Ideally, we would partition data like:
	Profile.Data = {
		Shop = {...},
		Inventory = {...}
	}
	And handlers would register for "Shop", "Inventory".

	However, to support the "Legacy" blob migration, we allow a "Root" handler
	that receives the entire data table.
]]
function DataService.RegisterHandler(key: string, handler: DataHandler)
	Handlers[key] = handler
end

--[[
	Gets the current data for a player (entire profile).
]]
function DataService.GetData(player: Player)
	local profile = Profiles[player]
	if profile then
		return profile.Data
	end
	return nil
end

--[[
	Gets a specific component's data slice.
	@param player Player
	@param componentKey string - The component key (e.g., "Inventory", "Prestige")
	@return any? - The component data, or nil if not found
]]
function DataService.GetComponentData(player: Player, componentKey: string): any?
	local profile = Profiles[player]
	if profile and profile.Data then
		return profile.Data[componentKey]
	end
	return nil
end

--[[
	Sets a specific component's data (replaces entirely).
	Use this when you want to overwrite the component data.
	@param player Player
	@param componentKey string - The component key
	@param data any - The new data to set
	@return boolean - Whether the operation was successful
]]
function DataService.SetComponentData(player: Player, componentKey: string, data: any): boolean
	local profile = Profiles[player]
	if profile and profile.Data then
		profile.Data[componentKey] = data
		return true
	end
	return false
end

--[[
	Updates a specific component's data (merges with existing).
	Use this when you want to update specific fields without replacing all data.
	@param player Player
	@param componentKey string - The component key
	@param updates table - The fields to update/merge
	@return boolean - Whether the operation was successful
]]
function DataService.UpdateComponentData(player: Player, componentKey: string, updates: {[string]: any}): boolean
	local profile = Profiles[player]
	if not profile or not profile.Data then
		return false
	end
	
	-- Initialize component data if it doesn't exist
	if not profile.Data[componentKey] then
		profile.Data[componentKey] = {}
	end
	
	-- Merge updates into existing data
	local componentData = profile.Data[componentKey]
	if type(componentData) == "table" and type(updates) == "table" then
		for k, v in pairs(updates) do
			componentData[k] = v
		end
		return true
	end
	
	return false
end

--[[
	Checks if a player's profile is loaded and ready.
	@param player Player
	@return boolean - Whether the profile is loaded
]]
function DataService.IsLoaded(player: Player): boolean
	return Profiles[player] ~= nil
end

--[[
	COMPLETELY WIPES a player's profile from the DataStore.
	Use this to fix corrupted data. The player will start fresh on next join.
	@param player Player
	@return boolean - Whether the wipe was successful
]]
function DataService.WipePlayerData(player: Player): boolean
	-- First release the current profile if loaded
	local profile = Profiles[player]
	if profile then
		profile:Release()
		Profiles[player] = nil
	end
	
	-- Wipe the profile from DataStore
	local success = ProfileStore:WipeProfileAsync("Player_" .. player.UserId)
	if success then
		print("DataService: WIPED all data for " .. player.Name .. " (UserId: " .. player.UserId .. ")")
	else
		warn("DataService: Failed to wipe data for " .. player.Name)
	end
	
	return success
end

--------------------------------------------------------------------------------
-- V3: No migration needed - fresh start
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- HELPERS
--------------------------------------------------------------------------------

local function deepCopy(original)
	local copy = {}
	for k, v in pairs(original) do
		if type(v) == "table" then
			v = deepCopy(v)
		end
		copy[k] = v
	end
	return copy
end

--[[
	Sanitizes strings to only contain valid ASCII characters (DataStore safe).
	Removes any characters outside the printable ASCII range (32-126) except newlines.
	@param str string - The string to sanitize
	@return string - The sanitized string
]]
local function sanitizeString(str: string): string
	-- Remove any characters that are not printable ASCII (32-126) or newlines/tabs
	local sanitized = string.gsub(str, "[^%w%s%p]", "")
	return sanitized
end

--[[
	Recursively sanitizes all data for DataStore safety.
	Removes non-ASCII characters from strings and skips unsaveable types.
	@param data any - The data to sanitize
	@return any - The sanitized data
]]
local function sanitizeData(data: any): any
	if type(data) == "string" then
		return sanitizeString(data)
	elseif type(data) == "table" then
		local clean = {}
		for k, v in pairs(data) do
			-- Sanitize key if it's a string
			local cleanKey = type(k) == "string" and sanitizeString(k) or k
			clean[cleanKey] = sanitizeData(v)
		end
		return clean
	elseif type(data) == "number" or type(data) == "boolean" then
		return data
	else
		-- Skip userdata, functions, threads, etc.
		return nil
	end
end

--------------------------------------------------------------------------------
-- PLAYER LIFECYCLE
--------------------------------------------------------------------------------

local function onPlayerAdded(player: Player)
	if Profiles[player] then return end -- Prevent double loading
	
	local profile = ProfileStore:LoadProfileAsync("Player_" .. player.UserId)

	if profile then
		profile:AddUserId(player.UserId)
		profile:Reconcile()

		profile:ListenToRelease(function()
			Profiles[player] = nil
			-- Kick player if profile is loaded on another server
			player:Kick("Profile released - Your data has been loaded on another server.")
		end)

		if player:IsDescendantOf(Players) then
			Profiles[player] = profile

			-- V3: No migration needed - ProfileService Reconcile() applies defaults from template

			-- Notify Handlers
			for key, handler in pairs(Handlers) do
				task.spawn(function()
					-- If key is "Root" or "Legacy", pass the whole table.
					-- Otherwise, pass profile.Data[key] (future proofing)
					local dataToPass = profile.Data

					if key == "Root" or key == "Legacy" then
						-- For Root/Legacy, if the profile is empty (no keys), apply defaults
						-- We check specifically for a critical key like 'money' to decide if it's empty
						if not next(profile.Data) and handler.DefaultData then
							print("DataService: Applying default data for new player...")
							local defaults = deepCopy(handler.DefaultData)
							for k, v in pairs(defaults) do
								profile.Data[k] = v
							end
						end
						dataToPass = profile.Data
					else
						-- For specific keys
						if not profile.Data[key] and handler.DefaultData then
							profile.Data[key] = deepCopy(handler.DefaultData)
						end
						dataToPass = profile.Data[key]
					end

					handler.OnLoad(player, dataToPass)
				end)
			end
			
			local plm = getPlayerLifecycleManager()
			if plm then plm.SetDataLoaded(player) end

			print("DataService: Profile loaded for " .. player.Name)
		else
			profile:Release()
		end
	else
		player:Kick("DataService: Could not load profile. Please rejoin.")
	end
end

local function onPlayerRemoving(player: Player)
	local profile = Profiles[player]
	if profile then
		-- Notify Handlers to perform any final updates before release
		for key, handler in pairs(Handlers) do
			if handler.OnSave then
				local dataToPass = profile.Data
				if key ~= "Root" and key ~= "Legacy" then
					dataToPass = profile.Data[key]
				end

				-- The handler might return modified data, or modify it in place.
				-- For the Legacy adapter, it effectively gathers data and returns it.
				-- If OnSave returns a table, we update the profile.
				local savedData = handler.OnSave(player, dataToPass)
				if savedData and (key == "Root" or key == "Legacy") then
					-- Merge/Overwrite for Root/Legacy
					for k, v in pairs(savedData) do
						profile.Data[k] = v
					end
				elseif savedData then
					profile.Data[key] = savedData
				end
			end
		end

		-- SANITIZE strings in-place before release to prevent UTF-8 errors
		-- Use in-place sanitization to avoid breaking ProfileService internal structures
		local function sanitizeInPlace(tbl)
			for k, v in pairs(tbl) do
				if type(v) == "string" then
					-- Remove non-ASCII characters
					tbl[k] = string.gsub(v, "[^%w%s%p]", "")
				elseif type(v) == "table" then
					sanitizeInPlace(v)
				end
			end
		end
		sanitizeInPlace(profile.Data)

		profile:Release()
	end
end

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

local Initialized = false

function DataService.Init()
	if Initialized then return end
	Initialized = true
	
	for _, player in ipairs(Players:GetPlayers()) do
		task.spawn(onPlayerAdded, player)
	end

	Players.PlayerAdded:Connect(onPlayerAdded)
	Players.PlayerRemoving:Connect(onPlayerRemoving)
	
	game:BindToClose(function()
		print("DataService: Server closing, releasing profiles...")
		
		-- Trigger safe removal for all players
		for _, player in ipairs(Players:GetPlayers()) do
			-- Use coroutines to parallelize saving
			task.spawn(onPlayerRemoving, player)
		end
		
		-- Wait for all profiles to be released (saved)
		local startTime = os.clock()
		while next(Profiles) ~= nil do
			if os.clock() - startTime > 30 then 
				warn("DataService: BindToClose timed out waiting for saves!")
				break 
			end
			task.wait(0.1)
		end
		
		print("DataService: All profiles released.")
	end)
end

return DataService


================================================================================
FILE: src\server\GridManager.luau
================================================================================

--[[
	GridManager Server Module
	
	Manages grid-based brainrot placement on player plots.
]]

-- Services
local _Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local _CollectionService = game:GetService("CollectionService")

-- Shared configs
-- Shared configs (Lazy Loaded)
local TileConfig

local function getTileConfig()
	if not TileConfig then
		local Shared = ReplicatedStorage:WaitForChild("Shared")
		TileConfig = require(Shared:WaitForChild("TileConfig"))
	end
	return TileConfig
end

-- DataService (Lazy Loaded via Services)
local DataService -- Will be set from Services.DataService

-- Constants
local _BRAINROT_TAG = "Brainrot"
local _TILE_TAG = "GridTile"
local CONFIG = {
	TILE_SIZE = 10,
	GRID_SIZES = {
		starter = {rows = 4, cols = 4},   -- 16 slots
		bronze = {rows = 4, cols = 5},    -- 20 slots
		silver = {rows = 5, cols = 5},    -- 25 slots
		gold = {rows = 6, cols = 6},      -- 36 slots
	},
	DEFAULT_GRID = "starter",
	GRID_OFFSET_Y = 0,
	TILE_THICKNESS = 1,
}

-- Remote Objects
local RemoteEvents = ReplicatedStorage:FindFirstChild("RemoteEvents") or Instance.new("Folder")
RemoteEvents.Name = "RemoteEvents"
RemoteEvents.Parent = ReplicatedStorage

local RemoteFunctions = ReplicatedStorage:FindFirstChild("RemoteFunctions") or Instance.new("Folder")
RemoteFunctions.Name = "RemoteFunctions"
RemoteFunctions.Parent = ReplicatedStorage

local GridUpdatedEvent = RemoteEvents:FindFirstChild("GridUpdated") or Instance.new("RemoteEvent")
GridUpdatedEvent.Name = "GridUpdated"
GridUpdatedEvent.Parent = RemoteEvents

local UnitPlacedEvent = RemoteEvents:FindFirstChild("UnitPlaced") or Instance.new("RemoteEvent")
UnitPlacedEvent.Name = "UnitPlaced"
UnitPlacedEvent.Parent = RemoteEvents

local PlaceUnitFunction = RemoteFunctions:FindFirstChild("PlaceUnit") or Instance.new("RemoteFunction")
PlaceUnitFunction.Name = "PlaceUnit"
PlaceUnitFunction.Parent = RemoteFunctions

local MoveUnitFunction = RemoteFunctions:FindFirstChild("MoveUnit") or Instance.new("RemoteFunction")
MoveUnitFunction.Name = "MoveUnit"
MoveUnitFunction.Parent = RemoteFunctions

local SwapUnitsFunction = RemoteFunctions:FindFirstChild("SwapUnits") or Instance.new("RemoteFunction")
SwapUnitsFunction.Name = "SwapUnits"
SwapUnitsFunction.Parent = RemoteFunctions

local StashUnitFunction = RemoteFunctions:FindFirstChild("StashUnit") or Instance.new("RemoteFunction")
StashUnitFunction.Name = "StashUnit"
StashUnitFunction.Parent = RemoteFunctions

local GetGridFunction = RemoteFunctions:FindFirstChild("GetGrid") or Instance.new("RemoteFunction")
GetGridFunction.Name = "GetGrid"
GetGridFunction.Parent = RemoteFunctions

-- Admin/Debug functions referenced in legacy
local PlaceBrainrotFunction = RemoteEvents:FindFirstChild("PlaceBrainrot") or Instance.new("RemoteFunction")
PlaceBrainrotFunction.Name = "PlaceBrainrot"
PlaceBrainrotFunction.Parent = RemoteEvents

local RemoveBrainrotFunction = RemoteEvents:FindFirstChild("RemoveBrainrot") or Instance.new("RemoteFunction")
RemoveBrainrotFunction.Name = "RemoveBrainrot"
RemoveBrainrotFunction.Parent = RemoteEvents

local PlaceTileFunction = RemoteFunctions:FindFirstChild("PlaceTile") or Instance.new("RemoteFunction")
PlaceTileFunction.Name = "PlaceTile"
PlaceTileFunction.Parent = RemoteFunctions

local RemoveTileFunction = RemoteFunctions:FindFirstChild("RemoveTile") or Instance.new("RemoteFunction")
RemoveTileFunction.Name = "RemoveTile"
RemoveTileFunction.Parent = RemoteFunctions

-- Module Table
local GridManager = {}
local Services = {}

-- Getter for DataService (to avoid circular require)
local function getDataService()
	if not DataService then
		DataService = rawget(Services, "DataService")
	end
	return DataService
end

-- Player Grid Data
local PlayerGrids = {}

--------------------------------------------------------------------------------
-- HELPERS
--------------------------------------------------------------------------------

local function getPlayerGrid(player)
	if not PlayerGrids[player.UserId] then
		PlayerGrids[player.UserId] = {
			gridSize = CONFIG.DEFAULT_GRID,
			slots = {},
			tileInstances = {},
		}
	end
	return PlayerGrids[player.UserId]
end

local function getSlotData(gridData, slotIndex)
	if not gridData.slots[slotIndex] then
		gridData.slots[slotIndex] = { Unit = nil, Tile = nil }
	end
	return gridData.slots[slotIndex]
end

local function getGridDimensions(player)
	local gridData = getPlayerGrid(player)
	local sizeConfig = CONFIG.GRID_SIZES[gridData.gridSize] or CONFIG.GRID_SIZES.starter
	return sizeConfig.rows, sizeConfig.cols
end

local function getTotalSlots(player)
	local rows, cols = getGridDimensions(player)
	return rows * cols
end

local function findPlayerPlot(player)
	-- Assumes plots are in Workspace.Plots and have OwnerId attribute
	local plotsFolder = workspace:FindFirstChild("Plots")
	if not plotsFolder then return nil end
	for _, plot in plotsFolder:GetChildren() do
		if plot:GetAttribute("OwnerId") == player.UserId then return plot end
	end
	return nil
end

local function getPlotCenter(plot)
	local floor = plot:FindFirstChild("Island") or plot:FindFirstChild("PlotFloor") or plot:FindFirstChild("Floor") or plot:FindFirstChildWhichIsA("BasePart")
	if floor and floor:IsA("BasePart") then return floor.Position end
	if plot:IsA("Model") then return plot:GetBoundingBox().Position end
	if plot:IsA("BasePart") then return plot.Position end
	return Vector3.new(0, 5, 0)
end

local function getPlotSize(plot)
	local floor = plot:FindFirstChild("Island") or plot:FindFirstChild("PlotFloor") or plot:FindFirstChild("Floor") or plot:FindFirstChildWhichIsA("BasePart")
	if floor and floor:IsA("BasePart") then return floor.Size end
	if plot:IsA("BasePart") then return plot.Size end
	if plot:IsA("Model") then local _, size = plot:GetBoundingBox(); return size end
	return Vector3.new(50, 10, 50)
end

local function getTileAtSlot(player, slotIndex)
	local gridData = getPlayerGrid(player)
	local slot = gridData.slots[slotIndex]
	return slot and slot.Tile
end

local function getFloorTopY(player)
	local plot = findPlayerPlot(player)
	if not plot then return 10 end
	local floor = plot:FindFirstChild("Island") or plot:FindFirstChild("PlotFloor") or plot:FindFirstChild("Floor") or plot:FindFirstChildWhichIsA("BasePart")
	if floor and floor:IsA("BasePart") then
		return floor.Position.Y + (floor.Size.Y / 2)
	end
	return 10
end

local function getSlotCFrame(player, slotIndex)
	local plot = findPlayerPlot(player)
	if not plot then return CFrame.new(0, 10, 0) end
	
	local plotCenter = getPlotCenter(plot)
	local plotSize = getPlotSize(plot)
	
	local posY = plotCenter.Y + (plotSize.Y / 2) + CONFIG.GRID_OFFSET_Y
	local tileId = getTileAtSlot(player, slotIndex)
	if tileId then 
		local tc = getTileConfig()
		posY = posY + tc.TileHeight 
	end
	
	local CLUSTER_SIZE = 2
	local TILE_SPACING = CONFIG.TILE_SIZE
	local cornerOffsetX = (plotSize.X / 2) - (CLUSTER_SIZE * TILE_SPACING / 2) - TILE_SPACING
	local cornerOffsetZ = (plotSize.Z / 2) - (CLUSTER_SIZE * TILE_SPACING / 2) - TILE_SPACING
	
	local cornerIndex = math.floor((slotIndex - 1) / 4)
	local posInCorner = (slotIndex - 1) % 4
	
	local localRow = math.floor(posInCorner / 2)
	local localCol = posInCorner % 2
	
	local cornerPositions = {
		{x = -cornerOffsetX, z = -cornerOffsetZ},
		{x = cornerOffsetX, z = -cornerOffsetZ},
		{x = -cornerOffsetX, z = cornerOffsetZ},
		{x = cornerOffsetX, z = cornerOffsetZ},
	}
	local corner = cornerPositions[cornerIndex + 1] or cornerPositions[1]
	
	local posX = plotCenter.X + corner.x + (localCol - 0.5) * TILE_SPACING
	local posZ = plotCenter.Z + corner.z + (localRow - 0.5) * TILE_SPACING
	
	local unitPos = Vector3.new(posX, posY, posZ)
	local lookDirection = (plotCenter - unitPos) * Vector3.new(1, 0, 1)
	
	if lookDirection.Magnitude == 0 then lookDirection = Vector3.new(0, 0, -1) end
	return CFrame.lookAt(unitPos, unitPos + lookDirection)
end

local function repositionUnitOnTile(player, brainrot, slotIndex)
	if not brainrot then 
		print("[DEBUG] repositionUnitOnTile: brainrot is nil!")
		return 
	end
	local baseCFrame = getSlotCFrame(player, slotIndex)
	print(string.format("[DEBUG] repositionUnitOnTile: Moving %s to slot %d at Y=%.1f", 
		brainrot.Name, slotIndex, baseCFrame.Position.Y))
	brainrot:PivotTo(baseCFrame)
end

local function createTileVisual(player, slotIndex, tileId)
	local tc = getTileConfig()
	local tileData = tc.GetTile(tileId)
	if not tileData then return nil end
	local plot = findPlayerPlot(player)
	if not plot then return nil end
	
	local baseCFrame = getSlotCFrame(player, slotIndex)
	local floorTopY = getFloorTopY(player)
	local tileY = floorTopY + (tc.TileHeight / 2)
	
	local tilePart = Instance.new("Part")
	tilePart.Name = "GridTile_" .. slotIndex
	tilePart.Size = Vector3.new(tc.TileSize, tc.TileHeight, tc.TileSize)
	tilePart.Anchored = true
	tilePart.CanCollide = false
	tilePart.Material = Enum.Material.SmoothPlastic
	tilePart.Color = tileData.Color
	tilePart.Transparency = 0.2
	tilePart.Position = Vector3.new(baseCFrame.Position.X, tileY, baseCFrame.Position.Z)
	
	local highlight = Instance.new("SurfaceLight")
	highlight.Color = tileData.Color
	highlight.Brightness = 0.3
	highlight.Range = 4
	highlight.Face = Enum.NormalId.Top
	highlight.Parent = tilePart
	
	tilePart:SetAttribute("TileId", tileId)
	tilePart:SetAttribute("SlotIndex", slotIndex)
	
	local tilesFolder = plot:FindFirstChild("GridTiles") or Instance.new("Folder", plot)
	tilesFolder.Name = "GridTiles"
	tilePart.Parent = tilesFolder
	
	return tilePart
end

local function syncToProfile(player)
	local ds = getDataService()
	if ds and ds.IsLoaded(player) then
		local gridData = getPlayerGrid(player)
		local positions = {}
		for idx, slotInfo in pairs(gridData.slots) do
			if slotInfo.Unit or slotInfo.Tile then
				local entry = { Unit = nil, Tile = slotInfo.Tile }
				if slotInfo.Unit then
					local u = slotInfo.Unit
					local uType = u:GetAttribute("UnitType")
					if uType then
						entry.Unit = {
							unitType = uType,
							rarity = u:GetAttribute("Rarity") or "Normal",
							level = u:GetAttribute("Level") or 1,
							unitId = u:GetAttribute("UnitId"),
						}
					end
				end
				positions[tostring(idx)] = entry
			end
		end
		ds.SetComponentData(player, "GridPlacements", positions)
	end
end

--------------------------------------------------------------------------------
-- PUBLIC API
--------------------------------------------------------------------------------

function GridManager.Init(services)
	print("   GridManager (Module) - Initializing")
	Services = services or {}
	
	-- Register Data Handler
	local ds = getDataService()
	if not ds then
		warn("GridManager: DataService not available during Init")
		return
	end
	
	ds.RegisterHandler("GridPlacements", {
		DefaultData = {},
		OnLoad = function(player, data)
			-- Restore Grid
			if not data then
				local PlayerLifecycleManager = rawget(Services, "PlayerLifecycleManager")
				if PlayerLifecycleManager then
					PlayerLifecycleManager.SetGridRestored(player)
				end
				return
			end
			
			task.spawn(function()
				local BrainrotManager = rawget(Services, "BrainrotManager")
				local MapSystem = rawget(Services, "MapSystem")
				
				-- WAIT FOR PLOT (Fix Race Condition)
				local plot = nil
				local attempts = 0
				while not plot and attempts < 100 do -- Wait up to 10s
					if not player.Parent then return end -- Player left
					
					if MapSystem and MapSystem.GetPlayerPlot then
						plot = MapSystem.GetPlayerPlot(player)
					end
					
					if not plot then
						task.wait(0.1)
						attempts += 1
					end
				end
				
				if not plot then
					warn("GridManager: Could not find plot for " .. player.Name .. " - Grid restoration failed")
					return
				end
				
				-- Proceed with restoration
				for slotIndexStr, slotData in pairs(data) do
					local slotIndex = tonumber(slotIndexStr)
					if slotIndex then
						-- Restore Tile
						if slotData.Tile then
							GridManager.PlaceTile(player, slotIndex, slotData.Tile)
						end
						
						-- Restore Unit
						if slotData.Unit and BrainrotManager then
							-- Reconstruct placement data for BrainrotManager
							local placementData = {
								unitType = slotData.Unit.unitType,
								rarity = slotData.Unit.rarity,
								level = slotData.Unit.level,
								unitId = slotData.Unit.unitId,
								slotIndex = slotIndex
							}
							-- Spawn physical unit and place it
							BrainrotManager.SpawnFromPlacement(player, placementData)
						end
					end
				end
				
				local PlayerLifecycleManager = rawget(Services, "PlayerLifecycleManager")
				if PlayerLifecycleManager then
					PlayerLifecycleManager.SetGridRestored(player)
				end
			end)
		end,
		OnSave = function(player, data)
			-- Return current state to ensure it's saved correctly
			return GridManager.GetGridPositions(player)
		end
	})
	
	-- Connect Remotes
	PlaceUnitFunction.OnServerInvoke = GridManager.PlaceUnitFromInventory
	MoveUnitFunction.OnServerInvoke = GridManager.MoveUnit
	SwapUnitsFunction.OnServerInvoke = GridManager.SwapUnits
	StashUnitFunction.OnServerInvoke = GridManager.StashUnit
	
	-- Legacy Connections
	PlaceBrainrotFunction.OnServerInvoke = GridManager.PlaceUnitFromInventory
	RemoveBrainrotFunction.OnServerInvoke = GridManager.StashUnit
	
	GetGridFunction.OnServerInvoke = function(player)
		local gridData = getPlayerGrid(player)
		-- Serialize specific fields for client
		local serialized = {
			gridSize = gridData.gridSize,
			slots = {}
		}
		for k, v in pairs(gridData.slots) do
			if v.Unit or v.Tile then
				serialized.slots[k] = {
					Tile = v.Tile,
					UnitName = v.Unit and v.Unit.Name or nil
				}
			end
		end
		return serialized
	end
	
	print("âœ“ GridManager Initialized")
end

function GridManager.PlaceUnit(player, brainrot, slotIndex)
	local gridData = getPlayerGrid(player)
	local totalSlots = getTotalSlots(player)
	
	if slotIndex < 1 or slotIndex > totalSlots then return false, "Invalid slot" end
	
	local slot = getSlotData(gridData, slotIndex)
	if slot.Unit then return false, "Occupied" end
	
	-- Uniqueness check
	local unitType = brainrot:GetAttribute("UnitType") or brainrot.Name
	for _, slotData in pairs(gridData.slots) do
		if slotData.Unit then
			local otherType = slotData.Unit:GetAttribute("UnitType")
			if otherType == unitType then return false, "Already placed!" end
		end
	end
	
	slot.Unit = brainrot
	brainrot:SetAttribute("GridSlot", slotIndex)
	brainrot:SetAttribute("IsStored", false)
	
	repositionUnitOnTile(player, brainrot, slotIndex)
	
	for _, part in brainrot:GetDescendants() do
		if part:IsA("BasePart") then part.Anchored = true end
	end
	
	UnitPlacedEvent:FireClient(player, slotIndex, brainrot.Name)
	syncToProfile(player)
	return true
end

function GridManager.PlaceUnitFromInventory(player, unitName, arg2, arg3)
	-- Polymorphic Argument Handling
	local slotIndex
	if type(arg2) == "number" then
		slotIndex = arg2
	elseif type(arg3) == "number" then
		slotIndex = arg3
	else
		print("[DEBUG] PlaceUnitFromInventory: Invalid arguments", unitName, arg2, arg3)
		return false, "Invalid arguments"
	end

	print(string.format("[DEBUG] PlaceUnitFromInventory: %s -> slot %d", unitName, slotIndex))

	-- Logic wrapper for Remote
	local BrainrotManager = rawget(Services, "BrainrotManager")
	local InventoryManager = rawget(Services, "InventoryManager")
	
	if not BrainrotManager or not InventoryManager then return false, "Server not ready" end
	
	-- 1. Ownership Check
	local unitData = InventoryManager.GetUnit(player, unitName)
	if not unitData then
		print("[DEBUG] PlaceUnitFromInventory: Unit not owned -", unitName)
		return false, "Unit not owned"
	end
	print(string.format("[DEBUG] PlaceUnitFromInventory: Ownership verified (level=%d)", unitData.level or 0))
	
	-- 2. Find Physical Unit
	local plot = findPlayerPlot(player)
	if not plot then return false, "No plot" end
	
	local brainrots = plot:FindFirstChild("Brainrots")
	local unit
	if brainrots then
		for _, child in brainrots:GetChildren() do
			if child:GetAttribute("UnitType") == unitName then
				unit = child
				print(string.format("[DEBUG] PlaceUnitFromInventory: Found existing model at Y=%.1f", child:GetPivot().Position.Y))
				break
			end
		end
	end
	
	-- 3. Recovery if unit missing physically but owned
	-- 3. Recovery if unit missing physically but owned
	if not unit then
		-- Force Spawn using SpawnForGrid (avoids duplicate AddUnit call)
		print("[DEBUG] PlaceUnitFromInventory: No model found, spawning new visual...")
		
		-- Construct data from inventory
		local spawnData = {
			level = unitData.level or 1,
			rarity = unitData.rarity or "Normal",
			unitId = unitData.unitId -- Vital to keep same ID
		}
		
		unit = BrainrotManager.SpawnForGrid(player, unitName, spawnData)
		if unit then
			print(string.format("[DEBUG] PlaceUnitFromInventory: Spawned new model at Y=%.1f", unit:GetPivot().Position.Y))
		else
			print("[DEBUG] PlaceUnitFromInventory: Spawn failed!")
		end
	end
	
	if unit then
		return GridManager.PlaceUnit(player, unit, slotIndex)
	end
	
	return false, "Unit model not found (Try rejoining)"
end

function GridManager.MoveUnit(player, fromSlot, toSlot)
	local gridData = getPlayerGrid(player)
	local fromSlotData = gridData.slots[fromSlot]
	if not fromSlotData or not fromSlotData.Unit then return false, "Empty source" end
	
	local toSlotData = getSlotData(gridData, toSlot)
	if toSlotData.Unit then return false, "Target occupied" end
	
	local brainrot = fromSlotData.Unit
	fromSlotData.Unit = nil
	toSlotData.Unit = brainrot
	brainrot:SetAttribute("GridSlot", toSlot)
	
	repositionUnitOnTile(player, brainrot, toSlot)
	GridUpdatedEvent:FireClient(player, toSlot, brainrot.Name, "moved")
	syncToProfile(player)
	
	return true
end

function GridManager.SwapUnits(player, slot1, slot2)
	local gridData = getPlayerGrid(player)
	local s1 = getSlotData(gridData, slot1)
	local s2 = getSlotData(gridData, slot2)
	
	if not s1.Unit and not s2.Unit then return false, "Nothing to swap" end
	
	local u1, u2 = s1.Unit, s2.Unit
	s1.Unit, s2.Unit = u2, u1
	
	if u1 then
		u1:SetAttribute("GridSlot", slot2)
		repositionUnitOnTile(player, u1, slot2)
	end
	if u2 then
		u2:SetAttribute("GridSlot", slot1)
		repositionUnitOnTile(player, u2, slot1)
	end
	
	syncToProfile(player)
	return true
end

function GridManager.StashUnit(player, slotIndex)
	local gridData = getPlayerGrid(player)
	local slot = getSlotData(gridData, slotIndex)
	
	if not slot.Unit then return false, "Empty slot" end
	
	local brainrot = slot.Unit
	slot.Unit = nil
	
	local BrainrotManager = rawget(Services, "BrainrotManager")
	if BrainrotManager then
		BrainrotManager.StashBrainrot(player, brainrot)
	end
	
	syncToProfile(player)
	return true
end

function GridManager.GetGridPositions(player)
	-- Returns legacy grid format for other managers
	local gridData = getPlayerGrid(player)
	local export = {}
	for k, v in pairs(gridData.slots) do
		if v.Unit then
			-- Reconstruct the full unit data obj if needed
			export[tostring(k)] = {
				Unit = {
					unitType = v.Unit:GetAttribute("UnitType"),
					rarity = v.Unit:GetAttribute("Rarity"),
					level = v.Unit:GetAttribute("Level"),
					unitId = v.Unit:GetAttribute("UnitId")
				},
				Tile = v.Tile
			}
		elseif v.Tile then
			export[tostring(k)] = { Tile = v.Tile }
		end
	end
	return export
end

function GridManager.GetTileAtSlot(player, slotIndex)
	return getTileAtSlot(player, slotIndex)
end

function GridManager.PlaceTile(player, slotIndex, tileId)
	local tc = getTileConfig()
	if not tc.GetTile(tileId) then return false end
	local gridData = getPlayerGrid(player)
	local slot = getSlotData(gridData, slotIndex)
	
	-- Remove old
	if gridData.tileInstances[slotIndex] then
		gridData.tileInstances[slotIndex]:Destroy()
		gridData.tileInstances[slotIndex] = nil
	end
	
	slot.Tile = tileId
	local visual = createTileVisual(player, slotIndex, tileId)
	if visual then gridData.tileInstances[slotIndex] = visual end
	
	if slot.Unit then repositionUnitOnTile(player, slot.Unit, slotIndex) end
	
	syncToProfile(player)
	return true
end

function GridManager.ClearGrid(player)
	local gridData = PlayerGrids[player.UserId]
	if not gridData then return end
	
	-- Destroy tile visuals
	for _, visual in pairs(gridData.tileInstances) do
		if visual then visual:Destroy() end
	end
	gridData.tileInstances = {}
	gridData.slots = {}
	
	-- Ensure the grid is cleared in DataService
	syncToProfile(player)
	
	-- Notify client
	GridUpdatedEvent:FireClient(player, 0, "", "cleared")
end

return GridManager


================================================================================
FILE: src\server\InventoryManager.luau
================================================================================

--[[
	InventoryManager Server Module
	
	â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	                   PERMANENT COLLECTION ASSETS ONLY
	â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	PURPOSE:
	  The Single Source of Truth for player-OWNED Units (Brainrots) and their
	  metadata. These are PERMANENT assets that persist across sessions and
	  are saved to the player's DataStore profile.
	
	MANAGES:
	  â€¢ CollectionUnits  - Brainrots the player owns (with level, rarity, unitId)
	  â€¢ Unit Placement   - Whether a unit is "placed" on grid or "stored"
	
	DATA LIFECYCLE:
	  â€¢ Saved to Profile via DataService ("Inventory" component)
	  â€¢ Persists across sessions
	  â€¢ Never automatically consumed or sold
	
	INTEGRATION:
	  â†’ GridManager       - For unit placement status
	  â†’ BrainrotManager   - Listens to UnitChanged signal
	  â†’ ArtifactManager   - Separate manager for Artifact collection
	
	â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	âš ï¸  DO NOT USE THIS FOR TRANSIENT TYCOON RESOURCES:
	    Produced items (resources waiting in silos) belong in ItemStorageManager,
	    which connects to ItemProductionManager â†’ TransportManager supply chain.
	â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")

-- Type Imports
local Shared = ReplicatedStorage:WaitForChild("Shared")
local _ItemTypes = require(Shared:WaitForChild("ItemTypes")) -- For type reference (see BrainrotUnit)

-- Strict Type Definitions for BrainrotUnits (permanent collection assets)
-- See ItemTypes.luau for full type: BrainrotUnit
export type UnitData = {
	level: number,
	rarity: string,
	unitId: string,
}

-- Lazy Config
local RarityConfig

local function getRarityConfig()
	if not RarityConfig then
		local Shared = ReplicatedStorage:WaitForChild("Shared")
		RarityConfig = require(Shared:WaitForChild("RarityConfig"))
	end
	return RarityConfig
end

-- DataService (Lazy Loaded via Services)
local DataService -- Will be set from Services.DataService

-- Events
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local InventoryChangedEvent = RemoteEvents:FindFirstChild("InventoryChanged") or Instance.new("RemoteEvent")
InventoryChangedEvent.Name = "InventoryChanged"
InventoryChangedEvent.Parent = RemoteEvents

-- Component key for DataService
local COMPONENT_KEY = "Inventory"

--------------------------------------------------------------------------------
-- MODULE DEFINITION
--------------------------------------------------------------------------------

local InventoryManager = {}
local Services = {} -- Service Container

-- Getter for DataService (to avoid circular require)
local function getDataService()
	if not DataService then
		DataService = rawget(Services, "DataService")
	end
	return DataService
end

-- Signal for server-side listeners (BrainrotManager)
local UnitChangedSignal = Instance.new("BindableEvent")
InventoryManager.UnitChanged = UnitChangedSignal.Event

-- Internal helper
local function getInventoryData(player: Player): {[string]: any}?
	local ds = getDataService()
	if not ds then return nil end
	
	local data = ds.GetComponentData(player, COMPONENT_KEY)
	if data then
		return data
	end
	
	-- Initialize if not exists and profile is loaded
	if ds.IsLoaded(player) then
		ds.SetComponentData(player, COMPONENT_KEY, {})
		return ds.GetComponentData(player, COMPONENT_KEY)
	end
	
	return nil
end

--------------------------------------------------------------------------------
-- PUBLIC API
--------------------------------------------------------------------------------

function InventoryManager.Init(services)
	print("   InventoryManager (Module) - Initializing")
	Services = services or {}
	
	-- Create canonical GetInventory RemoteFunction
	local GetInventoryRemote = RemoteEvents:FindFirstChild("GetInventory") or Instance.new("RemoteFunction")
	GetInventoryRemote.Name = "GetInventory"
	GetInventoryRemote.Parent = RemoteEvents
	
	-- Register with DataService
	local ds = getDataService()
	if ds then
		ds.RegisterHandler(COMPONENT_KEY, {
			DefaultData = {},
			OnLoad = function(player: Player, data: any)
				local unitCount = 0
				if data and type(data) == "table" then
					for _ in pairs(data) do unitCount += 1 end
				end
				print(string.format("InventoryManager: Loaded %d units for %s", unitCount, player.Name))
				
				task.defer(function()
					UnitChangedSignal:Fire(player, nil, nil)
				end)
			end,
			OnSave = function(player: Player, data: any)
				return data
			end
		})
	else
		warn("InventoryManager: DataService not available during Init")
	end
	
	-- Canonical GetInventory handler
	GetInventoryRemote.OnServerInvoke = function(player)
		local inventory = { units = {} }
		local invData = getInventoryData(player) or {}
		
		-- Get GridManager to check placement status
		local GridManager = rawget(Services, "GridManager")
		local gridPositions = {}
		if GridManager and GridManager.GetGridPositions then
			gridPositions = GridManager.GetGridPositions(player) or {}
		end
		
		-- Build placed units set
		local placedUnits = {}
		for _, slotData in pairs(gridPositions) do
			if slotData.Unit and slotData.Unit.unitType then
				placedUnits[slotData.Unit.unitType] = true
			end
		end
		
		-- Build response
		for unitName, unitData in pairs(invData) do
			if unitData.level and unitData.level > 0 then
				inventory.units[unitName] = {
					level = unitData.level or 1,
					rarity = unitData.rarity or "Normal",
					status = placedUnits[unitName] and "placed" or "stored"
				}
			end
		end
		
		return inventory
	end
	
	-- Create GetUnifiedInventory RemoteFunction (for BackpackHUD)
	local RemoteFunctions = ReplicatedStorage:FindFirstChild("RemoteFunctions") or Instance.new("Folder")
	RemoteFunctions.Name = "RemoteFunctions"
	RemoteFunctions.Parent = ReplicatedStorage
	
	local GetUnifiedInventoryRemote = RemoteFunctions:FindFirstChild("GetUnifiedInventory") or Instance.new("RemoteFunction")
	GetUnifiedInventoryRemote.Name = "GetUnifiedInventory"
	GetUnifiedInventoryRemote.Parent = RemoteFunctions
	
	-- Unified inventory handler (returns units + artifacts in format BackpackHUD expects)
	GetUnifiedInventoryRemote.OnServerInvoke = function(player)
		local items = {}
		local invData = getInventoryData(player) or {}
		
		-- Get GridManager to check placement status
		local GridManager = rawget(Services, "GridManager")
		local gridPositions = {}
		if GridManager and GridManager.GetGridPositions then
			gridPositions = GridManager.GetGridPositions(player) or {}
		end
		
		-- Build placed units set
		local placedUnits = {}
		for _, slotData in pairs(gridPositions) do
			if slotData.Unit and slotData.Unit.unitType then
				placedUnits[slotData.Unit.unitType] = true
			end
		end
		
		-- Add units to items list
		for unitName, unitData in pairs(invData) do
			if unitData.level and unitData.level > 0 then
				table.insert(items, {
					Type = "Unit",
					UUID = unitName, -- For units, UUID is the unit name
					Name = unitName,
					Rarity = unitData.rarity or "Normal",
					IsPlaced = placedUnits[unitName] or false,
					Data = {
						Level = unitData.level or 1,
						Rarity = unitData.rarity or "Normal",
					}
				})
			end
		end
		
		-- Artifacts
		local ArtifactManager = rawget(Services, "ArtifactManager")
		if ArtifactManager and ArtifactManager.GetArtifacts then
			local artifactData = ArtifactManager.GetArtifacts(player)
			-- GetArtifacts returns {all = {...}, unequipped = {...}}
			if artifactData and artifactData.all then
				for guid, artifact in pairs(artifactData.all) do
					table.insert(items, {
						Type = "Artifact",
						UUID = guid,
						Name = artifact.Name,
						Rarity = artifact.Rarity,
						Icon = artifact.BaseIcon, -- Map BaseIcon to Icon for UI
						IsPlaced = false,
						Data = artifact
					})
				end
			end
		end
		
		return items
	end
	
	-- Backwards compatibility hooks
	Players.PlayerAdded:Connect(InventoryManager.InitPlayer)
	
	print("âœ“ InventoryManager Initialized")
end

function InventoryManager.InitPlayer(player: Player)
	-- No-op: DataService handles initialization
end

function InventoryManager.SetInventory(player: Player, data: {[string]: any})
	DataService.SetComponentData(player, COMPONENT_KEY, data or {})
	UnitChangedSignal:Fire(player, nil, nil)
end

function InventoryManager.GetInventory(player: Player): {[string]: any}
	return getInventoryData(player) or {}
end

function InventoryManager.GetUnit(player: Player, unitName: string): UnitData?
	local inventory = getInventoryData(player)
	return inventory and inventory[unitName]
end

function InventoryManager.GetUnitLevel(player: Player, unitName: string): number
	local unitData = InventoryManager.GetUnit(player, unitName)
	return unitData and unitData.level or 0
end

--[[
	AddUnit: Adds or upgrades a BrainrotUnit in the player's permanent inventory.
	
	@param player Player - The player to add the unit to
	@param unitName string - The unit model name (e.g. "Skibidi_Toilet")
	@param rarity string? - Optional rarity override ("Normal", "Rare", etc.)
	@param level number? - Optional level override (defaults to increment)
	@return UnitData? - The new/updated unit data, or nil if failed
	
	âš ï¸ WARNING: This is for BrainrotUnits ONLY (permanent collection assets).
	   Do NOT use this for FactoryItems (transient production resources).
	   FactoryItems should go to ItemStorageManager.AddToStorage() instead.
]]
function InventoryManager.AddUnit(player: Player, unitName: string, rarity: string?, level: number?): UnitData?
	-- GUARD: Reject if this looks like a FactoryItem (has itemId/count pattern)
	-- This catches accidental misuse of the wrong manager
	if type(unitName) == "table" then
		warn("InventoryManager.AddUnit: Received table instead of unitName string!")
		warn("  If you're trying to add a FactoryItem, use ItemStorageManager.AddToStorage() instead.")
		return nil
	end
	
	local inventory = getInventoryData(player)
	if not inventory then
		warn("InventoryManager: Profile not loaded for " .. player.Name)
		return nil
	end

	local currentData = inventory[unitName]

	local newLevel = level
	local newRarity = rarity or "Normal"

	if currentData then
		if not newLevel then
			newLevel = currentData.level + 1
		end
		
		if rarity then
			local rc = getRarityConfig()
			local currentRank = rc.GetRarityValue(currentData.rarity)
			local newRank = rc.GetRarityValue(rarity)

			if newRank > currentRank then
				newRarity = rarity
			else
				newRarity = currentData.rarity
			end
		else
			newRarity = currentData.rarity
		end
	else
		if not newLevel then
			newLevel = 1
		end
	end

	local newData: UnitData = {
		level = newLevel,
		rarity = newRarity,
		unitId = currentData and currentData.unitId or HttpService:GenerateGUID(false)
	}

	inventory[unitName] = newData

	UnitChangedSignal:Fire(player, unitName, newData)
	InventoryChangedEvent:FireClient(player, unitName, newData)

	return newData
end

return InventoryManager


================================================================================
FILE: src\server\IslandShopManager.luau
================================================================================

--[[
	IslandShopManager Server Module
	
	Handles the Island Shop on the main island where players can:
	1. Purchase tier unlocks early
	2. View their current tier status
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")

local RemoteEvents = ReplicatedStorage:FindFirstChild("RemoteEvents") or Instance.new("Folder")
RemoteEvents.Name = "RemoteEvents"
RemoteEvents.Parent = ReplicatedStorage

local PurchaseTierEvent = RemoteEvents:FindFirstChild("PurchaseTier") or Instance.new("RemoteEvent")
PurchaseTierEvent.Name = "PurchaseTier"
PurchaseTierEvent.Parent = RemoteEvents

local GetTierInfoEvent = RemoteEvents:FindFirstChild("GetTierInfo") or Instance.new("RemoteFunction")
GetTierInfoEvent.Name = "GetTierInfo"
GetTierInfoEvent.Parent = RemoteEvents

local SHOP_CONFIG = {
	BASE_TIER_PRICE = 5000,
	PRICE_MULTIPLIER = 2,
	VENDOR_SIZE = Vector3.new(6, 8, 6),
	VENDOR_POSITION_OFFSET = Vector3.new(-30, 10, 30),
}

local IslandShopManager = {}
local Services = {}

--------------------------------------------------------------------------------
-- HELPERS
--------------------------------------------------------------------------------

local function getTierPrice(tierNumber)
	if tierNumber <= 1 then return 0 end
	return SHOP_CONFIG.BASE_TIER_PRICE * (SHOP_CONFIG.PRICE_MULTIPLIER ^ (tierNumber - 2))
end

local function createIslandShopVendor()
	local mainIsland = workspace:WaitForChild("MainIsland", 10)
	if not mainIsland then return end
	if mainIsland:FindFirstChild("IslandShopVendor") then return end
	
	local center = Vector3.new(0, 30, 0)
	local ip = mainIsland:FindFirstChild("Island") or mainIsland:FindFirstChildWhichIsA("BasePart")
	if ip then center = ip.Position end
	
	local part = Instance.new("Part")
	part.Name = "IslandShopVendor"
	part.Size = SHOP_CONFIG.VENDOR_SIZE
	part.BrickColor = BrickColor.new("Bright violet")
	part.Material = Enum.Material.Neon
	part.Anchored = true
	part.Position = center + SHOP_CONFIG.VENDOR_POSITION_OFFSET
	
	local bb = Instance.new("BillboardGui")
	bb.Name = "ShopDisplay"
	bb.Size = UDim2.new(6,0,3,0)
	bb.StudsOffset = Vector3.new(0,6,0)
	bb.Parent = part
	
	local bg = Instance.new("Frame")
	bg.BackgroundColor3 = Color3.fromRGB(40,20,60)
	bg.BackgroundTransparency = 0.2
	bg.Size = UDim2.new(1,0,1,0)
	bg.Parent = bb
	Instance.new("UICorner", bg).CornerRadius = UDim.new(0.1,0)
	
	local t = Instance.new("TextLabel")
	t.Size = UDim2.new(1,0,0.4,0)
	t.BackgroundTransparency = 1
	t.Text = "ðŸï¸ ISLAND SHOP"
	t.TextColor3 = Color3.fromRGB(255,200,255)
	t.TextScaled = true
	t.Parent = bg
	
	local pp = Instance.new("ProximityPrompt")
	pp.ActionText = "Open Island Shop"
	pp.ObjectText = "Island Shop"
	pp.KeyboardKeyCode = Enum.KeyCode.E
	pp.Parent = part
	
	part.Parent = mainIsland
	CollectionService:AddTag(part, "IslandShopVendor")
end

--------------------------------------------------------------------------------
-- API
--------------------------------------------------------------------------------

function IslandShopManager.Init(services)
	print("   IslandShopManager (Module) - Initializing")
	Services = services or {}
	
	task.spawn(function()
		task.wait(2)
		createIslandShopVendor()
	end)
	
	PurchaseTierEvent.OnServerEvent:Connect(function(player)
		local s, m = IslandShopManager.HandleTierPurchase(player)
		PurchaseTierEvent:FireClient(player, s, m)
	end)
	
	GetTierInfoEvent.OnServerInvoke = function(player)
		return IslandShopManager.GetTierInfo(player)
	end
	
	print("âœ“ IslandShopManager Initialized")
end

function IslandShopManager.HandleTierPurchase(player)
	local MapSystem = rawget(Services, "MapSystem")
	if not MapSystem then return false, "Shop system not ready" end
	local ts = MapSystem.GetPlayerTierSystem(player)
	if not ts then return false, "No plot assigned" end
	
	local currentCount = #ts.Tiers
	local nextNum = currentCount + 1
	local CONF = MapSystem.TIER_CONFIG
	if nextNum > CONF.MAX_TIERS then return false, "Max islands reached" end
	
	local price = getTierPrice(nextNum)
	local ls = player:FindFirstChild("leaderstats")
	local m = ls and ls:FindFirstChild("Money")
	if not m or m.Value < price then return false, "Not enough money" end
	
	local parentTier
	for i = currentCount, 1, -1 do
		local t = ts.Tiers[i]
		if (3 - #t.UsedSides) > 0 then parentTier = t; break end
	end
	if not parentTier then return false, "No space for new island" end
	
	m.Value -= price
	local newTier = MapSystem.SpawnTierPlot(player, parentTier)
	if not newTier then
		m.Value += price
		return false, "Spawn failed"
	end
	
	return true, "Purchased Island " .. nextNum
end

function IslandShopManager.GetTierInfo(player)
	local MapSystem = rawget(Services, "MapSystem")
	if not MapSystem then return nil end
	local ts = MapSystem.GetPlayerTierSystem(player)
	if not ts then return nil end
	local cnt = #ts.Tiers
	local Conf = MapSystem.TIER_CONFIG
	return {
		CurrentTiers = cnt,
		MaxTiers = Conf.MAX_TIERS,
		NextTierPrice = getTierPrice(cnt + 1),
		CanPurchase = (cnt + 1) <= Conf.MAX_TIERS,
		TotalModels = ts.TotalModels,
		ModelsPerTier = Conf.MODELS_PER_TIER
	}
end

IslandShopManager.GetTierPrice = getTierPrice
IslandShopManager.SHOP_CONFIG = SHOP_CONFIG

return IslandShopManager


================================================================================
FILE: src\server\ItemProductionManager.luau
================================================================================

--[[
	ItemProductionManager Server Module
	
	Handles item production for the Sell a Brainrot system.
	
	PERFORMANCE FIX:
	- Caches active unit counts to avoid O(N^2) loop.
	- Uses InventoryManager events to update cache.
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")

-- Lazy Configs
local ItemConfig, TileConfig, ArtifactConfig

local function loadConfigs()
	if not ItemConfig then
		local Shared = ReplicatedStorage:WaitForChild("Shared")
		ItemConfig = require(Shared:WaitForChild("ItemConfig"))
		TileConfig = require(Shared:WaitForChild("TileConfig"))
		ArtifactConfig = require(Shared:WaitForChild("ArtifactConfig"))
	end
end

local RemoteEvents = ReplicatedStorage:FindFirstChild("RemoteEvents") or Instance.new("Folder")
RemoteEvents.Name = "RemoteEvents"
RemoteEvents.Parent = ReplicatedStorage

local ItemProducedEvent = RemoteEvents:FindFirstChild("ItemProduced") or Instance.new("RemoteEvent")
ItemProducedEvent.Name = "ItemProduced"
ItemProducedEvent.Parent = RemoteEvents

local StorageFullEvent = RemoteEvents:FindFirstChild("StorageFull") or Instance.new("RemoteEvent")
StorageFullEvent.Name = "StorageFull"
StorageFullEvent.Parent = RemoteEvents

-- Constants
local CONFIG = {
	PRODUCTION_TICK = 1,
	STORAGE_FULL_CHECK_INTERVAL = 5,
	BASE_ARTIFACT_DROP_CHANCE = 0.001,
	MAX_ARTIFACT_DROP_CHANCE = 0.05,
}

local BRAINROT_TAG = "ActiveBrainrot"

-- Module Table
local ItemProductionManager = {}
local Services = {}

-- Cache State
local PlayerCache = {}

--------------------------------------------------------------------------------
-- CACHE MANAGEMENT
--------------------------------------------------------------------------------

-- Helper for debug
local function getKeys(t)
	local keys = {}
	for k in pairs(t) do table.insert(keys, tostring(k)) end
	return keys
end

local function initPlayerCache(player)
	PlayerCache[player] = {
		UnitTypeCounts = {},
		ProductionState = {}, -- Per unit type timing
		lastStorageFullWarning = 0
	}
end

local function updatePlayerCache(player)
	if not PlayerCache[player] then initPlayerCache(player) end
	local cache = PlayerCache[player]
	
	-- Clear counts
	cache.UnitTypeCounts = {}
	
	-- Rebuild from GridManager (Source of Truth for PLACED units)
	local GridManager = rawget(Services, "GridManager")
	if not GridManager then
		warn("[DEBUG] ItemProductionManager: GridManager not found in Services!")
		return
	end
	
	if not GridManager.GetGridPositions then
		warn("[DEBUG] ItemProductionManager: GridManager.GetGridPositions is nil!")
		return
	end
	
	local gridPos = GridManager.GetGridPositions(player)
	
	-- DEBUG: Log what we got
	local slotCount = 0
	for _ in pairs(gridPos) do slotCount += 1 end
	-- if slotCount > 0 then
	-- 	print(string.format("[DEBUG] ItemProductionManager: Player %s has %d grid slots with data", player.Name, slotCount))
	-- end
	
	for slotKey, data in pairs(gridPos) do
		-- Extract unit data
		local unitType, _unitId
		if data.Unit then
			unitType = data.Unit.unitType
			_unitId = data.Unit.unitId
		elseif data.unitType then
			unitType = data.unitType -- Legacy fallback
		end
		
		if unitType then
			-- Update Unit Type Count
			cache.UnitTypeCounts[unitType] = (cache.UnitTypeCounts[unitType] or 0) + 1
			-- print(string.format("[DEBUG] ItemProductionManager: Slot %s has unit '%s' (count now: %d)", 
			-- 	tostring(slotKey), unitType, cache.UnitTypeCounts[unitType]))
		else
			-- DEBUG: Log slots without unitType
			if data.Unit then
				local unitKeys = getKeys(data.Unit)
				warn(string.format("[DEBUG] ItemProductionManager: Slot %s has Unit table but NO unitType field! Keys: %s", 
					tostring(slotKey), table.concat(unitKeys, ", ")))
			end
		end
	end
	
	-- DEBUG: Summary
	local modelCount = 0
	for _, _ in pairs(cache.UnitTypeCounts) do
		modelCount += 1
	end
	if modelCount == 0 and slotCount > 0 then
		warn("[DEBUG] ItemProductionManager: Grid has slots but NO unit types were extracted!")
	end
end

--------------------------------------------------------------------------------
-- PRODUCTION LOGIC
--------------------------------------------------------------------------------

-- Helper to find physical instances for bonus calculation
-- This avoids caching instance references which can leak or become stale
local function findUnitInstances(player, unitType)
	local units = {}
	local plot = nil
	local BrainrotManager = rawget(Services, "BrainrotManager")
	if BrainrotManager then
		plot = BrainrotManager.GetPlayerPlot(player)
	end

	if not plot then
		-- Try legacy find
		local plotsFolder = workspace:FindFirstChild("Plots")
		if plotsFolder then
			for _, p in plotsFolder:GetChildren() do
				if p:GetAttribute("OwnerId") == player.UserId then plot = p; break end
			end
		end
	end

	if not plot then return units end

	local brainrots = plot:FindFirstChild("Brainrots")
	if brainrots then
		for _, unit in brainrots:GetChildren() do
			local uType = unit:GetAttribute("UnitType")
			if uType == unitType then
				table.insert(units, unit)
			end
		end
	end

	return units
end


local function calculateUnitBonuses(player, brainrot)
	local bonuses = {
		speedMult = 1,
		luckMult = 1,
		tierBonus = 0,
	}
	
	if not brainrot then return bonuses end

	local slotIndex = brainrot:GetAttribute("GridSlot")
	local unitGUID = brainrot:GetAttribute("UnitId")
	local unitType = brainrot:GetAttribute("UnitType")
	
	-- Tile Bonus
	local GridManager = rawget(Services, "GridManager")
	if slotIndex and GridManager and GridManager.GetTileAtSlot then
		local tileId = GridManager.GetTileAtSlot(player, slotIndex)
		if tileId and unitType then
			-- Pass unitType as "category" for legacy tile support
			local tileBonus = TileConfig.GetBonus(tileId, unitType)
			bonuses.speedMult = bonuses.speedMult * tileBonus.SpeedMult
			bonuses.luckMult = bonuses.luckMult * tileBonus.LuckMult
		end
	end
	
	-- Artifact Bonus
	local ArtifactManager = rawget(Services, "ArtifactManager")
	if unitGUID and ArtifactManager and ArtifactManager.CalculateUnitArtifactStats then
		local artifactStats = ArtifactManager.CalculateUnitArtifactStats(player, unitGUID)
		bonuses.speedMult = bonuses.speedMult * artifactStats.CycleTimeMult
		bonuses.luckMult = bonuses.luckMult + artifactStats.LuckBonus
		bonuses.tierBonus = bonuses.tierBonus + artifactStats.ItemTierBonus
	end
	
	bonuses.speedMult = math.max(bonuses.speedMult, 0.1)
	return bonuses
end

local function tryArtifactDrop(player, bonuses)
	local ArtifactManager = rawget(Services, "ArtifactManager")
	if not ArtifactManager then return end
	
	local dropChance = CONFIG.BASE_ARTIFACT_DROP_CHANCE * bonuses.luckMult
	dropChance = math.min(dropChance, CONFIG.MAX_ARTIFACT_DROP_CHANCE)
	
	if math.random() < dropChance then
		local artifact = ArtifactManager.GenerateArtifact()
		if artifact then
			ArtifactManager.AddArtifact(player, artifact)
		end
	end
end

local function produceItems(player)
	local ISM = rawget(Services, "ItemStorageManager")
	if not ISM then return end
	
	-- 1. Check Storage
	if ISM.IsStorageFull(player) then
		local cache = PlayerCache[player]
		if cache then
			local now = tick()
			if now - cache.lastStorageFullWarning > CONFIG.STORAGE_FULL_CHECK_INTERVAL then
				cache.lastStorageFullWarning = now
				StorageFullEvent:FireClient(player)
				-- DEBUG: Storage Full
				print("[DEBUG] Production paused: Storage Full")
			end
		end
		return
	end
	
	-- 2. Use Cached Counts
	local cache = PlayerCache[player]
	if not cache then return end
	
	local now = tick()
	
	-- DEBUG: Trace loop (throttle to avoid spam, e.g. every 5s)
	-- if now % 5 < 1 then
	-- 	print("[DEBUG] Running produceItems for " .. player.Name)
	-- end
	
	for unitType, ownedCount in pairs(cache.UnitTypeCounts) do
		if ownedCount > 0 then
			local productions = ItemConfig.GetProductions(unitType, ownedCount)
			
			-- Re-enable bonuses by scanning actual units
			local activeUnits = findUnitInstances(player, unitType)
			local unitBonus = { speedMult = 1, luckMult = 1, tierBonus = 0 }
			
			for _, unitModel in ipairs(activeUnits) do
				local b = calculateUnitBonuses(player, unitModel)
				unitBonus.speedMult = math.min(unitBonus.speedMult, b.speedMult)
				unitBonus.luckMult = unitBonus.luckMult + (b.luckMult - 1)
				unitBonus.tierBonus = math.max(unitBonus.tierBonus, b.tierBonus)
			end
			
			-- Production Timing
			if not cache.ProductionState[unitType] then cache.ProductionState[unitType] = {} end
			
			for _, prod in ipairs(productions) do
				local tier = (ItemConfig.Items[prod.itemId] and ItemConfig.Items[prod.itemId].tier or 1) + math.floor(unitBonus.tierBonus)
				
				local lastProd = cache.ProductionState[unitType][tier] or 0
				local adjustedRate = math.max(0.1, prod.rate * unitBonus.speedMult)
				
				if now - lastProd >= adjustedRate then
					local added = ISM.AddToStorage(player, prod.itemId, 1)
					if added > 0 then
						cache.ProductionState[unitType][tier] = now
						ItemProducedEvent:FireClient(player, prod.itemId, 1)
						
						-- Update physical units with production timestamp for HUD sync
						for _, unitModel in ipairs(activeUnits) do
							unitModel:SetAttribute("LastProductionTime", now)
							unitModel:SetAttribute("IncomeInterval", adjustedRate)
						end
						
						-- Artifact Drop Roll
						tryArtifactDrop(player, unitBonus)
					end
				end
			end
		end
	end
end

--------------------------------------------------------------------------------
-- PUBLIC API
--------------------------------------------------------------------------------

function ItemProductionManager.Init(services)
	print("   ItemProductionManager (Module) - Initializing")
	Services = services or {}
	
	loadConfigs()
	CONFIG.BASE_ARTIFACT_DROP_CHANCE = ArtifactConfig.BaseDropChance
	CONFIG.MAX_ARTIFACT_DROP_CHANCE = ArtifactConfig.MaxDropChance
	
	-- Polling fallback for cache update
	task.spawn(function()
		while true do
			for _, player in Players:GetPlayers() do
				updatePlayerCache(player)
			end
			task.wait(5) -- Update cache every 5s
		end
	end)
	
	-- Production Loop
	task.spawn(function()
		while true do
			task.wait(CONFIG.PRODUCTION_TICK)
			for _, player in Players:GetPlayers() do
				local success, err = pcall(produceItems, player)
				if not success then
					warn("ItemProductionManager: Error producing for " .. player.Name .. ": " .. tostring(err))
				end
			end
		end
	end)
	
	Players.PlayerAdded:Connect(initPlayerCache)
	Players.PlayerRemoving:Connect(function(player) PlayerCache[player] = nil end)
	
	for _, p in Players:GetPlayers() do initPlayerCache(p) end
	
	print("âœ“ ItemProductionManager Initialized")
end

-- Export for compatibility
ItemProductionManager.ProduceItems = produceItems
ItemProductionManager.GetCategoryCounts = function(player)
	return PlayerCache[player] and PlayerCache[player].UnitTypeCounts or {}
end

return ItemProductionManager


================================================================================
FILE: src\server\ItemStorageManager.luau
================================================================================

--[[
	ItemStorageManager Server Module
	
	â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	              TRANSIENT PRODUCTION RESOURCES (SUPPLY CHAIN)
	â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	PURPOSE:
	  Manages the temporary "ProductionItems" (resources) that units produce.
	  These items sit in Storage (silos) until collected into Backpack, then
	  transported and sold by TransportManager.
	
	MANAGES:
	  â€¢ ProductionItems  - Resources produced by placed units (e.g., "Skibidi", "Sigma")
	  â€¢ Storage (Silos)  - Tycoon storage capacity for produced items
	  â€¢ Backpack         - Temporary carry capacity before selling
	
	DATA LIFECYCLE:
	  â€¢ ProductionItems are TRANSIENT - produced, stored, sold, and consumed
	  â€¢ Saved to profile for session continuity, but economically consumed
	  â€¢ Flow: Units â†’ Storage â†’ Backpack â†’ Sell (via TransportManager)
	
	SUPPLY CHAIN INTEGRATION:
	  â† ItemProductionManager  - Adds items when units produce
	  â†’ TransportManager       - Removes items when collected/sold
	  â†’ MarketManager          - Determines sell prices
	
	â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	âš ï¸  DO NOT USE THIS FOR PERMANENT COLLECTION ASSETS:
	    Player-owned Units (Brainrots) and Artifacts belong in InventoryManager
	    and ArtifactManager respectively. Those are permanent collection items.
	â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
]]

local _Players = game:GetService("Players") -- Reserved for future player cleanup
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local DataService -- Will be set from Services.DataService

-- Type Imports
local Shared = ReplicatedStorage:WaitForChild("Shared")
local _ItemTypes = require(Shared:WaitForChild("ItemTypes")) -- For type reference (see FactoryItem)

-- Strict Type Definitions for FactoryItems (transient production resources)
-- See ItemTypes.luau for full type: FactoryItem
-- This storage is for transient production items only. Do not store Units here.
export type ItemMap = {[string]: number}  -- Map of itemId -> count

-- Constants
local CONFIG = {
	DEFAULT_STORAGE_CAPACITY = 2000,
	BACKPACK_CAPACITY = 200,
}

-- Configs (loaded lazily)
local _ItemConfig -- Reserved for future item validation

-- State: Player storage holds FactoryItems (transient production resources)
-- NOT for BrainrotUnits (permanent assets) - those go in InventoryManager
local PlayerStorage: {[Player]: {items: ItemMap, capacity: number}} = {} 
local PlayerBackpack: {[Player]: {items: ItemMap, capacity: number}} = {}

-- Remotes
local RemoteEvents = ReplicatedStorage:FindFirstChild("RemoteEvents") or Instance.new("Folder")
RemoteEvents.Name = "RemoteEvents"
RemoteEvents.Parent = ReplicatedStorage

local RemoteFunctions = ReplicatedStorage:FindFirstChild("RemoteFunctions") or Instance.new("Folder")
RemoteFunctions.Name = "RemoteFunctions"
RemoteFunctions.Parent = ReplicatedStorage

local StorageUpdatedEvent = RemoteEvents:FindFirstChild("StorageUpdated") or Instance.new("RemoteEvent")
StorageUpdatedEvent.Name = "StorageUpdated"
StorageUpdatedEvent.Parent = RemoteEvents

local BackpackUpdatedEvent = RemoteEvents:FindFirstChild("BackpackUpdated") or Instance.new("RemoteEvent")
BackpackUpdatedEvent.Name = "BackpackUpdated"
BackpackUpdatedEvent.Parent = RemoteEvents

local GetStorageFunction = RemoteFunctions:FindFirstChild("GetStorage") or Instance.new("RemoteFunction")
GetStorageFunction.Name = "GetStorage"
GetStorageFunction.Parent = RemoteFunctions

local GetBackpackFunction = RemoteFunctions:FindFirstChild("GetBackpack") or Instance.new("RemoteFunction")
GetBackpackFunction.Name = "GetBackpack"
GetBackpackFunction.Parent = RemoteFunctions

local TakeFromStorageEvent = RemoteEvents:FindFirstChild("TakeFromStorage") or Instance.new("RemoteEvent")
TakeFromStorageEvent.Name = "TakeFromStorage"
TakeFromStorageEvent.Parent = RemoteEvents

-- Module
local ItemStorageManager = {}
local Services = {}

-- Getter for DataService (to avoid circular require)
local function getDataService()
	if not DataService then
		DataService = rawget(Services, "DataService")
	end
	return DataService
end

--------------------------------------------------------------------------------
-- HELPERS
--------------------------------------------------------------------------------

local function getTotalItemCount(items)
	local total = 0
	if items then
		for _, count in pairs(items) do total += count end
	end
	return total
end

--------------------------------------------------------------------------------
-- PUBLIC API
--------------------------------------------------------------------------------

function ItemStorageManager.Init(services)
	print("   ItemStorageManager (Module) - Initializing")
	Services = services or {}
	
	-- Load Configs (reserved for item validation)
	task.spawn(function()
		local SharedFolder = ReplicatedStorage:WaitForChild("Shared")
		_ItemConfig = require(SharedFolder:WaitForChild("ItemConfig"))
	end)
	
	-- Register Data Handlers
	local ds = getDataService()
	if not ds then
		warn("ItemStorageManager: DataService not available during Init")
		return
	end
	
	ds.RegisterHandler("ItemStorage", {
		DefaultData = {},
		OnLoad = function(player, data)
			if not PlayerStorage[player] then
				PlayerStorage[player] = { items = {}, capacity = CONFIG.DEFAULT_STORAGE_CAPACITY }
			end
			PlayerStorage[player].items = data or {}
			
			local root = ds.GetData(player)
			if root and root.storageCapacity then
				local cap = tonumber(root.storageCapacity)
				if cap and cap > 0 then
					PlayerStorage[player].capacity = cap
				else
					print("ItemStorageManager: Found invalid capacity " .. tostring(cap) .. ", resetting to default")
					PlayerStorage[player].capacity = CONFIG.DEFAULT_STORAGE_CAPACITY
				end
			else
				PlayerStorage[player].capacity = CONFIG.DEFAULT_STORAGE_CAPACITY
			end

			-- Sync attribute for UI
			player:SetAttribute("StorageCapacity", PlayerStorage[player].capacity)
		end,
		OnSave = function(player, data)
			if PlayerStorage[player] then
				return PlayerStorage[player].items
			end
			return {}
		end
	})
	
	ds.RegisterHandler("Backpack", {
		DefaultData = {},
		OnLoad = function(player, data)
			if not PlayerBackpack[player] then
				PlayerBackpack[player] = { items = {}, capacity = CONFIG.BACKPACK_CAPACITY }
			end
			PlayerBackpack[player].items = data or {}

			-- Sync attribute for UI
			player:SetAttribute("BackpackCapacity", PlayerBackpack[player].capacity)
		end,
		OnSave = function(player, data)
			if PlayerBackpack[player] then
				return PlayerBackpack[player].items
			end
			return {}
		end
	})
	
	-- Connect Remotes
	GetStorageFunction.OnServerInvoke = function(player)
		local s = PlayerStorage[player]
		if not s then return {}, 0, CONFIG.DEFAULT_STORAGE_CAPACITY end
		return s.items, getTotalItemCount(s.items), s.capacity
	end
	GetBackpackFunction.OnServerInvoke = function(player)
		local b = PlayerBackpack[player]
		if not b then return {}, 0, CONFIG.BACKPACK_CAPACITY end
		return b.items, getTotalItemCount(b.items), b.capacity
	end
	
	TakeFromStorageEvent.OnServerEvent:Connect(function(player, itemId, count)
		if type(itemId) ~= "string" or type(count) ~= "number" then return end
		ItemStorageManager.TakeFromStorage(player, itemId, count)
	end)
	
	print("âœ“ ItemStorageManager Initialized")
end

--[[
	AddToStorage: Adds FactoryItems (production resources) to the player's storage silo.
	
	@param player Player - The player whose storage to add to
	@param itemId string - The FactoryItem ID (e.g. "ToiletPaper", "Plunger")
	@param count number - How many items to add
	@return number - The actual number of items added (may be less if storage is full)
	
	âš ï¸ WARNING: This is for FactoryItems ONLY (transient production resources).
	   Do NOT use this for BrainrotUnits (permanent collection assets).
	   BrainrotUnits should go to InventoryManager.AddUnit() instead.
]]
function ItemStorageManager.AddToStorage(player: Player, itemId: string, count: number): number
	-- GUARD: Reject if this looks like a BrainrotUnit (has level/rarity/unitId pattern)
	-- This catches accidental misuse of the wrong manager
	if type(itemId) == "table" then
		warn("ItemStorageManager.AddToStorage: Received table instead of itemId string!")
		warn("  If you're trying to add a BrainrotUnit, use InventoryManager.AddUnit() instead.")
		return 0
	end
	
	if type(count) ~= "number" or count <= 0 then
		warn("ItemStorageManager.AddToStorage: Invalid count:", count)
		return 0
	end
	
	local storage = PlayerStorage[player]
	if not storage then return 0 end
	
	local current = getTotalItemCount(storage.items)
	local available = storage.capacity - current
	local toAdd = math.min(count, available)
	
	if toAdd <= 0 then return 0 end
	
	storage.items[itemId] = (storage.items[itemId] or 0) + toAdd
	StorageUpdatedEvent:FireClient(player, storage.items, current + toAdd, storage.capacity)
	return toAdd
end

function ItemStorageManager.IsStorageFull(player)
	local storage = PlayerStorage[player]
	if not storage then return true end
	return getTotalItemCount(storage.items) >= storage.capacity
end

function ItemStorageManager.TakeFromStorage(player, itemId, count)
	local storage = PlayerStorage[player]
	local backpack = PlayerBackpack[player]
	if not storage or not backpack then return 0 end
	
	local inStorage = storage.items[itemId] or 0
	local backSize = getTotalItemCount(backpack.items)
	local backSpace = backpack.capacity - backSize
	
	local amount = math.min(count, inStorage, backSpace)
	if amount <= 0 then return 0 end
	
	storage.items[itemId] = inStorage - amount
	if storage.items[itemId] <= 0 then storage.items[itemId] = nil end
	
	backpack.items[itemId] = (backpack.items[itemId] or 0) + amount
	
	StorageUpdatedEvent:FireClient(player, storage.items, getTotalItemCount(storage.items), storage.capacity)
	BackpackUpdatedEvent:FireClient(player, backpack.items, getTotalItemCount(backpack.items), backpack.capacity)
	
	return amount
end

--[[
	RemoveFromStorage: Removes items directly from storage (for Cart loading).
	Does NOT add to backpack.
]]
function ItemStorageManager.RemoveFromStorage(player, itemId, count)
	local storage = PlayerStorage[player]
	if not storage then return 0 end
	
	local inStorage = storage.items[itemId] or 0
	local toRemove = math.min(count, inStorage)
	if toRemove <= 0 then return 0 end
	
	storage.items[itemId] = inStorage - toRemove
	if storage.items[itemId] <= 0 then storage.items[itemId] = nil end
	
	StorageUpdatedEvent:FireClient(player, storage.items, getTotalItemCount(storage.items), storage.capacity)
	return toRemove
end

-- Compatibility Exports
function ItemStorageManager.GetBackpackContents(player)
	return PlayerBackpack[player] and PlayerBackpack[player].items or {}
end

function ItemStorageManager.GetStorageContents(player)
	return PlayerStorage[player] and PlayerStorage[player].items or {}
end

function ItemStorageManager.GetStorageCapacity(player)
	return PlayerStorage[player] and PlayerStorage[player].capacity or CONFIG.DEFAULT_STORAGE_CAPACITY
end

function ItemStorageManager.SetBackpackCapacity(player, cap)
	if not PlayerBackpack[player] then PlayerBackpack[player] = { items={}, capacity=cap} end
	PlayerBackpack[player].capacity = cap
	player:SetAttribute("BackpackCapacity", cap)
	BackpackUpdatedEvent:FireClient(player, PlayerBackpack[player].items, getTotalItemCount(PlayerBackpack[player].items), cap)
end

function ItemStorageManager.SetStorageCapacity(player, cap)
	if not PlayerStorage[player] then PlayerStorage[player] = { items={}, capacity=cap} end
	PlayerStorage[player].capacity = cap
	player:SetAttribute("StorageCapacity", cap)

	-- Update DataService root if needed (legacy capacity storage)
	local ds = getDataService()
	if ds then ds.SetComponentData(player, "storageCapacity", cap) end

	StorageUpdatedEvent:FireClient(player, PlayerStorage[player].items, getTotalItemCount(PlayerStorage[player].items), cap)
end

function ItemStorageManager.TransferToBackpack(player, itemId, count)
	-- Alias for TakeFromStorage used by TransportManager
	return ItemStorageManager.TakeFromStorage(player, itemId, count)
end

function ItemStorageManager.RemoveFromBackpack(player, itemId, count)
	local backpack = PlayerBackpack[player]
	if not backpack then return 0 end

	local avail = backpack.items[itemId] or 0
	local toRemove = math.min(count, avail)
	if toRemove <= 0 then return 0 end

	backpack.items[itemId] = avail - toRemove
	if backpack.items[itemId] <= 0 then backpack.items[itemId] = nil end

	BackpackUpdatedEvent:FireClient(player, backpack.items, getTotalItemCount(backpack.items), backpack.capacity)
	return toRemove
end

function ItemStorageManager.ResetPlayerStorage(player)
	if PlayerStorage[player] then
		PlayerStorage[player].items = {}
		PlayerStorage[player].capacity = CONFIG.DEFAULT_STORAGE_CAPACITY
		player:SetAttribute("StorageCapacity", CONFIG.DEFAULT_STORAGE_CAPACITY)
		StorageUpdatedEvent:FireClient(player, {}, 0, CONFIG.DEFAULT_STORAGE_CAPACITY)
	end
	if PlayerBackpack[player] then
		PlayerBackpack[player].items = {}
		PlayerBackpack[player].capacity = CONFIG.BACKPACK_CAPACITY
		player:SetAttribute("BackpackCapacity", CONFIG.BACKPACK_CAPACITY)
		BackpackUpdatedEvent:FireClient(player, {}, 0, CONFIG.BACKPACK_CAPACITY)
	end
	
	-- Clear DataService components
	local ds = getDataService()
	if ds then
		ds.SetComponentData(player, "ItemStorage", {})
		ds.SetComponentData(player, "Backpack", {})
	end
end

return ItemStorageManager


================================================================================
FILE: src\server\MapSystem.luau
================================================================================

--[[
	MapSystem Server Module
	(Formerly init.server.luau)
	
	Handles:
	1. Spawning the central MainIsland hub
	2. Generating 8 player plots in a circular formation
	3. Creating bridges connecting each plot to the hub
	4. Assigning plots to players
	5. Tier System (expanding plots)
]]

local Players = game:GetService("Players")
local ServerStorage = game:GetService("ServerStorage")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local CONFIG = {
	MAX_PLAYERS = 8,
	PLOT_RADIUS = 400,
	MAIN_ISLAND_HEIGHT = 30,
	PLOT_MIN_HEIGHT = 50,
	PLOT_MAX_HEIGHT = 120,
}

local TIER_CONFIG = {
	MODELS_PER_TIER = 16,
	MAX_TIERS = 6,
	TIER_HEIGHT_MIN = 20,
	TIER_HEIGHT_MAX = 60,
	TIER_DISTANCE_MIN = 80,
	TIER_DISTANCE_MAX = 140,
	STAIR_WIDTH = 10,
	STAIR_DEPTH = 4,
	STAIR_HEIGHT = 3,
	GRID_COLUMNS = 6,
	GRID_ROWS = 2,
	SIDE_OFFSETS = {
		[0] = Vector3.new(0, 0, 1),
		[1] = Vector3.new(1, 0, 0),
		[2] = Vector3.new(0, 0, -1),
		[3] = Vector3.new(-1, 0, 0),
	},
}

local MainIslandTemplate, PlayerPlotTemplate, BridgeTemplate
local Plots = {}
local PlayerToPlot = {}
local PlotsFolder
local PlayerTierSystems = {}

local MapSystem = {}
local Services = {}

--------------------------------------------------------------------------------
-- UTILITY
--------------------------------------------------------------------------------

local function calculatePlotCFrame(index)
	local i = index - 1
	local angle = i * ((2 * math.pi) / CONFIG.MAX_PLAYERS)
	local x = CONFIG.PLOT_RADIUS * math.cos(angle)
	local z = CONFIG.PLOT_RADIUS * math.sin(angle)
	local h = math.random(CONFIG.PLOT_MIN_HEIGHT, CONFIG.PLOT_MAX_HEIGHT)
	return CFrame.new(x, h, z) * CFrame.Angles(0, -(angle + math.pi), 0)
end

local function calculateBridgeCFrame(plotCFrame)
	local plotPos = plotCFrame.Position
	local dir2D = Vector3.new(plotPos.X, 0, plotPos.Z).Unit
	local hubEdge = Vector3.new(dir2D.X * 50, CONFIG.MAIN_ISLAND_HEIGHT + 10, dir2D.Z * 50)
	local plotEdge = Vector3.new(plotPos.X - dir2D.X * 40, plotPos.Y + 6.5, plotPos.Z - dir2D.Z * 40)
	return CFrame.new((hubEdge + plotEdge) / 2, plotEdge), (plotEdge - hubEdge).Magnitude
end

--------------------------------------------------------------------------------
-- TIER SYSTEM
--------------------------------------------------------------------------------

local function getAvailableSide(tierData)
	local avail = {}
	for side = 0, 3 do
		local blocked = (side == tierData.BlockedSide)
		local used = false
		for _, u in tierData.UsedSides do if u == side then used = true; break end end
		if not blocked and not used then table.insert(avail, side) end
	end
	if #avail == 0 then return nil end
	return avail[math.random(1, #avail)]
end

local function calculateIncomingSide(parentPos, childPos)
	local dir = parentPos - childPos
	if math.abs(dir.Z) > math.abs(dir.X) then
		return dir.Z > 0 and 0 or 2
	else
		return dir.X > 0 and 1 or 3
	end
end

local function spawnTierPlot(player, parentTier)
	local side = getAvailableSide(parentTier)
	if not side then warn("No sides for tier " .. player.Name); return nil end
	
	local sys = PlayerTierSystems[player]
	if not sys then return nil end
	local nextIdx = #sys.Tiers + 1
	if nextIdx > TIER_CONFIG.MAX_TIERS then return nil end
	
	local parentCF = parentTier.Model:GetPivot()
	local offset = TIER_CONFIG.SIDE_OFFSETS[side]
	local hOff = math.random(TIER_CONFIG.TIER_HEIGHT_MIN, TIER_CONFIG.TIER_HEIGHT_MAX)
	local dist = math.random(TIER_CONFIG.TIER_DISTANCE_MIN, TIER_CONFIG.TIER_DISTANCE_MAX)
	
	local newPos = parentCF.Position + (offset * dist)
	newPos = Vector3.new(newPos.X, parentCF.Position.Y + hOff, newPos.Z)
	
	local newModel = PlayerPlotTemplate:Clone()
	newModel.Name = string.format("Plot_%d_Tier_%d", sys.BasePlotIndex, nextIdx)
	
	local lookDir = parentCF.Position - newPos
	local newCF = CFrame.new(newPos) * CFrame.Angles(0, math.atan2(lookDir.X, lookDir.Z), 0)
	newModel:PivotTo(newCF)
	newModel:SetAttribute("OwnerId", player.UserId)
	newModel:SetAttribute("TierIndex", nextIdx)
	newModel.Parent = PlotsFolder
	
	-- Stairs
	local stairs = Instance.new("Model")
	stairs.Name = string.format("Stairs_%d_Tier_%d", sys.BasePlotIndex, nextIdx)
	
	local pEdge = parentCF.Position + (offset * 40); pEdge = Vector3.new(pEdge.X, pEdge.Y + 2, pEdge.Z)
	local cEdge = newPos - (offset * 40); cEdge = Vector3.new(cEdge.X, cEdge.Y + 2, cEdge.Z)
	
	local vDist = cEdge.Y - pEdge.Y
	local hDist = (Vector3.new(cEdge.X, 0, cEdge.Z) - Vector3.new(pEdge.X, 0, pEdge.Z)).Magnitude
	
	local steps = math.max(1, math.floor(vDist / TIER_CONFIG.STAIR_HEIGHT))
	local sH = vDist / steps; local sD = hDist / steps
	local dir = (Vector3.new(cEdge.X, 0, cEdge.Z) - Vector3.new(pEdge.X, 0, pEdge.Z)).Unit
	
	for i = 0, steps - 1 do
		local s = Instance.new("Part")
		s.Name = "Step_"..i
		s.Size = Vector3.new(TIER_CONFIG.STAIR_WIDTH, math.max(0.5, sH), math.max(0.5, sD))
		s.Anchored = true; s.CanCollide = true; s.Material = Enum.Material.Concrete
		s.Position = Vector3.new(pEdge.X + dir.X*(i+0.5)*sD, pEdge.Y + (i+0.5)*sH, pEdge.Z + dir.Z*(i+0.5)*sD)
		s.CFrame = CFrame.new(s.Position) * CFrame.Angles(0, math.atan2(dir.X, dir.Z), 0)
		s.Parent = stairs
	end
	if stairs:FindFirstChild("Step_0") then stairs.PrimaryPart = stairs.Step_0 end
	stairs.Parent = workspace
	
	table.insert(parentTier.UsedSides, side)
	
	local incSide = calculateIncomingSide(parentCF.Position, newPos)
	local newTierData = {
		TierIndex = nextIdx,
		Model = newModel,
		Bridge = stairs,
		ParentTier = parentTier,
		BlockedSide = incSide,
		UsedSides = {},
		GridIndex = 0
	}
	table.insert(sys.Tiers, newTierData)
	return newTierData
end

--------------------------------------------------------------------------------
-- PLOTS
--------------------------------------------------------------------------------

local function createClaimPart(model)
	local p = Instance.new("Part")
	p.Name = "ClaimPart"; p.Size = Vector3.new(10, 1, 10); p.BrickColor = BrickColor.new("Lime green")
	p.Transparency = 0.3; p.Anchored = true; p.CanCollide = false
	p.Position = model:GetPivot().Position + Vector3.new(0, 3, 0)
	p.Parent = model
	return p
end

local function generatePlots()
	PlotsFolder = Instance.new("Folder"); PlotsFolder.Name = "Plots"; PlotsFolder.Parent = workspace
	for i = 1, CONFIG.MAX_PLAYERS do
		local cf = calculatePlotCFrame(i)
		local pm = PlayerPlotTemplate:Clone(); pm.Name = "Plot_"..i; pm:PivotTo(cf); pm.Parent = PlotsFolder
		
		local bcf, bdist = calculateBridgeCFrame(cf)
		local bm = BridgeTemplate:Clone(); bm.Name = "Bridge_"..i
		for _, part in bm:GetDescendants() do if part:IsA("BasePart") then part.Size = Vector3.new(part.Size.X, part.Size.Y, bdist) end end
		bm:PivotTo(bcf); bm.Parent = workspace
		
		Plots[i] = { Index = i, Model = pm, Bridge = bm, Position = cf, Owner = nil, ClaimPart = createClaimPart(pm) }
		
		if workspace:FindFirstChild("MainIsland") then
			local zp = Instance.new("Part"); zp.Name="Zipline_"..i; zp.Size=Vector3.new(4,8,4); zp.Anchored=true; zp.CanCollide=false; zp.Transparency=0.5
			local dir = (cf.Position - Vector3.new(0,CONFIG.MAIN_ISLAND_HEIGHT,0)).Unit
			zp.Position = Vector3.new(0,CONFIG.MAIN_ISLAND_HEIGHT,0) + dir*45
			zp.Parent = workspace.MainIsland
		end
	end
end

local function findAvailablePlot()
	for i, p in pairs(Plots) do if not p.Owner then return i end end
	return nil
end

local function assignPlotToPlayer(player, idx)
	local pData = Plots[idx]
	if not pData or pData.Owner then return end
	
	pData.Owner = player
	PlayerToPlot[player] = idx
	pData.Model:SetAttribute("OwnerId", player.UserId)
	pData.Model:SetAttribute("TierIndex", 1)
	if pData.ClaimPart then pData.ClaimPart.BrickColor = BrickColor.new("Really red"); pData.ClaimPart.Transparency = 0.7 end
	
	Instance.new("Folder", pData.Model).Name = "PlayerBuildings"
	
	local blocked = calculateIncomingSide(Vector3.new(0,0,0), pData.Position.Position)
	PlayerTierSystems[player] = {
		BasePlotIndex = idx,
		Tiers = {{TierIndex=1, Model=pData.Model, Bridge=pData.Bridge, ParentTier=nil, BlockedSide=blocked, UsedSides={}, GridIndex=0}},
		CurrentTier = 1,
		TotalModels = 0
	}
	print("âœ“ Assigned Plot " .. idx .. " to " .. player.Name)
	
	local PlayerLifecycleManager = rawget(Services, "PlayerLifecycleManager")
	if PlayerLifecycleManager then
		PlayerLifecycleManager.SetMapReady(player)
	end
end

local function teleportPlayer(player)
	local idx = PlayerToPlot[player]
	if not idx then return end
	local pData = Plots[idx]
	local char = player.Character or player.CharacterAdded:Wait()
	local hrp = char:WaitForChild("HumanoidRootPart", 5)
	if hrp then hrp.CFrame = CFrame.new(pData.Model:GetPivot().Position + Vector3.new(0, 10, 0)) end
end

local function clearPlayerPlot(player)
	local idx = PlayerToPlot[player]
	if not idx then return end
	local pData = Plots[idx]
	
	local sys = PlayerTierSystems[player]
	if sys then
		for i = #sys.Tiers, 2, -1 do
			local t = sys.Tiers[i]
			if t.Bridge then t.Bridge:Destroy() end
			if t.Model then t.Model:Destroy() end
		end
		PlayerTierSystems[player] = nil
	end
	
	if pData.Model:FindFirstChild("PlayerBuildings") then pData.Model.PlayerBuildings:Destroy() end
	if pData.Model:FindFirstChild("Brainrots") then pData.Model.Brainrots:Destroy() end
	
	if pData.ClaimPart then pData.ClaimPart.BrickColor = BrickColor.new("Lime green"); pData.ClaimPart.Transparency = 0.3 end
	pData.Owner = nil
	PlayerToPlot[player] = nil
	pData.Model:SetAttribute("OwnerId", nil)
	pData.Model:SetAttribute("TierIndex", nil)
end

--------------------------------------------------------------------------------
-- API
--------------------------------------------------------------------------------

function MapSystem.Init(services)
	print("   MapSystem (Module) - Initializing")
	Services = services or {}
	
	MainIslandTemplate = ServerStorage:FindFirstChild("MainIsland") or ReplicatedStorage:FindFirstChild("MainIsland")
	PlayerPlotTemplate = ServerStorage:FindFirstChild("PlayerPlot") or ReplicatedStorage:FindFirstChild("PlayerPlot")
	BridgeTemplate = ServerStorage:FindFirstChild("Bridge") or ReplicatedStorage:FindFirstChild("Bridge")
	
	-- Placeholders
	if not MainIslandTemplate then
		local m = Instance.new("Model"); m.Name="MainIsland"; local p = Instance.new("Part"); p.Name="Island"; p.Size=Vector3.new(100,20,100); p.Anchored=true; p.Color=Color3.new(0,1,0); p.Parent=m; m.PrimaryPart=p; m.Parent=ServerStorage; MainIslandTemplate=m
	end
	if not PlayerPlotTemplate then
		local m = Instance.new("Model"); m.Name="PlayerPlot"; local p = Instance.new("Part"); p.Name="Island"; p.Size=Vector3.new(80,15,80); p.Anchored=true; p.Color=Color3.new(0,1,0); p.Parent=m; m.PrimaryPart=p; m.Parent=ServerStorage; PlayerPlotTemplate=m
	end
	if not BridgeTemplate then
		local m = Instance.new("Model"); m.Name="Bridge"; local p = Instance.new("Part"); p.Name="BridgePart"; p.Size=Vector3.new(10,2,50); p.Anchored=true; p.Color=Color3.new(0.6,0.4,0.2); p.Parent=m; m.PrimaryPart=p; m.Parent=ServerStorage; BridgeTemplate=m
	end
	
	-- Spawn Main
	local mi = MainIslandTemplate:Clone(); mi.Name="MainIsland"; mi:PivotTo(CFrame.new(0, CONFIG.MAIN_ISLAND_HEIGHT, 0)); mi.Parent=workspace
	
	-- Generate Plots
	generatePlots()
	
	-- Handlers
	Players.PlayerAdded:Connect(function(player)
		local idx = findAvailablePlot()
		if idx then
			assignPlotToPlayer(player, idx)
			player.CharacterAdded:Connect(function() task.wait(1); teleportPlayer(player) end)
			if player.Character then task.wait(1); teleportPlayer(player) end
		end
	end)
	
	Players.PlayerRemoving:Connect(clearPlayerPlot)
	
	for _, p in Players:GetPlayers() do
		local idx = findAvailablePlot()
		if idx then assignPlotToPlayer(p, idx) end
	end
	
	print("âœ“ MapSystem Initialized")
end

MapSystem.GetPlayerPlot = function(p) local idx = PlayerToPlot[p]; return idx and Plots[idx] and Plots[idx].Model end
MapSystem.GetAllPlots = function() return Plots end
MapSystem.CONFIG = CONFIG
MapSystem.TIER_CONFIG = TIER_CONFIG
MapSystem.GetPlayerTierSystem = function(p) return PlayerTierSystems[p] end
MapSystem.SpawnTierPlot = spawnTierPlot
MapSystem.GetCurrentTier = function(p) local s = PlayerTierSystems[p]; return s and s.Tiers[s.CurrentTier] end
MapSystem.ResetPlayerPlot = function(p)
	local idx = PlayerToPlot[p]
	if idx then
		clearPlayerPlot(p)
		task.wait(0.1)
		assignPlotToPlayer(p, idx)
		task.delay(0.5, function() teleportPlayer(p) end)
	end
end
MapSystem.RestoreTiers = function(player, count)
	local sys = PlayerTierSystems[player]
	if not sys or count <= 1 then return end
	print("Restoring tiers for "..player.Name)
	for i = 2, count do
		local cur = sys.Tiers[#sys.Tiers]
		if cur then 
			local new = spawnTierPlot(player, cur)
			if new then sys.CurrentTier = new.TierIndex end
		end
	end
end

return MapSystem


================================================================================
FILE: src\server\MarketManager.luau
================================================================================

--[[
	MarketManager Server Module
	
	Handles selling items from backpack for money at market prices.
]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Shared = ReplicatedStorage:WaitForChild("Shared")
local ItemConfig = require(Shared:WaitForChild("ItemConfig"))

local stockMarketFolder = ReplicatedStorage:WaitForChild("StockMarket", 10) or ReplicatedStorage

local RemoteEvents = ReplicatedStorage:FindFirstChild("RemoteEvents") or Instance.new("Folder")
RemoteEvents.Name = "RemoteEvents"
RemoteEvents.Parent = ReplicatedStorage

local RemoteFunctions = ReplicatedStorage:FindFirstChild("RemoteFunctions") or Instance.new("Folder")
RemoteFunctions.Name = "RemoteFunctions"
RemoteFunctions.Parent = ReplicatedStorage

local ItemSoldEvent = RemoteEvents:FindFirstChild("ItemSold") or Instance.new("RemoteEvent")
ItemSoldEvent.Name = "ItemSold"
ItemSoldEvent.Parent = RemoteEvents

local SellItemFunction = RemoteFunctions:FindFirstChild("SellItem") or Instance.new("RemoteFunction")
SellItemFunction.Name = "SellItem"
SellItemFunction.Parent = RemoteFunctions

local SellAllFunction = RemoteFunctions:FindFirstChild("SellAll") or Instance.new("RemoteFunction")
SellAllFunction.Name = "SellAll"
SellAllFunction.Parent = RemoteFunctions

local GetMarketPricesFunction = RemoteFunctions:FindFirstChild("GetMarketPrices") or Instance.new("RemoteFunction")
GetMarketPricesFunction.Name = "GetMarketPrices"
GetMarketPricesFunction.Parent = RemoteFunctions

local CONFIG = {
	MARKET_POSITION = Vector3.new(0, 32, -60),
	MARKET_SIZE = Vector3.new(20, 15, 20),
	ENDGAME_EARNINGS_THRESHOLD = 1000000000, -- $1B total money to lose welfare protection
}

local MarketManager = {}
local Services = {}

--------------------------------------------------------------------------------
-- HELPERS
--------------------------------------------------------------------------------

local function getItemSector(itemId)
	if not itemId then return nil end
	
	-- Scan BrainrotItems to find which model produces this item
	for modelName, mapping in pairs(ItemConfig.BrainrotItems) do
		if mapping.tier1 == itemId or mapping.tier2 == itemId or 
		   mapping.tier3 == itemId or mapping.tier4 == itemId then
			return ItemConfig.GetSector(modelName)
		end
	end
	return "Neutral"
end

--[[
	Determines if a player is "endgame" (no welfare protection).
	Endgame = total money exceeds threshold.
	Simple check â€” can be replaced with a more nuanced metric later.
]]
local function isEndgame(player)
	local ls = player:FindFirstChild("leaderstats")
	local m = ls and ls:FindFirstChild("Money")
	if m and m.Value >= CONFIG.ENDGAME_EARNINGS_THRESHOLD then
		return true
	end
	return false
end

--[[
	Gets the appropriate market rate for a player+item combo.
	- Endgame players get the true MarketRate (can be very low)
	- New players get the BailoutRate (welfare-protected floor)
]]
local function getPlayerRate(player, itemId)
	local SM = rawget(Services, "StockMarketManager")
	if not SM then
		return stockMarketFolder:GetAttribute("CurrentRate") or 1.0
	end
	
	local sector = getItemSector(itemId)
	if not sector or sector == "Neutral" then
		return SM.GetSectorRate("Food") or 1.0
	end
	
	if isEndgame(player) then
		return SM.GetSectorRate(sector) or 1.0
	else
		return SM.GetBailoutRate(sector) or 1.0
	end
end

-- Legacy compat: returns MarketRate (endgame/true rate)
local function getMarketRate(itemId)
	local SM = rawget(Services, "StockMarketManager")
	if itemId and SM then
		local sector = getItemSector(itemId)
		if sector and sector ~= "Neutral" then 
			return SM.GetSectorRate(sector) or 1.0 
		end
	end
	return stockMarketFolder:GetAttribute("CurrentRate") or 1.0
end

local function getItemPrice(itemId)
	local info = ItemConfig.Items[itemId]
	if not info then return 0 end
	return math.floor((info.basePrice or 1) * getMarketRate(itemId))
end

-- Player-specific price (uses welfare check)
local function getPlayerItemPrice(player, itemId)
	local info = ItemConfig.Items[itemId]
	if not info then return 0 end
	return math.floor((info.basePrice or 1) * getPlayerRate(player, itemId))
end

-- Report sold volume to StockMarketManager for global price influence
local function reportSalesVolume(itemId, count)
	local SM = rawget(Services, "StockMarketManager")
	if SM and SM.AddSalesVolume then
		local sector = getItemSector(itemId)
		if sector and sector ~= "Neutral" then
			SM.AddSalesVolume(sector, count)
		end
	end
end

local function createMarketBuilding()
	local mainIsland = workspace:FindFirstChild("MainIsland")
	if mainIsland and mainIsland:FindFirstChild("MarketBuilding") then return end
	
	local building = Instance.new("Part")
	building.Name = "MarketBuilding"
	building.Size = CONFIG.MARKET_SIZE
	building.Position = CONFIG.MARKET_POSITION
	building.Anchored = true
	building.BrickColor = BrickColor.new("Deep orange")
	building.Material = Enum.Material.SmoothPlastic
	
	local bb = Instance.new("BillboardGui")
	bb.Size = UDim2.new(0,200,0,60)
	bb.StudsOffset = Vector3.new(0,12,0)
	bb.Parent = building
	local lbl = Instance.new("TextLabel")
	lbl.Size = UDim2.new(1,0,1,0)
	lbl.BackgroundTransparency = 0.2
	lbl.BackgroundColor3 = Color3.fromRGB(30,30,40)
	lbl.Text = "ðŸª MARKET"
	lbl.TextColor3 = Color3.fromRGB(255,200,50)
	lbl.TextScaled=true
	lbl.Parent=bb
	Instance.new("UICorner", lbl).CornerRadius = UDim.new(0,12)
	
	local pp = Instance.new("ProximityPrompt")
	pp.ActionText = "Open Market"
	pp.ObjectText = "Market Terminal"
	pp.KeyboardKeyCode = Enum.KeyCode.E
	pp.Parent = building
	
	if mainIsland then building.Parent = mainIsland else building.Parent = workspace end
end

--------------------------------------------------------------------------------
-- API
--------------------------------------------------------------------------------

function MarketManager.Init(services)
	print("   MarketManager (Module) - Initializing")
	Services = services or {}
	
	task.spawn(function()
		task.wait(3)
		createMarketBuilding() -- Wait for MainIsland
	end)
	
	SellItemFunction.OnServerInvoke = function(p, id, c) return MarketManager.SellItem(p, id, c) end
	SellAllFunction.OnServerInvoke = function(p) return MarketManager.SellAll(p) end
	GetMarketPricesFunction.OnServerInvoke = function(p) return MarketManager.GetAllPrices(p), getMarketRate() end

	print("âœ“ MarketManager Initialized")
end

function MarketManager.SellItem(player, itemId, count)
	local ISM = rawget(Services, "ItemStorageManager")
	if not ISM then return 0, 0 end
	
	local bp = ISM.GetBackpackContents(player)
	local avail = bp[itemId] or 0
	if avail <= 0 then return 0,0 end
	
	local toSell = math.min(count or 1, avail)
	local price = getPlayerItemPrice(player, itemId) -- Welfare-aware price
	local total = toSell * price
	
	local removed = ISM.RemoveFromBackpack(player, itemId, toSell)
	if removed <= 0 then return 0,0 end
	
	local ls = player:FindFirstChild("leaderstats")
	local m = ls and ls:FindFirstChild("Money")
	if m then m.Value += total end
	
	-- Report to global market (influences prices across all servers)
	reportSalesVolume(itemId, removed)
	
	ItemSoldEvent:FireClient(player, itemId, removed, total)
	return removed, total
end

function MarketManager.SellAll(player)
	local ISM = rawget(Services, "ItemStorageManager")
	if not ISM then return 0,0 end
	
	local bp = ISM.GetBackpackContents(player)
	local sold, earned = 0, 0
	
	for id, c in pairs(bp) do
		if c > 0 then
			local s, e = MarketManager.SellItem(player, id, c)
			sold += s; earned += e
		end
	end
	return sold, earned
end

function MarketManager.SellCartContents(player, cartInventory)
	if not cartInventory then return 0, 0 end
	local sold, earned = 0, 0
	
	for itemId, count in pairs(cartInventory) do
		if count > 0 then
			local price = getPlayerItemPrice(player, itemId) -- Welfare-aware price
			local total = count * price
			
			sold += count
			earned += total
			
			-- Report to global market
			reportSalesVolume(itemId, count)
		end
	end
	
	if earned > 0 then
		local ls = player:FindFirstChild("leaderstats")
		local m = ls and ls:FindFirstChild("Money")
		if m then m.Value += earned end
		
		for itemId, count in pairs(cartInventory) do
			if count > 0 then
				local price = getPlayerItemPrice(player, itemId)
				ItemSoldEvent:FireClient(player, itemId, count, count * price)
			end
		end
	end
	
	return sold, earned
end

function MarketManager.GetAllPrices(player)
	local p = {}
	local SM = rawget(Services, "StockMarketManager")
	local endgame = player and isEndgame(player)
	
	for id, info in pairs(ItemConfig.Items) do
		local bp = info.basePrice or 1
		local sector = getItemSector(id)
		local marketRate = 1.0
		local bailoutRate = 1.0
		if sector and SM then 
			marketRate = SM.GetSectorRate(sector) or 1.0 
			bailoutRate = SM.GetBailoutRate(sector) or 1.0
		end
		local effectiveRate = (endgame == true) and marketRate or bailoutRate
		p[id] = {
			basePrice = bp,
			currentPrice = math.floor(bp * effectiveRate),
			marketPrice = math.floor(bp * marketRate),
			bailoutPrice = math.floor(bp * bailoutRate),
			tier = info.tier or 1,
			sector = sector,
			sectorRate = effectiveRate,
			isEndgame = endgame or false,
		}
	end
	return p
end

-- Public helpers
MarketManager.GetItemPrice = getItemPrice
MarketManager.GetPlayerItemPrice = getPlayerItemPrice
MarketManager.GetMarketRate = getMarketRate
MarketManager.IsEndgame = isEndgame

return MarketManager


================================================================================
FILE: src\server\MewingManager.luau
================================================================================

--[[
	MewingManager Server Module
	
	Tracks and rewards players for "Mewing" (staying AFK/silent).
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TextChatService = game:GetService("TextChatService")
local RunService = game:GetService("RunService")

local RemoteEvents = ReplicatedStorage:FindFirstChild("RemoteEvents") or Instance.new("Folder")
RemoteEvents.Name = "RemoteEvents"
RemoteEvents.Parent = ReplicatedStorage

local MewingUpdateEvent = RemoteEvents:FindFirstChild("MewingUpdate") or Instance.new("RemoteEvent")
MewingUpdateEvent.Name = "MewingUpdate"
MewingUpdateEvent.Parent = RemoteEvents

local CONFIG = {
	CHECK_INTERVAL = 1,
	MOVEMENT_THRESHOLD = 0.1,
	TIERS = {
		{ time = 60, name = "Streak Started", multiplier = 1.05, emoji = "ðŸ¤«" },
		{ time = 300, name = "Locked In", multiplier = 1.10, emoji = "ðŸ”’" },
		{ time = 600, name = "GigaChad", multiplier = 1.20, emoji = "ðŸ—¿", cosmetic = true },
	},
}

local MewingManager = {}
local Services = {}
local PlayerMewingState = {}
local lastCheck = 0

--------------------------------------------------------------------------------
-- LOGIC
--------------------------------------------------------------------------------

local function applyGigaChadCosmetic(player)
	local state = PlayerMewingState[player]
	if not state or state.HasCosmetic then return end
	local char = player.Character
	if not char then return end
	local head = char:FindFirstChild("Head")
	if not head then return end
	
	local jaw = Instance.new("Part")
	jaw.Name = "GigaChadJawline"
	jaw.Size = Vector3.new(1.5, 0.5, 1.2)
	jaw.BrickColor = BrickColor.new("Light orange")
	jaw.Material = Enum.Material.SmoothPlastic
	jaw.CanCollide = false
	jaw.Massless = true
	
	local w = Instance.new("Weld")
	w.Part0 = head; w.Part1 = jaw; w.C0 = CFrame.new(0, -0.6, 0.1); w.Parent = jaw
	
	jaw.Parent = char
	state.HasCosmetic = true
end

local function breakStreak(player, reason)
	local state = PlayerMewingState[player]
	if not state then return end
	local had = state.CurrentTier > 0
	
	state.LastActivityTime = os.time()
	state.CurrentTier = 0
	
	if state.HasCosmetic then
		local char = player.Character
		if char then
			local jaw = char:FindFirstChild("GigaChadJawline")
			if jaw then jaw:Destroy() end
		end
		state.HasCosmetic = false
	end
	
	player:SetAttribute("MewingMultiplier", 1.0)
	player:SetAttribute("MewingTier", 0)
	
	if had then
		MewingUpdateEvent:FireClient(player, { type = "break", reason = reason })
	end
end

local function checkMovement(player)
	local state = PlayerMewingState[player]
	if not state then return false end
	local char = player.Character
	if not char then return false end
	local hrp = char:FindFirstChild("HumanoidRootPart")
	if not hrp then return false end
	
	local pos = hrp.Position
	if hrp.AssemblyLinearVelocity.Magnitude > CONFIG.MOVEMENT_THRESHOLD then return true end
	if state.LastPosition and (pos - state.LastPosition).Magnitude > 1 then return true end
	
	state.LastPosition = pos
	return false
end

local function updateMewingStreaks()
	local now = os.time()
	if now - lastCheck < CONFIG.CHECK_INTERVAL then return end
	lastCheck = now
	
	for player, state in pairs(PlayerMewingState) do
		if not player.Parent then continue end
		
		if checkMovement(player) then
			breakStreak(player, "Movement detected")
			continue
		end
		
		local streak = now - state.LastActivityTime
		local newTier = 0
		local tData = nil
		
		for i, tier in ipairs(CONFIG.TIERS) do
			if streak >= tier.time then newTier = i; tData = tier end
		end
		
		if newTier ~= state.CurrentTier then
			state.CurrentTier = newTier
			if newTier > 0 and tData then
				player:SetAttribute("MewingMultiplier", tData.multiplier)
				player:SetAttribute("MewingTier", newTier)
				if tData.cosmetic then applyGigaChadCosmetic(player) end
				
				MewingUpdateEvent:FireClient(player, {
					type = "tier_up", tier = newTier, name = tData.name, emoji = tData.emoji, multiplier = tData.multiplier
				})
			end
		end
	end
end

--------------------------------------------------------------------------------
-- API
--------------------------------------------------------------------------------

function MewingManager.Init(services)
	print("   MewingManager (Module) - Initializing")
	Services = services or {}
	
	Players.PlayerAdded:Connect(function(player)
		PlayerMewingState[player] = { LastActivityTime = os.time(), CurrentTier = 0, HasCosmetic = false }
		player:SetAttribute("MewingMultiplier", 1.0)
		player:SetAttribute("MewingTier", 0)
	end)
	
	Players.PlayerRemoving:Connect(function(player)
		PlayerMewingState[player] = nil
	end)
	
	for _, p in Players:GetPlayers() do
		PlayerMewingState[p] = { LastActivityTime = os.time(), CurrentTier = 0, HasCosmetic = false }
	end
	
	-- Chat Detection
	task.spawn(function()
		local tc = TextChatService:WaitForChild("TextChannels", 5)
		if tc then
			local gc = tc:FindFirstChild("RBXGeneral")
			if gc then
				gc.MessageReceived:Connect(function(msg)
					local p = Players:GetPlayerByUserId(msg.TextSource.UserId)
					if p then breakStreak(p, "Chatted") end
				end)
			end
		else
			-- Legacy
			local lce = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
			if lce then
				local omd = lce:FindFirstChild("OnMessageDoneFiltering")
				if omd then
					omd.OnServerEvent:Connect(function(p) breakStreak(p, "Chatted") end)
				end
			end
		end
	end)
	
	RunService.Heartbeat:Connect(updateMewingStreaks)
	print("âœ“ MewingManager Initialized")
end

MewingManager.BreakStreak = breakStreak
MewingManager.GetPlayerState = function(player) return PlayerMewingState[player] end

return MewingManager


================================================================================
FILE: src\server\PlayerLifecycleManager.luau
================================================================================

--[[
	PlayerLifecycleManager Server Module
	
	Central coordinator for player loading state.
	Gates client interaction until all systems (Data, Map, Grid) are ready.
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Events
local RemoteEvents = ReplicatedStorage:FindFirstChild("RemoteEvents") or Instance.new("Folder")
RemoteEvents.Name = "RemoteEvents"
RemoteEvents.Parent = ReplicatedStorage

local PlayerReadyEvent = RemoteEvents:FindFirstChild("PlayerReady") or Instance.new("RemoteEvent")
PlayerReadyEvent.Name = "PlayerReady"
PlayerReadyEvent.Parent = RemoteEvents

-- State Definitions
type PlayerState = {
	DataLoaded: boolean,
	MapReady: boolean,
	GridRestored: boolean,
}

local PlayerStates: {[Player]: PlayerState} = {}
local PlayerLifecycleManager = {}

--------------------------------------------------------------------------------
-- HELPERS
--------------------------------------------------------------------------------

local function checkReady(player: Player)
	local state = PlayerStates[player]
	if not state then return end
	
	if state.DataLoaded and state.MapReady and state.GridRestored then
		print("PlayerLifecycleManager: " .. player.Name .. " is READY!")
		PlayerReadyEvent:FireClient(player)
		-- Clean up state monitoring, we are done
		-- (Optional: Keep tracking if we want to handle re-syncs, but for loading screen it's one-off)
	end
end

local function getOrInitState(player: Player)
	if not PlayerStates[player] then
		PlayerStates[player] = {
			DataLoaded = false,
			MapReady = false,
			GridRestored = false -- Will be set true immediately if data says grid is empty
		}
	end
	return PlayerStates[player]
end

--------------------------------------------------------------------------------
-- API
--------------------------------------------------------------------------------

function PlayerLifecycleManager.Init()
	print("   PlayerLifecycleManager (Module) - Initializing")
	
	Players.PlayerRemoving:Connect(function(player)
		PlayerStates[player] = nil
	end)
	
	print("âœ“ PlayerLifecycleManager Initialized")
end

function PlayerLifecycleManager.SetDataLoaded(player: Player)
	local state = getOrInitState(player)
	state.DataLoaded = true
	-- print("Lifecycle: Data Loaded for " .. player.Name)
	checkReady(player)
end

function PlayerLifecycleManager.SetMapReady(player: Player)
	local state = getOrInitState(player)
	state.MapReady = true
	-- print("Lifecycle: Map Ready for " .. player.Name)
	checkReady(player)
end

function PlayerLifecycleManager.SetGridRestored(player: Player)
	local state = getOrInitState(player)
	state.GridRestored = true
	-- print("Lifecycle: Grid Restored for " .. player.Name)
	checkReady(player)
end

function PlayerLifecycleManager.IsReady(player: Player)
	local state = PlayerStates[player]
	return state and state.DataLoaded and state.MapReady and state.GridRestored
end

return PlayerLifecycleManager


================================================================================
FILE: src\server\PrestigeManager.luau
================================================================================

--[[
	PrestigeManager Server Module
	
	Handles:
	1. Meatball calculation based on lifetime earnings
	2. Prestige execution (reset + award meatballs)
	3. Meatball Shop purchases
	4. Golden Meatball Altar creation and interaction
	5. Income multipliers from meatballs and upgrades
]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

-- Lazy Config
local PrestigeConfig

local function getPrestigeConfig()
	if not PrestigeConfig then
		local Shared = ReplicatedStorage:WaitForChild("Shared")
		PrestigeConfig = require(Shared:WaitForChild("PrestigeConfig"))
	end
	return PrestigeConfig
end

local DataService -- Will be set from Services.DataService

-- Remotes
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local PrestigeEvent = RemoteEvents:FindFirstChild("PrestigeEvent") or Instance.new("RemoteEvent")
PrestigeEvent.Name = "PrestigeEvent"
PrestigeEvent.Parent = RemoteEvents

local COMPONENT_KEY = "Prestige"
local DEFAULT_PRESTIGE_DATA = {
	lifetimeEarnings = 0,
	totalMeatballs = 0,
	spentMeatballs = 0,
	prestigeCount = 0,
	meatballUpgrades = {},
}

-- Module
local PrestigeManager = {}
local Services = {}

-- Getter for DataService (to avoid circular require)
local function getDataService()
	if not DataService then
		DataService = rawget(Services, "DataService")
	end
	return DataService
end

--------------------------------------------------------------------------------
-- HELPER FUNCTIONS
--------------------------------------------------------------------------------

local function getPrestigeData(player)
	local ds = getDataService()
	if not ds then return nil end
	
	local data = ds.GetComponentData(player, COMPONENT_KEY)
	if data then return data end
	if ds.IsLoaded(player) then
		local d = {}
		for k, v in pairs(DEFAULT_PRESTIGE_DATA) do
			if type(v) == "table" then d[k] = {} else d[k] = v end
		end
		ds.SetComponentData(player, COMPONENT_KEY, d)
		return ds.GetComponentData(player, COMPONENT_KEY)
	end
	return nil
end

local function calculateTotalMeatballsFromEarnings(lifetimeEarnings)
	local pc = getPrestigeConfig()
	if lifetimeEarnings < pc.MEATBALL_DIVISOR then return 0 end
	return math.floor(pc.MEATBALL_MULTIPLIER * math.sqrt(lifetimeEarnings / pc.MEATBALL_DIVISOR))
end

local function calculatePendingMeatballs(player)
	local data = getPrestigeData(player)
	if not data then return 0, 0 end
	local current = data.totalMeatballs
	local projected = calculateTotalMeatballsFromEarnings(data.lifetimeEarnings)
	return math.max(0, projected - current), projected
end

--------------------------------------------------------------------------------
-- ALTAR LOGIC
--------------------------------------------------------------------------------

local function createAltar()
	task.wait(2)
	local mainIsland = Workspace:WaitForChild("MainIsland", 10)
	if not mainIsland then
		mainIsland = Instance.new("Part")
		mainIsland.Name = "MainIsland"
		mainIsland.Size = Vector3.new(100, 1, 100)
		mainIsland.Anchored = true
		mainIsland.Parent = Workspace
	end
	
	local model = Instance.new("Model")
	model.Name = "GoldenMeatballAltar"
	
	local sphere = Instance.new("Part")
	sphere.Name = "Sphere"
	sphere.Size = Vector3.new(12, 12, 12)
	sphere.Shape = Enum.PartType.Ball
	sphere.Color = Color3.fromRGB(255, 215, 0)
	sphere.Material = Enum.Material.Neon
	sphere.Anchored = true
	sphere.Position = Vector3.new(30, 40, 50)
	sphere.Parent = model
	
	task.spawn(function()
		local RunService = game:GetService("RunService")
		local y = sphere.Position.Y
		local t = 0
		RunService.Heartbeat:Connect(function(dt)
			if not sphere or not sphere.Parent then return end
			t += dt
			sphere.Position = Vector3.new(sphere.Position.X, y + math.sin(t)*2, sphere.Position.Z)
			sphere.Orientation += Vector3.new(0, 1, 0)
		end)
	end)
	
	local p = Instance.new("ProximityPrompt")
	p.ObjectText = "Golden Meatball Altar"
	p.ActionText = "Open Prestige Menu"
	p.KeyboardKeyCode = Enum.KeyCode.E
	p.MaxActivationDistance = 20
	p.Parent = sphere
	
	p.Triggered:Connect(function(player)
		local pending, _ = calculatePendingMeatballs(player)
		local data = getPrestigeData(player)
		if data then
			PrestigeEvent:FireClient(player, "OpenMenu", {
				totalMeatballs = data.totalMeatballs,
				spentMeatballs = data.spentMeatballs,
				pendingMeatballs = pending,
				lifetimeEarnings = data.lifetimeEarnings,
				upgrades = data.meatballUpgrades
			})
		end
	end)
	
	model.Parent = Workspace
	print("âœ“ Golden Meatball Altar created")
end

--------------------------------------------------------------------------------
-- PUBLIC API
--------------------------------------------------------------------------------

function PrestigeManager.Init(services)
	print("   PrestigeManager (Module) - Initializing")
	Services = services or {}
	
	-- Register with DataService
	local ds = getDataService()
	if ds then
		ds.RegisterHandler(COMPONENT_KEY, {
			DefaultData = DEFAULT_PRESTIGE_DATA,
			OnLoad = function(p, d) 
				print("PrestigeManager: Loaded for " .. p.Name) 
			end,
			OnSave = function(p, d) return d end
		})
	else
		warn("PrestigeManager: DataService not available during Init")
	end
	
	PrestigeEvent.OnServerEvent:Connect(function(player, action, ...)
		local args = {...}
		if action == "Prestige" then
			PrestigeManager.ExecutePrestige(player)
		elseif action == "PurchaseUpgrade" then
			local success = PrestigeManager.PurchaseUpgrade(player, args[1])
			if success then
				local pending, _ = calculatePendingMeatballs(player)
				local data = getPrestigeData(player)
				if data then
					PrestigeEvent:FireClient(player, "UpdateData", {
						totalMeatballs = data.totalMeatballs,
						spentMeatballs = data.spentMeatballs,
						pendingMeatballs = pending,
						lifetimeEarnings = data.lifetimeEarnings,
						upgrades = data.meatballUpgrades
					})
				end
			end
		end
	end)
	
	task.spawn(createAltar)
	print("âœ“ PrestigeManager Initialized")
end

function PrestigeManager.AddLifetimeEarnings(player, amount)
	local data = getPrestigeData(player)
	if data then data.lifetimeEarnings += amount end
end

function PrestigeManager.GetMeatballIncomeMultiplier(player)
	local data = getPrestigeData(player)
	if not data then return 1 end
	local unspent = data.totalMeatballs - data.spentMeatballs
	local pc = getPrestigeConfig()
	return 1 + (unspent * pc.MEATBALL_BONUS_RATE)
end

function PrestigeManager.GetShopMultiplier(player)
	local data = getPrestigeData(player)
	if not data then return 1 end
	local m = 1
	local pc = getPrestigeConfig()
	for _, id in ipairs(data.meatballUpgrades) do
		local item = pc.GetItem(id)
		if item and item.Effect == "IncomeMultiplier" then m += item.Value end
	end
	return m
end

function PrestigeManager.GetTotalIncomeMultiplier(player)
	return PrestigeManager.GetMeatballIncomeMultiplier(player) * PrestigeManager.GetShopMultiplier(player)
end

function PrestigeManager.GetStartingMoneyBonus(player)
	local data = getPrestigeData(player)
	if not data then return 0 end
	local b = 0
	local pc = getPrestigeConfig()
	for _, id in ipairs(data.meatballUpgrades) do
		local item = pc.GetItem(id)
		if item and item.Effect == "StartingMoney" then b += item.Value end
	end
	return b
end

function PrestigeManager.ExecutePrestige(player)
	local pending = calculatePendingMeatballs(player)
	local pc = getPrestigeConfig()
	if pending < pc.MINIMUM_PRESTIGE_GAIN then return false, "Not enough meatballs" end
	
	local data = getPrestigeData(player)
	if not data then return false, "No Data" end
	
	data.totalMeatballs += pending
	data.prestigeCount += 1
	
	local DataManager = rawget(Services, "DataManager")
	if DataManager and DataManager.ResetPlayerData then
		DataManager.ResetPlayerData(player, true)
	else
		warn("PrestigeManager: Check DataManager usage")
	end
	
	player:LoadCharacter()
	PrestigeEvent:FireClient(player, "PrestigeCompleted", { gained = pending, total = data.totalMeatballs })
	return true
end

function PrestigeManager.PurchaseUpgrade(player, upgradeId)
	local data = getPrestigeData(player)
	if not data then return false end
	
	if not data then return false end
	
	local pc = getPrestigeConfig()
	local item = pc.GetItem(upgradeId)
	if not item then return false end
	
	for _, id in ipairs(data.meatballUpgrades) do
		if id == upgradeId then return false end
	end
	
	if data.totalMeatballs < item.UnlockAt then return false end
	
	local unspent = data.totalMeatballs - data.spentMeatballs
	if unspent < item.Price then return false end
	
	data.spentMeatballs += item.Price
	table.insert(data.meatballUpgrades, upgradeId)
	return true
end

-- Export API & Compatibility
PrestigeManager.GetPlayerData = function(player) return getPrestigeData(player) or DEFAULT_PRESTIGE_DATA end
PrestigeManager.InitializePlayerData = function(p, d) if d and DataService.IsLoaded(p) then DataService.SetComponentData(p, COMPONENT_KEY, d) end end

return PrestigeManager


================================================================================
FILE: src\server\ProfileService.luau
================================================================================

--[[
{Madwork}

-[ProfileService]---------------------------------------
	(STANDALONE VERSION)
	DataStore profiles - universal session-locked savable table API

	Official documentation:
		https://madstudioroblox.github.io/ProfileService/

	DevForum discussion:
		https://devforum.roblox.com/t/ProfileService/667805

	WARNINGS FOR "Profile.Data" VALUES:
		! Do not create numeric tables with gaps - attempting to replicate such tables will result in an error;
		! Do not create mixed tables (some values indexed by number and others by string key), as only
		     the data indexed by number will be replicated.
		! Do not index tables by anything other than numbers and strings.
		! Do not reference Roblox Instances
		! Do not reference userdata (Vector3, Color3, CFrame...) - Serialize userdata before referencing
		! Do not reference functions

	WARNING: Calling ProfileStore:LoadProfileAsync() with a "profile_key" which wasn't released in the SAME SESSION will result
		in an error! If you want to "ProfileStore:LoadProfileAsync()" instead of using the already loaded profile, :Release()
		the old Profile object.

	Members:

		ProfileService.ServiceLocked         [bool]

		ProfileService.IssueSignal           [ScriptSignal] (error_message, profile_store_name, profile_key)
		ProfileService.CorruptionSignal      [ScriptSignal] (profile_store_name, profile_key)
		ProfileService.CriticalStateSignal   [ScriptSignal] (is_critical_state)

	Functions:

		ProfileService.GetProfileStore(profile_store_index, profile_template) --> [ProfileStore]
			profile_store_index   [string] -- DataStore name
			OR
			profile_store_index   [table]: -- Allows the developer to define more GlobalDataStore variables
				{
					Name = "StoreName", -- [string] -- DataStore name
					-- Optional arguments:
					Scope = "StoreScope", -- [string] -- DataStore scope
				}
			profile_template      [table] -- Profiles will default to given table (hard-copy) when no data was saved previously

		ProfileService.IsLive() --> [bool] -- (CAN YIELD!!!)
			-- Returns true if ProfileService is connected to live Roblox DataStores

	Members [ProfileStore]:

		ProfileStore.Mock   [ProfileStore] -- Reflection of ProfileStore methods, but the methods will use a mock DataStore

	Methods [ProfileStore]:

		ProfileStore:LoadProfileAsync(profile_key, not_released_handler) --> [Profile] or nil -- not_released_handler(place_id, game_job_id)
			profile_key            [string] -- DataStore key
			not_released_handler   nil or []: -- Defaults to "ForceLoad"
				[string] "ForceLoad" -- Force loads profile on first call
				OR
				[string] "Steal" -- Steals the profile ignoring it's session lock
				OR
				[function] (place_id, game_job_id) --> [string] "Repeat", "Cancel", "ForceLoad" or "Steal"
					place_id      [number] or nil
					game_job_id   [string] or nil

				-- not_released_handler [function] will be triggered in cases where the profile is not released by a session. This
				--      function may yield for as long as desirable and must return one of three string values:

						["Repeat"] - ProfileService will repeat the profile loading proccess and may trigger the release handler again
						["Cancel"] - ProfileStore:LoadProfileAsync() will immediately return nil
						["ForceLoad"] - ProfileService will repeat the profile loading call, but will return Profile object afterwards
							and release the profile for another session that has loaded the profile
						["Steal"] - The profile will usually be loaded immediately, ignoring an existing remote session lock and applying
							a session lock for this session.

		ProfileStore:GlobalUpdateProfileAsync(profile_key, update_handler) --> [GlobalUpdates] or nil
			-- Returns GlobalUpdates object if update was successful, otherwise returns nil
			profile_key      [string] -- DataStore key
			update_handler   [function] (global_updates [GlobalUpdates])

		ProfileStore:ViewProfileAsync(profile_key, version) --> [Profile] or nil
			-- Reads profile without requesting a session lock; Data will not be saved and profile doesn't need to be released
			profile_key   [string] -- DataStore key
			version       nil or [string] -- DataStore key version

		ProfileStore:ProfileVersionQuery(profile_key, sort_direction, min_date, max_date) --> [ProfileVersionQuery]
			profile_key      [string]
			sort_direction   nil or [Enum.SortDirection]
			min_date         nil or [DateTime]
			max_date         nil or [DateTime]

		ProfileStore:WipeProfileAsync(profile_key) --> is_wipe_successful [bool]
			-- Completely wipes out profile data from the DataStore / mock DataStore with no way to recover it.

		* Parameter description for "ProfileStore:GlobalUpdateProfileAsync()":

			profile_key      [string] -- DataStore key
			update_handler   [function] (GlobalUpdates) -- This function gains access to GlobalUpdates object methods
				(update_handler can't yield)

	Methods [ProfileVersionQuery]:

		ProfileVersionQuery:NextAsync() --> [Profile] or nil -- (Yields)
			-- Returned profile has the same rules as profile returned by :ViewProfileAsync()

	Members [Profile]:

		Profile.Data              [table] -- Writable table that gets saved automatically and once the profile is released
		Profile.MetaData          [table] (Read-only) -- Information about this profile

			Profile.MetaData.ProfileCreateTime   [number] (Read-only) -- os.time() timestamp of profile creation
			Profile.MetaData.SessionLoadCount    [number] (Read-only) -- Amount of times the profile was loaded
			Profile.MetaData.ActiveSession       [table] (Read-only) {place_id, game_job_id} / nil -- Set to a session link if a
				game session is currently having this profile loaded; nil if released
			Profile.MetaData.MetaTags            [table] {["tag_name"] = tag_value, ...} -- Saved and auto-saved just like Profile.Data
			Profile.MetaData.MetaTagsLatest      [table] (Read-only) -- Latest version of MetaData.MetaTags that was definetly saved to DataStore
				(You can use Profile.MetaData.MetaTagsLatest for product purchase save confirmation, but create a system to clear old tags after
				they pile up)

		Profile.MetaTagsUpdated   [ScriptSignal] (meta_tags_latest) -- Fires after every auto-save, after
			--      Profile.MetaData.MetaTagsLatest has been updated with the version that's guaranteed to be saved;
			--  .MetaTagsUpdated will fire regardless of whether .MetaTagsLatest changed after update;
			--      .MetaTagsUpdated may fire after the Profile is released - changes to Profile.Data are not saved
			--      after release.

		Profile.RobloxMetaData    [table] -- Writable table that gets saved automatically and once the profile is released
		Profile.UserIds           [table] -- (Read-only) -- {user_id [number], ...} -- User ids associated with this profile

		Profile.KeyInfo           [DataStoreKeyInfo]
		Profile.KeyInfoUpdated    [ScriptSignal] (key_info [DataStoreKeyInfo])

		Profile.GlobalUpdates     [GlobalUpdates]

	Methods [Profile]:

		-- SAFE METHODS - Will not error after profile expires:
		Profile:IsActive() --> [bool] -- Returns true while the profile is active and can be written to

		Profile:GetMetaTag(tag_name) --> value [any]
			tag_name   [string]

		Profile:Reconcile() -- Fills in missing (nil) [string_key] = [value] pairs to the Profile.Data structure

		Profile:ListenToRelease(listener) --> [ScriptConnection] (place_id / nil, game_job_id / nil)
			-- WARNING: Profiles can be released externally if another session force-loads
			--      this profile - use :ListenToRelease() to handle player leaving cleanup.

		Profile:Release() -- Call after the session has finished working with this profile
			e.g., after the player leaves (Profile object will become expired) (Does not yield)

		Profile:ListenToHopReady(listener) --> [ScriptConnection] () -- Passed listener will be executed after the releasing UpdateAsync call finishes;
			--      Wrap universe teleport requests with this method AFTER releasing the profile to improve session lock sharing between universe places;
			--  :ListenToHopReady() will usually call the listener in around a second, but may ocassionally take up to 7 seconds when a release happens
			--      next to an auto-update in regular usage scenarios.

		Profile:AddUserId(user_id) -- Associates user_id with profile (GDPR compliance)
			user_id   [number]

		Profile:RemoveUserId(user_id) -- Unassociates user_id with profile (safe function)
			user_id   [number]

		Profile:Identify() --> [string] -- Returns a string containing DataStore name, scope and key; Used for debug;
			-- Example return: "[Store:"GameData";Scope:"Live";Key:"Player_2312310"]"

		Profile:SetMetaTag(tag_name, value) -- Equivalent of Profile.MetaData.MetaTags[tag_name] = value
			tag_name   [string]
			value      [any]

		Profile:Save() -- Call to quickly progress global update state or to speed up save validation processes (Does not yield)

		-- VIEW-MODE ONLY:

		Profile:ClearGlobalUpdates() -- Clears all global updates data from a profile payload

		Profile:OverwriteAsync() -- (Yields) Saves the profile payload to the DataStore and removes the session lock

	Methods [GlobalUpdates]:

	-- ALWAYS PUBLIC:
		GlobalUpdates:GetActiveUpdates() --> [table] {{update_id, update_data [table]}, ...}
		GlobalUpdates:GetLockedUpdates() --> [table] {{update_id, update_data [table]}, ...}

	-- ONLY WHEN FROM "Profile.GlobalUpdates":
		GlobalUpdates:ListenToNewActiveUpdate(listener) --> [ScriptConnection] (update_id, update_data)
			update_data   [table]
		GlobalUpdates:ListenToNewLockedUpdate(listener) --> [ScriptConnection] (update_id, update_data)
			update_data   [table]
		GlobalUpdates:LockActiveUpdate(update_id)  -- WARNING: will error after profile expires
		GlobalUpdates:ClearLockedUpdate(update_id) -- WARNING: will error after profile expires

	-- EXPOSED TO "update_handler" DURING ProfileStore:GlobalUpdateProfileAsync() CALL
		GlobalUpdates:AddActiveUpdate(update_data)
			update_data   [table]
		GlobalUpdates:ChangeActiveUpdate(update_id, update_data)
			update_data   [table]
		GlobalUpdates:ClearActiveUpdate(update_id)

--]]

local SETTINGS = {

	AutoSaveProfiles = 30, -- Seconds (This value may vary - ProfileService will split the auto save load evenly in the given time)
	RobloxWriteCooldown = 7, -- Seconds between successive DataStore calls for the same key
	ForceLoadMaxSteps = 8, -- Steps taken before ForceLoad request steals the active session for a profile
	AssumeDeadSessionLock = 30 * 60, -- (seconds) If a profile hasn't been updated for 30 minutes, assume the session lock is dead
		-- As of writing, os.time() is not completely reliable, so we can only assume session locks are dead after a significant amount of time.

	IssueCountForCriticalState = 5, -- Issues to collect to announce critical state
	IssueLast = 120, -- Seconds
	CriticalStateLast = 120, -- Seconds

	MetaTagsUpdatedValues = { -- Technical stuff - do not alter
		ProfileCreateTime = true,
		SessionLoadCount = true,
		ActiveSession = true,
		ForceLoadSession = true,
		LastUpdate = true,
	},

}

local Madwork -- Standalone Madwork reference for portable version of ProfileService
do

	local MadworkScriptSignal = {}

	local FreeRunnerThread = nil

	local function AcquireRunnerThreadAndCallEventHandler(fn, ...)
		local acquired_runner_thread = FreeRunnerThread
		FreeRunnerThread = nil
		fn(...)
		FreeRunnerThread = acquired_runner_thread
	end

	local function RunEventHandlerInFreeThread(...)
		AcquireRunnerThreadAndCallEventHandler(...)
		while true do
			AcquireRunnerThreadAndCallEventHandler(coroutine.yield())
		end
	end

	-- ScriptConnection object:

	local ScriptConnection = {
		--[[
			_listener = listener,
			_script_signal = script_signal,
			_disconnect_listener = disconnect_listener,
			_disconnect_param = disconnect_param,

			_next = next_script_connection,
			_is_connected = is_connected,
		--]]
	}
	ScriptConnection.__index = ScriptConnection

	function ScriptConnection:Disconnect()

		if self._is_connected == false then
			return
		end

		self._is_connected = false
		self._script_signal._listener_count -= 1

		if self._script_signal._head == self then
			self._script_signal._head = self._next
		else
			local prev = self._script_signal._head
			while prev ~= nil and prev._next ~= self do
				prev = prev._next
			end
			if prev ~= nil then
				prev._next = self._next
			end
		end

		if self._disconnect_listener ~= nil then
			if not FreeRunnerThread then
				FreeRunnerThread = coroutine.create(RunEventHandlerInFreeThread)
			end
			task.spawn(FreeRunnerThread, self._disconnect_listener, self._disconnect_param)
			self._disconnect_listener = nil
		end

	end

	-- ScriptSignal object:

	local ScriptSignal = {
		--[[
			_head = nil,
			_listener_count = 0,
		--]]
	}
	ScriptSignal.__index = ScriptSignal

	function ScriptSignal:Connect(listener, disconnect_listener, disconnect_param) --> [ScriptConnection]

		local script_connection = {
			_listener = listener,
			_script_signal = self,
			_disconnect_listener = disconnect_listener,
			_disconnect_param = disconnect_param,

			_next = self._head,
			_is_connected = true,
		}
		setmetatable(script_connection, ScriptConnection)

		self._head = script_connection
		self._listener_count += 1

		return script_connection

	end

	function ScriptSignal:GetListenerCount() --> [number]
		return self._listener_count
	end

	function ScriptSignal:Fire(...)
		local item = self._head
		while item ~= nil do
			if item._is_connected == true then
				if not FreeRunnerThread then
					FreeRunnerThread = coroutine.create(RunEventHandlerInFreeThread)
				end
				task.spawn(FreeRunnerThread, item._listener, ...)
			end
			item = item._next
		end
	end

	function ScriptSignal:FireUntil(continue_callback, ...)
		local item = self._head
		while item ~= nil do
			if item._is_connected == true then
				item._listener(...)
				if continue_callback() ~= true then
					return
				end
			end
			item = item._next
		end
	end

	function MadworkScriptSignal.NewScriptSignal() --> [ScriptSignal]
		return {
			_head = nil,
			_listener_count = 0,
			Connect = ScriptSignal.Connect,
			GetListenerCount = ScriptSignal.GetListenerCount,
			Fire = ScriptSignal.Fire,
			FireUntil = ScriptSignal.FireUntil,
		}
	end

	-- Madwork framework namespace:

	Madwork = {
		NewScriptSignal = MadworkScriptSignal.NewScriptSignal,
		ConnectToOnClose = function(task, run_in_studio_mode)
			if game:GetService("RunService"):IsStudio() == false or run_in_studio_mode == true then
				game:BindToClose(task)
			end
		end,
	}

end

----- Service Table -----

local ProfileService = {
ServiceLocked = false :: boolean, -- Set to true once the server is shutting down


	IssueSignal = Madwork.NewScriptSignal(), -- (error_message, profile_store_name, profile_key) -- Fired when a DataStore API call throws an error
	CorruptionSignal = Madwork.NewScriptSignal(), -- (profile_store_name, profile_key) -- Fired when DataStore key returns a value that has
	-- all or some of it's profile components set to invalid data types. E.g., accidentally setting Profile.Data to a noon table value

	CriticalState = false, -- Set to true while DataStore service is throwing too many errors
	CriticalStateSignal = Madwork.NewScriptSignal(), -- (is_critical_state) -- Fired when CriticalState is set to true
	-- (You may alert players with this, or set up analytics)

	ServiceIssueCount = 0,

	_active_profile_stores = {}, -- {profile_store, ...}

	_auto_save_list = {}, -- {profile, ...} -- loaded profile table which will be circularly auto-saved

	_issue_queue = {}, -- [table] {issue_time, ...}
	_critical_state_start = 0, -- [number] 0 = no critical state / os.clock() = critical state start

	-- Debug:
	_mock_data_store = {},
	_user_mock_data_store = {},

	_use_mock_data_store = false,

}

--[[
	Saved profile structure:

	DataStoreProfile = {
		Data = {},
		MetaData = {
			ProfileCreateTime = 0,
			SessionLoadCount = 0,
			ActiveSession = {place_id, game_job_id} / nil,
			ForceLoadSession = {place_id, game_job_id} / nil,
			MetaTags = {},
			LastUpdate = 0, -- os.time()
		},
		RobloxMetaData = {},
		UserIds = {},
		GlobalUpdates = {
			update_index,
			{
				{update_id, version_id, update_locked, update_data},
				...
			}
		},
	}

	OR

	DataStoreProfile = {
		GlobalUpdates = {
			update_index,
			{
				{update_id, version_id, update_locked, update_data},
				...
			}
		},
	}
--]]

----- Private Variables -----

local ActiveProfileStores = ProfileService._active_profile_stores
local AutoSaveList = ProfileService._auto_save_list
local IssueQueue = ProfileService._issue_queue

local DataStoreService = game:GetService("DataStoreService")
local RunService = game:GetService("RunService")

local PlaceId = game.PlaceId
local JobId = game.JobId

local AutoSaveIndex = 1 -- Next profile to auto save
local LastAutoSave = os.clock()

local LoadIndex = 0

local ActiveProfileLoadJobs = 0 -- Number of active threads that are loading in profiles
local ActiveProfileSaveJobs = 0 -- Number of active threads that are saving profiles

local CriticalStateStart = 0 -- os.clock()

local IsStudio = RunService:IsStudio()
local IsLiveCheckActive = false

local UseMockDataStore = false
local MockDataStore = ProfileService._mock_data_store -- Mock data store used when API access is disabled

local UserMockDataStore = ProfileService._user_mock_data_store -- Separate mock data store accessed via ProfileStore.Mock
local UseMockTag = {}

local CustomWriteQueue = {
	--[[
		[store] = {
			[key] = {
				LastWrite = os.clock(),
				Queue = {callback, ...},
				CleanupJob = nil,
			},
			...
		},
		...
	--]]
}

----- Utils -----

local function DeepCopyTable(t)
	local copy = {}
	for key, value in pairs(t) do
		if type(value) == "table" then
			copy[key] = DeepCopyTable(value)
		else
			copy[key] = value
		end
	end
	return copy
end

local function ReconcileTable(target, template)
	for k, v in pairs(template) do
		if type(k) == "string" then -- Only string keys will be reconciled
			if target[k] == nil then
				if type(v) == "table" then
					target[k] = DeepCopyTable(v)
				else
					target[k] = v
				end
			elseif type(target[k]) == "table" and type(v) == "table" then
				ReconcileTable(target[k], v)
			end
		end
	end
end

----- Private functions -----

local function IdentifyProfile(store_name, store_scope, key)
	return string.format(
		"[Store:\"%s\";%sKey:\"%s\"]",
		store_name,
		store_scope ~= nil and string.format("Scope:\"%s\";", store_scope) or "",
		key
	)
end

local function CustomWriteQueueCleanup(store, key)
	if CustomWriteQueue[store] ~= nil then
		CustomWriteQueue[store][key] = nil
		if next(CustomWriteQueue[store]) == nil then
			CustomWriteQueue[store] = nil
		end
	end
end

local function CustomWriteQueueMarkForCleanup(store, key)
	if CustomWriteQueue[store] ~= nil then
		if CustomWriteQueue[store][key] ~= nil then

			local queue_data = CustomWriteQueue[store][key]
			local queue = queue_data.Queue

			if queue_data.CleanupJob == nil then

				queue_data.CleanupJob = RunService.Heartbeat:Connect(function()
					if os.clock() - queue_data.LastWrite > SETTINGS.RobloxWriteCooldown and #queue == 0 then
						queue_data.CleanupJob:Disconnect()
						CustomWriteQueueCleanup(store, key)
					end
				end)

			end

		elseif next(CustomWriteQueue[store]) == nil then
			CustomWriteQueue[store] = nil
		end
	end
end

local function CustomWriteQueueAsync(callback, store, key) --> ... -- Passed return from callback

	if CustomWriteQueue[store] == nil then
		CustomWriteQueue[store] = {}
	end
	if CustomWriteQueue[store][key] == nil then
		CustomWriteQueue[store][key] = {LastWrite = 0, Queue = {}, CleanupJob = nil}
	end

	local queue_data = CustomWriteQueue[store][key]
	local queue = queue_data.Queue

	-- Cleanup job:

	if queue_data.CleanupJob ~= nil then
		queue_data.CleanupJob:Disconnect()
		queue_data.CleanupJob = nil
	end

	-- Queue logic:

	if os.clock() - queue_data.LastWrite > SETTINGS.RobloxWriteCooldown and #queue == 0 then
		queue_data.LastWrite = os.clock()
		return callback()
	else
		table.insert(queue, callback)
		while true do
			if os.clock() - queue_data.LastWrite > SETTINGS.RobloxWriteCooldown and queue[1] == callback then
				table.remove(queue, 1)
				queue_data.LastWrite = os.clock()
				return callback()
			end
			task.wait()
		end
	end

end

local function IsCustomWriteQueueEmptyFor(store, key) --> is_empty [bool]
	local lookup = CustomWriteQueue[store]
	if lookup ~= nil then
		lookup = lookup[key]
		return lookup == nil or #lookup.Queue == 0
	end
	return true
end

local function WaitForLiveAccessCheck() -- This function was created to prevent the ProfileService module yielding execution when required
	while IsLiveCheckActive == true do
		task.wait()
	end
end

local function WaitForPendingProfileStore(profile_store)
	while profile_store._is_pending == true do
		task.wait()
	end
end

local function RegisterIssue(error_message, store_name, store_scope, profile_key) -- Called when a DataStore API call errors
	warn("[ProfileService]: DataStore API error " .. IdentifyProfile(store_name, store_scope, profile_key) .. " - \"" .. tostring(error_message) .. "\"")
	table.insert(IssueQueue, os.clock()) -- Adding issue time to queue
	ProfileService.IssueSignal:Fire(tostring(error_message), store_name, profile_key)
end

local function RegisterCorruption(store_name, store_scope, profile_key) -- Called when a corrupted profile is loaded
	warn("[ProfileService]: Resolved profile corruption " .. IdentifyProfile(store_name, store_scope, profile_key))
	ProfileService.CorruptionSignal:Fire(store_name, profile_key)
end

local function NewMockDataStoreKeyInfo(params)

	local version_id_string = tostring(params.VersionId or 0)
	local meta_data = params.MetaData or {}
	local user_ids = params.UserIds or {}

	return {
		CreatedTime = params.CreatedTime,
		UpdatedTime = params.UpdatedTime,
		Version = string.rep("0", 16) .. "."
			.. string.rep("0", 10 - string.len(version_id_string)) .. version_id_string
			.. "." .. string.rep("0", 16) .. "." .. "01",

		GetMetadata = function()
			return DeepCopyTable(meta_data)
		end,

		GetUserIds = function()
			return DeepCopyTable(user_ids)
		end,
	}

end

local function MockUpdateAsync(mock_data_store, profile_store_name, key, transform_function, is_get_call) --> loaded_data, key_info

	local profile_store = mock_data_store[profile_store_name]

	if profile_store == nil then
		profile_store = {}
		mock_data_store[profile_store_name] = profile_store
	end

	local epoch_time = math.floor(os.time() * 1000)
	local mock_entry = profile_store[key]
	local mock_entry_was_nil = false

	if mock_entry == nil then
		mock_entry_was_nil = true
		if is_get_call ~= true then
			mock_entry = {
				Data = nil,
				CreatedTime = epoch_time,
				UpdatedTime = epoch_time,
				VersionId = 0,
				UserIds = {},
				MetaData = {},
			}
			profile_store[key] = mock_entry
		end
	end

	local mock_key_info = mock_entry_was_nil == false and NewMockDataStoreKeyInfo(mock_entry) or nil

	local transform, user_ids, roblox_meta_data = transform_function(mock_entry and mock_entry.Data, mock_key_info)

	if transform == nil then
		return nil
	else
		if mock_entry ~= nil and is_get_call ~= true then
			mock_entry.Data = transform
			mock_entry.UserIds = DeepCopyTable(user_ids or {})
			mock_entry.MetaData = DeepCopyTable(roblox_meta_data or {})
			mock_entry.VersionId += 1
			mock_entry.UpdatedTime = epoch_time
		end

		return DeepCopyTable(transform), mock_entry ~= nil and NewMockDataStoreKeyInfo(mock_entry) or nil
	end

end

local function IsThisSession(session_tag)
	return session_tag[1] == PlaceId and session_tag[2] == JobId
end

--[[
update_settings = {
	ExistingProfileHandle = function(latest_data),
	MissingProfileHandle = function(latest_data),
	EditProfile = function(lastest_data),
}
--]]
local function StandardProfileUpdateAsyncDataStore(profile_store, profile_key, update_settings, is_user_mock, is_get_call, version) --> loaded_data, key_info
	local loaded_data, key_info
	local success, error_message = pcall(function()
		local transform_function = function(latest_data)

			local missing_profile = false
			local data_corrupted = false
			local global_updates_data = {0, {}}

			if latest_data == nil then
				missing_profile = true
			elseif type(latest_data) ~= "table" then
				missing_profile = true
				data_corrupted = true
			end

			if type(latest_data) == "table" then
				-- Case #1: Profile was loaded
				if type(latest_data.Data) == "table"
					and type(latest_data.MetaData) == "table"
					and type(latest_data.GlobalUpdates) == "table" then

					latest_data.WasCorrupted = false -- Must be set to false if set previously
					global_updates_data = latest_data.GlobalUpdates
					if update_settings.ExistingProfileHandle ~= nil then
						update_settings.ExistingProfileHandle(latest_data)
					end
					-- Case #2: Profile was not loaded but GlobalUpdate data exists
				elseif latest_data.Data == nil
					and latest_data.MetaData == nil
					and type(latest_data.GlobalUpdates) == "table" then

					latest_data.WasCorrupted = false -- Must be set to false if set previously
					global_updates_data = latest_data.GlobalUpdates or global_updates_data
					missing_profile = true
				else
					missing_profile = true
					data_corrupted = true
				end
			end

			-- Case #3: Profile was not created or corrupted and no GlobalUpdate data exists
			if missing_profile == true then
				latest_data = {
					-- Data = nil,
					-- MetaData = nil,
					GlobalUpdates = global_updates_data,
				}
				if update_settings.MissingProfileHandle ~= nil then
					update_settings.MissingProfileHandle(latest_data)
				end
			end

			-- Editing profile:
			if update_settings.EditProfile ~= nil then
				update_settings.EditProfile(latest_data)
			end

			-- Data corruption handling (Silently override with empty profile) (Also run Case #1)
			if data_corrupted == true then
				latest_data.WasCorrupted = true -- Temporary tag that will be removed on first save
			end

			return latest_data, latest_data.UserIds, latest_data.RobloxMetaData
		end
		if is_user_mock == true then -- Used when the profile is accessed through ProfileStore.Mock
			loaded_data, key_info = MockUpdateAsync(UserMockDataStore, profile_store._profile_store_lookup, profile_key, transform_function, is_get_call)
			task.wait() -- Simulate API call yield
		elseif UseMockDataStore == true then -- Used when API access is disabled
			loaded_data, key_info = MockUpdateAsync(MockDataStore, profile_store._profile_store_lookup, profile_key, transform_function, is_get_call)
			task.wait() -- Simulate API call yield
		else
			loaded_data, key_info = CustomWriteQueueAsync(
				function() -- Callback
					if is_get_call == true then
						local get_data, get_key_info
						if version ~= nil then
							local success, error_message = pcall(function()
								get_data, get_key_info = profile_store._global_data_store:GetVersionAsync(profile_key, version)
							end)
							if success == false and type(error_message) == "string" and string.find(error_message, "not valid") ~= nil then
								warn("[ProfileService]: Passed version argument is not valid; Traceback:\n" .. debug.traceback())
							end
						else
							get_data, get_key_info = profile_store._global_data_store:GetAsync(profile_key)
						end
						get_data = transform_function(get_data)
						return get_data, get_key_info
					else
						return profile_store._global_data_store:UpdateAsync(profile_key, transform_function)
					end
				end,
				profile_store._profile_store_lookup, -- Store
				profile_key -- Key
			)
		end
	end)
	if success == true and type(loaded_data) == "table" then
		-- Corruption handling:
		if loaded_data.WasCorrupted == true and is_get_call ~= true then
			RegisterCorruption(
				profile_store._profile_store_name,
				profile_store._profile_store_scope,
				profile_key
			)
		end
		-- Return loaded_data:
		return loaded_data, key_info
	else
		RegisterIssue(
			(error_message ~= nil) and error_message or "Undefined error",
			profile_store._profile_store_name,
			profile_store._profile_store_scope,
			profile_key
		)
		-- Return nothing:
		return nil
	end
end

local function RemoveProfileFromAutoSave(profile)
	local auto_save_index = table.find(AutoSaveList, profile)
	if auto_save_index ~= nil then
		table.remove(AutoSaveList, auto_save_index)
		if auto_save_index < AutoSaveIndex then
			AutoSaveIndex = AutoSaveIndex - 1 -- Table contents were moved left before AutoSaveIndex so move AutoSaveIndex left as well
		end
		if AutoSaveList[AutoSaveIndex] == nil then -- AutoSaveIndex was at the end of the AutoSaveList - reset to 1
			AutoSaveIndex = 1
		end
	end
end

local function AddProfileToAutoSave(profile) -- Notice: Makes sure this profile isn't auto-saved too soon
	-- Add at AutoSaveIndex and move AutoSaveIndex right:
	table.insert(AutoSaveList, AutoSaveIndex, profile)
	if #AutoSaveList > 1 then
		AutoSaveIndex = AutoSaveIndex + 1
	elseif #AutoSaveList == 1 then
		-- First profile created - make sure it doesn't get immediately auto saved:
		LastAutoSave = os.clock()
	end
end

local function ReleaseProfileInternally(profile)
	-- 1) Remove profile object from ProfileService references: --
	-- Clear reference in ProfileStore:
	local profile_store = profile._profile_store
	local loaded_profiles = profile._is_user_mock == true and profile_store._mock_loaded_profiles or profile_store._loaded_profiles
	loaded_profiles[profile._profile_key] = nil
	if next(profile_store._loaded_profiles) == nil and next(profile_store._mock_loaded_profiles) == nil then -- ProfileStore has turned inactive
		local index = table.find(ActiveProfileStores, profile_store)
		if index ~= nil then
			table.remove(ActiveProfileStores, index)
		end
	end
	-- Clear auto update reference:
	RemoveProfileFromAutoSave(profile)
	-- 2) Trigger release listeners: --
	local place_id
	local game_job_id
	local active_session = profile.MetaData.ActiveSession
	if active_session ~= nil then
		place_id = active_session[1]
		game_job_id = active_session[2]
	end
	profile._release_listeners:Fire(place_id, game_job_id)
end

local function CheckForNewGlobalUpdates(profile, old_global_updates_data, new_global_updates_data)
	local global_updates_object = profile.GlobalUpdates -- [GlobalUpdates]
	local pending_update_lock = global_updates_object._pending_update_lock -- {update_id, ...}
	local pending_update_clear = global_updates_object._pending_update_clear -- {update_id, ...}
	-- "old_" or "new_" global_updates_data = {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
	for _, new_global_update in ipairs(new_global_updates_data[2]) do
		-- Find old global update with the same update_id:
		local old_global_update
		for _, global_update in ipairs(old_global_updates_data[2]) do
			if global_update[1] == new_global_update[1] then
				old_global_update = global_update
				break
			end
		end
		-- A global update is new when it didn't exist before or its version_id or update_locked state changed:
		local is_new = false
		if old_global_update == nil or new_global_update[2] > old_global_update[2] or new_global_update[3] ~= old_global_update[3] then
			is_new = true
		end
		if is_new == true then
			-- Active global updates:
			if new_global_update[3] == false then
				-- Check if update is not pending to be locked: (Preventing firing new active update listeners more than necessary)
				local is_pending_lock = false
				for _, update_id in ipairs(pending_update_lock) do
					if new_global_update[1] == update_id then
						is_pending_lock = true
						break
					end
				end
				if is_pending_lock == false then
					-- Trigger new active update listeners:
					global_updates_object._new_active_update_listeners:Fire(new_global_update[1], new_global_update[4])
				end
			end
			-- Locked global updates:
			if new_global_update[3] == true then
				-- Check if update is not pending to be cleared: (Preventing firing new locked update listeners after marking a locked update for clearing)
				local is_pending_clear = false
				for _, update_id in ipairs(pending_update_clear) do
					if new_global_update[1] == update_id then
						is_pending_clear = true
						break
					end
				end
				if is_pending_clear == false then
					-- Trigger new locked update listeners:

					global_updates_object._new_locked_update_listeners:FireUntil(
						function()
							-- Check if listener marked the update to be cleared:
							-- Normally there should be only one listener per profile for new locked global updates, but
							-- in case several listeners are connected we will not trigger more listeners after one listener
							-- marks the locked global update to be cleared.
							return table.find(pending_update_clear, new_global_update[1]) == nil
						end,
						new_global_update[1], new_global_update[4]
					)

				end
			end
		end
	end
end

local function SaveProfileAsync(profile, release_from_session, is_overwriting)
	if type(profile.Data) ~= "table" then
		RegisterCorruption(
			profile._profile_store._profile_store_name,
			profile._profile_store._profile_store_scope,
			profile._profile_key
		)
		error("[ProfileService]: PROFILE DATA CORRUPTED DURING RUNTIME! Profile: " .. profile:Identify())
	end
	if release_from_session == true and is_overwriting ~= true then
		ReleaseProfileInternally(profile)
	end
	ActiveProfileSaveJobs = ActiveProfileSaveJobs + 1
	local last_session_load_count = profile.MetaData.SessionLoadCount
	-- Compare "SessionLoadCount" when writing to profile to prevent a rare case of repeat last save when the profile is loaded on the same server again
	local repeat_save_flag = true -- Released Profile save calls have to repeat until they succeed
	while repeat_save_flag == true do
		if release_from_session ~= true then
			repeat_save_flag = false
		end
		local loaded_data, key_info = StandardProfileUpdateAsyncDataStore(
			profile._profile_store,
			profile._profile_key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = nil,
				EditProfile = function(latest_data)

					local session_owns_profile = false
					local force_load_pending = false

					if is_overwriting ~= true then
						-- 1) Check if this session still owns the profile: --
						local active_session = latest_data.MetaData.ActiveSession
						local force_load_session = latest_data.MetaData.ForceLoadSession
						local session_load_count = latest_data.MetaData.SessionLoadCount

						if type(active_session) == "table" then
							session_owns_profile = IsThisSession(active_session) and session_load_count == last_session_load_count
						end
						if type(force_load_session) == "table" then
							force_load_pending = not IsThisSession(force_load_session)
						end
					else
						session_owns_profile = true
					end

					if session_owns_profile == true then -- We may only edit the profile if this session has ownership of the profile

						if is_overwriting ~= true then
							-- 2) Manage global updates: --
							local latest_global_updates_data = latest_data.GlobalUpdates -- {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
							local latest_global_updates_list = latest_global_updates_data[2]

							local global_updates_object = profile.GlobalUpdates -- [GlobalUpdates]
							local pending_update_lock = global_updates_object._pending_update_lock -- {update_id, ...}
							local pending_update_clear = global_updates_object._pending_update_clear -- {update_id, ...}
							-- Active update locking:
							for i = 1, #latest_global_updates_list do
								for _, lock_id in ipairs(pending_update_lock) do
									if latest_global_updates_list[i][1] == lock_id then

										latest_global_updates_list[i][3] = true

										break
									end
								end
							end
							-- Locked update clearing:
							for _, clear_id in ipairs(pending_update_clear) do
								for i = 1, #latest_global_updates_list do
									if latest_global_updates_list[i][1] == clear_id and latest_global_updates_list[i][3] == true then

										table.remove(latest_global_updates_list, i)

										break
									end
								end
							end
						end

						-- 3) Save profile data: --
						latest_data.Data = profile.Data
						latest_data.RobloxMetaData = profile.RobloxMetaData
						latest_data.UserIds = profile.UserIds

						if is_overwriting ~= true then
							latest_data.MetaData.MetaTags = profile.MetaData.MetaTags -- MetaData.MetaTags is the only actively savable component of MetaData
							latest_data.MetaData.LastUpdate = os.time()
							if release_from_session == true or force_load_pending == true then
								latest_data.MetaData.ActiveSession = nil
							end
						else
							latest_data.MetaData = profile.MetaData
							latest_data.MetaData.ActiveSession = nil
							latest_data.MetaData.ForceLoadSession = nil
							latest_data.GlobalUpdates = profile.GlobalUpdates._updates_latest
						end

					end
				end,
			},
			profile._is_user_mock
		)
		if loaded_data ~= nil and key_info ~= nil then
			if is_overwriting == true then
				break
			end
			repeat_save_flag = false
			-- 4) Set latest data in profile: --
			-- Updating DataStoreKeyInfo:
			profile.KeyInfo = key_info
			-- Setting global updates:
			local global_updates_object = profile.GlobalUpdates -- [GlobalUpdates]
			local old_global_updates_data = global_updates_object._updates_latest
			local new_global_updates_data = loaded_data.GlobalUpdates
			global_updates_object._updates_latest = new_global_updates_data
			-- Setting MetaData:
			local session_meta_data = profile.MetaData
			local latest_meta_data = loaded_data.MetaData
			for key in pairs(SETTINGS.MetaTagsUpdatedValues) do
				session_meta_data[key] = latest_meta_data[key]
			end
			session_meta_data.MetaTagsLatest = latest_meta_data.MetaTags
			-- 5) Check if session still owns the profile: --
			local active_session = loaded_data.MetaData.ActiveSession
			local session_load_count = loaded_data.MetaData.SessionLoadCount
			local session_owns_profile = false
			if type(active_session) == "table" then
				session_owns_profile = IsThisSession(active_session) and session_load_count == last_session_load_count
			end
			local is_active = profile:IsActive()
			if session_owns_profile == true then
				-- 6) Check for new global updates: --
				if is_active == true then -- Profile could've been released before the saving thread finished
					CheckForNewGlobalUpdates(profile, old_global_updates_data, new_global_updates_data)
				end
			else
				-- Session no longer owns the profile:
				-- 7) Release profile if it hasn't been released yet: --
				if is_active == true then
					ReleaseProfileInternally(profile)
				end
				-- Cleanup reference in custom write queue:
				CustomWriteQueueMarkForCleanup(profile._profile_store._profile_store_lookup, profile._profile_key)
				-- Hop ready listeners:
				if profile._hop_ready == false then
					profile._hop_ready = true
					profile._hop_ready_listeners:Fire()
				end
			end
			-- Signaling MetaTagsUpdated listeners after a possible external profile release was handled:
			profile.MetaTagsUpdated:Fire(profile.MetaData.MetaTagsLatest)
			-- Signaling KeyInfoUpdated listeners:
			profile.KeyInfoUpdated:Fire(key_info)
		elseif repeat_save_flag == true then
			task.wait() -- Prevent infinite loop in case DataStore API does not yield
		end
	end
	ActiveProfileSaveJobs = ActiveProfileSaveJobs - 1
end

----- Public functions -----

-- GlobalUpdates object:

local GlobalUpdates = {
	--[[
		_updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
		_pending_update_lock = {update_id, ...} / nil, -- [table / nil]
		_pending_update_clear = {update_id, ...} / nil, -- [table / nil]

		_new_active_update_listeners = [ScriptSignal] / nil, -- [table / nil]
		_new_locked_update_listeners = [ScriptSignal] / nil, -- [table / nil]

		_profile = Profile / nil, -- [Profile / nil]

		_update_handler_mode = true / nil, -- [bool / nil]
	--]]
}
GlobalUpdates.__index = GlobalUpdates

-- ALWAYS PUBLIC:
function GlobalUpdates:GetActiveUpdates() --> [table] {{update_id, update_data}, ...}
	local query_list = {}
	for _, global_update in ipairs(self._updates_latest[2]) do
		if global_update[3] == false then
			local is_pending_lock = false
			if self._pending_update_lock ~= nil then
				for _, update_id in ipairs(self._pending_update_lock) do
					if global_update[1] == update_id then
						is_pending_lock = true -- Exclude global updates pending to be locked
						break
					end
				end
			end
			if is_pending_lock == false then
				table.insert(query_list, {global_update[1], global_update[4]})
			end
		end
	end
	return query_list
end

function GlobalUpdates:GetLockedUpdates() --> [table] {{update_id, update_data}, ...}
	local query_list = {}
	for _, global_update in ipairs(self._updates_latest[2]) do
		if global_update[3] == true then
			local is_pending_clear = false
			if self._pending_update_clear ~= nil then
				for _, update_id in ipairs(self._pending_update_clear) do
					if global_update[1] == update_id then
						is_pending_clear = true -- Exclude global updates pending to be cleared
						break
					end
				end
			end
			if is_pending_clear == false then
				table.insert(query_list, {global_update[1], global_update[4]})
			end
		end
	end
	return query_list
end

-- ONLY WHEN FROM "Profile.GlobalUpdates":
function GlobalUpdates:ListenToNewActiveUpdate(listener) --> [ScriptConnection] listener(update_id, update_data)
	if type(listener) ~= "function" then
		error("[ProfileService]: Only a function can be set as listener in GlobalUpdates:ListenToNewActiveUpdate()")
	end
	local profile = self._profile
	if self._update_handler_mode == true then
		error("[ProfileService]: Can't listen to new global updates in ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._new_active_update_listeners == nil then
		error("[ProfileService]: Can't listen to new global updates in view mode")
	elseif profile:IsActive() == false then -- Check if profile is expired
		return { -- Do not connect listener if the profile is expired
			Disconnect = function() end,
		}
	end
	-- Connect listener:
	return self._new_active_update_listeners:Connect(listener)
end

function GlobalUpdates:ListenToNewLockedUpdate(listener) --> [ScriptConnection] listener(update_id, update_data)
	if type(listener) ~= "function" then
		error("[ProfileService]: Only a function can be set as listener in GlobalUpdates:ListenToNewLockedUpdate()")
	end
	local profile = self._profile
	if self._update_handler_mode == true then
		error("[ProfileService]: Can't listen to new global updates in ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._new_locked_update_listeners == nil then
		error("[ProfileService]: Can't listen to new global updates in view mode")
	elseif profile:IsActive() == false then -- Check if profile is expired
		return { -- Do not connect listener if the profile is expired
			Disconnect = function() end,
		}
	end
	-- Connect listener:
	return self._new_locked_update_listeners:Connect(listener)
end

function GlobalUpdates:LockActiveUpdate(update_id)
	if type(update_id) ~= "number" then
		error("[ProfileService]: Invalid update_id")
	end
	local profile = self._profile
	if self._update_handler_mode == true then
		error("[ProfileService]: Can't lock active global updates in ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._pending_update_lock == nil then
		error("[ProfileService]: Can't lock active global updates in view mode")
	elseif profile:IsActive() == false then -- Check if profile is expired
		error("[ProfileService]: PROFILE EXPIRED - Can't lock active global updates")
	end
	-- Check if global update exists with given update_id
	local global_update_exists = nil
	for _, global_update in ipairs(self._updates_latest[2]) do
		if global_update[1] == update_id then
			global_update_exists = global_update
			break
		end
	end
	if global_update_exists ~= nil then
		local is_pending_lock = false
		for _, lock_update_id in ipairs(self._pending_update_lock) do
			if update_id == lock_update_id then
				is_pending_lock = true -- Exclude global updates pending to be locked
				break
			end
		end
		if is_pending_lock == false and global_update_exists[3] == false then -- Avoid id duplicates in _pending_update_lock
			table.insert(self._pending_update_lock, update_id)
		end
	else
		error("[ProfileService]: Passed non-existant update_id")
	end
end

function GlobalUpdates:ClearLockedUpdate(update_id)
	if type(update_id) ~= "number" then
		error("[ProfileService]: Invalid update_id")
	end
	local profile = self._profile
	if self._update_handler_mode == true then
		error("[ProfileService]: Can't clear locked global updates in ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._pending_update_clear == nil then
		error("[ProfileService]: Can't clear locked global updates in view mode")
	elseif profile:IsActive() == false then -- Check if profile is expired
		error("[ProfileService]: PROFILE EXPIRED - Can't clear locked global updates")
	end
	-- Check if global update exists with given update_id
	local global_update_exists = nil
	for _, global_update in ipairs(self._updates_latest[2]) do
		if global_update[1] == update_id then
			global_update_exists = global_update
			break
		end
	end
	if global_update_exists ~= nil then
		local is_pending_clear = false
		for _, clear_update_id in ipairs(self._pending_update_clear) do
			if update_id == clear_update_id then
				is_pending_clear = true -- Exclude global updates pending to be cleared
				break
			end
		end
		if is_pending_clear == false and global_update_exists[3] == true then -- Avoid id duplicates in _pending_update_clear
			table.insert(self._pending_update_clear, update_id)
		end
	else
		error("[ProfileService]: Passed non-existant update_id")
	end
end

-- EXPOSED TO "update_handler" DURING ProfileStore:GlobalUpdateProfileAsync() CALL
function GlobalUpdates:AddActiveUpdate(update_data)
	if type(update_data) ~= "table" then
		error("[ProfileService]: Invalid update_data")
	end
	if self._new_active_update_listeners ~= nil then
		error("[ProfileService]: Can't add active global updates in loaded Profile; Use ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._update_handler_mode ~= true then
		error("[ProfileService]: Can't add active global updates in view mode; Use ProfileStore:GlobalUpdateProfileAsync()")
	end
	-- self._updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
	local updates_latest = self._updates_latest
	local update_index = updates_latest[1] + 1 -- Incrementing global update index
	updates_latest[1] = update_index
	-- Add new active global update:
	table.insert(updates_latest[2], {update_index, 1, false, update_data})
end

function GlobalUpdates:ChangeActiveUpdate(update_id, update_data)
	if type(update_id) ~= "number" then
		error("[ProfileService]: Invalid update_id")
	end
	if type(update_data) ~= "table" then
		error("[ProfileService]: Invalid update_data")
	end
	if self._new_active_update_listeners ~= nil then
		error("[ProfileService]: Can't change active global updates in loaded Profile; Use ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._update_handler_mode ~= true then
		error("[ProfileService]: Can't change active global updates in view mode; Use ProfileStore:GlobalUpdateProfileAsync()")
	end
	-- self._updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
	local updates_latest = self._updates_latest
	local get_global_update = nil
	for _, global_update in ipairs(updates_latest[2]) do
		if update_id == global_update[1] then
			get_global_update = global_update
			break
		end
	end
	if get_global_update ~= nil then
		if get_global_update[3] == true then
			error("[ProfileService]: Can't change locked global update")
		end
		get_global_update[2] = get_global_update[2] + 1 -- Increment version id
		get_global_update[4] = update_data -- Set new global update data
	else
		error("[ProfileService]: Passed non-existant update_id")
	end
end

function GlobalUpdates:ClearActiveUpdate(update_id)
	if type(update_id) ~= "number" then
		error("[ProfileService]: Invalid update_id argument")
	end
	if self._new_active_update_listeners ~= nil then
		error("[ProfileService]: Can't clear active global updates in loaded Profile; Use ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._update_handler_mode ~= true then
		error("[ProfileService]: Can't clear active global updates in view mode; Use ProfileStore:GlobalUpdateProfileAsync()")
	end
	-- self._updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
	local updates_latest = self._updates_latest
	local get_global_update_index = nil
	local get_global_update = nil
	for index, global_update in ipairs(updates_latest[2]) do
		if update_id == global_update[1] then
			get_global_update_index = index
			get_global_update = global_update
			break
		end
	end
	if get_global_update ~= nil then
		if get_global_update[3] == true then
			error("[ProfileService]: Can't clear locked global update")
		end
		table.remove(updates_latest[2], get_global_update_index) -- Remove active global update
	else
		error("[ProfileService]: Passed non-existant update_id")
	end
end

-- Profile object:

local Profile = {
	--[[
		Data = {}, -- [table] -- Loaded once after ProfileStore:LoadProfileAsync() finishes
		MetaData = {}, -- [table] -- Updated with every auto-save
		GlobalUpdates = GlobalUpdates, -- [GlobalUpdates]

		_profile_store = ProfileStore, -- [ProfileStore]
		_profile_key = "", -- [string]

		_release_listeners = [ScriptSignal] / nil, -- [table / nil]
		_hop_ready_listeners = [ScriptSignal] / nil, -- [table / nil]
		_hop_ready = false,

		_view_mode = true / nil, -- [bool] or nil

		_load_timestamp = os.clock(),

		_is_user_mock = false, -- ProfileStore.Mock
		_mock_key_info = {},
	--]]
}
Profile.__index = Profile

function Profile:IsActive() --> [bool]
	local loaded_profiles = self._is_user_mock == true and self._profile_store._mock_loaded_profiles or self._profile_store._loaded_profiles
	return loaded_profiles[self._profile_key] == self
end

function Profile:GetMetaTag(tag_name) --> value
	local meta_data = self.MetaData
	if meta_data == nil then
		return nil
		-- error("[ProfileService]: This Profile hasn't been loaded before - MetaData not available")
	end
	return self.MetaData.MetaTags[tag_name]
end

function Profile:SetMetaTag(tag_name, value)
	if type(tag_name) ~= "string" then
		error("[ProfileService]: tag_name must be a string")
	elseif string.len(tag_name) == 0 then
		error("[ProfileService]: Invalid tag_name")
	end
	self.MetaData.MetaTags[tag_name] = value
end

function Profile:Reconcile()
	ReconcileTable(self.Data, self._profile_store._profile_template)
end

function Profile:ListenToRelease(listener) --> [ScriptConnection] (place_id / nil, game_job_id / nil)
	if type(listener) ~= "function" then
		error("[ProfileService]: Only a function can be set as listener in Profile:ListenToRelease()")
	end
	if self._view_mode == true then
		return {Disconnect = function() end}
	end
	if self:IsActive() == false then
		-- Call release listener immediately if profile is expired
		local place_id
		local game_job_id
		local active_session = self.MetaData.ActiveSession
		if active_session ~= nil then
			place_id = active_session[1]
			game_job_id = active_session[2]
		end
		listener(place_id, game_job_id)
		return {Disconnect = function() end}
	else
		return self._release_listeners:Connect(listener)
	end
end

function Profile:Save()
	if self._view_mode == true then
		error("[ProfileService]: Can't save Profile in view mode - Should you be calling :OverwriteAsync() instead?")
	end
	if self:IsActive() == false then
		warn("[ProfileService]: Attempted saving an inactive profile "
			.. self:Identify() .. "; Traceback:\n" .. debug.traceback())
		return
	end
	-- Reject save request if a save is already pending in the queue - this will prevent the user from
	--      unecessary API request spam which we could not meaningfully execute anyways!
	if IsCustomWriteQueueEmptyFor(self._profile_store._profile_store_lookup, self._profile_key) == true then
		-- We don't want auto save to trigger too soon after manual saving - this will reset the auto save timer:
		RemoveProfileFromAutoSave(self)
		AddProfileToAutoSave(self)
		-- Call save function in a new thread:
		task.spawn(SaveProfileAsync, self)
	end
end

function Profile:Release()
	if self._view_mode == true then
		return
	end
	if self:IsActive() == true then
		task.spawn(SaveProfileAsync, self, true) -- Call save function in a new thread with release_from_session = true
	end
end

function Profile:ListenToHopReady(listener) --> [ScriptConnection] ()
	if type(listener) ~= "function" then
		error("[ProfileService]: Only a function can be set as listener in Profile:ListenToHopReady()")
	end
	if self._view_mode == true then
		return {Disconnect = function() end}
	end
	if self._hop_ready == true then
		task.spawn(listener)
		return {Disconnect = function() end}
	else
		return self._hop_ready_listeners:Connect(listener)
	end
end

function Profile:AddUserId(user_id) -- Associates user_id with profile (GDPR compliance)

	if type(user_id) ~= "number" or user_id % 1 ~= 0 then
		warn("[ProfileService]: Invalid UserId argument for :AddUserId() ("
			.. tostring(user_id) .. "); Traceback:\n" .. debug.traceback())
		return
	end

	if user_id < 0 and self._is_user_mock ~= true and UseMockDataStore ~= true then
		return -- Avoid giving real Roblox APIs negative UserId's
	end

	if table.find(self.UserIds, user_id) == nil then
		table.insert(self.UserIds, user_id)
	end

end

function Profile:RemoveUserId(user_id) -- Unassociates user_id with profile (safe function)

	if type(user_id) ~= "number" or user_id % 1 ~= 0 then
		warn("[ProfileService]: Invalid UserId argument for :RemoveUserId() ("
			.. tostring(user_id) .. "); Traceback:\n" .. debug.traceback())
		return
	end

	local index = table.find(self.UserIds, user_id)

	if index ~= nil then
		table.remove(self.UserIds, index)
	end

end

function Profile:Identify() --> [string]
	return IdentifyProfile(
		self._profile_store._profile_store_name,
		self._profile_store._profile_store_scope,
		self._profile_key
	)
end

function Profile:ClearGlobalUpdates() -- Clears all global updates data from a profile payload

	if self._view_mode ~= true then
		error("[ProfileService]: :ClearGlobalUpdates() can only be used in view mode")
	end

	local global_updates_object = {
		_updates_latest = {0, {}},
		_profile = self,
	}
	setmetatable(global_updates_object, GlobalUpdates)

	self.GlobalUpdates = global_updates_object

end

function Profile:OverwriteAsync() -- Saves the profile to the DataStore and removes the session lock

	if self._view_mode ~= true then
		error("[ProfileService]: :OverwriteAsync() can only be used in view mode")
	end

	SaveProfileAsync(self, nil, true)

end

-- ProfileVersionQuery object:

local ProfileVersionQuery = {
	--[[
		_profile_store = profile_store,
		_profile_key = profile_key,
		_sort_direction = sort_direction,
		_min_date = min_date,
		_max_date = max_date,

		_query_pages = pages, -- [DataStoreVersionPages]
		_query_index = index, -- [number]
		_query_failure = false,

		_is_query_yielded = false,
		_query_queue = {},
	--]]
}
ProfileVersionQuery.__index = ProfileVersionQuery

function ProfileVersionQuery:_MoveQueue()
	while #self._query_queue > 0 do
		local queue_entry = table.remove(self._query_queue, 1)
		task.spawn(queue_entry)
		if self._is_query_yielded == true then
			break
		end
	end
end

function ProfileVersionQuery:NextAsync(_is_stacking) --> [Profile] or nil

	if self._profile_store == nil then
		return nil
	end

	local profile
	local is_finished = false

	local function query_job()

		if self._query_failure == true then
			is_finished = true
			return
		end

		-- First "next" call loads version pages:

		if self._query_pages == nil then

			self._is_query_yielded = true
			task.spawn(function()
				profile = self:NextAsync(true)
				is_finished = true
			end)

			local list_success, error_message = pcall(function()
				self._query_pages = self._profile_store._global_data_store:ListVersionsAsync(
					self._profile_key,
					self._sort_direction,
					self._min_date,
					self._max_date
				)
				self._query_index = 0
			end)

			if list_success == false or self._query_pages == nil then
				warn("[ProfileService]: Version query fail - " .. tostring(error_message))
				self._query_failure = true
			end

			self._is_query_yielded = false
			self:_MoveQueue()

			return

		end

		local current_page = self._query_pages:GetCurrentPage()
		local next_item = current_page[self._query_index + 1]

		-- No more entries:

		if self._query_pages.IsFinished == true and next_item == nil then
			is_finished = true
			return
		end

		-- Load next page when this page is over:

		if next_item == nil then

			self._is_query_yielded = true
			task.spawn(function()
				profile = self:NextAsync(true)
				is_finished = true
			end)

			local success = pcall(function()
				self._query_pages:AdvanceToNextPageAsync()
				self._query_index = 0
			end)

			if success == false or #self._query_pages:GetCurrentPage() == 0 then
				self._query_failure = true
			end

			self._is_query_yielded = false
			self:_MoveQueue()

			return

		end

		-- Next page item:

		self._query_index += 1
		profile = self._profile_store:ViewProfileAsync(self._profile_key, next_item.Version)
		is_finished = true

	end

	if self._is_query_yielded == false then
		query_job()
	else
		if _is_stacking == true then
			table.insert(self._query_queue, 1, query_job)
		else
			table.insert(self._query_queue, query_job)
		end
	end

	while is_finished == false do
		task.wait()
	end

	return profile

end

-- ProfileStore object:

local ProfileStore = {
	--[[
		Mock = {},

		_profile_store_name = "", -- [string] -- DataStore name
		_profile_store_scope = nil, -- [string] or [nil] -- DataStore scope
		_profile_store_lookup = "", -- [string] -- _profile_store_name .. "\0" .. (_profile_store_scope or "")

		_profile_template = {}, -- [table]
		_global_data_store = global_data_store, -- [GlobalDataStore] -- Object returned by DataStoreService:GetDataStore(_profile_store_name)

		_loaded_profiles = {[profile_key] = Profile, ...},
		_profile_load_jobs = {[profile_key] = {load_id, loaded_data}, ...},

		_mock_loaded_profiles = {[profile_key] = Profile, ...},
		_mock_profile_load_jobs = {[profile_key] = {load_id, loaded_data}, ...},
	--]]
}
ProfileStore.__index = ProfileStore

function ProfileStore:LoadProfileAsync(profile_key, not_released_handler, _use_mock) --> [Profile / nil] not_released_handler(place_id, game_job_id)

	not_released_handler = not_released_handler or "ForceLoad"

	if self._profile_template == nil then
		error("[ProfileService]: Profile template not set - ProfileStore:LoadProfileAsync() locked for this ProfileStore")
	end
	if type(profile_key) ~= "string" then
		error("[ProfileService]: profile_key must be a string")
	elseif string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end
	if type(not_released_handler) ~= "function" and not_released_handler ~= "ForceLoad" and not_released_handler ~= "Steal" then
		error("[ProfileService]: Invalid not_released_handler")
	end

	if ProfileService.ServiceLocked == true then
		return nil
	end

	WaitForPendingProfileStore(self)

	local is_user_mock = _use_mock == UseMockTag

	-- Check if profile with profile_key isn't already loaded in this session:
	for _, profile_store in ipairs(ActiveProfileStores) do
		if profile_store._profile_store_lookup == self._profile_store_lookup then
			local loaded_profiles = is_user_mock == true and profile_store._mock_loaded_profiles or profile_store._loaded_profiles
			if loaded_profiles[profile_key] ~= nil then
				error("[ProfileService]: Profile " .. IdentifyProfile(self._profile_store_name, self._profile_store_scope, profile_key) .. " is already loaded in this session")
				-- Are you using Profile:Release() properly?
			end
		end
	end

	ActiveProfileLoadJobs = ActiveProfileLoadJobs + 1
	local force_load = not_released_handler == "ForceLoad"
	local force_load_steps = 0
	local request_force_load = force_load -- First step of ForceLoad
	local steal_session = false -- Second step of ForceLoad
	local aggressive_steal = not_released_handler == "Steal" -- Developer invoked steal
	while ProfileService.ServiceLocked == false do
		-- Load profile:
		-- SPECIAL CASE - If LoadProfileAsync is called for the same key before another LoadProfileAsync finishes,
		-- yoink the DataStore return for the new call. The older call will return nil. This would prevent very rare
		-- game breaking errors where a player rejoins the server super fast.
		local profile_load_jobs = is_user_mock == true and self._mock_profile_load_jobs or self._profile_load_jobs
		local loaded_data, key_info
		local load_id = LoadIndex + 1
		LoadIndex = load_id
		local profile_load_job = profile_load_jobs[profile_key] -- {load_id, {loaded_data, key_info} or nil}
		if profile_load_job ~= nil then
			profile_load_job[1] = load_id -- Yoink load job
			while profile_load_job[2] == nil do -- Wait for job to finish
				task.wait()
			end
			if profile_load_job[1] == load_id then -- Load job hasn't been double-yoinked
				loaded_data, key_info = table.unpack(profile_load_job[2])
				profile_load_jobs[profile_key] = nil
			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil
			end
		else
			profile_load_job = {load_id, nil}
			profile_load_jobs[profile_key] = profile_load_job
			profile_load_job[2] = table.pack(StandardProfileUpdateAsyncDataStore(
				self,
				profile_key,
				{
					ExistingProfileHandle = function(latest_data)
						if ProfileService.ServiceLocked == false then
							local active_session = latest_data.MetaData.ActiveSession
							local force_load_session = latest_data.MetaData.ForceLoadSession
							-- IsThisSession(active_session)
							if active_session == nil then
								latest_data.MetaData.ActiveSession = {PlaceId, JobId}
								latest_data.MetaData.ForceLoadSession = nil
							elseif type(active_session) == "table" then
								if IsThisSession(active_session) == false then
									local last_update = latest_data.MetaData.LastUpdate
									if last_update ~= nil then

										if os.time() - last_update > SETTINGS.AssumeDeadSessionLock then

											latest_data.MetaData.ActiveSession = {PlaceId, JobId}

											latest_data.MetaData.ForceLoadSession = nil

											return

										end
									end
									if steal_session == true or aggressive_steal == true then

										local force_load_uninterrupted = false

										if force_load_session ~= nil then

											force_load_uninterrupted = IsThisSession(force_load_session)

										end

										if force_load_uninterrupted == true or aggressive_steal == true then

											latest_data.MetaData.ActiveSession = {PlaceId, JobId}

											latest_data.MetaData.ForceLoadSession = nil

										end
									elseif request_force_load == true then

										latest_data.MetaData.ForceLoadSession = {PlaceId, JobId}
									end
								else
									latest_data.MetaData.ForceLoadSession = nil
								end
							end
						end
					end,
					MissingProfileHandle = function(latest_data)
						latest_data.Data = DeepCopyTable(self._profile_template)
						latest_data.MetaData = {
							ProfileCreateTime = os.time(),
							SessionLoadCount = 0,
							ActiveSession = {PlaceId, JobId},
							ForceLoadSession = nil,
							MetaTags = {},
						}
					end,
					EditProfile = function(latest_data)
						if ProfileService.ServiceLocked == false then
							local active_session = latest_data.MetaData.ActiveSession
							if active_session ~= nil and IsThisSession(active_session) == true then
								latest_data.MetaData.SessionLoadCount = latest_data.MetaData.SessionLoadCount + 1
								latest_data.MetaData.LastUpdate = os.time()
							end
						end
					end,
				},
				is_user_mock
			))
			if profile_load_job[1] == load_id then -- Load job hasn't been yoinked
				loaded_data, key_info = table.unpack(profile_load_job[2])
				profile_load_jobs[profile_key] = nil
			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil -- Load job yoinked
			end
		end
		-- Handle load_data:
		if loaded_data ~= nil and key_info ~= nil then
			local active_session = loaded_data.MetaData.ActiveSession
			if type(active_session) == "table" then
				if IsThisSession(active_session) == true then
					-- Special component in MetaTags:
					loaded_data.MetaData.MetaTagsLatest = DeepCopyTable(loaded_data.MetaData.MetaTags)
					-- Case #1: Profile is now taken by this session:
					-- Create Profile object:
					local global_updates_object = {
						_updates_latest = loaded_data.GlobalUpdates,
						_pending_update_lock = {},
						_pending_update_clear = {},

						_new_active_update_listeners = Madwork.NewScriptSignal(),
						_new_locked_update_listeners = Madwork.NewScriptSignal(),

						_profile = nil,
					}
					setmetatable(global_updates_object, GlobalUpdates)
					local profile = {
						Data = loaded_data.Data,
						MetaData = loaded_data.MetaData,
						MetaTagsUpdated = Madwork.NewScriptSignal(),

						RobloxMetaData = loaded_data.RobloxMetaData or {},
						UserIds = loaded_data.UserIds or {},
						KeyInfo = key_info,
						KeyInfoUpdated = Madwork.NewScriptSignal(),

						GlobalUpdates = global_updates_object,

						_profile_store = self,
						_profile_key = profile_key,

						_release_listeners = Madwork.NewScriptSignal(),
						_hop_ready_listeners = Madwork.NewScriptSignal(),
						_hop_ready = false,

						_load_timestamp = os.clock(),

						_is_user_mock = is_user_mock,
					}
					setmetatable(profile, Profile)
					global_updates_object._profile = profile
					-- Referencing Profile object in ProfileStore:
					if next(self._loaded_profiles) == nil and next(self._mock_loaded_profiles) == nil then -- ProfileStore object was inactive
						table.insert(ActiveProfileStores, self)
					end
					if is_user_mock == true then
						self._mock_loaded_profiles[profile_key] = profile
					else
						self._loaded_profiles[profile_key] = profile
					end
					-- Adding profile to AutoSaveList;
					AddProfileToAutoSave(profile)
					-- Special case - finished loading profile, but session is shutting down:
					if (ProfileService.ServiceLocked :: boolean) == true then
						SaveProfileAsync(profile, true) -- Release profile and yield until the DataStore call is finished
						profile = nil :: any -- nil will be returned by this call
					end
					-- Return Profile object:
					ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
					return profile
				else
					-- Case #2: Profile is taken by some other session:
					if force_load == true then
						local force_load_session = loaded_data.MetaData.ForceLoadSession
						local force_load_uninterrupted = false
						if force_load_session ~= nil then
							force_load_uninterrupted = IsThisSession(force_load_session)
						end
						if force_load_uninterrupted == true then
							if request_force_load == false then
								force_load_steps = force_load_steps + 1
								if force_load_steps == SETTINGS.ForceLoadMaxSteps then
									steal_session = true
								end
							end
							task.wait() -- Overload prevention
						else
							-- Another session tried to force load this profile:
							ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
							return nil
						end
						request_force_load = false -- Only request a force load once
					elseif aggressive_steal == true then
						task.wait() -- Overload prevention
					else
						local handler_result = (not_released_handler :: (number, string) -> string)(active_session[1], active_session[2])
						if handler_result == "Repeat" then
							task.wait() -- Overload prevention
						elseif handler_result == "Cancel" then
							ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
							return nil
						elseif handler_result == "ForceLoad" then
							force_load = true
							request_force_load = true
							task.wait() -- Overload prevention
						elseif handler_result == "Steal" then
							aggressive_steal = true
							task.wait() -- Overload prevention
						else
							error(
								"[ProfileService]: Invalid return from not_released_handler (\"" .. tostring(handler_result) .. "\")(" .. type(handler_result) .. ");" ..
									"\n" .. IdentifyProfile(self._profile_store_name, self._profile_store_scope, profile_key) ..
									" Traceback:\n" .. debug.traceback()
							)
						end
					end
				end
			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil -- In this scenario it is likely the ProfileService.ServiceLocked flag was raised
			end
		else
			task.wait() -- Overload prevention
		end
	end
	ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
	return nil -- If loop breaks return nothing
end

function ProfileStore:GlobalUpdateProfileAsync(profile_key, update_handler, _use_mock) --> [GlobalUpdates / nil] (update_handler(GlobalUpdates))
	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end
	if type(update_handler) ~= "function" then
		error("[ProfileService]: Invalid update_handler")
	end

	if ProfileService.ServiceLocked == true then
		return nil
	end

	WaitForPendingProfileStore(self)

	while ProfileService.ServiceLocked == false do
		-- Updating profile:
		local loaded_data = StandardProfileUpdateAsyncDataStore(
			self,
			profile_key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = nil,
				EditProfile = function(latest_data)
					-- Running update_handler:
					local global_updates_object = {
						_updates_latest = latest_data.GlobalUpdates,
						_update_handler_mode = true,
					}
					setmetatable(global_updates_object, GlobalUpdates)
					update_handler(global_updates_object)
				end,
			},
			_use_mock == UseMockTag
		)
		CustomWriteQueueMarkForCleanup(self._profile_store_lookup, profile_key)
		-- Handling loaded_data:
		if loaded_data ~= nil then
			-- Return GlobalUpdates object (Update successful):
			local global_updates_object = {
				_updates_latest = loaded_data.GlobalUpdates,
			}
			setmetatable(global_updates_object, GlobalUpdates)
			return global_updates_object
		else
			task.wait() -- Overload prevention
		end
	end
	return nil -- Return nothing (Update unsuccessful)
end

function ProfileStore:ViewProfileAsync(profile_key, version, _use_mock) --> [Profile / nil]
	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end

	if ProfileService.ServiceLocked == true then
		return nil
	end

	WaitForPendingProfileStore(self)

	if version ~= nil and (_use_mock == UseMockTag or UseMockDataStore == true) then
		return nil -- No version support in mock mode
	end

	while ProfileService.ServiceLocked == false do
		-- Load profile:
		local loaded_data, key_info = StandardProfileUpdateAsyncDataStore(
			self,
			profile_key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = function(latest_data)
					latest_data.Data = DeepCopyTable(self._profile_template)
					latest_data.MetaData = {
						ProfileCreateTime = os.time(),
						SessionLoadCount = 0,
						ActiveSession = nil,
						ForceLoadSession = nil,
						MetaTags = {},
					}
				end,
				EditProfile = nil,
			},
			_use_mock == UseMockTag,
			true, -- Use :GetAsync()
			version -- DataStore key version
		)
		CustomWriteQueueMarkForCleanup(self._profile_store_lookup, profile_key)
		-- Handle load_data:
		if loaded_data ~= nil then
			if key_info == nil then
				return nil -- Load was successful, but the key was empty - return no profile object
			end
			-- Create Profile object:
			local global_updates_object = {
				_updates_latest = loaded_data.GlobalUpdates, -- {0, {}}
				_profile = nil,
			}
			setmetatable(global_updates_object, GlobalUpdates)
			local profile = {
				Data = loaded_data.Data,
				MetaData = loaded_data.MetaData,
				MetaTagsUpdated = Madwork.NewScriptSignal(),

				RobloxMetaData = loaded_data.RobloxMetaData or {},
				UserIds = loaded_data.UserIds or {},
				KeyInfo = key_info,
				KeyInfoUpdated = Madwork.NewScriptSignal(),

				GlobalUpdates = global_updates_object,

				_profile_store = self,
				_profile_key = profile_key,

				_view_mode = true,

				_load_timestamp = os.clock(),
			}
			setmetatable(profile, Profile)
			global_updates_object._profile = profile
			-- Returning Profile object:
			return profile
		else
			task.wait() -- Overload prevention
		end
	end
	return nil -- If loop breaks return nothing
end

function ProfileStore:ProfileVersionQuery(profile_key, sort_direction, min_date, max_date, _use_mock) --> [ProfileVersionQuery]
	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end

	if ProfileService.ServiceLocked == true then
		return setmetatable({}, ProfileVersionQuery) -- Silently fail :Next() requests
	end

	WaitForPendingProfileStore(self)

	if _use_mock == UseMockTag or UseMockDataStore == true then
		error("[ProfileService]: :ProfileVersionQuery() is not supported in mock mode")
	end

	-- Type check:
	if sort_direction ~= nil and (typeof(sort_direction) ~= "EnumItem"
		or sort_direction.EnumType ~= Enum.SortDirection) then
		error("[ProfileService]: Invalid sort_direction (" .. tostring(sort_direction) .. ")")
	end

	if min_date ~= nil and typeof(min_date) ~= "DateTime" and typeof(min_date) ~= "number" then
		error("[ProfileService]: Invalid min_date (" .. tostring(min_date) .. ")")
	end

	if max_date ~= nil and typeof(max_date) ~= "DateTime" and typeof(max_date) ~= "number" then
		error("[ProfileService]: Invalid max_date (" .. tostring(max_date) .. ")")
	end

	min_date = typeof(min_date) == "DateTime" and min_date.UnixTimestampMillis or min_date
	max_date = typeof(max_date) == "DateTime" and max_date.UnixTimestampMillis or max_date

	local profile_version_query = {
		_profile_store = self,
		_profile_key = profile_key,
		_sort_direction = sort_direction,
		_min_date = min_date,
		_max_date = max_date,

		_query_pages = nil,
		_query_index = 0,
		_query_failure = false,

		_is_query_yielded = false,
		_query_queue = {},
	}
	setmetatable(profile_version_query, ProfileVersionQuery)

	return profile_version_query

end

function ProfileStore:WipeProfileAsync(profile_key, _use_mock) --> is_wipe_successful [bool]
	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end

	if ProfileService.ServiceLocked == true then
		return false
	end

	WaitForPendingProfileStore(self)

	local wipe_status = false

	if _use_mock == UseMockTag then -- Used when the profile is accessed through ProfileStore.Mock
		local mock_data_store = UserMockDataStore[self._profile_store_lookup]
		if mock_data_store ~= nil then
			mock_data_store[profile_key] = nil
		end
		wipe_status = true
		task.wait() -- Simulate API call yield
	elseif UseMockDataStore == true then -- Used when API access is disabled
		local mock_data_store = MockDataStore[self._profile_store_lookup]
		if mock_data_store ~= nil then
			mock_data_store[profile_key] = nil
		end
		wipe_status = true
		task.wait() -- Simulate API call yield
	else
		wipe_status = pcall(function()
			self._global_data_store:RemoveAsync(profile_key)
		end)
	end

	CustomWriteQueueMarkForCleanup(self._profile_store_lookup, profile_key)

	return wipe_status
end

-- New ProfileStore:

function ProfileService.GetProfileStore(profile_store_index, profile_template) --> [ProfileStore]

	local profile_store_name
	local profile_store_scope = nil

	-- Parsing profile_store_index:
	if type(profile_store_index) == "string" then
		-- profile_store_index as string:
		profile_store_name = profile_store_index
	elseif type(profile_store_index) == "table" then
		-- profile_store_index as table:
		profile_store_name = profile_store_index.Name
		profile_store_scope = profile_store_index.Scope
	else
		error("[ProfileService]: Invalid or missing profile_store_index")
	end

	-- Type checking:
	if profile_store_name == nil or type(profile_store_name) ~= "string" then
		error("[ProfileService]: Missing or invalid \"Name\" parameter")
	elseif string.len(profile_store_name) == 0 then
		error("[ProfileService]: ProfileStore name cannot be an empty string")
	end

	if profile_store_scope ~= nil and (type(profile_store_scope) ~= "string" or string.len(profile_store_scope) == 0) then
		error("[ProfileService]: Invalid \"Scope\" parameter")
	end

	if type(profile_template) ~= "table" then
		error("[ProfileService]: Invalid profile_template")
	end

	local profile_store
	profile_store = {
		Mock = {
			LoadProfileAsync = function(_, profile_key, not_released_handler)
				return profile_store:LoadProfileAsync(profile_key, not_released_handler, UseMockTag)
			end,
			GlobalUpdateProfileAsync = function(_, profile_key, update_handler)
				return profile_store:GlobalUpdateProfileAsync(profile_key, update_handler, UseMockTag)
			end,
			ViewProfileAsync = function(_, profile_key, version)
				return profile_store:ViewProfileAsync(profile_key, version, UseMockTag)
			end,
			ProfileVersionQuery = function(_, profile_key, sort_direction, min_date, max_date)
				return profile_store:ProfileVersionQuery(profile_key, sort_direction, min_date, max_date, UseMockTag)
			end,
			WipeProfileAsync = function(_, profile_key)
				return profile_store:WipeProfileAsync(profile_key, UseMockTag)
			end
		},

		_profile_store_name = profile_store_name,
		_profile_store_scope = profile_store_scope,
		_profile_store_lookup = profile_store_name .. "\0" .. (profile_store_scope or ""),

		_profile_template = profile_template,
		_global_data_store = nil,
		_loaded_profiles = {},
		_profile_load_jobs = {},
		_mock_loaded_profiles = {},
		_mock_profile_load_jobs = {},
		_is_pending = false,
	}
	setmetatable(profile_store, ProfileStore)

	if IsLiveCheckActive == true then
		profile_store._is_pending = true
		task.spawn(function()
			WaitForLiveAccessCheck()
			if UseMockDataStore == false then
				profile_store._global_data_store = DataStoreService:GetDataStore(profile_store_name, profile_store_scope)
			end
			profile_store._is_pending = false
		end)
	else
		if UseMockDataStore == false then
			profile_store._global_data_store = DataStoreService:GetDataStore(profile_store_name, profile_store_scope)
		end
	end

	return profile_store
end

function ProfileService.IsLive() --> [bool] -- (CAN YIELD!!!)

	WaitForLiveAccessCheck()

	return UseMockDataStore == false

end

----- Initialize -----

if IsStudio == true then
	IsLiveCheckActive = true
	task.spawn(function()
		local status, message = pcall(function()
			-- This will error if current instance has no Studio API access:
			-- Using GetAsync instead of SetAsync to avoid "deleted datastore" errors
			DataStoreService:GetDataStore("____PS_ConnectivityCheck"):GetAsync("____PS_ConnectivityCheck")
		end)
		local no_internet_access = status == false and string.find(message, "ConnectFail", 1, true) ~= nil
		if no_internet_access == true then
			warn("[ProfileService]: No internet access - check your network connection")
		end
		if status == false and
			(string.find(message, "403", 1, true) ~= nil or -- Cannot write to DataStore from studio if API access is not enabled
				string.find(message, "must publish", 1, true) ~= nil or -- Game must be published to access live keys
				no_internet_access == true) then -- No internet access

			UseMockDataStore = true
			ProfileService._use_mock_data_store = true
			print("[ProfileService]: Roblox API services unavailable - data will not be saved")
		else
			print("[ProfileService]: Roblox API services available - data will be saved")
		end
		IsLiveCheckActive = false
	end)
end

----- Connections -----

-- Auto saving and issue queue managing:
RunService.Heartbeat:Connect(function()
	-- 1) Auto saving: --
	local auto_save_list_length = #AutoSaveList
	if auto_save_list_length > 0 then
		local auto_save_index_speed = SETTINGS.AutoSaveProfiles / auto_save_list_length
		local os_clock = os.clock()
		while os_clock - LastAutoSave > auto_save_index_speed do
			LastAutoSave = LastAutoSave + auto_save_index_speed
			local profile = AutoSaveList[AutoSaveIndex]
			if os_clock - profile._load_timestamp < SETTINGS.AutoSaveProfiles then
				-- This profile is freshly loaded - auto-saving immediately after loading will cause a warning in the log:
				profile = nil
				for _ = 1, auto_save_list_length - 1 do
					-- Move auto save index to the right:
					AutoSaveIndex = AutoSaveIndex + 1
					if AutoSaveIndex > auto_save_list_length then
						AutoSaveIndex = 1
					end
					profile = AutoSaveList[AutoSaveIndex]
					if os_clock - profile._load_timestamp >= SETTINGS.AutoSaveProfiles then
						break
					else
						profile = nil
					end
				end
			end
			-- Move auto save index to the right:
			AutoSaveIndex = AutoSaveIndex + 1
			if AutoSaveIndex > auto_save_list_length then
				AutoSaveIndex = 1
			end
			-- Perform save call:
			if profile ~= nil then
				task.spawn(SaveProfileAsync, profile) -- Auto save profile in new thread
			end
		end
	end
	-- 2) Issue queue: --
	-- Critical state handling:
	if ProfileService.CriticalState == false then
		if #IssueQueue >= SETTINGS.IssueCountForCriticalState then
			ProfileService.CriticalState = true
			ProfileService.CriticalStateSignal:Fire(true)
			CriticalStateStart = os.clock()
			warn("[ProfileService]: Entered critical state")
		end
	else
		if #IssueQueue >= SETTINGS.IssueCountForCriticalState then
			CriticalStateStart = os.clock()
		elseif os.clock() - CriticalStateStart > SETTINGS.CriticalStateLast then
			ProfileService.CriticalState = false
			ProfileService.CriticalStateSignal:Fire(false)
			warn("[ProfileService]: Critical state ended")
		end
	end
	-- Issue queue:
	while true do
		local issue_time = IssueQueue[1]
		if issue_time == nil then
			break
		elseif os.clock() - issue_time > SETTINGS.IssueLast then
			table.remove(IssueQueue, 1)
		else
			break
		end
	end
end)

-- Release all loaded profiles when the server is shutting down:
task.spawn(function()
	WaitForLiveAccessCheck()
	Madwork.ConnectToOnClose(
		function()
			ProfileService.ServiceLocked = true
			-- 1) Release all active profiles: --
			-- Clone AutoSaveList to a new table because AutoSaveList changes when profiles are released:
			local on_close_save_job_count = 0
			local active_profiles = {}
			for index, profile in ipairs(AutoSaveList) do
				active_profiles[index] = profile
			end
			-- Release the profiles; Releasing profiles can trigger listeners that release other profiles, so check active state:
			for _, profile in ipairs(active_profiles) do
				if profile:IsActive() == true then
					on_close_save_job_count = on_close_save_job_count + 1
					task.spawn(function() -- Save profile on new thread
						SaveProfileAsync(profile, true)
						on_close_save_job_count = on_close_save_job_count - 1
					end)
				end
			end
			-- 2) Yield until all active profile jobs are finished: --
			while on_close_save_job_count > 0 or ActiveProfileLoadJobs > 0 or ActiveProfileSaveJobs > 0 do
				task.wait()
			end
			return -- We're done!
		end,
		UseMockDataStore == false -- Always run this OnClose task if using Roblox API services
	)
end)

return ProfileService


================================================================================
FILE: src\server\ServerMain.server.luau
================================================================================

--[[
	ServerMain.server.luau
	
	The central bootstrapper for the server-side architecture.
	Ensures deterministic load order and initializes systems with Dependency Injection.
	
	Load Order:
	1. Core Services (Data, Inventory)
	2. Logic Systems (Brainrot, ItemProduction)
	3. Feature Systems (Shop, etc.)
]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")

-- Ensure Remote Folders Exist
local RemoteEvents = ReplicatedStorage:FindFirstChild("RemoteEvents") or Instance.new("Folder")
RemoteEvents.Name = "RemoteEvents"
RemoteEvents.Parent = ReplicatedStorage

local RemoteFunctions = ReplicatedStorage:FindFirstChild("RemoteFunctions") or Instance.new("Folder")
RemoteFunctions.Name = "RemoteFunctions"
RemoteFunctions.Parent = ReplicatedStorage

local StockMarketFolder = ReplicatedStorage:FindFirstChild("StockMarket") or Instance.new("Folder")
StockMarketFolder.Name = "StockMarket"
StockMarketFolder.Parent = ReplicatedStorage

-- Service Container (Dependency Injection)
local Services = {}

--[[
	Helper to safe require and register a module.
]]
local function registerService(name, path)
	local success, module = pcall(require, path)
	if not success then
		warn(string.format("âŒ Failed to require %s: %s", name, module))
		return nil
	end
	
	print(string.format("ðŸ“¦ Loaded service: %s", name))
	Services[name] = module
	return module
end

--[[
	Helper to initialize a loaded service.
]]
local function initService(name)
	local module = Services[name]
	if module and type(module.Init) == "function" then
		print(string.format("ðŸš€ Initializing %s...", name))
		task.spawn(function()
			local success, err = pcall(module.Init, Services)
			if not success then
				warn(string.format("âŒ Error initializing %s: %s", name, err))
			else
				print(string.format("âœ“ %s Initialized", name))
			end
		end)
	end
end

--------------------------------------------------------------------------------
-- LOADING SEQUENCE
--------------------------------------------------------------------------------

print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
print("â•‘           SERVER BOOTSTRAP START          â•‘")
print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")

-- 1. Load All Modules (DataService and PlayerLifecycleManager first to avoid circular deps)
registerService("DataService", script.Parent.DataService)
registerService("PlayerLifecycleManager", script.Parent.PlayerLifecycleManager)
registerService("DataManager", script.Parent.DataManager)
registerService("InventoryManager", script.Parent.InventoryManager)
registerService("MapSystem", script.Parent.MapSystem)
registerService("BrainrotManager", script.Parent.BrainrotManager)
registerService("ItemProductionManager", script.Parent.ItemProductionManager)
registerService("GridManager", script.Parent.GridManager)
registerService("ItemStorageManager", script.Parent.ItemStorageManager)
registerService("ShopManager", script.Parent.ShopManager)
registerService("TransportManager", script.Parent.TransportManager)
registerService("CartManager", script.Parent.CartManager)
registerService("PrestigeManager", script.Parent.PrestigeManager)
registerService("ArtifactManager", script.Parent.ArtifactManager)
registerService("StockMarketManager", script.Parent.StockMarketManager)
registerService("StockMarketBillboards", script.Parent.StockMarketBillboards)
registerService("MarketManager", script.Parent.MarketManager)
registerService("StorageBoxManager", script.Parent.StorageBoxManager)
registerService("StorageUpgradeManager", script.Parent.StorageUpgradeManager)
registerService("ConvenienceUpgradesManager", script.Parent.ConvenienceUpgradesManager)
registerService("BuildModeManager", script.Parent.BuildModeManager)
registerService("IslandShopManager", script.Parent.IslandShopManager)
registerService("MewingManager", script.Parent.MewingManager)
registerService("UnitInteractionManager", script.Parent.UnitInteractionManager)
registerService("AdminService", script.Parent.AdminService)

-- 2. Initialize All Systems (In Order)

-- Priority 0: Core Infrastructure (must be first)
initService("DataService")
initService("PlayerLifecycleManager")

-- Priority 1: Core Data & Map
initService("DataManager")
initService("MapSystem")
initService("InventoryManager")

-- Priority 2: Core Logic
initService("BrainrotManager")
initService("ItemProductionManager")
initService("GridManager")
initService("ItemStorageManager")

-- Priority 3: Features
initService("ShopManager")
initService("TransportManager")
initService("CartManager")
initService("PrestigeManager")
initService("ArtifactManager")
initService("StockMarketManager")
initService("StockMarketBillboards")
initService("MarketManager")
initService("StorageBoxManager")
initService("StorageUpgradeManager")
initService("ConvenienceUpgradesManager")
initService("BuildModeManager")
initService("IslandShopManager")
initService("MewingManager")
initService("UnitInteractionManager")
initService("AdminService")

print("---------------------------------------------")
print("âœ“ Server Bootstrap Complete")
print("---------------------------------------------")


================================================================================
FILE: src\server\ShopManager.luau
================================================================================

--[[
	ShopManager Server Module
	
	Handles all purchase logic for the shop system.
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Lazy Configs
local ShopConfig
local RarityConfig

local function getConfigs()
	if not ShopConfig then
		local Shared = ReplicatedStorage:WaitForChild("Shared")
		ShopConfig = require(Shared:WaitForChild("ShopConfig"))
		RarityConfig = require(Shared:WaitForChild("RarityConfig"))
	end
	return ShopConfig, RarityConfig
end

-- Remotes
local RemoteEvents = ReplicatedStorage:FindFirstChild("RemoteEvents") or Instance.new("Folder")
RemoteEvents.Name = "RemoteEvents"
RemoteEvents.Parent = ReplicatedStorage

local BuyUnitRemote = RemoteEvents:FindFirstChild("BuyUnit") or Instance.new("RemoteFunction")
BuyUnitRemote.Name = "BuyUnit"
BuyUnitRemote.Parent = RemoteEvents

local OwnershipChangedEvent = RemoteEvents:FindFirstChild("OwnershipChanged") or Instance.new("RemoteEvent")
OwnershipChangedEvent.Name = "OwnershipChanged"
OwnershipChangedEvent.Parent = RemoteEvents

local UnlockProgressChangedEvent = RemoteEvents:FindFirstChild("UnlockProgressChanged") or Instance.new("RemoteEvent")
UnlockProgressChangedEvent.Name = "UnlockProgressChanged"
UnlockProgressChangedEvent.Parent = RemoteEvents

local GetOwnershipRemote = RemoteEvents:FindFirstChild("GetOwnership") or Instance.new("RemoteFunction")
GetOwnershipRemote.Name = "GetOwnership"
GetOwnershipRemote.Parent = RemoteEvents

-- Module
local ShopManager = {}
local Services = {}

-- State
local PlayerUnlockProgress = {} 

--------------------------------------------------------------------------------
-- HELPER FUNCTIONS
--------------------------------------------------------------------------------

local function initializePlayerData(player)
	PlayerUnlockProgress[player] = ShopConfig.INITIAL_UNLOCKED
	
	-- Visual folder (Legacy)
	local ownedFolder = Instance.new("Folder")
	ownedFolder.Name = "OwnedUnits"
	ownedFolder.Parent = player
	
	for unitName, _ in pairs(ShopConfig.Units) do
		local c = Instance.new("IntValue")
		c.Name = unitName
		c.Value = 0
		c.Parent = ownedFolder
	end
	
	local unlockValue = Instance.new("IntValue")
	unlockValue.Name = "UnlockProgress"
	unlockValue.Value = ShopConfig.INITIAL_UNLOCKED
	unlockValue.Parent = player
end

local function cleanupPlayerData(player)
	PlayerUnlockProgress[player] = nil
end

local function getMoney(player)
	local ls = player:FindFirstChild("leaderstats")
	return ls and ls:FindFirstChild("Money") and ls.Money.Value or 0
end

local function deductMoney(player, amount)
	local ls = player:FindFirstChild("leaderstats")
	local m = ls and ls:FindFirstChild("Money")
	if m and m.Value >= amount then
		m.Value -= amount
		return true
	end
	return false
end

local function updateLegacyOwnedCount(player, unitName, count)
	local f = player:FindFirstChild("OwnedUnits")
	if f then
		local c = f:FindFirstChild(unitName)
		if c then c.Value = count end
	end
end

--------------------------------------------------------------------------------
-- PUBLIC API & CORE LOGIC
--------------------------------------------------------------------------------

function ShopManager.Init(services)
	print("   ShopManager (Module) - Initializing")
	Services = services or {}
	
	Players.PlayerAdded:Connect(initializePlayerData)
	Players.PlayerRemoving:Connect(cleanupPlayerData)
	
	-- Preload Configs
	getConfigs()
	
	for _, p in Players:GetPlayers() do initializePlayerData(p) end

	BuyUnitRemote.OnServerInvoke = ShopManager.HandleBuyUnit
	GetOwnershipRemote.OnServerInvoke = ShopManager.GetPlayerOwnership
	
	print("âœ“ ShopManager Initialized")
end

function ShopManager.GetOwnedCount(player, unitName)
	local InvMgr = rawget(Services, "InventoryManager")
	if InvMgr then return InvMgr.GetUnitLevel(player, unitName) end
	return 0
end

function ShopManager.GetUnlockProgress(player)
	return PlayerUnlockProgress[player] or ShopConfig.INITIAL_UNLOCKED
end

function ShopManager.HandleBuyUnit(player, unitName)
	-- Distance Check
	local mainIsland = workspace:FindFirstChild("MainIsland")
	local shopVendor = mainIsland and mainIsland:FindFirstChild("ShopVendor")
	if shopVendor and player.Character then
		local hrp = player.Character:FindFirstChild("HumanoidRootPart")
		if hrp and (hrp.Position - shopVendor.Position).Magnitude > 20 then
			return false, "Too far from shop!"
		end
	end
	
	if not ShopConfig.GetConfig(unitName) then return false, "Unknown Unit" end
	
	local progress = ShopManager.GetUnlockProgress(player)
	if not ShopConfig.IsUnitUnlocked(unitName, progress) then return false, "Locked!" end
	
	local owned = ShopManager.GetOwnedCount(player, unitName)
	local price = ShopConfig.CalculatePrice(unitName, owned)
	
	if getMoney(player) < price then return false, "Not enough cash" end
	
	-- Check item costs BEFORE deducting cash (avoid partial transactions)
	local itemCost = ShopConfig.GetItemCost(unitName)
	local ISM = rawget(Services, "ItemStorageManager")
	if itemCost then
		if not ISM then return false, "Storage System Offline" end
		local storageItems = ISM.GetStorageContents(player)
		local backpackItems = ISM.GetBackpackContents(player)
		for itemId, needed in pairs(itemCost) do
			local available = (storageItems[itemId] or 0) + (backpackItems[itemId] or 0)
			if available < needed then
				return false, "Need " .. needed .. "x " .. itemId .. " (have " .. available .. ")"
			end
		end
	end
	
	if not deductMoney(player, price) then return false, "Transaction failed" end
	
	-- Deduct items (burn them â€” NOT reported as sales to market)
	if itemCost and ISM then
		for itemId, needed in pairs(itemCost) do
			local remaining = needed
			-- Take from storage first, then backpack
			local fromStorage = ISM.RemoveFromStorage(player, itemId, remaining)
			remaining -= fromStorage
			if remaining > 0 then
				ISM.RemoveFromBackpack(player, itemId, remaining)
			end
		end
	end
	
	local InvMgr = rawget(Services, "InventoryManager")
	if not InvMgr then return false, "Inventory System Offline" end
	
	local rarity = RarityConfig.RollRarity()
	local newData = InvMgr.AddUnit(player, unitName, rarity)
	local newLevel = newData.level
	
	updateLegacyOwnedCount(player, unitName, newLevel)
	
	-- Update client
	local newPrice = ShopConfig.CalculatePrice(unitName, newLevel)
	OwnershipChangedEvent:FireClient(player, unitName, newLevel, newPrice)
	
	-- Increment Unlock
	local total = ShopConfig.GetTotalUnits()
	if progress < total then
		PlayerUnlockProgress[player] = progress + 1
		local uv = player:FindFirstChild("UnlockProgress")
		if uv then uv.Value = PlayerUnlockProgress[player] end
		UnlockProgressChangedEvent:FireClient(player, PlayerUnlockProgress[player])
	end
	
	return true, "Purchased!"
end

function ShopManager.GetPlayerOwnership(player)
	local data = { units = {}, unlockProgress = ShopManager.GetUnlockProgress(player) }
	for unitName, _ in pairs(ShopConfig.Units) do
		local count = ShopManager.GetOwnedCount(player, unitName)
		data.units[unitName] = { 
			count = count, 
			price = ShopConfig.CalculatePrice(unitName, count) 
		}
	end
	return data
end

function ShopManager.SetPlayerData(player, ownedUnits, unlockProgress)
	PlayerUnlockProgress[player] = unlockProgress
	
	local uv = player:FindFirstChild("UnlockProgress")
	if uv then uv.Value = unlockProgress end
	
	-- Restore legacy folder visuals
	local f = player:FindFirstChild("OwnedUnits")
	if f then
		for name, count in pairs(ownedUnits) do
			local c = f:FindFirstChild(name)
			if c then c.Value = count end
		end
	end
	
	UnlockProgressChangedEvent:FireClient(player, unlockProgress)
	
	-- Batch notify ownership
	for unitName, count in pairs(ownedUnits) do
		local price = ShopConfig.CalculatePrice(unitName, count)
		OwnershipChangedEvent:FireClient(player, unitName, count, price)
	end
end

-- Compatibility Export
ShopManager.ResetPlayerData = function(player)
	PlayerUnlockProgress[player] = ShopConfig.INITIAL_UNLOCKED
	local uv = player:FindFirstChild("UnlockProgress")
	if uv then uv.Value = ShopConfig.INITIAL_UNLOCKED end
	local f = player:FindFirstChild("OwnedUnits")
	if f then
		for _, v in pairs(f:GetChildren()) do v.Value = 0 end
	end
	UnlockProgressChangedEvent:FireClient(player, ShopConfig.INITIAL_UNLOCKED)
end

return ShopManager


================================================================================
FILE: src\server\StockMarketBillboards.luau
================================================================================

--[[
	StockMarketBillboards Server Module
	
	Creates giant floating billboards above the Main Island.
]]

local Workspace = game:GetService("Workspace")

local BILLBOARD_CONFIG = {
	SIZE = Vector3.new(80, 60, 2),
	HEIGHT_OFFSET = 120,
	DISTANCE_FROM_CENTER = 100,
	FRAME_COLOR = Color3.fromRGB(30, 30, 40),
	SCREEN_COLOR = Color3.fromRGB(15, 15, 25),
}

local BILLBOARD_POSITIONS = {
	{ name = "North", offset = Vector3.new(0, 0, -BILLBOARD_CONFIG.DISTANCE_FROM_CENTER), rotation = 0 },
	{ name = "South", offset = Vector3.new(0, 0, BILLBOARD_CONFIG.DISTANCE_FROM_CENTER), rotation = 180 },
	{ name = "East", offset = Vector3.new(BILLBOARD_CONFIG.DISTANCE_FROM_CENTER, 0, 0), rotation = -90 },
	{ name = "West", offset = Vector3.new(-BILLBOARD_CONFIG.DISTANCE_FROM_CENTER, 0, 0), rotation = 90 },
}

local StockMarketBillboards = {}
local Services = {}

--------------------------------------------------------------------------------
-- LOGIC
--------------------------------------------------------------------------------

local function createBillboard(posData, center)
	local model = Instance.new("Model")
	model.Name = "StockMarketBillboard_" .. posData.name
	
	local screen = Instance.new("Part")
	screen.Name = "Screen"
	screen.Size = BILLBOARD_CONFIG.SIZE
	screen.Anchored = true
	screen.Material = Enum.Material.Neon
	screen.Color = BILLBOARD_CONFIG.SCREEN_COLOR
	screen.CastShadow = false
	
	local pos = center + posData.offset + Vector3.new(0, BILLBOARD_CONFIG.HEIGHT_OFFSET, 0)
	screen.CFrame = CFrame.new(pos) * CFrame.Angles(0, math.rad(posData.rotation), 0)
	screen.Parent = model
	
	local ft = 2
	local fc = BILLBOARD_CONFIG.FRAME_COLOR
	
	local function makeFrame(n, s, cf)
		local p = Instance.new("Part"); p.Name=n; p.Size=s; p.Anchored=true; p.Color=fc; p.CFrame=cf; p.Parent=model
	end
	makeFrame("Top", Vector3.new(BILLBOARD_CONFIG.SIZE.X+ft*2, ft, BILLBOARD_CONFIG.SIZE.Z), screen.CFrame * CFrame.new(0, BILLBOARD_CONFIG.SIZE.Y/2+ft/2, 0))
	makeFrame("Bottom", Vector3.new(BILLBOARD_CONFIG.SIZE.X+ft*2, ft, BILLBOARD_CONFIG.SIZE.Z), screen.CFrame * CFrame.new(0, -BILLBOARD_CONFIG.SIZE.Y/2-ft/2, 0))
	makeFrame("Left", Vector3.new(ft, BILLBOARD_CONFIG.SIZE.Y, BILLBOARD_CONFIG.SIZE.Z), screen.CFrame * CFrame.new(-BILLBOARD_CONFIG.SIZE.X/2-ft/2, 0, 0))
	makeFrame("Right", Vector3.new(ft, BILLBOARD_CONFIG.SIZE.Y, BILLBOARD_CONFIG.SIZE.Z), screen.CFrame * CFrame.new(BILLBOARD_CONFIG.SIZE.X/2+ft/2, 0, 0))
	
	local sg = Instance.new("SurfaceGui")
	sg.Name = "StockMarketDisplay"
	sg.Face = Enum.NormalId.Front
	sg.CanvasSize = Vector2.new(1600, 1200)
	sg.Parent = screen
	
	local c = Instance.new("Frame"); c.Name="Container"; c.Size=UDim2.new(1,0,1,0); c.BackgroundColor3=BILLBOARD_CONFIG.SCREEN_COLOR; c.Parent=sg
	
	local t = Instance.new("TextLabel"); t.Size=UDim2.new(1,0,0.12,0); t.BackgroundTransparency=1; t.Text="ðŸ“ˆ BRAINROT STOCKS"; t.TextColor3=Color3.new(1,1,1); t.TextScaled=true; t.Parent=c
	
	local rd = Instance.new("TextLabel"); rd.Size=UDim2.new(0.35,0,0.12,0); rd.Position=UDim2.new(0.05,0,0.12,0); rd.BackgroundTransparency=1; rd.Text="BEST: 1.00x"; rd.TextColor3=Color3.fromRGB(100,255,100); rd.TextScaled=true; rd.TextXAlignment=Enum.TextXAlignment.Left; rd.Parent=c
	
	local rn = Instance.new("TextLabel"); rn.Size=UDim2.new(0.5,0,0.08,0); rn.Position=UDim2.new(0.45,0,0.16,0); rn.BackgroundTransparency=1; rn.Text="NORMAL"; rn.TextColor3=Color3.fromRGB(180,180,180); rn.TextScaled=true; rn.TextXAlignment=Enum.TextXAlignment.Right; rn.Parent=c
	
	local gc = Instance.new("Frame"); gc.Name="GraphContainer"; gc.Size=UDim2.new(0.9,0,0.6,0); gc.Position=UDim2.new(0.05,0,0.3,0); gc.BackgroundColor3=Color3.fromRGB(25,25,35); gc.Parent=c
	
	local bl = Instance.new("Frame"); bl.Size=UDim2.new(1,0,0,2); bl.Position=UDim2.new(0,0,0.4,0); bl.BackgroundColor3=Color3.fromRGB(100,100,100); bl.Parent=gc
	
	local gl = Instance.new("Frame"); gl.Name="GraphLines"; gl.Size=UDim2.new(1,0,1,0); gl.BackgroundTransparency=1; gl.Parent=gc
	
	local td = Instance.new("TextLabel"); td.Size=UDim2.new(1,0,0.08,0); td.Position=UDim2.new(0,0,0.92,0); td.BackgroundTransparency=1; td.Text="Next update in: 10s"; td.TextColor3=Color3.fromRGB(150,150,150); td.TextScaled=true; td.Parent=c
	
	model.Parent = Workspace
	return model
end

--------------------------------------------------------------------------------
-- API
--------------------------------------------------------------------------------

function StockMarketBillboards.Init(services)
	print("   StockMarketBillboards (Module) - Initializing")
	Services = services or {}
	
	task.spawn(function()
		local mainIsland = Workspace:WaitForChild("MainIsland", 10)
		local center = Vector3.new(0, 30, 0)
		
		if mainIsland then
			local ip = mainIsland:FindFirstChild("Island") or mainIsland:FindFirstChildWhichIsA("BasePart")
			if ip then center = Vector3.new(ip.Position.X, 30, ip.Position.Z) end
		end
		
		local folder = Instance.new("Folder")
		folder.Name = "StockMarketBillboards"
		folder.Parent = Workspace
		
		for _, pd in ipairs(BILLBOARD_POSITIONS) do
			local bb = createBillboard(pd, center)
			bb.Parent = folder
		end
	end)
	
	print("âœ“ StockMarketBillboards Initialized")
end

return StockMarketBillboards


================================================================================
FILE: src\server\StockMarketManager.luau
================================================================================

--[[
	StockMarketManager Server Module
	
	â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	              GLOBAL SHARDED MARKET WITH WELFARE
	â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	PURPOSE:
	  Replaces the old random-local sector pricing with a player-driven global
	  market. Prices are derived from REAL cross-server sales volume stored in
	  MemoryStoreService. All servers read a sharded volume dataset and compute
	  synchronized rates.
	
	ARCHITECTURE:
	  â€¢ READ LOOP  (every 5s)  â€” Read 5 MemoryStore shards, sum volumes, compute
	    MarketRate + BailoutRate per sector, replicate via attributes.
	  â€¢ WRITE LOOP (every 10s) â€” Flush this server's buffered sales volume into
	    one random shard to avoid key-lock contention.
	  â€¢ FALLBACK â€” If MemoryStore fails (Studio / offline), gracefully degrade to
	    the old random local pricing so gameplay isn't blocked.
	
	â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local MemoryStoreService = game:GetService("MemoryStoreService")

--------------------------------------------------------------------------------
-- CONFIGURATION
--------------------------------------------------------------------------------

local CONFIG = {
	-- Timing
	READ_INTERVAL = 5,       -- seconds between MemoryStore reads
	WRITE_INTERVAL = 10,     -- seconds between buffer flushes
	LOCAL_UPDATE_INTERVAL = 20, -- fallback local update rate (Studio mode)
	
	-- Sharding
	NUM_SHARDS = 5,
	SHARD_EXPIRATION = 300,  -- MemoryStore key TTL (5 minutes)
	
	-- Pricing
	MIN_RATE = 0.3,
	MAX_RATE = 3.0,
	STARTING_RATE = 1.0,
	BAILOUT_FLOOR = 0.8,     -- Minimum rate for welfare-protected players
	IMPACT_FACTOR = 0.00005, -- How much each sold unit depresses price
	RECOVERY_RATE = 0.02,    -- Natural price recovery per read cycle
	
	-- Synthetic Volatility (keeps market alive at low player count)
	JITTER_SPEED = 0.1,      -- Perlin noise time multiplier (lower = slower waves)
	JITTER_AMPLITUDE = 0.05, -- Â±5% micro-fluctuation
	TREND_PERIOD = 600,      -- seconds per synthetic trend cycle (10 minutes)
	HYPE_CHANCE = 0.20,      -- 20% chance of a bull run per cycle
	HYPE_MULTIPLIER = 1.4,   -- Bull run rate multiplier
	TREND_MIN = 0.9,         -- Normal drift minimum
	TREND_MAX = 1.1,         -- Normal drift maximum
	DEAD_MARKET_THRESHOLD = 1000, -- Volume below this triggers ghost trading
	
	-- Fallback (old random pricing for Studio)
	BASE_VOLATILITY = 0.25,
	SPIKE_CHANCE = 0.10,
	SPIKE_MULTIPLIER = 2.5,
	MEAN_REVERSION = 0.05,
	
	-- History
	MAX_HISTORY = 60,
}

local SECTOR_VOLATILITY = {
	Food = 0.20, Animals = 0.25, Entertainment = 0.30,
	Mystic = 0.40, Tech = 0.35, Action = 0.45,
}
local SECTORS = {"Food", "Animals", "Entertainment", "Mystic", "Tech", "Action"}
local SECTOR_COLORS = {
	Food = {227, 119, 194}, Animals = {44, 160, 44}, Entertainment = {255, 127, 14},
	Mystic = {148, 103, 189}, Tech = {31, 119, 180}, Action = {214, 39, 40},
}

--------------------------------------------------------------------------------
-- STATE
--------------------------------------------------------------------------------

local StockMarketManager = {}
local Services = {}

local sectorRates = {}        -- { [sector] = currentMarketRate }
local bailoutRates = {}       -- { [sector] = bailoutRate }
local sectorHistories = {}
local stockMarketFolder = nil

-- MemoryStore state
local GlobalMarketMap = nil       -- MemoryStoreService sorted map
local ServerSalesBuffer = {}      -- { [sector] = volumeToFlush }
local useGlobalPricing = false    -- true once MemoryStore is confirmed working
local nextReadTime = 0
local nextWriteTime = 0
local nextLocalUpdate = 0

--------------------------------------------------------------------------------
-- HELPERS
--------------------------------------------------------------------------------

local function serializeHistory(history)
	local parts = {}
	for _, rate in ipairs(history) do table.insert(parts, string.format("%.3f", rate)) end
	return table.concat(parts, ",")
end

local function serializeSectorRates()
	local t = {}
	for c, r in pairs(sectorRates) do t[c] = math.floor(r * 1000) / 1000 end
	return HttpService:JSONEncode(t)
end

local function serializeSectorHistories()
	local t = {}
	for c, h in pairs(sectorHistories) do t[c] = serializeHistory(h) end
	return HttpService:JSONEncode(t)
end

local function getGlobalRateName()
	local sum = 0; for _, r in pairs(sectorRates) do sum += r end
	local avg = sum / #SECTORS
	if avg >= 2.5 then return "HYPER INFLATION"
	elseif avg >= 1.5 then return "STONKS"
	elseif avg <= 0.7 then return "CRASH"
	else return "NORMAL" end
end

-- Fallback random pricing (same as old logic, used in Studio)
local function calculateLocalRate(sector)
	local current = sectorRates[sector]
	local vol = SECTOR_VOLATILITY[sector] or CONFIG.BASE_VOLATILITY
	local base = (math.random() - 0.5) * 2 * vol
	if math.random() < CONFIG.SPIKE_CHANCE then base *= CONFIG.SPIKE_MULTIPLIER end
	local rev = (CONFIG.STARTING_RATE - current) * CONFIG.MEAN_REVERSION
	return math.clamp(current + base + rev, CONFIG.MIN_RATE, CONFIG.MAX_RATE)
end

--------------------------------------------------------------------------------
-- SYNTHETIC VOLATILITY
--------------------------------------------------------------------------------

-- Generate a unique numeric seed from a sector name
local function getSectorSeed(sectorName: string): number
	local seed = 0
	for i = 1, #sectorName do
		seed = seed + string.byte(sectorName, i) * i
	end
	return seed
end

--[[
	Perlin Noise Jitter: smooth Â±5% micro-fluctuations.
	Uses math.noise for natural-looking waves instead of jagged random spikes.
	Each sector has a unique seed so they don't move in lockstep.
]]
local function getJitter(sectorName: string): number
	local seed = getSectorSeed(sectorName)
	local timeOffset = os.clock() * CONFIG.JITTER_SPEED
	local noise = math.noise(timeOffset, seed * 0.1, 0) -- Returns -0.5 to 0.5
	return 1 + (noise * CONFIG.JITTER_AMPLITUDE)
end

--[[
	Synthetic Trend ("Market Maker Bot"): deterministic wave shared by all servers.
	Every TREND_PERIOD seconds, each sector gets a new trend direction.
	20% chance of a BULL RUN (1.4x), otherwise normal drift (0.9-1.1x).
	Deterministic via timeKey + seed so all servers agree.
]]
local function getSyntheticTrend(sectorName: string): number
	local timeKey = math.floor(os.time() / CONFIG.TREND_PERIOD)
	local seed = getSectorSeed(sectorName)
	local rng = Random.new(timeKey + seed)
	
	if rng:NextNumber() > (1 - CONFIG.HYPE_CHANCE) then
		return CONFIG.HYPE_MULTIPLIER -- BULL RUN!
	else
		return rng:NextNumber(CONFIG.TREND_MIN, CONFIG.TREND_MAX) -- Normal drift
	end
end

--------------------------------------------------------------------------------
-- MEMORYSTORE: SHARDED READER
--------------------------------------------------------------------------------

local function readGlobalVolumes(): {[string]: number}
	local totalVolumes: {[string]: number} = {}
	for _, sector in ipairs(SECTORS) do totalVolumes[sector] = 0 end
	
	for shardId = 1, CONFIG.NUM_SHARDS do
		local key = "GlobalVol_Shard_" .. shardId
		local ok, data = pcall(function()
			return GlobalMarketMap:GetAsync(key)
		end)
		if ok and data and type(data) == "table" then
			for sector, vol in pairs(data) do
				if totalVolumes[sector] then
					totalVolumes[sector] += (tonumber(vol) or 0)
				end
			end
		end
	end
	
	return totalVolumes
end

local function computeGlobalRates(totalVolumes: {[string]: number})
	for _, sector in ipairs(SECTORS) do
		local vol = totalVolumes[sector] or 0
		
		-- Base rate from real player volume
		local rawRate = CONFIG.STARTING_RATE * (1 - (vol * CONFIG.IMPACT_FACTOR))
		rawRate += CONFIG.RECOVERY_RATE
		
		-- SYNTHETIC VOLATILITY: Apply Market Maker when volume is low
		if vol < CONFIG.DEAD_MARKET_THRESHOLD then
			local trend = getSyntheticTrend(sector)
			rawRate *= trend
		end
		
		-- JITTER: Always-on Perlin noise micro-fluctuation
		local jitter = getJitter(sector)
		rawRate *= jitter
		
		-- Final clamp
		rawRate = math.clamp(rawRate, CONFIG.MIN_RATE, CONFIG.MAX_RATE)
		
		sectorRates[sector] = rawRate
		bailoutRates[sector] = math.max(rawRate, CONFIG.BAILOUT_FLOOR)
		
		-- Record history
		table.insert(sectorHistories[sector], rawRate)
		if #sectorHistories[sector] > CONFIG.MAX_HISTORY then
			table.remove(sectorHistories[sector], 1)
		end
	end
end

local function performGlobalRead()
	local ok, vol = pcall(readGlobalVolumes)
	if ok and vol then
		computeGlobalRates(vol)
		return true
	else
		warn("StockMarketManager: MemoryStore read failed:", vol)
		return false
	end
end

--------------------------------------------------------------------------------
-- MEMORYSTORE: SHARDED WRITER
--------------------------------------------------------------------------------

local function flushSalesBuffer()
	-- Snapshot and clear buffer atomically
	local snapshot = ServerSalesBuffer
	ServerSalesBuffer = {}
	
	-- Check if there's anything to write
	local hasData = false
	for _, v in pairs(snapshot) do
		if v > 0 then hasData = true; break end
	end
	if not hasData then return end
	
	-- Pick a random shard to minimize key contention
	local shardId = math.random(1, CONFIG.NUM_SHARDS)
	local key = "GlobalVol_Shard_" .. shardId
	
	local ok, err = pcall(function()
		GlobalMarketMap:UpdateAsync(key, function(old)
			old = old or {}
			for sector, amount in pairs(snapshot) do
				old[sector] = (old[sector] or 0) + amount
			end
			return old
		end, CONFIG.SHARD_EXPIRATION)
	end)
	
	if ok then
		local totalFlushed = 0
		for _, v in pairs(snapshot) do totalFlushed += v end
		if totalFlushed > 0 then
			print("StockMarketManager: Flushed " .. totalFlushed .. " volume to shard " .. shardId)
		end
	else
		-- Restore buffer on failure (don't lose data)
		for sector, amount in pairs(snapshot) do
			ServerSalesBuffer[sector] = (ServerSalesBuffer[sector] or 0) + amount
		end
		warn("StockMarketManager: MemoryStore write failed (shard " .. shardId .. "):", err)
	end
end

--------------------------------------------------------------------------------
-- ATTRIBUTE REPLICATION
--------------------------------------------------------------------------------

local function replicateToClients()
	local sum = 0; for _, r in pairs(sectorRates) do sum += r end
	local avgRate = sum / #SECTORS
	
	stockMarketFolder:SetAttribute("SectorRates", serializeSectorRates())
	stockMarketFolder:SetAttribute("SectorHistories", serializeSectorHistories())
	stockMarketFolder:SetAttribute("Sectors", HttpService:JSONEncode(SECTORS))
	stockMarketFolder:SetAttribute("SectorColors", HttpService:JSONEncode(SECTOR_COLORS))
	
	-- Legacy compat
	stockMarketFolder:SetAttribute("CurrentRate", avgRate)
	stockMarketFolder:SetAttribute("RateName", getGlobalRateName())
	stockMarketFolder:SetAttribute("RateHistory", serializeHistory(sectorHistories.Food))
	stockMarketFolder:SetAttribute("LastUpdate", os.time())
	stockMarketFolder:SetAttribute("UpdateInterval", 
		useGlobalPricing and CONFIG.READ_INTERVAL or CONFIG.LOCAL_UPDATE_INTERVAL)
	
	-- NEW: Per-sector bailout rates for welfare check
	local bailoutJson = {}
	for sector, rate in pairs(bailoutRates) do
		bailoutJson[sector] = math.floor(rate * 1000) / 1000
	end
	stockMarketFolder:SetAttribute("BailoutRates", HttpService:JSONEncode(bailoutJson))
	
	-- Flag for clients to know which pricing model is active
	stockMarketFolder:SetAttribute("GlobalPricingActive", useGlobalPricing)
end

-- Fallback: old-style random local update (with jitter for liveliness)
local function updateMarketLocal()
	for _, cat in ipairs(SECTORS) do
		local nr = calculateLocalRate(cat)
		-- Apply jitter even in fallback mode for smooth wiggling
		nr *= getJitter(cat)
		nr = math.clamp(nr, CONFIG.MIN_RATE, CONFIG.MAX_RATE)
		sectorRates[cat] = nr
		bailoutRates[cat] = math.max(nr, CONFIG.BAILOUT_FLOOR)
		table.insert(sectorHistories[cat], nr)
		if #sectorHistories[cat] > CONFIG.MAX_HISTORY then
			table.remove(sectorHistories[cat], 1)
		end
	end
	replicateToClients()
end

--------------------------------------------------------------------------------
-- PUBLIC API
--------------------------------------------------------------------------------

function StockMarketManager.Init(services)
	print("   StockMarketManager (Module) - Initializing")
	Services = services or {}
	
	-- Create or find the ReplicatedStorage folder for client access
	stockMarketFolder = ReplicatedStorage:FindFirstChild("StockMarket") or Instance.new("Folder")
	stockMarketFolder.Name = "StockMarket"
	stockMarketFolder.Parent = ReplicatedStorage
	
	-- Initialize all sector rates
	for _, cat in ipairs(SECTORS) do
		sectorRates[cat] = CONFIG.STARTING_RATE
		bailoutRates[cat] = CONFIG.STARTING_RATE
		sectorHistories[cat] = {}
		for i = 1, CONFIG.MAX_HISTORY do
			table.insert(sectorHistories[cat], CONFIG.STARTING_RATE)
		end
		ServerSalesBuffer[cat] = 0
	end
	
	-- Static attributes
	stockMarketFolder:SetAttribute("MinRate", CONFIG.MIN_RATE)
	stockMarketFolder:SetAttribute("MaxRate", CONFIG.MAX_RATE)
	stockMarketFolder:SetAttribute("BailoutFloor", CONFIG.BAILOUT_FLOOR)
	
	-- Try to connect to MemoryStoreService
	local initOk, initErr = pcall(function()
		GlobalMarketMap = MemoryStoreService:GetSortedMap("GlobalMarket_v1")
	end)
	
	if initOk and GlobalMarketMap then
		-- Test read to verify MemoryStore is working
		local testOk = pcall(function()
			GlobalMarketMap:GetAsync("GlobalVol_Shard_1")
		end)
		if testOk then
			useGlobalPricing = true
			print("   StockMarketManager: âœ“ MemoryStore connected â€” global pricing ACTIVE")
		else
			print("   StockMarketManager: MemoryStore read test failed â€” using local fallback")
		end
	else
		warn("   StockMarketManager: MemoryStore init failed:", initErr, "â€” using local fallback")
	end
	
	-- Initial replication
	replicateToClients()
	
	local now = os.time()
	nextReadTime = now + CONFIG.READ_INTERVAL
	nextWriteTime = now + CONFIG.WRITE_INTERVAL
	nextLocalUpdate = now + CONFIG.LOCAL_UPDATE_INTERVAL
	stockMarketFolder:SetAttribute("NextUpdate", nextReadTime)
	
	-- Main heartbeat loop
	RunService.Heartbeat:Connect(function()
		local now2 = os.time()
		
		if useGlobalPricing then
			-- GLOBAL MODE: Read from MemoryStore shards
			if now2 >= nextReadTime then
				nextReadTime = now2 + CONFIG.READ_INTERVAL
				task.spawn(function()
					performGlobalRead()
					replicateToClients()
					stockMarketFolder:SetAttribute("NextUpdate", nextReadTime)
				end)
			end
			
			-- Flush sales buffer to a random shard
			if now2 >= nextWriteTime then
				nextWriteTime = now2 + CONFIG.WRITE_INTERVAL
				task.spawn(flushSalesBuffer)
			end
		else
			-- FALLBACK MODE: Old random local pricing
			if now2 >= nextLocalUpdate then
				nextLocalUpdate = now2 + CONFIG.LOCAL_UPDATE_INTERVAL
				updateMarketLocal()
				stockMarketFolder:SetAttribute("NextUpdate", nextLocalUpdate)
			end
		end
	end)
	
	print("âœ“ StockMarketManager Initialized (" 
		.. (useGlobalPricing and "GLOBAL" or "LOCAL FALLBACK") .. " mode)")
end

--[[
	AddSalesVolume: Called by MarketManager after a player sells items.
	Buffers the volume to be flushed to MemoryStore on the next write cycle.
	
	@param sector string - The market sector (e.g., "Food", "Animals")
	@param count number - Number of items sold
]]
function StockMarketManager.AddSalesVolume(sector: string, count: number)
	if not sector or not count or count <= 0 then return end
	ServerSalesBuffer[sector] = (ServerSalesBuffer[sector] or 0) + count
end

-- Getters (backward compatible)
StockMarketManager.GetSectorRate = function(c) return sectorRates[c] or 1.0 end
StockMarketManager.GetBailoutRate = function(c) return bailoutRates[c] or CONFIG.BAILOUT_FLOOR end
StockMarketManager.GetAllSectorRates = function() return table.clone(sectorRates) end
StockMarketManager.GetAllBailoutRates = function() return table.clone(bailoutRates) end
StockMarketManager.GetSectors = function() return SECTORS end
StockMarketManager.IsGlobalPricingActive = function() return useGlobalPricing end

return StockMarketManager


================================================================================
FILE: src\server\StorageBoxManager.luau
================================================================================

--[[
	StorageBoxManager Server Module
	
	Creates a visual storage box on each player's plot.
]]

local Players = game:GetService("Players")

local STORAGE_CONFIG = {
	SIZE = Vector3.new(8, 6, 8),
	COLOR = Color3.fromRGB(80, 140, 200),
	MATERIAL = Enum.Material.SmoothPlastic,
	TRANSPARENCY = 0.2,
	OFFSET_Y = 3,
}

local StorageBoxManager = {}
local Services = {}

--------------------------------------------------------------------------------
-- STORAGE LOGIC
--------------------------------------------------------------------------------

local function createStorageBox(player)
	local plotsFolder = workspace:FindFirstChild("Plots")
	if not plotsFolder then return nil end
	
	local plot
	for _, p in plotsFolder:GetChildren() do
		if p:GetAttribute("OwnerId") == player.UserId then plot = p; break end
	end
	if not plot then return nil end
	
	if plot:FindFirstChild("Storage") then return plot:FindFirstChild("Storage") end
	
	local floor = plot:FindFirstChild("Island") or plot:FindFirstChildWhichIsA("BasePart")
	if not floor then return nil end
	
	local fp = floor.Position
	local fs = floor.Size
	local sy = fp.Y + (fs.Y / 2) + STORAGE_CONFIG.OFFSET_Y + (STORAGE_CONFIG.SIZE.Y / 2)
	
	local storage = Instance.new("Part")
	storage.Name = "Storage"
	storage.Size = STORAGE_CONFIG.SIZE
	storage.Position = Vector3.new(fp.X, sy, fp.Z)
	storage.Anchored = true
	storage.CanCollide = false
	storage.Color = STORAGE_CONFIG.COLOR
	storage.Material = STORAGE_CONFIG.MATERIAL
	storage.Transparency = STORAGE_CONFIG.TRANSPARENCY
	storage.Parent = plot
	
	-- Tag for client-side HUD (Handles rich item display and capacity bar)
	game:GetService("CollectionService"):AddTag(storage, "PhysicalStorageHUD")
	
	local pl = Instance.new("PointLight"); pl.Color = STORAGE_CONFIG.COLOR; pl.Range = 15; pl.Brightness = 0.3; pl.Parent = storage
	
	return storage
end

local function removeStorageBox(player)
	local plotsFolder = workspace:FindFirstChild("Plots")
	if not plotsFolder then return end
	for _, plot in plotsFolder:GetChildren() do
		if plot:GetAttribute("OwnerId") == player.UserId then
			local s = plot:FindFirstChild("Storage")
			if s then s:Destroy() end
			break
		end
	end
end

--------------------------------------------------------------------------------
-- API
--------------------------------------------------------------------------------

function StorageBoxManager.Init(services)
	print("   StorageBoxManager (Module) - Initializing")
	Services = services or {}
	
	for _, player in Players:GetPlayers() do
		task.defer(function()
			task.wait(1)
			createStorageBox(player)
		end)
	end
	
	Players.PlayerAdded:Connect(function(player)
		task.defer(function()
			task.wait(2)
			createStorageBox(player)
		end)
	end)
	
	print("âœ“ StorageBoxManager Initialized")
end

StorageBoxManager.CreateStorage = createStorageBox
StorageBoxManager.RemoveStorage = removeStorageBox

return StorageBoxManager


================================================================================
FILE: src\server\StorageUpgradeManager.luau
================================================================================

--[[
	StorageUpgradeManager Server Module
	
	Handles the storage upgrade shop on the Main Island.
]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local RemoteEvents = ReplicatedStorage:FindFirstChild("RemoteEvents") or Instance.new("Folder")
RemoteEvents.Name = "RemoteEvents"
RemoteEvents.Parent = ReplicatedStorage

local UpgradeStorageRemote = Instance.new("RemoteFunction")
UpgradeStorageRemote.Name = "UpgradeStorage"
UpgradeStorageRemote.Parent = RemoteEvents

local GetStorageInfoRemote = Instance.new("RemoteFunction")
GetStorageInfoRemote.Name = "GetStorageInfo"
GetStorageInfoRemote.Parent = RemoteEvents

local StorageUpgradedEvent = Instance.new("RemoteEvent")
StorageUpgradedEvent.Name = "StorageUpgraded"
StorageUpgradedEvent.Parent = RemoteEvents

local CONFIG = {
	BASE_STORAGE = 500,
	BASE_PRICE = 100,
	MULTIPLIER = 2,
}

local StorageUpgradeManager = {}
local Services = {}

--------------------------------------------------------------------------------
-- LOGIC
--------------------------------------------------------------------------------

local function getUpgradeLevel(max)
	if max <= CONFIG.BASE_STORAGE then return 0 end
	return math.floor(math.log(max / CONFIG.BASE_STORAGE) / math.log(2))
end

local function getUpgradePrice(lvl)
	return CONFIG.BASE_PRICE * (CONFIG.MULTIPLIER ^ lvl)
end

local function getNewMaxStorage(curr)
	return curr * CONFIG.MULTIPLIER
end

local function handleUpgradeStorage(player)
	local mainIsland = workspace:FindFirstChild("MainIsland")
	local vendor = mainIsland and mainIsland:FindFirstChild("StorageVendor")
	if vendor then
		local char = player.Character
		local hrp = char and char:FindFirstChild("HumanoidRootPart")
		if hrp and (hrp.Position - vendor.Position).Magnitude > 20 then
			return false, "Too far from vendor"
		end
	end
	
	local ISM = rawget(Services, "ItemStorageManager")
	if not ISM then return false, "ItemStorageManager failed" end
	
	-- Calculate price
	local currentCap = ISM.GetStorageCapacity(player)
	local lvl = getUpgradeLevel(currentCap)
	local price = getUpgradePrice(lvl)

	local ls = player:FindFirstChild("leaderstats")
	local money = ls and ls:FindFirstChild("Money")
	if not money or money.Value < price then return false, "Not enough money" end

	money.Value -= price
	local newCap = getNewMaxStorage(currentCap)

	ISM.SetStorageCapacity(player, newCap)

	local nextLvl = lvl + 1
	local nextPrice = getUpgradePrice(nextLvl)
	local nextCap = getNewMaxStorage(newCap)

	StorageUpgradedEvent:FireClient(player, {
		currentMax = newCap,
		upgradeLevel = nextLvl,
		nextPrice = nextPrice,
		nextMaxStorage = nextCap
	})

	return true, "Storage Upgraded!"
end

local function handleGetStorageInfo(player)
	local ISM = rawget(Services, "ItemStorageManager")
	local currentCap = ISM and ISM.GetStorageCapacity(player) or CONFIG.BASE_STORAGE
	local lvl = getUpgradeLevel(currentCap)
	return {
		currentMax = currentCap,
		upgradeLevel = lvl,
		nextPrice = getUpgradePrice(lvl),
		nextMaxStorage = getNewMaxStorage(currentCap)
	}
end

local function createStorageVendor()
	local mainIsland = workspace:WaitForChild("MainIsland", 30)
	if not mainIsland then return end
	if mainIsland:FindFirstChild("StorageVendor") then return end
	
	local part = Instance.new("Part")
	part.Name = "StorageVendor"
	part.Size = Vector3.new(6, 8, 6)
	part.BrickColor = BrickColor.new("Deep orange")
	part.Material = Enum.Material.Neon
	part.Anchored = true
	
	local sv = mainIsland:FindFirstChild("ShopVendor")
	if sv then
		part.Position = sv.Position + Vector3.new(15, 0, 0)
	else
		local pp = mainIsland.PrimaryPart or mainIsland:FindFirstChildWhichIsA("BasePart")
		if pp then part.Position = pp.Position + Vector3.new(35, 10, 0) 
		else part.Position = Vector3.new(35, 40, 0) end
	end
	
	part.Parent = mainIsland
	
	local bb = Instance.new("BillboardGui"); bb.Size=UDim2.new(5,0,2,0); bb.StudsOffset=Vector3.new(0,6,0); bb.Parent=part
	local lbl = Instance.new("TextLabel"); lbl.Size=UDim2.new(1,0,1,0); lbl.BackgroundTransparency=1; lbl.Text="ðŸ“¦ STORAGE"; lbl.TextColor3=Color3.fromRGB(255,200,100); lbl.TextScaled=true; lbl.Parent=bb
	
	local pp = Instance.new("ProximityPrompt")
	pp.ActionText = "Upgrade Storage"
	pp.ObjectText = "Storage"
	pp.KeyboardKeyCode = Enum.KeyCode.E
	pp.Parent = part
end

--------------------------------------------------------------------------------
-- API
--------------------------------------------------------------------------------

function StorageUpgradeManager.Init(services)
	print("   StorageUpgradeManager (Module) - Initializing")
	Services = services or {}
	task.spawn(createStorageVendor)
	
	UpgradeStorageRemote.OnServerInvoke = handleUpgradeStorage
	GetStorageInfoRemote.OnServerInvoke = handleGetStorageInfo
	
	print("âœ“ StorageUpgradeManager Initialized")
end

StorageUpgradeManager.CONFIG = CONFIG
StorageUpgradeManager.GetUpgradeLevel = getUpgradeLevel
StorageUpgradeManager.GetUpgradePrice = getUpgradePrice
StorageUpgradeManager.GetNewMaxStorage = getNewMaxStorage

return StorageUpgradeManager


================================================================================
FILE: src\server\TransportManager.luau
================================================================================

--[[
	TransportManager Server Module
	
	Handles the transport system for carrying items from storage to market.
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Shared -- = ReplicatedStorage:WaitForChild("Shared") -- Moved to lazy
local ItemConfig -- = require(Shared:WaitForChild("ItemConfig"))

local function getItemConfig()
	if not ItemConfig then
		local SharedRef = ReplicatedStorage:WaitForChild("Shared")
		ItemConfig = require(SharedRef:WaitForChild("ItemConfig"))
	end
	return ItemConfig
end

-- Config
local CONFIG = {
	DEFAULT_VEHICLE = "Sneakers",
	VEHICLES = {
		Sneakers = { capacity = 100, price = 0, description = "Basic transport, small capacity" },
		Cart = { capacity = 500, price = 5000, description = "Wooden cart, medium capacity" },
		Hoverboard = { capacity = 2000, price = 50000, description = "Futuristic hover transport" },
		Truck = { capacity = 10000, price = 500000, description = "Massive hauler, huge capacity" },
	},
}

-- Remotes
local RemoteEvents = ReplicatedStorage:FindFirstChild("RemoteEvents") or Instance.new("Folder")
RemoteEvents.Name = "RemoteEvents"
RemoteEvents.Parent = ReplicatedStorage

local RemoteFunctions = ReplicatedStorage:FindFirstChild("RemoteFunctions") or Instance.new("Folder")
RemoteFunctions.Name = "RemoteFunctions"
RemoteFunctions.Parent = ReplicatedStorage

local VehicleUpdated = RemoteEvents:FindFirstChild("VehicleUpdated") or Instance.new("RemoteEvent")
VehicleUpdated.Name = "VehicleUpdated"
VehicleUpdated.Parent = RemoteEvents

local BackpackLoaded = RemoteEvents:FindFirstChild("BackpackLoaded") or Instance.new("RemoteEvent")
BackpackLoaded.Name = "BackpackLoaded"
BackpackLoaded.Parent = RemoteEvents

local SelectVehicleRemote = RemoteFunctions:FindFirstChild("SelectVehicle") or Instance.new("RemoteFunction")
SelectVehicleRemote.Name = "SelectVehicle"
SelectVehicleRemote.Parent = RemoteFunctions

local GetVehicleInfoRemote = RemoteFunctions:FindFirstChild("GetVehicleInfo") or Instance.new("RemoteFunction")
GetVehicleInfoRemote.Name = "GetVehicleInfo"
GetVehicleInfoRemote.Parent = RemoteFunctions

local LoadFromStorageRemote = RemoteFunctions:FindFirstChild("LoadFromStorage") or Instance.new("RemoteFunction")
LoadFromStorageRemote.Name = "LoadFromStorage"
LoadFromStorageRemote.Parent = RemoteFunctions

local LoadMaxFromStorageRemote = RemoteFunctions:FindFirstChild("LoadMaxFromStorage") or Instance.new("RemoteFunction")
LoadMaxFromStorageRemote.Name = "LoadMaxFromStorage"
LoadMaxFromStorageRemote.Parent = RemoteFunctions

-- Module
local TransportManager = {}
local Services = {}

-- State
local PlayerTransport = {}

--------------------------------------------------------------------------------
-- HELPERS
--------------------------------------------------------------------------------

local function getCartManager()
	return rawget(Services, "CartManager")
end

local function getItemStorage()
	return rawget(Services, "ItemStorageManager")
end

local function getCartCapacity(player)
	local t = PlayerTransport[player]
	local vid = t and t.selectedVehicle or CONFIG.DEFAULT_VEHICLE
	local vc = CONFIG.VEHICLES[vid]
	return vc and vc.capacity or 100
end

local function getCartUsage(player)
	local CM = getCartManager()
	if not CM then return 0 end
	local cart = CM.GetCartState(player)
	if not cart then return 0 end
	
	local total = 0
	for _, c in pairs(cart.Inventory) do total += c end
	return total
end

local function initializePlayer(player)
	PlayerTransport[player] = { selectedVehicle = CONFIG.DEFAULT_VEHICLE }
	
	-- Sync attribute for UI
	player:SetAttribute("CartCapacity", getCartCapacity(player))

	-- Update Cart Capacity if cart exists
	local CM = getCartManager()
	if CM then
		-- CM might create cart later, so handled in CM or on vehicle select
	end
end

--------------------------------------------------------------------------------
-- PUBLIC API
--------------------------------------------------------------------------------

function TransportManager.Init(services)
	print("   TransportManager (Module) - Initializing")
	Services = services or {}
	
	Players.PlayerAdded:Connect(function(player)
		initializePlayer(player)
	end)
	Players.PlayerRemoving:Connect(function(player)
		PlayerTransport[player] = nil
	end)
	
	for _, p in Players:GetPlayers() do initializePlayer(p) end
	
	SelectVehicleRemote.OnServerInvoke = TransportManager.SelectVehicle
	GetVehicleInfoRemote.OnServerInvoke = TransportManager.GetVehicleInfo
	LoadFromStorageRemote.OnServerInvoke = TransportManager.LoadFromStorage
	LoadMaxFromStorageRemote.OnServerInvoke = TransportManager.LoadMaxFromStorage
	
	print("âœ“ TransportManager Initialized")
end

function TransportManager.SelectVehicle(player, vehicleId)
	local t = PlayerTransport[player]
	if not t then return false end
	
	local conf = CONFIG.VEHICLES[vehicleId]
	if not conf then return false, "Unknown Vehicle" end
	
	if vehicleId ~= "Sneakers" then
		-- Check Money
		local ls = player:FindFirstChild("leaderstats")
		local m = ls and ls:FindFirstChild("Money")
		if not m or m.Value < conf.price then return false, "Not enough cash" end
		m.Value -= conf.price
	end
	
	t.selectedVehicle = vehicleId
	player:SetAttribute("CartCapacity", conf.capacity)
	
	-- Update Cart Capacity
	local CM = getCartManager()
	if CM then
		-- Create a Setter in CartManager or just update if exposed?
		-- CM.GetCartState returns reference?
		local cart = CM.GetCartState(player)
		if cart then
			cart.Capacity = conf.capacity
			-- Trigger update
			-- CM should expose a method to update safely and fire events
			-- For now, modifying state directly if reference is valid, but better to add "SetCapacity"
			-- Let's just modify the table since it's in-memory and we are server-side.
			-- Ideally we add CM.SetCapacity(player, cap)
			cart.Capacity = conf.capacity
			-- We need to fire update
			-- Let's assume CM handles updates on change? No, we need to trigger it.
			-- Let's add UpdateCart(player) to CM or just fire the event here?
			-- Better: CM.SetCapacity(player, cap)
			-- I'll implement SetCapacity in CM in next step if needed, or just hack it here by firing the event if I can access it.
			-- But I can't access CM's local event.
			-- I will assume CM has SetCapacity or I will add it.
			if CM.SetCapacity then CM.SetCapacity(player, conf.capacity) end
		end
	end
	
	VehicleUpdated:FireClient(player, vehicleId, conf.capacity)
	return true
end

function TransportManager.LoadFromStorage(player, itemId, count)
	local CM = getCartManager()
	local ISM = getItemStorage()
	if not CM or not ISM then return 0 end
	
	local cart = CM.GetCartState(player)
	if not cart then return 0 end
	if cart.State ~= "idle" then return 0 end
	
	local current = 0
	for _, c in pairs(cart.Inventory) do current += c end
	local space = cart.Capacity - current
	
	local toMove = math.min(count or 1, space)
	if toMove <= 0 then return 0 end
	
	local actuallyRemoved = ISM.RemoveFromStorage(player, itemId, toMove)
	if actuallyRemoved > 0 then
		CM.LoadItem(player, itemId, actuallyRemoved)
	end
	return actuallyRemoved
end

function TransportManager.LoadMaxFromStorage(player)
	local CM = getCartManager()
	local ISM = getItemStorage()
	if not CM or not ISM then return {} end
	
	local cart = CM.GetCartState(player)
	if not cart then return {} end
	if cart.State ~= "idle" then return {} end
	
	local current = 0
	for _, c in pairs(cart.Inventory) do current += c end
	local space = cart.Capacity - current
	
	if space <= 0 then return {} end
	
	local loaded = {}
	local storage = ISM.GetStorageContents(player)
	local list = {}
	
	for id, c in pairs(storage) do
		local ic = getItemConfig()
		local info = ic.Items[id]
		if info and c > 0 then
			table.insert(list, { id = id, count = c, val = info.basePrice or 1 })
		end
	end
	table.sort(list, function(a,b) return a.val > b.val end)
	
	for _, item in ipairs(list) do
		if space <= 0 then break end
		local toLoad = math.min(item.count, space)
		local didLoad = ISM.RemoveFromStorage(player, item.id, toLoad)
		if didLoad > 0 then
			CM.LoadItem(player, item.id, didLoad)
			loaded[item.id] = didLoad
			space -= didLoad
		end
	end
	
	return loaded
end

function TransportManager.GetVehicleInfo(player)
	local sel = PlayerTransport[player] and PlayerTransport[player].selectedVehicle or CONFIG.DEFAULT_VEHICLE
	
	local inventory = {}
	local CM = getCartManager()
	if CM then
		local cart = CM.GetCartState(player)
		if cart then inventory = cart.Inventory end
	end
	
	return {
		selectedVehicle = sel,
		capacity = getCartCapacity(player),
		currentLoad = getCartUsage(player),
		availableVehicles = CONFIG.VEHICLES,
		inventory = inventory
	}
end

function TransportManager.GetTransportData(player)
	return { selectedVehicle = PlayerTransport[player] and PlayerTransport[player].selectedVehicle or CONFIG.DEFAULT_VEHICLE }
end

function TransportManager.SetTransportData(player, data)
	if not PlayerTransport[player] then PlayerTransport[player] = {} end
	PlayerTransport[player].selectedVehicle = data.selectedVehicle or CONFIG.DEFAULT_VEHICLE
	
	local CM = getCartManager()
	if CM and CM.SetCapacity then
		CM.SetCapacity(player, getCartCapacity(player))
	end
end

-- Export Config
TransportManager.CONFIG = CONFIG
TransportManager.GetCartCapacity = getCartCapacity
TransportManager.GetCartUsage = getCartUsage

return TransportManager


================================================================================
FILE: src\server\UnitInteractionManager.luau
================================================================================

--[[
	UnitInteractionManager Server Module
	
	Handles ProximityPrompts on brainrot units.
]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")
local HttpService = game:GetService("HttpService")

local BRAINROT_TAG = "ActiveBrainrot"

local RemoteEvents = ReplicatedStorage:FindFirstChild("RemoteEvents") or Instance.new("Folder")
RemoteEvents.Name = "RemoteEvents"
RemoteEvents.Parent = ReplicatedStorage

local OpenUnitUIEvent = RemoteEvents:FindFirstChild("OpenUnitUI") or Instance.new("RemoteEvent")
OpenUnitUIEvent.Name = "OpenUnitUI"
OpenUnitUIEvent.Parent = RemoteEvents

local CONFIG = {
	PROMPT_ACTION_TEXT = "Inspect",
	PROMPT_OBJECT_TEXT = "Equipment",
	PROMPT_KEY = Enum.KeyCode.E,
	PROMPT_HOLD_DURATION = 0,
	PROMPT_MAX_DISTANCE = 15,
	PROMPT_LINE_OF_SIGHT = false,
}

local UnitInteractionManager = {}
local Services = {}

--------------------------------------------------------------------------------
-- LOGIC
--------------------------------------------------------------------------------

local function createPromptForUnit(unit)
	if unit:FindFirstChild("InspectPrompt") then return end
	
	local attachPart = unit.PrimaryPart 
		or unit:FindFirstChild("HumanoidRootPart")
		or unit:FindFirstChild("RootPart")
		or unit:FindFirstChildWhichIsA("BasePart")
	
	if not attachPart then return end
	
	local prompt = Instance.new("ProximityPrompt")
	prompt.Name = "InspectPrompt"
	prompt.ActionText = CONFIG.PROMPT_ACTION_TEXT
	prompt.ObjectText = CONFIG.PROMPT_OBJECT_TEXT
	prompt.KeyboardKeyCode = CONFIG.PROMPT_KEY
	prompt.HoldDuration = CONFIG.PROMPT_HOLD_DURATION
	prompt.MaxActivationDistance = CONFIG.PROMPT_MAX_DISTANCE
	prompt.RequiresLineOfSight = CONFIG.PROMPT_LINE_OF_SIGHT
	prompt.Parent = attachPart
	
	prompt.Triggered:Connect(function(player)
		local ownerId = unit:GetAttribute("OwnerId")
		if ownerId ~= player.UserId then return end
		
		local unitId = unit:GetAttribute("UnitId")
		if not unitId then
			unitId = HttpService:GenerateGUID(false)
			unit:SetAttribute("UnitId", unitId)
		end
		
		local data = {
			unitGUID = unitId,
			unitType = unit:GetAttribute("UnitType") or unit.Name,
			level = unit:GetAttribute("Level") or 1,
			rarity = unit:GetAttribute("Rarity") or "Normal",
			gridSlot = unit:GetAttribute("GridSlot"),
			itemTier = unit:GetAttribute("ItemTier") or 1,
		}
		
		OpenUnitUIEvent:FireClient(player, data)
	end)
end

local function removePromptFromUnit(unit)
	local p = unit:FindFirstChild("InspectPrompt", true)
	if p then p:Destroy() end
end

--------------------------------------------------------------------------------
-- API
--------------------------------------------------------------------------------

function UnitInteractionManager.Init(services)
	print("   UnitInteractionManager (Module) - Initializing")
	Services = services or {}
	
	for _, unit in CollectionService:GetTagged(BRAINROT_TAG) do
		task.spawn(function()
			task.wait()
			createPromptForUnit(unit)
		end)
	end
	
	CollectionService:GetInstanceAddedSignal(BRAINROT_TAG):Connect(function(unit)
		task.spawn(function()
			task.wait()
			createPromptForUnit(unit)
		end)
	end)
	
	CollectionService:GetInstanceRemovedSignal(BRAINROT_TAG):Connect(function(unit)
		removePromptFromUnit(unit)
	end)
	
	print("âœ“ UnitInteractionManager Initialized")
end

UnitInteractionManager.CreatePromptForUnit = createPromptForUnit
UnitInteractionManager.RemovePromptFromUnit = removePromptFromUnit

return UnitInteractionManager


================================================================================
FILE: src\shared\ArtifactConfig.luau
================================================================================

--[[
	ArtifactConfig - Shared Configuration for Procedural Artifacts
	
	Defines artifact generation rules, rarity weights, affixes, and equipment slots.
	
	Located in ReplicatedStorage so both Server and Client can access it.
]]

local ArtifactConfig = {}

--------------------------------------------------------------------------------
-- RARITY SYSTEM
--------------------------------------------------------------------------------

ArtifactConfig.RarityWeights = {
	Common = 60,      -- 60% drop chance
	Uncommon = 25,    -- 25% drop chance
	Rare = 10,        -- 10% drop chance
	Epic = 4,         -- 4% drop chance
	Legendary = 1,    -- 1% drop chance
}

ArtifactConfig.RarityColors = {
	Common = Color3.fromRGB(180, 180, 180),      -- Gray
	Uncommon = Color3.fromRGB(100, 200, 100),    -- Green
	Rare = Color3.fromRGB(100, 150, 255),        -- Blue
	Epic = Color3.fromRGB(180, 100, 255),        -- Purple
	Legendary = Color3.fromRGB(255, 180, 50),    -- Gold
}

-- Number of affixes per rarity
ArtifactConfig.AffixCountByRarity = {
	Common = 1,
	Uncommon = 1,
	Rare = 2,
	Epic = 2,
	Legendary = 3,
}

--------------------------------------------------------------------------------
-- EQUIPMENT SLOTS
--------------------------------------------------------------------------------

ArtifactConfig.EquipmentSlots = {
	"Head",
	"Body",
	"Accessory",
}

ArtifactConfig.SlotIcons = {
	Head = "ðŸ‘’",
	Body = "ðŸ‘”",
	Accessory = "ðŸ“¿",
}

--------------------------------------------------------------------------------
-- AFFIXES (Prefixes and Suffixes)
--------------------------------------------------------------------------------

-- Prefixes: Applied to artifact names
ArtifactConfig.Prefixes = {
	-- Speed affixes
	Glitchy = { Name = "Glitchy", Stat = "CycleTime", Mult = 0.95, Icon = "âš¡" },
	Swift = { Name = "Swift", Stat = "CycleTime", Mult = 0.90, Icon = "ðŸ’¨" },
	Blazing = { Name = "Blazing", Stat = "CycleTime", Mult = 0.85, Icon = "ðŸ”¥" },
	Hypercharged = { Name = "Hypercharged", Stat = "CycleTime", Mult = 0.80, Icon = "âš¡" },
	
	-- Luck affixes
	Lucky = { Name = "Lucky", Stat = "LuckBonus", Add = 0.02, Icon = "ðŸ€" },
	Fortunate = { Name = "Fortunate", Stat = "LuckBonus", Add = 0.05, Icon = "âœ¨" },
	Blessed = { Name = "Blessed", Stat = "LuckBonus", Add = 0.08, Icon = "ðŸŒŸ" },
	
	-- Tier affixes
	Enhanced = { Name = "Enhanced", Stat = "ItemTierBonus", Add = 1, Icon = "ðŸ“ˆ" },
	Superior = { Name = "Superior", Stat = "ItemTierBonus", Add = 2, Icon = "ðŸ’Ž" },
}

-- Suffixes: Applied to artifact names
ArtifactConfig.Suffixes = {
	-- Speed suffixes
	ofSpeed = { Name = "of Speed", Stat = "CycleTime", Mult = 0.95, Icon = "ðŸƒ" },
	ofHaste = { Name = "of Haste", Stat = "CycleTime", Mult = 0.90, Icon = "â©" },
	ofVelocity = { Name = "of Velocity", Stat = "CycleTime", Mult = 0.85, Icon = "ðŸš€" },
	
	-- Luck suffixes
	ofFortune = { Name = "of Fortune", Stat = "LuckBonus", Add = 0.03, Icon = "ðŸŽ°" },
	ofProsperity = { Name = "of Prosperity", Stat = "LuckBonus", Add = 0.06, Icon = "ðŸ’°" },
	
	-- Synergy suffixes
	ofResonance = { Name = "of Resonance", Stat = "SynergyRangeBonus", Add = 1, Icon = "ðŸ”—" },
	ofHarmony = { Name = "of Harmony", Stat = "SynergyRangeBonus", Add = 2, Icon = "ðŸŽµ" },
	
	-- Tier suffixes
	ofQuality = { Name = "of Quality", Stat = "ItemTierBonus", Add = 1, Icon = "â¬†ï¸" },
	ofMastery = { Name = "of Mastery", Stat = "ItemTierBonus", Add = 2, Icon = "ðŸ‘‘" },
}

--------------------------------------------------------------------------------
-- BASE ARTIFACTS (Visuals per slot type)
--------------------------------------------------------------------------------

ArtifactConfig.BaseArtifacts = {
	Head = {
		{ Id = "Crown", Name = "Crown", Icon = "ðŸ‘‘" },
		{ Id = "Helmet", Name = "Helmet", Icon = "ðŸª–" },
		{ Id = "Headband", Name = "Headband", Icon = "ðŸŽ€" },
		{ Id = "Goggles", Name = "Goggles", Icon = "ðŸ¥½" },
		{ Id = "TopHat", Name = "Top Hat", Icon = "ðŸŽ©" },
	},
	Body = {
		{ Id = "Armor", Name = "Armor", Icon = "ðŸ›¡ï¸" },
		{ Id = "Cloak", Name = "Cloak", Icon = "ðŸ§¥" },
		{ Id = "Vest", Name = "Vest", Icon = "ðŸ¦º" },
		{ Id = "Robe", Name = "Robe", Icon = "ðŸ¥‹" },
		{ Id = "Cape", Name = "Cape", Icon = "ðŸ¦¸" },
	},
	Accessory = {
		{ Id = "Amulet", Name = "Amulet", Icon = "ðŸ“¿" },
		{ Id = "Ring", Name = "Ring", Icon = "ðŸ’" },
		{ Id = "Charm", Name = "Charm", Icon = "ðŸ”®" },
		{ Id = "Pendant", Name = "Pendant", Icon = "ðŸ’Ž" },
		{ Id = "Bracelet", Name = "Bracelet", Icon = "âŒš" },
	},
}

--------------------------------------------------------------------------------
-- DROP CHANCES
--------------------------------------------------------------------------------

ArtifactConfig.BaseDropChance = 0.01  -- 1% base chance per production cycle
ArtifactConfig.MaxDropChance = 0.25   -- 25% max after all bonuses

--------------------------------------------------------------------------------
-- STAT LIMITS (for balance)
--------------------------------------------------------------------------------

ArtifactConfig.StatLimits = {
	CycleTimeMin = 0.1,       -- Minimum cycle time in seconds (prevents instant production)
	MaxLuckBonus = 0.5,       -- Maximum luck bonus from artifacts (50%)
	MaxSynergyRange = 3,      -- Maximum extra synergy range
	MaxTierBonus = 5,         -- Maximum tier bonus
}

--------------------------------------------------------------------------------
-- HELPER FUNCTIONS
--------------------------------------------------------------------------------

--[[
	Rolls a rarity based on weights.
	@return string - The rarity name
]]
function ArtifactConfig.RollRarity()
	local total = 0
	for _, weight in pairs(ArtifactConfig.RarityWeights) do
		total = total + weight
	end
	
	local roll = math.random() * total
	local cumulative = 0
	
	-- Roll in order from most to least common
	local rarityOrder = {"Legendary", "Epic", "Rare", "Uncommon", "Common"}
	for _, rarity in ipairs(rarityOrder) do
		cumulative = cumulative + ArtifactConfig.RarityWeights[rarity]
		if roll <= cumulative then
			return rarity
		end
	end
	
	return "Common"
end

--[[
	Gets a random prefix for artifact generation.
	@return table - The prefix data
]]
function ArtifactConfig.GetRandomPrefix()
	local prefixes = {}
	for key, data in pairs(ArtifactConfig.Prefixes) do
		table.insert(prefixes, {key = key, data = data})
	end
	return prefixes[math.random(#prefixes)]
end

--[[
	Gets a random suffix for artifact generation.
	@return table - The suffix data
]]
function ArtifactConfig.GetRandomSuffix()
	local suffixes = {}
	for key, data in pairs(ArtifactConfig.Suffixes) do
		table.insert(suffixes, {key = key, data = data})
	end
	return suffixes[math.random(#suffixes)]
end

--[[
	Gets a random base artifact for a slot.
	@param slot string - The equipment slot
	@return table - The base artifact data
]]
function ArtifactConfig.GetRandomBase(slot)
	local bases = ArtifactConfig.BaseArtifacts[slot]
	if not bases then return nil end
	return bases[math.random(#bases)]
end

--[[
	Calculates combined stats from an artifact.
	@param artifact table - The artifact data
	@return table - Combined stats {CycleTime, LuckBonus, etc.}
]]
function ArtifactConfig.CalculateArtifactStats(artifact)
	local stats = {
		CycleTimeMult = 1,
		LuckBonus = 0,
		ItemTierBonus = 0,
		SynergyRangeBonus = 0,
	}
	
	if not artifact or not artifact.Affixes then
		return stats
	end
	
	for _, affix in ipairs(artifact.Affixes) do
		if affix.Stat == "CycleTime" then
			stats.CycleTimeMult = stats.CycleTimeMult * (affix.Mult or 1)
		elseif affix.Stat == "LuckBonus" then
			stats.LuckBonus = stats.LuckBonus + (affix.Add or 0)
		elseif affix.Stat == "ItemTierBonus" then
			stats.ItemTierBonus = stats.ItemTierBonus + (affix.Add or 0)
		elseif affix.Stat == "SynergyRangeBonus" then
			stats.SynergyRangeBonus = stats.SynergyRangeBonus + (affix.Add or 0)
		end
	end
	
	return stats
end

return ArtifactConfig


================================================================================
FILE: src\shared\ConvenienceUpgradesConfig.luau
================================================================================

--[[
	ConvenienceUpgradesConfig ModuleScript
	
	Defines all purchasable convenience upgrades for the Island Shop.
	Located in ReplicatedStorage so both Server and Client can access it.
	
	Categories:
	- Movement: Walkspeed, jump, bridge speed boosts
	- Income: Global income multipliers
	- Automation: Auto-collector bots, faster cycles
	- Premium: High-tier quality of life upgrades
]]

export type UpgradeConfig = {
	Price: number,
	Description: string,
	Category: string,
	EffectType: string,
	EffectValue: number,
	Icon: string,
	Prerequisite: string?, -- Must own this upgrade first
}

-- All convenience upgrades
local Upgrades: {[string]: UpgradeConfig} = {
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- TIER 1: Movement & Speed ($1,000 - $10,000)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	["Speed Treadmill Bridge"] = {
		Price = 1000,
		Description = "Bridges boost your speed 2x! Zoom between islands.",
		Category = "Movement",
		EffectType = "BridgeSpeed",
		EffectValue = 2, -- 2x speed on bridges
		Icon = "ðŸƒ",
	},
	
	["Walkspeed Boost I"] = {
		Price = 2500,
		Description = "Permanent +25% walkspeed everywhere.",
		Category = "Movement",
		EffectType = "Walkspeed",
		EffectValue = 0.25, -- +25%
		Icon = "ðŸ‘Ÿ",
	},
	
	["Jump Boost"] = {
		Price = 5000,
		Description = "Permanent +50% jump height. Leap tall buildings!",
		Category = "Movement",
		EffectType = "JumpPower",
		EffectValue = 0.50, -- +50%
		Icon = "ðŸ¦˜",
	},
	
	["Walkspeed Boost II"] = {
		Price = 10000,
		Description = "Additional +25% walkspeed. Stacks with Boost I!",
		Category = "Movement",
		EffectType = "Walkspeed",
		EffectValue = 0.25, -- +25% more
		Icon = "âš¡",
		Prerequisite = "Walkspeed Boost I",
	},
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- TIER 2: Income Boosters ($50,000 - $500,000)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	["Global Income +10%"] = {
		Price = 50000,
		Description = "All brainrots produce +10% more income!",
		Category = "Income",
		EffectType = "IncomeMultiplier",
		EffectValue = 0.10, -- +10%
		Icon = "ðŸ’µ",
	},
	
	["Auto-Collector Bot I"] = {
		Price = 100000,
		Description = "A cute bot collects from brainrots to storage for you!",
		Category = "Automation",
		EffectType = "AutoCollector",
		EffectValue = 1, -- 1 bot
		Icon = "ðŸ¤–",
	},
	
	["Global Income +25%"] = {
		Price = 250000,
		Description = "Even more productivity! +25% income (stacks).",
		Category = "Income",
		EffectType = "IncomeMultiplier",
		EffectValue = 0.25, -- +25%
		Icon = "ðŸ’°",
		Prerequisite = "Global Income +10%",
	},
	
	["Faster Cycles I"] = {
		Price = 500000,
		Description = "All brainrots work 15% faster!",
		Category = "Automation",
		EffectType = "CycleReduction",
		EffectValue = 0.15, -- -15% cycle time
		Icon = "â±ï¸",
	},
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- TIER 3: Automation ($1M - $10M)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	["Auto-Collector Bot II"] = {
		Price = 1000000,
		Description = "A second bot joins the collection crew!",
		Category = "Automation",
		EffectType = "AutoCollector",
		EffectValue = 1, -- +1 more bot
		Icon = "ðŸ¤–",
		Prerequisite = "Auto-Collector Bot I",
	},
	
	["Faster Cycles II"] = {
		Price = 2500000,
		Description = "Lightning speed! Additional -15% cycle time.",
		Category = "Automation",
		EffectType = "CycleReduction",
		EffectValue = 0.15, -- -15% more
		Icon = "âš¡",
		Prerequisite = "Faster Cycles I",
	},
	
	["Lucky Bonus Chance"] = {
		Price = 5000000,
		Description = "10% chance for 2x payout on each cycle!",
		Category = "Income",
		EffectType = "LuckyChance",
		EffectValue = 0.10, -- 10% chance
		Icon = "ðŸ€",
	},
	
	["Instant Teleport Home"] = {
		Price = 10000000,
		Description = "Press H to teleport to your main island anytime!",
		Category = "Movement",
		EffectType = "TeleportHome",
		EffectValue = 1, -- enabled
		Icon = "ðŸ ",
	},
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- TIER 4: Premium Upgrades ($50M+)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	["Global Income +50%"] = {
		Price = 50000000,
		Description = "Massive profits! +50% income from all brainrots.",
		Category = "Income",
		EffectType = "IncomeMultiplier",
		EffectValue = 0.50, -- +50%
		Icon = "ðŸ’Ž",
		Prerequisite = "Global Income +25%",
	},
	
	["Critical Bonus Chance"] = {
		Price = 100000000,
		Description = "5% chance for JACKPOT 5x income payout!",
		Category = "Income",
		EffectType = "CriticalChance",
		EffectValue = 0.05, -- 5% chance
		Icon = "ðŸŽ°",
		Prerequisite = "Lucky Bonus Chance",
	},
	
	["Golden Speed Bridges"] = {
		Price = 250000000,
		Description = "Bridges boost speed 3x and shine golden!",
		Category = "Movement",
		EffectType = "BridgeSpeed",
		EffectValue = 3, -- 3x speed (replaces 2x)
		Icon = "âœ¨",
		Prerequisite = "Speed Treadmill Bridge",
	},
}

-- Cache for sorted upgrades
local SortedUpgradesCache: {{name: string, config: UpgradeConfig}}? = nil

--------------------------------------------------------------------------------
-- UTILITY FUNCTIONS
--------------------------------------------------------------------------------

--[[
	Gets the config for a specific upgrade.
	
	@param upgradeName string - The name of the upgrade
	@return UpgradeConfig? - The config, or nil if not found
]]
local function GetConfig(upgradeName: string): UpgradeConfig?
	return Upgrades[upgradeName]
end

--[[
	Returns all upgrades sorted by price (ascending).
	Cached for performance.
	
	@return table - Array of {name, config} pairs sorted by Price
]]
local function GetAllUpgradesSorted(): {{name: string, config: UpgradeConfig}}
	if SortedUpgradesCache then
		return SortedUpgradesCache
	end
	
	local sorted = {}
	
	for name, config in Upgrades do
		table.insert(sorted, {name = name, config = config})
	end
	
	table.sort(sorted, function(a, b)
		return a.config.Price < b.config.Price
	end)
	
	SortedUpgradesCache = sorted
	return sorted
end

--[[
	Gets all upgrades in a specific category.
	
	@param category string - The category name
	@return table - Array of {name, config} pairs in that category
]]
local function GetUpgradesByCategory(category: string): {{name: string, config: UpgradeConfig}}
	local result = {}
	
	for name, config in Upgrades do
		if config.Category == category then
			table.insert(result, {name = name, config = config})
		end
	end
	
	table.sort(result, function(a, b)
		return a.config.Price < b.config.Price
	end)
	
	return result
end

--[[
	Gets all unique categories.
	
	@return {string} - Array of category names
]]
local function GetCategories(): {string}
	local categories = {}
	local seen = {}
	
	for _, config in Upgrades do
		if not seen[config.Category] then
			seen[config.Category] = true
			table.insert(categories, config.Category)
		end
	end
	
	-- Sort in logical order
	local order = {Movement = 1, Income = 2, Automation = 3, Premium = 4}
	table.sort(categories, function(a, b)
		return (order[a] or 99) < (order[b] or 99)
	end)
	
	return categories
end

--[[
	Checks if a player can purchase an upgrade (meets prerequisites).
	
	@param upgradeName string - The upgrade to check
	@param ownedUpgrades {string} - List of upgrades the player owns
	@return boolean, string? - Can purchase, and reason if not
]]
local function CanPurchase(upgradeName: string, ownedUpgrades: {string}): (boolean, string?)
	local config = Upgrades[upgradeName]
	if not config then
		return false, "Upgrade not found"
	end
	
	-- Check if already owned
	for _, owned in ownedUpgrades do
		if owned == upgradeName then
			return false, "Already owned"
		end
	end
	
	-- Check prerequisite
	if config.Prerequisite then
		local hasPrereq = false
		for _, owned in ownedUpgrades do
			if owned == config.Prerequisite then
				hasPrereq = true
				break
			end
		end
		if not hasPrereq then
			return false, "Requires: " .. config.Prerequisite
		end
	end
	
	return true, nil
end

--------------------------------------------------------------------------------
-- MODULE EXPORT
--------------------------------------------------------------------------------

return {
	Upgrades = Upgrades,
	GetConfig = GetConfig,
	GetAllUpgradesSorted = GetAllUpgradesSorted,
	GetUpgradesByCategory = GetUpgradesByCategory,
	GetCategories = GetCategories,
	CanPurchase = CanPurchase,
}


================================================================================
FILE: src\shared\ItemConfig.luau
================================================================================

--[[
    ItemConfig - Shared Configuration for Producible Items
    67+ Unique Brainrot Production Lines
]]

local ItemConfig = {}

-- Typografi definitioner
export type ItemDefinition = {
    id: string,
    displayName: string,
    icon: string,
    tier: number,
    basePrice: number,
    volatility: number,
}

--------------------------------------------------------------------------------
-- PRODUCTION SETTINGS
--------------------------------------------------------------------------------

ItemConfig.ProductionRates = {
    tier1 = 2,    -- Common
    tier2 = 10,   -- Uncommon
    tier3 = 45,   -- Rare
    tier4 = 180,  -- Legendary
}

ItemConfig.MilestoneThresholds = {
    tier1 = 1,
    tier2 = 10,
    tier3 = 50,
    tier4 = 100,
}

--------------------------------------------------------------------------------
-- ITEM DEFINITIONS (The massive list of 4 tiers per model)
--------------------------------------------------------------------------------

ItemConfig.Items = {
    -- Avocadini Guffo
    Guac1 = { id = "Guac1", displayName = "Brown Pit", icon = "ðŸ¥‘", tier = 1, basePrice = 5, volatility = 0.1 },
    Guac2 = { id = "Guac2", displayName = "Sliced Avocado", icon = "ðŸ¥‘", tier = 2, basePrice = 25, volatility = 0.2 },
    Guac3 = { id = "Guac3", displayName = "Fresh Guacamole", icon = "ðŸ¥£", tier = 3, basePrice = 150, volatility = 0.5 },
    Guac4 = { id = "Guac4", displayName = "Golden Avocado", icon = "âœ¨", tier = 4, basePrice = 1000, volatility = 0.8 },

    -- Ballerina_Cappuccina
    Cap1 = { id = "Cap1", displayName = "Empty Cup", icon = "â˜•", tier = 1, basePrice = 6, volatility = 0.1 },
    Cap2 = { id = "Cap2", displayName = "Cold Latte", icon = "â˜•", tier = 2, basePrice = 30, volatility = 0.2 },
    Cap3 = { id = "Cap3", displayName = "Foamy Cappuccino", icon = "â˜•", tier = 3, basePrice = 180, volatility = 0.5 },
    Cap4 = { id = "Cap4", displayName = "Elite Espresso", icon = "ðŸ‘‘", tier = 4, basePrice = 1200, volatility = 0.8 },

    -- Bananita_Dolphinita
    BanDolph1 = { id = "BanDolph1", displayName = "Banana Peel", icon = "ðŸŒ", tier = 1, basePrice = 4, volatility = 0.1 },
    BanDolph2 = { id = "BanDolph2", displayName = "Frozen Banana", icon = "â„ï¸", tier = 2, basePrice = 22, volatility = 0.2 },
    BanDolph3 = { id = "BanDolph3", displayName = "Banana Split", icon = "ðŸ¨", tier = 3, basePrice = 140, volatility = 0.5 },
    BanDolph4 = { id = "BanDolph4", displayName = "Dolphin Figurine", icon = "ðŸ¬", tier = 4, basePrice = 950, volatility = 0.8 },

    -- Brainrot God Lucky Block
    GodLuck1 = { id = "GodLuck1", displayName = "Lucky Shard", icon = "ðŸ€", tier = 1, basePrice = 50, volatility = 0.2 },
    GodLuck2 = { id = "GodLuck2", displayName = "Mystery Cube", icon = "ðŸ“¦", tier = 2, basePrice = 250, volatility = 0.4 },
    GodLuck3 = { id = "GodLuck3", displayName = "Jackpot Token", icon = "ðŸŽ°", tier = 3, basePrice = 1200, volatility = 0.7 },
    GodLuck4 = { id = "GodLuck4", displayName = "Godly Artifact", icon = "ðŸ”±", tier = 4, basePrice = 8000, volatility = 1.0 },

    -- Nuclearo Dinossauro
    NukeDino1 = { id = "NukeDino1", displayName = "Radioactive Bone", icon = "ðŸ¦´", tier = 1, basePrice = 40, volatility = 0.2 },
    NukeDino2 = { id = "NukeDino2", displayName = "Uranium Egg", icon = "ðŸ¥š", tier = 2, basePrice = 200, volatility = 0.4 },
    NukeDino3 = { id = "NukeDino3", displayName = "Plasma Core", icon = "â˜¢ï¸", tier = 3, basePrice = 1000, volatility = 0.8 },
    NukeDino4 = { id = "NukeDino4", displayName = "Atomic Tyrant Eye", icon = "ðŸ‘ï¸", tier = 4, basePrice = 6500, volatility = 1.0 },

    -- Statutino Libertino
    Lib1 = { id = "Lib1", displayName = "Copper Plate", icon = "ðŸ§±", tier = 1, basePrice = 8, volatility = 0.1 },
    Lib2 = { id = "Lib2", displayName = "Rusty Torch", icon = "ðŸ”¦", tier = 2, basePrice = 45, volatility = 0.2 },
    Lib3 = { id = "Lib3", displayName = "Liberty Crown", icon = "ðŸ—½", tier = 3, basePrice = 250, volatility = 0.5 },
    Lib4 = { id = "Lib4", displayName = "Golden Freedom Statue", icon = "âš–ï¸", tier = 4, basePrice = 1800, volatility = 0.8 },

    -- Sammyni_Spyderini
    Spy1 = { id = "Spy1", displayName = "Sticky Web", icon = "ðŸ•¸ï¸", tier = 1, basePrice = 5, volatility = 0.1 },
    Spy2 = { id = "Spy2", displayName = "Spider Leg", icon = "ðŸ•·ï¸", tier = 2, basePrice = 28, volatility = 0.2 },
    Spy3 = { id = "Spy3", displayName = "Venom Sack", icon = "ðŸ§ª", tier = 3, basePrice = 160, volatility = 0.5 },
    Spy4 = { id = "Spy4", displayName = "Widow's Gem", icon = "ðŸ’Ž", tier = 4, basePrice = 1100, volatility = 0.8 },

    -- Chimpanzini_Bananini
    ChimpBan1 = { id = "ChimpBan1", displayName = "Discarded Skin", icon = "ðŸŒ", tier = 1, basePrice = 4, volatility = 0.1 },
    ChimpBan2 = { id = "ChimpBan2", displayName = "Bunch of Bananas", icon = "ðŸŒ", tier = 2, basePrice = 20, volatility = 0.2 },
    ChimpBan3 = { id = "ChimpBan3", displayName = "Monkey Wrench", icon = "ðŸ”§", tier = 3, basePrice = 130, volatility = 0.5 },
    ChimpBan4 = { id = "ChimpBan4", displayName = "King of the Jungle Crown", icon = "ðŸ‘‘", tier = 4, basePrice = 900, volatility = 0.8 },
    
    -- Ballerino Lololo
    Dance1 = { id = "Dance1", displayName = "Sweaty Headband", icon = "ðŸ’¦", tier = 1, basePrice = 5, volatility = 0.1 },
    Dance2 = { id = "Dance2", displayName = "Worn Dance Shoes", icon = "ðŸ‘Ÿ", tier = 2, basePrice = 30, volatility = 0.2 },
    Dance3 = { id = "Dance3", displayName = "Silver Trophy", icon = "ðŸ¥ˆ", tier = 3, basePrice = 160, volatility = 0.5 },
    Dance4 = { id = "Dance4", displayName = "Golden Disco Ball", icon = "ðŸª©", tier = 4, basePrice = 1100, volatility = 0.8 },

    -- Bambini_Crostini
    Toast1 = { id = "Toast1", displayName = "Bread Crust", icon = "ðŸž", tier = 1, basePrice = 4, volatility = 0.1 },
    Toast2 = { id = "Toast2", displayName = "Toasted Slice", icon = "ðŸž", tier = 2, basePrice = 25, volatility = 0.2 },
    Toast3 = { id = "Toast3", displayName = "Buttered Jam Toast", icon = "ðŸ“", tier = 3, basePrice = 140, volatility = 0.5 },
    Toast4 = { id = "Toast4", displayName = "The Golden Loaf", icon = "ðŸ¥–", tier = 4, basePrice = 900, volatility = 0.8 },

    -- Bandito_Bobritto
    Taco1 = { id = "Taco1", displayName = "Corn Shell", icon = "ðŸŒ®", tier = 1, basePrice = 6, volatility = 0.1 },
    Taco2 = { id = "Taco2", displayName = "Spicy Burrito", icon = "ðŸŒ¯", tier = 2, basePrice = 35, volatility = 0.2 },
    Taco3 = { id = "Taco3", displayName = "Bandit Mask", icon = "ðŸŽ­", tier = 3, basePrice = 180, volatility = 0.5 },
    Taco4 = { id = "Taco4", displayName = "Diamond JalapeÃ±o", icon = "ðŸ’Ž", tier = 4, basePrice = 1300, volatility = 0.8 },

    -- Blueberrinni_Octopusini
    BerryOcto1 = { id = "BerryOcto1", displayName = "Blue Ink Shard", icon = "ðŸ–‹ï¸", tier = 1, basePrice = 7, volatility = 0.1 },
    BerryOcto2 = { id = "BerryOcto2", displayName = "Frozen Blueberry", icon = "ðŸ«", tier = 2, basePrice = 40, volatility = 0.2 },
    BerryOcto3 = { id = "BerryOcto3", displayName = "Suction Cup", icon = "ðŸ™", tier = 3, basePrice = 210, volatility = 0.5 },
    BerryOcto4 = { id = "BerryOcto4", displayName = "Kraken Berry", icon = "ðŸ”±", tier = 4, basePrice = 1500, volatility = 0.8 },

    -- Bombardiro_Crocodilo
    CrocBomb1 = { id = "CrocBomb1", displayName = "Croc Tooth", icon = "ðŸ¦·", tier = 1, basePrice = 8, volatility = 0.1 },
    CrocBomb2 = { id = "CrocBomb2", displayName = "Scaly Grenade", icon = "ðŸ’£", tier = 2, basePrice = 45, volatility = 0.2 },
    CrocBomb3 = { id = "CrocBomb3", displayName = "Swamp Missile", icon = "ðŸš€", tier = 3, basePrice = 220, volatility = 0.5 },
    CrocBomb4 = { id = "CrocBomb4", displayName = "Apex Detonator", icon = "ðŸŠ", tier = 4, basePrice = 1600, volatility = 0.8 },

    -- Bombombini_Gusini
    Goose1 = { id = "Goose1", displayName = "Loose Feather", icon = "ðŸª¶", tier = 1, basePrice = 4, volatility = 0.1 },
    Goose2 = { id = "Goose2", displayName = "Egg Bomb", icon = "ðŸ¥š", tier = 2, basePrice = 25, volatility = 0.2 },
    Goose3 = { id = "Goose3", displayName = "Tactical Honk", icon = "ðŸ“¢", tier = 3, basePrice = 150, volatility = 0.5 },
    Goose4 = { id = "Goose4", displayName = "Golden Goose Egg", icon = "âœ¨", tier = 4, basePrice = 1100, volatility = 0.8 },

    -- Boneca_Ambalabu
    Doll1 = { id = "Doll1", displayName = "Loose Thread", icon = "ðŸ§µ", tier = 1, basePrice = 5, volatility = 0.1 },
    Doll2 = { id = "Doll2", displayName = "Porcelain Arm", icon = "ðŸ¦´", tier = 2, basePrice = 30, volatility = 0.2 },
    Doll3 = { id = "Doll3", displayName = "Voodoo Pin", icon = "ðŸ“", tier = 3, basePrice = 170, volatility = 0.5 },
    Doll4 = { id = "Doll4", displayName = "Cursed Relic", icon = "ðŸº", tier = 4, basePrice = 1200, volatility = 0.8 },

    -- Brr_Brr_Patapim
    Brr1 = { id = "Brr1", displayName = "Ice Shaver", icon = "ðŸ§", tier = 1, basePrice = 5, volatility = 0.1 },
    Brr2 = { id = "Brr2", displayName = "Frosty Mug", icon = "ðŸº", tier = 2, basePrice = 30, volatility = 0.2 },
    Brr3 = { id = "Brr3", displayName = "Blizzard Core", icon = "ðŸŒ€", tier = 3, basePrice = 180, volatility = 0.5 },
    Brr4 = { id = "Brr4", displayName = "Zero Degree Orb", icon = "â„ï¸", tier = 4, basePrice = 1200, volatility = 0.8 },

    -- Brri_Brri_Bicus_Dicus_Bombicus
    Bicus1 = { id = "Bicus1", displayName = "Magic Spark", icon = "âœ¨", tier = 1, basePrice = 10, volatility = 0.2 },
    Bicus2 = { id = "Bicus2", displayName = "Ancient Scroll", icon = "ðŸ“œ", tier = 2, basePrice = 55, volatility = 0.3 },
    Bicus3 = { id = "Bicus3", displayName = "Wizard Staff", icon = "ðŸª„", tier = 3, basePrice = 280, volatility = 0.5 },
    Bicus4 = { id = "Bicus4", displayName = "The Forbidden Spell", icon = "ðŸ“–", tier = 4, basePrice = 2000, volatility = 0.9 },

    -- Burbaloni_Loliloli
    Bubble1 = { id = "Bubble1", displayName = "Soap Water", icon = "ðŸ§¼", tier = 1, basePrice = 4, volatility = 0.1 },
    Bubble2 = { id = "Bubble2", displayName = "Pink Bubble", icon = "ðŸ«§", tier = 2, basePrice = 22, volatility = 0.2 },
    Bubble3 = { id = "Bubble3", displayName = "Giant Bubble Wand", icon = "ðŸª„", tier = 3, basePrice = 130, volatility = 0.5 },
    Bubble4 = { id = "Bubble4", displayName = "The Eternal Bubble", icon = "ðŸ”®", tier = 4, basePrice = 900, volatility = 0.8 },

    -- Cacto Hipopotamo
    Cact1 = { id = "Cact1", displayName = "Cactus Needle", icon = "ðŸŒµ", tier = 1, basePrice = 5, volatility = 0.1 },
    Cact2 = { id = "Cact2", displayName = "Desert Sand", icon = "ðŸœï¸", tier = 2, basePrice = 30, volatility = 0.2 },
    Cact3 = { id = "Cact3", displayName = "Hippo Tusk", icon = "ðŸ¦·", tier = 3, basePrice = 160, volatility = 0.5 },
    Cact4 = { id = "Cact4", displayName = "Blooming Oasis", icon = "ðŸŒº", tier = 4, basePrice = 1100, volatility = 0.8 },

    -- Cappuccino_Assassino
    KillerCoffee1 = { id = "KillerCoffee1", displayName = "Coffee Bean", icon = "ðŸ«˜", tier = 1, basePrice = 6, volatility = 0.1 },
    KillerCoffee2 = { id = "KillerCoffee2", displayName = "Spilled Milk", icon = "ðŸ¥›", tier = 2, basePrice = 35, volatility = 0.2 },
    KillerCoffee3 = { id = "KillerCoffee3", displayName = "Dagger Spoon", icon = "ðŸ¥„", tier = 3, basePrice = 190, volatility = 0.5 },
    KillerCoffee4 = { id = "KillerCoffee4", displayName = "The Poisoned Brew", icon = "â˜•", tier = 4, basePrice = 1400, volatility = 0.8 },

    -- Cavallo_Virtuoso
    Horse1 = { id = "Horse1", displayName = "Old Horseshoe", icon = "ðŸ§²", tier = 1, basePrice = 5, volatility = 0.1 },
    Horse2 = { id = "Horse2", displayName = "Violin Bow", icon = "ðŸŽ»", tier = 2, basePrice = 35, volatility = 0.2 },
    Horse3 = { id = "Horse3", displayName = "Music Stand", icon = "ðŸŽ¼", tier = 3, basePrice = 170, volatility = 0.5 },
    Horse4 = { id = "Horse4", displayName = "Grand Stallion Piano", icon = "ðŸŽ¹", tier = 4, basePrice = 1200, volatility = 0.8 },

    -- Chef_Crabracadabra
    Crab1 = { id = "Crab1", displayName = "Crab Shell", icon = "ðŸ¦€", tier = 1, basePrice = 6, volatility = 0.1 },
    Crab2 = { id = "Crab2", displayName = "Sharp Cleaver", icon = "ðŸ”ª", tier = 2, basePrice = 40, volatility = 0.2 },
    Crab3 = { id = "Crab3", displayName = "Magic Spatula", icon = "ðŸª„", tier = 3, basePrice = 200, volatility = 0.5 },
    Crab4 = { id = "Crab4", displayName = "The Master Recipe", icon = "ðŸ“œ", tier = 4, basePrice = 1500, volatility = 0.8 },

    -- Chicleteira Bicicleteira
    Bike1 = { id = "Bike1", displayName = "Bike Valve", icon = "ðŸš²", tier = 1, basePrice = 5, volatility = 0.1 },
    Bike2 = { id = "Bike2", displayName = "Gum Wrapper", icon = "ðŸ¬", tier = 2, basePrice = 28, volatility = 0.2 },
    Bike3 = { id = "Bike3", displayName = "Rusty Chain", icon = "â›“ï¸", tier = 3, basePrice = 150, volatility = 0.5 },
    Bike4 = { id = "Bike4", displayName = "Diamond Gear", icon = "âš™ï¸", tier = 4, basePrice = 1100, volatility = 0.8 },

    -- Chimpanzini Spiderini
    ChimpSpy1 = { id = "ChimpSpy1", displayName = "Sticky Web", icon = "ðŸ•¸ï¸", tier = 1, basePrice = 7, volatility = 0.1 },
    ChimpSpy2 = { id = "ChimpSpy2", displayName = "Banana Peel Trap", icon = "ðŸŒ", tier = 2, basePrice = 40, volatility = 0.2 },
    ChimpSpy3 = { id = "ChimpSpy3", displayName = "8-Legged Suit", icon = "ðŸ•·ï¸", tier = 3, basePrice = 220, volatility = 0.5 },
    ChimpSpy4 = { id = "ChimpSpy4", displayName = "Arachnid King", icon = "ðŸ‘‘", tier = 4, basePrice = 1600, volatility = 0.8 },

    -- Cocofanto_Elefanto
    Elephant1 = { id = "Elephant1", displayName = "Peanut Shell", icon = "ðŸ¥œ", tier = 1, basePrice = 5, volatility = 0.1 },
    Elephant2 = { id = "Elephant2", displayName = "Ivory Scrap", icon = "ðŸ¦´", tier = 2, basePrice = 30, volatility = 0.2 },
    Elephant3 = { id = "Elephant3", displayName = "Water Trunk", icon = "ðŸš¿", tier = 3, basePrice = 170, volatility = 0.5 },
    Elephant4 = { id = "Elephant4", displayName = "Ancient Mammoth Tusk", icon = "ðŸ˜", tier = 4, basePrice = 1300, volatility = 0.8 },

    -- Espresso Signora
    Signora1 = { id = "Signora1", displayName = "Sugar Packet", icon = "ðŸ§‚", tier = 1, basePrice = 6, volatility = 0.1 },
    Signora2 = { id = "Signora2", displayName = "Milk Frother", icon = "ðŸ¥›", tier = 2, basePrice = 35, volatility = 0.2 },
    Signora3 = { id = "Signora3", displayName = "Fancy Saucer", icon = "ðŸ½ï¸", tier = 3, basePrice = 190, volatility = 0.5 },
    Signora4 = { id = "Signora4", displayName = "The Queen's Roast", icon = "â˜•", tier = 4, basePrice = 1450, volatility = 0.8 },

    -- Fluri_flura
    Fluri1 = { id = "Fluri1", displayName = "Petal Shard", icon = "ðŸŒ¸", tier = 1, basePrice = 4, volatility = 0.1 },
    Fluri2 = { id = "Fluri2", displayName = "Flower Pot", icon = "ðŸª´", tier = 2, basePrice = 25, volatility = 0.2 },
    Fluri3 = { id = "Fluri3", displayName = "Magic Nectar", icon = "ðŸ§ª", tier = 3, basePrice = 140, volatility = 0.5 },
    Fluri4 = { id = "Fluri4", displayName = "Eternal Bloom", icon = "ðŸŒ»", tier = 4, basePrice = 1000, volatility = 0.8 },

    -- Frigo_Camelo
    Camel1 = { id = "Camel1", displayName = "Desert Pebble", icon = "ðŸª¨", tier = 1, basePrice = 5, volatility = 0.1 },
    Camel2 = { id = "Camel2", displayName = "Water Canteen", icon = "ðŸ¥¤", tier = 2, basePrice = 32, volatility = 0.2 },
    Camel3 = { id = "Camel3", displayName = "Refrigerator Hump", icon = "ðŸ§Š", tier = 3, basePrice = 180, volatility = 0.5 },
    Camel4 = { id = "Camel4", displayName = "Mirage Core", icon = "ðŸœï¸", tier = 4, basePrice = 1200, volatility = 0.8 },

    -- Gangster_Footera
    Gang1 = { id = "Gang1", displayName = "Lace Scrap", icon = "ðŸ§µ", tier = 1, basePrice = 7, volatility = 0.1 },
    Gang2 = { id = "Gang2", displayName = "Gold Chain", icon = "â›“ï¸", tier = 2, basePrice = 45, volatility = 0.3 },
    Gang3 = { id = "Gang3", displayName = "Sneaker Box", icon = "ðŸ“¦", tier = 3, basePrice = 220, volatility = 0.5 },
    Gang4 = { id = "Gang4", displayName = "The Godfather's Boot", icon = "ðŸ‘Ÿ", tier = 4, basePrice = 1600, volatility = 0.8 },

    -- Garama_and_Madundung
    Garama1 = { id = "Garama1", displayName = "Dusty Rock", icon = "ðŸª¨", tier = 1, basePrice = 6, volatility = 0.1 },
    Garama2 = { id = "Garama2", displayName = "Old Staff", icon = "ðŸ¦¯", tier = 2, basePrice = 38, volatility = 0.2 },
    Garama3 = { id = "Garama3", displayName = "Tribal Mask", icon = "ðŸ‘º", tier = 3, basePrice = 200, volatility = 0.5 },
    Garama4 = { id = "Garama4", displayName = "Ancient Totem", icon = "ðŸ—¿", tier = 4, basePrice = 1400, volatility = 0.8 },

    -- Gattatino Neonino
    Neon1 = { id = "Neon1", displayName = "Flickering Bulb", icon = "ðŸ’¡", tier = 1, basePrice = 8, volatility = 0.1 },
    Neon2 = { id = "Neon2", displayName = "Glowing Wire", icon = "ðŸ”Œ", tier = 2, basePrice = 50, volatility = 0.2 },
    Neon3 = { id = "Neon3", displayName = "Neon Collar", icon = "ðŸŽ€", tier = 3, basePrice = 240, volatility = 0.5 },
    Neon4 = { id = "Neon4", displayName = "Cyber Cat Core", icon = "âš¡", tier = 4, basePrice = 1800, volatility = 0.8 },

    -- Gattatino_Nyanino
    Nyan1 = { id = "Nyan1", displayName = "Crumbly Cookie", icon = "ðŸª", tier = 1, basePrice = 5, volatility = 0.1 },
    Nyan2 = { id = "Nyan2", displayName = "Rainbow Dust", icon = "ðŸŒˆ", tier = 2, basePrice = 35, volatility = 0.2 },
    Nyan3 = { id = "Nyan3", displayName = "Space Jam", icon = "ðŸ¯", tier = 3, basePrice = 180, volatility = 0.5 },
    Nyan4 = { id = "Nyan4", displayName = "Cosmic Pop-Tart", icon = "ðŸŒŒ", tier = 4, basePrice = 1400, volatility = 0.8 },

    -- Girafa_Celestre
    Giraffe1 = { id = "Giraffe1", displayName = "Long Grass", icon = "ðŸŒ±", tier = 1, basePrice = 5, volatility = 0.1 },
    Giraffe2 = { id = "Giraffe2", displayName = "Spotty Scarf", icon = "ðŸ§£", tier = 2, basePrice = 30, volatility = 0.2 },
    Giraffe3 = { id = "Giraffe3", displayName = "Star Telescope", icon = "ðŸ”­", tier = 3, basePrice = 170, volatility = 0.5 },
    Giraffe4 = { id = "Giraffe4", displayName = "Cloud Tower", icon = "â˜ï¸", tier = 4, basePrice = 1200, volatility = 0.8 },

    -- Glorbo_Fruttodrillo
    Glorbo1 = { id = "Glorbo1", displayName = "Fruit Pit", icon = "ðŸ‘", tier = 1, basePrice = 6, volatility = 0.1 },
    Glorbo2 = { id = "Glorbo2", displayName = "Dragon Scale", icon = "ðŸ›¡ï¸", tier = 2, basePrice = 40, volatility = 0.2 },
    Glorbo3 = { id = "Glorbo3", displayName = "Juicy Claw", icon = "ðŸ¾", tier = 3, basePrice = 210, volatility = 0.5 },
    Glorbo4 = { id = "Glorbo4", displayName = "Tropical Emperor", icon = "ðŸ‘‘", tier = 4, basePrice = 1550, volatility = 0.8 },

    -- Gorillo Watermelondrillo
    Melon1 = { id = "Melon1", displayName = "Melon Seed", icon = "ðŸŒ±", tier = 1, basePrice = 5, volatility = 0.1 },
    Melon2 = { id = "Melon2", displayName = "Green Rind", icon = "ðŸ‰", tier = 2, basePrice = 35, volatility = 0.2 },
    Melon3 = { id = "Melon3", displayName = "Gorilla Fist", icon = "ðŸ‘Š", tier = 3, basePrice = 190, volatility = 0.5 },
    Melon4 = { id = "Melon4", displayName = "The Giant Watermelon", icon = "ðŸ‰", tier = 4, basePrice = 1400, volatility = 0.8 },

    -- Graipuss_Medussi
    Grai1 = { id = "Grai1", displayName = "Tentacle Scrap", icon = "ðŸ™", tier = 1, basePrice = 6, volatility = 0.1 },
    Grai2 = { id = "Grai2", displayName = "Frozen Grape", icon = "ðŸ‡", tier = 2, basePrice = 38, volatility = 0.2 },
    Grai3 = { id = "Grai3", displayName = "Stone Eye", icon = "ðŸ‘ï¸", tier = 3, basePrice = 200, volatility = 0.5 },
    Grai4 = { id = "Grai4", displayName = "Medusa's Jellyfish", icon = "ðŸ", tier = 4, basePrice = 1500, volatility = 0.8 },

    -- La_Grande_Combinasion
    Combo1 = { id = "Combo1", displayName = "Small Cog", icon = "âš™ï¸", tier = 1, basePrice = 8, volatility = 0.1 },
    Combo2 = { id = "Combo2", displayName = "Mixed Battery", icon = "ðŸ”‹", tier = 2, basePrice = 50, volatility = 0.2 },
    Combo3 = { id = "Combo3", displayName = "Mechanical Heart", icon = "â¤ï¸", tier = 3, basePrice = 250, volatility = 0.5 },
    Combo4 = { id = "Combo4", displayName = "The Ultimate Engine", icon = "ðŸš€", tier = 4, basePrice = 2000, volatility = 0.8 },

    -- La_Vacca_Saturno_Saturnita
    Cow1 = { id = "Cow1", displayName = "Milk Pail", icon = "ðŸª£", tier = 1, basePrice = 5, volatility = 0.1 },
    Cow2 = { id = "Cow2", displayName = "Space Hay", icon = "ðŸŒ¾", tier = 2, basePrice = 32, volatility = 0.2 },
    Cow3 = { id = "Cow3", displayName = "Saturn's Ring", icon = "ðŸª", tier = 3, basePrice = 190, volatility = 0.5 },
    Cow4 = { id = "Cow4", displayName = "The Galactic Bovine", icon = "ðŸ®", tier = 4, basePrice = 1400, volatility = 0.8 },

    -- Las Tralaleritas
    Trala1 = { id = "Trala1", displayName = "Sheet Music", icon = "ðŸ“„", tier = 1, basePrice = 4, volatility = 0.1 },
    Trala2 = { id = "Trala2", displayName = "Silver Bell", icon = "ðŸ””", tier = 2, basePrice = 28, volatility = 0.2 },
    Trala3 = { id = "Trala3", displayName = "Rhythm Sticks", icon = "ðŸ¥", tier = 3, basePrice = 150, volatility = 0.5 },
    Trala4 = { id = "Trala4", displayName = "The Golden Choir", icon = "ðŸŽ¶", tier = 4, basePrice = 1100, volatility = 0.8 },

    -- Las Vaquitas Saturnitas
    Vaqu1 = { id = "Vaqu1", displayName = "Mini Moon", icon = "ðŸŒ‘", tier = 1, basePrice = 6, volatility = 0.1 },
    Vaqu2 = { id = "Vaqu2", displayName = "Asteroid Cheese", icon = "ðŸ§€", tier = 2, basePrice = 38, volatility = 0.2 },
    Vaqu3 = { id = "Vaqu3", displayName = "Cosmic Bell", icon = "ðŸ””", tier = 3, basePrice = 210, volatility = 0.5 },
    Vaqu4 = { id = "Vaqu4", displayName = "Star-Dust Udder", icon = "ðŸŒŒ", tier = 4, basePrice = 1600, volatility = 0.8 },

    -- Lionel_Cactuseli
    Messi1 = { id = "Messi1", displayName = "Football Scraps", icon = "âš½", tier = 1, basePrice = 7, volatility = 0.1 },
    Messi2 = { id = "Messi2", displayName = "Spiky Ball", icon = "ðŸŒµ", tier = 2, basePrice = 45, volatility = 0.2 },
    Messi3 = { id = "Messi3", displayName = "Golden Boot", icon = "ðŸ‘Ÿ", tier = 3, basePrice = 250, volatility = 0.5 },
    Messi4 = { id = "Messi4", displayName = "World Cup Cactus", icon = "ðŸ†", tier = 4, basePrice = 2000, volatility = 0.8 },

    -- LirilÃ¬_LarilÃ 
    Liri1 = { id = "Liri1", displayName = "Note Shard", icon = "ðŸŽµ", tier = 1, basePrice = 5, volatility = 0.1 },
    Liri2 = { id = "Liri2", displayName = "Humming Box", icon = "ðŸ“»", tier = 2, basePrice = 32, volatility = 0.2 },
    Liri3 = { id = "Liri3", displayName = "Echo Crystal", icon = "ðŸ’Ž", tier = 3, basePrice = 180, volatility = 0.5 },
    Liri4 = { id = "Liri4", displayName = "Grand Symphony", icon = "ðŸŽ»", tier = 4, basePrice = 1300, volatility = 0.8 },

    -- Los Crocodillitos
    SmallCroc1 = { id = "SmallCroc1", displayName = "Egg Shell", icon = "ðŸ¥š", tier = 1, basePrice = 5, volatility = 0.1 },
    SmallCroc2 = { id = "SmallCroc2", displayName = "Baby Scale", icon = "ðŸ›¡ï¸", tier = 2, basePrice = 30, volatility = 0.2 },
    SmallCroc3 = { id = "SmallCroc3", displayName = "Swamp Toy", icon = "ðŸ§¸", tier = 3, basePrice = 160, volatility = 0.5 },
    SmallCroc4 = { id = "SmallCroc4", displayName = "King of the Pond", icon = "ðŸ‘‘", tier = 4, basePrice = 1200, volatility = 0.8 },

    -- Los_Tralaleritos
    Traler1 = { id = "Traler1", displayName = "Toy Flute", icon = "ðŸªˆ", tier = 1, basePrice = 4, volatility = 0.1 },
    Traler2 = { id = "Traler2", displayName = "Small Drum", icon = "ðŸ¥", tier = 2, basePrice = 28, volatility = 0.2 },
    Traler3 = { id = "Traler3", displayName = "Music Box", icon = "ðŸ“»", tier = 3, basePrice = 150, volatility = 0.5 },
    Traler4 = { id = "Traler4", displayName = "The Masterpiece", icon = "ðŸŽ¨", tier = 4, basePrice = 1100, volatility = 0.8 },

    -- Mat_teo
    Matteo1 = { id = "Matteo1", displayName = "Ink Pen", icon = "ðŸ–‹ï¸", tier = 1, basePrice = 6, volatility = 0.1 },
    Matteo2 = { id = "Matteo2", displayName = "Smart Glasses", icon = "ðŸ‘“", tier = 2, basePrice = 40, volatility = 0.2 },
    Matteo3 = { id = "Matteo3", displayName = "Strategy Board", icon = "ðŸ“‹", tier = 3, basePrice = 210, volatility = 0.5 },
    Matteo4 = { id = "Matteo4", displayName = "The Final Answer", icon = "ðŸ§ ", tier = 4, basePrice = 1600, volatility = 0.8 },

    -- Mythic Lucky Block
    MythLuck1 = { id = "MythLuck1", displayName = "Silver Shard", icon = "âœ¨", tier = 1, basePrice = 25, volatility = 0.3 },
    MythLuck2 = { id = "MythLuck2", displayName = "Purple Box", icon = "ðŸ“¦", tier = 2, basePrice = 120, volatility = 0.4 },
    MythLuck3 = { id = "MythLuck3", displayName = "Rare Key", icon = "ðŸ”‘", tier = 3, basePrice = 600, volatility = 0.6 },
    MythLuck4 = { id = "MythLuck4", displayName = "Mythical Prize", icon = "ðŸ’Ž", tier = 4, basePrice = 4000, volatility = 0.9 },

    -- Odin_Din_Din_Dun
    Odin1 = { id = "Odin1", displayName = "Ancient Nail", icon = "ðŸ”¨", tier = 1, basePrice = 10, volatility = 0.2 },
    Odin2 = { id = "Odin2", displayName = "Viking Shield", icon = "ðŸ›¡ï¸", tier = 2, basePrice = 60, volatility = 0.3 },
    Odin3 = { id = "Odin3", displayName = "Mjolnir Fragment", icon = "âš¡", tier = 3, basePrice = 350, volatility = 0.6 },
    Odin4 = { id = "Odin4", displayName = "The All-Father's Eye", icon = "ðŸ‘ï¸", tier = 4, basePrice = 2500, volatility = 0.9 },

    -- Orangutini_Ananassini
    Orang1 = { id = "Orang1", displayName = "Pineapple Top", icon = "ðŸ", tier = 1, basePrice = 5, volatility = 0.1 },
    Orang2 = { id = "Orang2", displayName = "Orange Peel", icon = "ðŸŠ", tier = 2, basePrice = 30, volatility = 0.2 },
    Orang3 = { id = "Orang3", displayName = "Jungle Juice", icon = "ðŸ¹", tier = 3, basePrice = 170, volatility = 0.5 },
    Orang4 = { id = "Orang4", displayName = "The Tropical King", icon = "ðŸ¦", tier = 4, basePrice = 1200, volatility = 0.8 },

    -- Orcalero Orcala
    Orca1 = { id = "Orca1", displayName = "Sea Shell", icon = "ðŸš", tier = 1, basePrice = 6, volatility = 0.1 },
    Orca2 = { id = "Orca2", displayName = "Whale Fin", icon = "ðŸ‹", tier = 2, basePrice = 40, volatility = 0.2 },
    Orca3 = { id = "Orca3", displayName = "Tidal Wave", icon = "ðŸŒŠ", tier = 3, basePrice = 220, volatility = 0.5 },
    Orca4 = { id = "Orca4", displayName = "The Deep Sea Pearl", icon = "âšª", tier = 4, basePrice = 1700, volatility = 0.8 },

    -- Pandaccini Bananini
    Panda1 = { id = "Panda1", displayName = "Bamboo Leaf", icon = "ðŸƒ", tier = 1, basePrice = 5, volatility = 0.1 },
    Panda2 = { id = "Panda2", displayName = "Banana Bread", icon = "ðŸž", tier = 2, basePrice = 35, volatility = 0.2 },
    Panda3 = { id = "Panda3", displayName = "Panda Paw", icon = "ðŸ¾", tier = 3, basePrice = 180, volatility = 0.5 },
    Panda4 = { id = "Panda4", displayName = "Zen Master's Banana", icon = "ðŸ§˜", tier = 4, basePrice = 1300, volatility = 0.8 },

    -- Perochello_Lemonchello
    Lemon1 = { id = "Lemon1", displayName = "Lemon Slice", icon = "ðŸ‹", tier = 1, basePrice = 4, volatility = 0.1 },
    Lemon2 = { id = "Lemon2", displayName = "Yellow Squeeze", icon = "ðŸ¥¤", tier = 2, basePrice = 25, volatility = 0.2 },
    Lemon3 = { id = "Lemon3", displayName = "Zesty Spritz", icon = "ðŸ¸", tier = 3, basePrice = 140, volatility = 0.5 },
    Lemon4 = { id = "Lemon4", displayName = "The Golden Lemon", icon = "ðŸ‹", tier = 4, basePrice = 1000, volatility = 0.8 },

    -- Piccione Macchina
    Pigeon1 = { id = "Pigeon1", displayName = "Bird Seed", icon = "ðŸŒ¾", tier = 1, basePrice = 5, volatility = 0.1 },
    Pigeon2 = { id = "Pigeon2", displayName = "Iron Wing", icon = "âš™ï¸", tier = 2, basePrice = 35, volatility = 0.2 },
    Pigeon3 = { id = "Pigeon3", displayName = "Pigeon Message", icon = "ðŸ“œ", tier = 3, basePrice = 190, volatility = 0.5 },
    Pigeon4 = { id = "Pigeon4", displayName = "The Cyber Dove", icon = "ðŸ•Šï¸", tier = 4, basePrice = 1400, volatility = 0.8 },

    -- Pipi_Kiwi
    Kiwi1 = { id = "Kiwi1", displayName = "Kiwi Skin", icon = "ðŸ¥", tier = 1, basePrice = 5, volatility = 0.1 },
    Kiwi2 = { id = "Kiwi2", displayName = "Fuzzy Feather", icon = "ðŸª¶", tier = 2, basePrice = 30, volatility = 0.2 },
    Kiwi3 = { id = "Kiwi3", displayName = "Kiwi Egg", icon = "ðŸ¥š", tier = 3, basePrice = 170, volatility = 0.5 },
    Kiwi4 = { id = "Kiwi4", displayName = "The Emerald Bird", icon = "ðŸ¦", tier = 4, basePrice = 1200, volatility = 0.8 },

    -- Pot Hotspot
    Pot1 = { id = "Pot1", displayName = "Clay Chunk", icon = "ðŸ§±", tier = 1, basePrice = 5, volatility = 0.1 },
    Pot2 = { id = "Pot2", displayName = "Stone Pot", icon = "ðŸº", tier = 2, basePrice = 35, volatility = 0.2 },
    Pot3 = { id = "Pot3", displayName = "Boiling Water", icon = "â™¨ï¸", tier = 3, basePrice = 180, volatility = 0.5 },
    Pot4 = { id = "Pot4", displayName = "The Iron Cauldron", icon = "ðŸ¥˜", tier = 4, basePrice = 1350, volatility = 0.8 },

    -- Rhino_Toasterino
    ToastRhino1 = { id = "ToastRhino1", displayName = "Crumbs", icon = "ðŸž", tier = 1, basePrice = 6, volatility = 0.1 },
    ToastRhino2 = { id = "ToastRhino2", displayName = "Burnt Toast", icon = "ðŸž", tier = 2, basePrice = 35, volatility = 0.2 },
    ToastRhino3 = { id = "ToastRhino3", displayName = "Electric Horn", icon = "ðŸ¦", tier = 3, basePrice = 200, volatility = 0.5 },
    ToastRhino4 = { id = "ToastRhino4", displayName = "The Steel Rhino", icon = "ðŸ›¡ï¸", tier = 4, basePrice = 1500, volatility = 0.8 },

    -- Salamino Penguino
    Penguin1 = { id = "Penguin1", displayName = "Small Fish", icon = "ðŸŸ", tier = 1, basePrice = 5, volatility = 0.1 },
    Penguin2 = { id = "Penguin2", displayName = "Ice Pebble", icon = "ðŸ§Š", tier = 2, basePrice = 32, volatility = 0.2 },
    Penguin3 = { id = "Penguin3", displayName = "Tuxedo Bow", icon = "ðŸŽ€", tier = 3, basePrice = 180, volatility = 0.5 },
    Penguin4 = { id = "Penguin4", displayName = "King of the Arctic", icon = "ðŸ‘‘", tier = 4, basePrice = 1300, volatility = 0.8 },

    -- Secret Lucky Block
    SecLuck1 = { id = "SecLuck1", displayName = "Dusty Box", icon = "ðŸ“¦", tier = 1, basePrice = 20, volatility = 0.3 },
    SecLuck2 = { id = "SecLuck2", displayName = "Hidden Note", icon = "ðŸ“œ", tier = 2, basePrice = 100, volatility = 0.4 },
    SecLuck3 = { id = "SecLuck3", displayName = "Encrypted Key", icon = "ðŸ”‘", tier = 3, basePrice = 500, volatility = 0.6 },
    SecLuck4 = { id = "SecLuck4", displayName = "Classified Prize", icon = "ðŸ“", tier = 4, basePrice = 3500, volatility = 1.0 },

    -- Noobini_Pizzanini
    PizzaCrust = { id = "PizzaCrust", displayName = "Burnt Pizza Crust", icon = "ðŸ•", tier = 1, basePrice = 5, volatility = 0.1 },
    ColdPizza = { id = "ColdPizza", displayName = "Cold Pizza Slice", icon = "ðŸ•", tier = 2, basePrice = 30, volatility = 0.2 },
    DeepDish = { id = "DeepDish", displayName = "Deep Dish Pizza", icon = "ðŸ¥§", tier = 3, basePrice = 160, volatility = 0.5 },
    PartyPizza = { id = "PartyPizza", displayName = "Ultimate Party Pizza", icon = "ðŸŽ‰", tier = 4, basePrice = 1200, volatility = 0.8 },

    -- Spioniro Golubiro
    Spion1 = { id = "Spion1", displayName = "Mini Camera", icon = "ðŸ“·", tier = 1, basePrice = 7, volatility = 0.1 },
    Spion2 = { id = "Spion2", displayName = "Stealth Cloak", icon = "ðŸ‘¤", tier = 2, basePrice = 45, volatility = 0.3 },
    Spion3 = { id = "Spion3", displayName = "Binoculars", icon = "ðŸ”­", tier = 3, basePrice = 230, volatility = 0.5 },
    Spion4 = { id = "Spion4", displayName = "The Master Spy", icon = "ðŸ•´ï¸", tier = 4, basePrice = 1700, volatility = 0.8 },

    -- Strawberrelli Flamingelli
    Flam1 = { id = "Flam1", displayName = "Pink Feather", icon = "ðŸª¶", tier = 1, basePrice = 5, volatility = 0.1 },
    Flam2 = { id = "Flam2", displayName = "Sweet Berry", icon = "ðŸ“", tier = 2, basePrice = 30, volatility = 0.2 },
    Flam3 = { id = "Flam3", displayName = "Flamingo Stand", icon = "ðŸ¦©", tier = 3, basePrice = 170, volatility = 0.5 },
    Flam4 = { id = "Flam4", displayName = "The Tropical Queen", icon = "ðŸ‘‘", tier = 4, basePrice = 1300, volatility = 0.8 },

    -- Svinina_Bombardino
    PigBomb1 = { id = "PigBomb1", displayName = "Pig Tail", icon = "ðŸ–", tier = 1, basePrice = 6, volatility = 0.1 },
    PigBomb2 = { id = "PigBomb2", displayName = "Ham Casing", icon = "ðŸ–", tier = 2, basePrice = 35, volatility = 0.2 },
    PigBomb3 = { id = "PigBomb3", displayName = "Bacon Bomb", icon = "ðŸ¥“", tier = 3, basePrice = 200, volatility = 0.5 },
    PigBomb4 = { id = "PigBomb4", displayName = "The Atomic Porker", icon = "ðŸ·", tier = 4, basePrice = 1500, volatility = 0.8 },

    -- Ta_Ta_Ta_Ta_Sahur
    Sahur1 = { id = "Sahur1", displayName = "Iron Scraps", icon = "â›“ï¸", tier = 1, basePrice = 8, volatility = 0.1 },
    Sahur2 = { id = "Sahur2", displayName = "Brass Trumpet", icon = "ðŸŽº", tier = 2, basePrice = 45, volatility = 0.2 },
    Sahur3 = { id = "Sahur3", displayName = "Marching Drum", icon = "ðŸ¥", tier = 3, basePrice = 220, volatility = 0.5 },
    Sahur4 = { id = "Sahur4", displayName = "The Grand Parade", icon = "ðŸŽª", tier = 4, basePrice = 1700, volatility = 0.8 },

    -- Talpa_Di_Fero
    Mole1 = { id = "Mole1", displayName = "Dirt Clump", icon = "ðŸª¨", tier = 1, basePrice = 5, volatility = 0.1 },
    Mole2 = { id = "Mole2", displayName = "Iron Claw", icon = "ðŸ¾", tier = 2, basePrice = 35, volatility = 0.2 },
    Mole3 = { id = "Mole3", displayName = "Tunneler", icon = "ðŸš‡", tier = 3, basePrice = 190, volatility = 0.5 },
    Mole4 = { id = "Mole4", displayName = "The Steel Driller", icon = "ðŸšœ", tier = 4, basePrice = 1450, volatility = 0.8 },

    -- Tigrilini Watermelini
    TigMelon1 = { id = "TigMelon1", displayName = "Tiger Stripe", icon = "ðŸ¦“", tier = 1, basePrice = 6, volatility = 0.1 },
    TigMelon2 = { id = "TigMelon2", displayName = "Melon Slice", icon = "ðŸ‰", tier = 2, basePrice = 40, volatility = 0.2 },
    TigMelon3 = { id = "TigMelon3", displayName = "Roaring Fruit", icon = "ðŸ¦", tier = 3, basePrice = 230, volatility = 0.5 },
    TigMelon4 = { id = "TigMelon4", displayName = "The Jungle Melon", icon = "ðŸ‘‘", tier = 4, basePrice = 1800, volatility = 0.8 },

    -- Tigroligre Frutonni
    Ligre1 = { id = "Ligre1", displayName = "Claw Scrap", icon = "ðŸ¾", tier = 1, basePrice = 7, volatility = 0.1 },
    Ligre2 = { id = "Ligre2", displayName = "Juicy Hide", icon = "ðŸ§¥", tier = 2, basePrice = 45, volatility = 0.2 },
    Ligre3 = { id = "Ligre3", displayName = "Fruit Armor", icon = "ðŸ›¡ï¸", tier = 3, basePrice = 250, volatility = 0.5 },
    Ligre4 = { id = "Ligre4", displayName = "The Hybrid King", icon = "ðŸ¦", tier = 4, basePrice = 1900, volatility = 0.8 },

    -- Tim_Cheese
    Cheese1 = { id = "Cheese1", displayName = "Yellow Crumb", icon = "ðŸ§€", tier = 1, basePrice = 4, volatility = 0.1 },
    Cheese2 = { id = "Cheese2", displayName = "Wedge of Swiss", icon = "ðŸ§€", tier = 2, basePrice = 25, volatility = 0.2 },
    Cheese3 = { id = "Cheese3", displayName = "Melting Fondue", icon = "ðŸ«•", tier = 3, basePrice = 140, volatility = 0.5 },
    Cheese4 = { id = "Cheese4", displayName = "The Golden Wheel", icon = "ðŸŒ•", tier = 4, basePrice = 1000, volatility = 0.8 },

    -- Torrtuginni Dragonfrutini
    Dragon1 = { id = "Dragon1", displayName = "Pink Scale", icon = "ðŸ›¡ï¸", tier = 1, basePrice = 7, volatility = 0.1 },
    Dragon2 = { id = "Dragon2", displayName = "Dragon Fruit", icon = "ðŸŒµ", tier = 2, basePrice = 45, volatility = 0.2 },
    Dragon3 = { id = "Dragon3", displayName = "Turtle Shell", icon = "ðŸ¢", tier = 3, basePrice = 240, volatility = 0.5 },
    Dragon4 = { id = "Dragon4", displayName = "The Mythic Dragon", icon = "ðŸ²", tier = 4, basePrice = 1900, volatility = 0.8 },

    -- Tralalero_Tralala
    Tra1 = { id = "Tra1", displayName = "Single Note", icon = "ðŸŽµ", tier = 1, basePrice = 4, volatility = 0.1 },
    Tra2 = { id = "Tra2", displayName = "Music Sheet", icon = "ðŸ“„", tier = 2, basePrice = 25, volatility = 0.2 },
    Tra3 = { id = "Tra3", displayName = "Microphone", icon = "ðŸŽ¤", tier = 3, basePrice = 150, volatility = 0.5 },
    Tra4 = { id = "Tra4", displayName = "Grand Piano", icon = "ðŸŽ¹", tier = 4, basePrice = 1100, volatility = 0.8 },

    -- Trenostruzzo_Turbo_3000
    Train1 = { id = "Train1", displayName = "Iron Bolt", icon = "ðŸ”©", tier = 1, basePrice = 10, volatility = 0.1 },
    Train2 = { id = "Train2", displayName = "Coal Lump", icon = "ðŸª¨", tier = 2, basePrice = 55, volatility = 0.2 },
    Train3 = { id = "Train3", displayName = "Turbo Engine", icon = "âš™ï¸", tier = 3, basePrice = 300, volatility = 0.5 },
    Train4 = { id = "Train4", displayName = "The Bullet Ostrich", icon = "ðŸš„", tier = 4, basePrice = 2200, volatility = 0.8 },

    -- Tric_Trac_Baraboom
    Boom1 = { id = "Boom1", displayName = "Fused Wire", icon = "ðŸ§µ", tier = 1, basePrice = 6, volatility = 0.1 },
    Boom2 = { id = "Boom2", displayName = "Gunpowder", icon = "ðŸ§‚", tier = 2, basePrice = 40, volatility = 0.3 },
    Boom3 = { id = "Boom3", displayName = "Heavy Crate", icon = "ðŸ“¦", tier = 3, basePrice = 220, volatility = 0.5 },
    Boom4 = { id = "Boom4", displayName = "The Grand Finale", icon = "ðŸŽ†", tier = 4, basePrice = 1600, volatility = 0.8 },

    -- Trippi_Troppi
    Trip1 = { id = "Trip1", displayName = "Old Shoe", icon = "ðŸ‘Ÿ", tier = 1, basePrice = 5, volatility = 0.1 },
    Trip2 = { id = "Trip2", displayName = "Energy Bar", icon = "ðŸ«", tier = 2, basePrice = 30, volatility = 0.2 },
    Trip3 = { id = "Trip3", displayName = "Hiking Staff", icon = "ðŸ¦¯", tier = 3, basePrice = 180, volatility = 0.5 },
    Trip4 = { id = "Trip4", displayName = "World Traveler", icon = "ðŸŒ", tier = 4, basePrice = 1300, volatility = 0.8 },

    -- Trulimero_Trulicina
    Truli1 = { id = "Truli1", displayName = "Small Shard", icon = "ðŸ’Ž", tier = 1, basePrice = 5, volatility = 0.1 },
    Truli2 = { id = "Truli2", displayName = "Glow Stone", icon = "ðŸª¨", tier = 2, basePrice = 35, volatility = 0.2 },
    Truli3 = { id = "Truli3", displayName = "Magic Charm", icon = "ðŸ§¿", tier = 3, basePrice = 190, volatility = 0.5 },
    Truli4 = { id = "Truli4", displayName = "The Divine Spark", icon = "âœ¨", tier = 4, basePrice = 1450, volatility = 0.8 },

    -- Tung_Tung_Tung_Sahur
    Tung1 = { id = "Tung1", displayName = "Steel Plate", icon = "ðŸ§±", tier = 1, basePrice = 8, volatility = 0.1 },
    Tung2 = { id = "Tung2", displayName = "Heavy Hammer", icon = "ðŸ”¨", tier = 2, basePrice = 50, volatility = 0.2 },
    Tung3 = { id = "Tung3", displayName = "Drum Kit", icon = "ðŸ¥", tier = 3, basePrice = 260, volatility = 0.5 },
    Tung4 = { id = "Tung4", displayName = "The Sahur Master", icon = "ðŸ‘‘", tier = 4, basePrice = 2000, volatility = 0.8 },

    -- Unclito_Samito
    Sam1 = { id = "Sam1", displayName = "Red Stripe", icon = "ðŸ§£", tier = 1, basePrice = 6, volatility = 0.1 },
    Sam2 = { id = "Sam2", displayName = "Blue Star", icon = "â­", tier = 2, basePrice = 40, volatility = 0.2 },
    Sam3 = { id = "Sam3", displayName = "Top Hat", icon = "ðŸŽ©", tier = 3, basePrice = 220, volatility = 0.5 },
    Sam4 = { id = "Sam4", displayName = "The Patriot's Pride", icon = "ðŸ‡ºðŸ‡¸", tier = 4, basePrice = 1600, volatility = 0.8 },

    -- Zibra Zubra Zibralini
    Zebra1 = { id = "Zebra1", displayName = "Black Stripe", icon = "ðŸ¦“", tier = 1, basePrice = 5, volatility = 0.1 },
    Zebra2 = { id = "Zebra2", displayName = "White Stripe", icon = "âšª", tier = 2, basePrice = 30, volatility = 0.2 },
    Zebra3 = { id = "Zebra3", displayName = "Savannah Grass", icon = "ðŸŒ¾", tier = 3, basePrice = 170, volatility = 0.5 },
    Zebra4 = { id = "Zebra4", displayName = "The Prism Zebra", icon = "ðŸŒˆ", tier = 4, basePrice = 1300, volatility = 0.8 },
}

--------------------------------------------------------------------------------
-- BRAINROT â†’ ITEM MAPPING (Hver model har sin egen rÃ¦kke)
--------------------------------------------------------------------------------

ItemConfig.BrainrotItems = {
    ["Avocadini Guffo"] = { tier1 = "Guac1", tier2 = "Guac2", tier3 = "Guac3", tier4 = "Guac4" },
    ["Ballerina_Cappuccina"] = { tier1 = "Cap1", tier2 = "Cap2", tier3 = "Cap3", tier4 = "Cap4" },
    ["Ballerino Lololo"] = { tier1 = "Dance1", tier2 = "Dance2", tier3 = "Dance3", tier4 = "Dance4" },
    ["Bambini_Crostini"] = { tier1 = "Toast1", tier2 = "Toast2", tier3 = "Toast3", tier4 = "Toast4" },
    ["Bananita_Dolphinita"] = { tier1 = "BanDolph1", tier2 = "BanDolph2", tier3 = "BanDolph3", tier4 = "BanDolph4" },
    ["Bandito_Bobritto"] = { tier1 = "Taco1", tier2 = "Taco2", tier3 = "Taco3", tier4 = "Taco4" },
    ["Blueberrinni_Octopusini"] = { tier1 = "BerryOcto1", tier2 = "BerryOcto2", tier3 = "BerryOcto3", tier4 = "BerryOcto4" },
    ["Bombardiro_Crocodilo"] = { tier1 = "CrocBomb1", tier2 = "CrocBomb2", tier3 = "CrocBomb3", tier4 = "CrocBomb4" },
    ["Bombombini_Gusini"] = { tier1 = "Goose1", tier2 = "Goose2", tier3 = "Goose3", tier4 = "Goose4" },
    ["Boneca_Ambalabu"] = { tier1 = "Doll1", tier2 = "Doll2", tier3 = "Doll3", tier4 = "Doll4" },
    ["Brainrot God Lucky Block"] = { tier1 = "GodLuck1", tier2 = "GodLuck2", tier3 = "GodLuck3", tier4 = "GodLuck4" },
    ["Brr_Brr_Patapim"] = { tier1 = "Brr1", tier2 = "Brr2", tier3 = "Brr3", tier4 = "Brr4" },
    ["Brri_Brri_Bicus_Dicus_Bombicus"] = { tier1 = "Bicus1", tier2 = "Bicus2", tier3 = "Bicus3", tier4 = "Bicus4" },
    ["Burbaloni_Loliloli"] = { tier1 = "Bubble1", tier2 = "Bubble2", tier3 = "Bubble3", tier4 = "Bubble4" },
    ["Cacto Hipopotamo"] = { tier1 = "Cact1", tier2 = "Cact2", tier3 = "Cact3", tier4 = "Cact4" },
    ["Cappuccino_Assassino"] = { tier1 = "KillerCoffee1", tier2 = "KillerCoffee2", tier3 = "KillerCoffee3", tier4 = "KillerCoffee4" },
    ["Cavallo_Virtuoso"] = { tier1 = "Horse1", tier2 = "Horse2", tier3 = "Horse3", tier4 = "Horse4" },
    ["Chef_Crabracadabra"] = { tier1 = "Crab1", tier2 = "Crab2", tier3 = "Crab3", tier4 = "Crab4" },
    ["Chicleteira Bicicleteira"] = { tier1 = "Bike1", tier2 = "Bike2", tier3 = "Bike3", tier4 = "Bike4" },
    ["Chimpanzini Spiderini"] = { tier1 = "ChimpSpy1", tier2 = "ChimpSpy2", tier3 = "ChimpSpy3", tier4 = "ChimpSpy4" },
    ["Chimpanzini_Bananini"] = { tier1 = "ChimpBan1", tier2 = "ChimpBan2", tier3 = "ChimpBan3", tier4 = "ChimpBan4" },
    ["Cocofanto_Elefanto"] = { tier1 = "Elephant1", tier2 = "Elephant2", tier3 = "Elephant3", tier4 = "Elephant4" },
    ["Espresso Signora"] = { tier1 = "Signora1", tier2 = "Signora2", tier3 = "Signora3", tier4 = "Signora4" },
    ["Fluri_flura"] = { tier1 = "Fluri1", tier2 = "Fluri2", tier3 = "Fluri3", tier4 = "Fluri4" },
    ["Frigo_Camelo"] = { tier1 = "Camel1", tier2 = "Camel2", tier3 = "Camel3", tier4 = "Camel4" },
    ["Gangster_Footera"] = { tier1 = "Gang1", tier2 = "Gang2", tier3 = "Gang3", tier4 = "Gang4" },
    ["Garama_and_Madundung"] = { tier1 = "Garama1", tier2 = "Garama2", tier3 = "Garama3", tier4 = "Garama4" },
    ["Gattatino Neonino"] = { tier1 = "Neon1", tier2 = "Neon2", tier3 = "Neon3", tier4 = "Neon4" },
    ["Gattatino_Nyanino"] = { tier1 = "Nyan1", tier2 = "Nyan2", tier3 = "Nyan3", tier4 = "Nyan4" },
    ["Girafa_Celestre"] = { tier1 = "Giraffe1", tier2 = "Giraffe2", tier3 = "Giraffe3", tier4 = "Giraffe4" },
    ["Glorbo_Fruttodrillo"] = { tier1 = "Glorbo1", tier2 = "Glorbo2", tier3 = "Glorbo3", tier4 = "Glorbo4" },
    ["Gorillo Watermelondrillo"] = { tier1 = "Melon1", tier2 = "Melon2", tier3 = "Melon3", tier4 = "Melon4" },
    ["Graipuss_Medussi"] = { tier1 = "Grai1", tier2 = "Grai2", tier3 = "Grai3", tier4 = "Grai4" },
    ["La_Grande_Combinasion"] = { tier1 = "Combo1", tier2 = "Combo2", tier3 = "Combo3", tier4 = "Combo4" },
    ["La_Vacca_Saturno_Saturnita"] = { tier1 = "Cow1", tier2 = "Cow2", tier3 = "Cow3", tier4 = "Cow4" },
    ["Las Tralaleritas"] = { tier1 = "Trala1", tier2 = "Trala2", tier3 = "Trala3", tier4 = "Trala4" },
    ["Las Vaquitas Saturnitas"] = { tier1 = "Vaqu1", tier2 = "Vaqu2", tier3 = "Vaqu3", tier4 = "Vaqu4" },
    ["Lionel_Cactuseli"] = { tier1 = "Messi1", tier2 = "Messi2", tier3 = "Messi3", tier4 = "Messi4" },
    ["LirilÃ¬_LarilÃ "] = { tier1 = "Liri1", tier2 = "Liri2", tier3 = "Liri3", tier4 = "Liri4" },
    ["Los Crocodillitos"] = { tier1 = "SmallCroc1", tier2 = "SmallCroc2", tier3 = "SmallCroc3", tier4 = "SmallCroc4" },
    ["Los_Tralaleritos"] = { tier1 = "Traler1", tier2 = "Traler2", tier3 = "Traler3", tier4 = "Traler4" },
    ["Mat_teo"] = { tier1 = "Matteo1", tier2 = "Matteo2", tier3 = "Matteo3", tier4 = "Matteo4" },
    ["Mythic Lucky Block"] = { tier1 = "MythLuck1", tier2 = "MythLuck2", tier3 = "MythLuck3", tier4 = "MythLuck4" },
    ["Noobini_Pizzanini"] = { tier1 = "PizzaCrust", tier2 = "ColdPizza", tier3 = "DeepDish", tier4 = "PartyPizza" },
    ["Nuclearo Dinossauro"] = { tier1 = "NukeDino1", tier2 = "NukeDino2", tier3 = "NukeDino3", tier4 = "NukeDino4" },
    ["Odin_Din_Din_Dun"] = { tier1 = "Odin1", tier2 = "Odin2", tier3 = "Odin3", tier4 = "Odin4" },
    ["Orangutini_Ananassini"] = { tier1 = "Orang1", tier2 = "Orang2", tier3 = "Orang3", tier4 = "Orang4" },
    ["Orcalero Orcala"] = { tier1 = "Orca1", tier2 = "Orca2", tier3 = "Orca3", tier4 = "Orca4" },
    ["Pandaccini Bananini"] = { tier1 = "Panda1", tier2 = "Panda2", tier3 = "Panda3", tier4 = "Panda4" },
    ["Perochello_Lemonchello"] = { tier1 = "Lemon1", tier2 = "Lemon2", tier3 = "Lemon3", tier4 = "Lemon4" },
    ["Piccione Macchina"] = { tier1 = "Pigeon1", tier2 = "Pigeon2", tier3 = "Pigeon3", tier4 = "Pigeon4" },
    ["Pipi_Kiwi"] = { tier1 = "Kiwi1", tier2 = "Kiwi2", tier3 = "Kiwi3", tier4 = "Kiwi4" },
    ["Pot Hotspot"] = { tier1 = "Pot1", tier2 = "Pot2", tier3 = "Pot3", tier4 = "Pot4" },
    ["Rhino_Toasterino"] = { tier1 = "ToastRhino1", tier2 = "ToastRhino2", tier3 = "ToastRhino3", tier4 = "ToastRhino4" },
    ["Salamino Penguino"] = { tier1 = "Penguin1", tier2 = "Penguin2", tier3 = "Penguin3", tier4 = "Penguin4" },
    ["Sammyni_Spyderini"] = { tier1 = "Spy1", tier2 = "Spy2", tier3 = "Spy3", tier4 = "Spy4" },
    ["Secret Lucky Block"] = { tier1 = "SecLuck1", tier2 = "SecLuck2", tier3 = "SecLuck3", tier4 = "SecLuck4" },
    ["Spioniro Golubiro"] = { tier1 = "Spion1", tier2 = "Spion2", tier3 = "Spion3", tier4 = "Spion4" },
    ["Statutino Libertino"] = { tier1 = "Lib1", tier2 = "Lib2", tier3 = "Lib3", tier4 = "Lib4" },
    ["Strawberrelli Flamingelli"] = { tier1 = "Flam1", tier2 = "Flam2", tier3 = "Flam3", tier4 = "Flam4" },
    ["Svinina_Bombardino"] = { tier1 = "PigBomb1", tier2 = "PigBomb2", tier3 = "PigBomb3", tier4 = "PigBomb4" },
    ["Ta_Ta_Ta_Ta_Sahur"] = { tier1 = "Sahur1", tier2 = "Sahur2", tier3 = "Sahur3", tier4 = "Sahur4" },
    ["Talpa_Di_Fero"] = { tier1 = "Mole1", tier2 = "Mole2", tier3 = "Mole3", tier4 = "Mole4" },
    ["Tigrilini Watermelini"] = { tier1 = "TigMelon1", tier2 = "TigMelon2", tier3 = "TigMelon3", tier4 = "TigMelon4" },
    ["Tigroligre Frutonni"] = { tier1 = "Ligre1", tier2 = "Ligre2", tier3 = "Ligre3", tier4 = "Ligre4" },
    ["Tim_Cheese"] = { tier1 = "Cheese1", tier2 = "Cheese2", tier3 = "Cheese3", tier4 = "Cheese4" },
    ["Torrtuginni Dragonfrutini"] = { tier1 = "Dragon1", tier2 = "Dragon2", tier3 = "Dragon3", tier4 = "Dragon4" },
    ["Tralalero_Tralala"] = { tier1 = "Tra1", tier2 = "Tra2", tier3 = "Tra3", tier4 = "Tra4" },
    ["Trenostruzzo_Turbo_3000"] = { tier1 = "Train1", tier2 = "Train2", tier3 = "Train3", tier4 = "Train4" },
    ["Tric_Trac_Baraboom"] = { tier1 = "Boom1", tier2 = "Boom2", tier3 = "Boom3", tier4 = "Boom4" },
    ["Trippi_Troppi"] = { tier1 = "Trip1", tier2 = "Trip2", tier3 = "Trip3", tier4 = "Trip4" },
    ["Trulimero_Trulicina"] = { tier1 = "Truli1", tier2 = "Truli2", tier3 = "Truli3", tier4 = "Truli4" },
    ["Tung_Tung_Tung_Sahur"] = { tier1 = "Tung1", tier2 = "Tung2", tier3 = "Tung3", tier4 = "Tung4" },
    ["Unclito_Samito"] = { tier1 = "Sam1", tier2 = "Sam2", tier3 = "Sam3", tier4 = "Sam4" },
    ["Zibra Zubra Zibralini"] = { tier1 = "Zebra1", tier2 = "Zebra2", tier3 = "Zebra3", tier4 = "Zebra4" },
}

--------------------------------------------------------------------------------
-- HELPER FUNCTIONS
--------------------------------------------------------------------------------

function ItemConfig.GetItem(itemId: string): ItemDefinition?
    return ItemConfig.Items[itemId]
end

function ItemConfig.GetProductions(modelName: string, ownedCount: number): {{itemId: string, rate: number}}
    -- Finder rÃ¦kken baseret pÃ¥ prÃ¦cis modelnavn
    local mapping = ItemConfig.BrainrotItems[modelName]
    if not mapping then return {} end
    
    local productions = {}
    local thresholds = ItemConfig.MilestoneThresholds
    local rates = ItemConfig.ProductionRates
    
    if ownedCount >= thresholds.tier1 then table.insert(productions, {itemId = mapping.tier1, rate = rates.tier1}) end
    if ownedCount >= thresholds.tier2 then table.insert(productions, {itemId = mapping.tier2, rate = rates.tier2}) end
    if ownedCount >= thresholds.tier3 then table.insert(productions, {itemId = mapping.tier3, rate = rates.tier3}) end
    if ownedCount >= thresholds.tier4 then table.insert(productions, {itemId = mapping.tier4, rate = rates.tier4}) end
    
    return productions
end

--[[
    Determines the stock market Sector for a brainrot based on its name.
    Replaces the old hardcoded Category system.
]]
function ItemConfig.GetSector(modelName: string): string
    local name = string.lower(modelName)
    
    local SECTORS = {
        Food = {"avocado", "pizza", "burrito", "coffee", "cheese", "cap", "signora", "lemon", "toast", "crostini", "guac", "berry", "crab", "glorbo", "melon", "fruit", "pineapple", "strawber"},
        Animals = {"chimp", "panda", "giraffe", "croc", "pig", "zebra", "orca", "whale", "dolphin", "octopus", "goose", "horse", "kiwi", "lion", "tiger", "penguin", "flamingo", "mole", "spider", "spyder"},
        Entertainment = {"dance", "music", "trala", "sahur", "symphony", "virtuoso", "bell", "choir", "rhythm", "drum", "trumpet", "marching", "parade", "lololo", "larila"},
        Mystic = {"god", "odin", "mythic", "lucky", "relic", "artifact", "ancient", "dragon", "kraken", "forbidden", "spell", "magic", "secret", "divine", "bicus", "truli", "bubble"},
        Tech = {"neon", "cyber", "machine", "hybrid", "combined", "drone", "turbo", "bullet", "engine", "battery", "neon", "cyber", "volt", "light", "circuit", "train", "combo", "mat_teo"},
        Action = {"bombard", "assassin", "gangster", "bandit", "crocbomb", "boom", "nuke", "atomic", "spy", "stealth", "binoculars", "camera", "spion", "detonator", "missile", "grenade", "trip", "matteo"},
    }
    
    for sector, keywords in pairs(SECTORS) do
        for _, keyword in ipairs(keywords) do
            if string.find(name, keyword) then
                return sector
            end
        end
    end
    
    return "Neutral" -- Fallback
end

return ItemConfig


================================================================================
FILE: src\shared\ItemTypes.luau
================================================================================

--[[
	ItemTypes.luau
	
	â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	                     TYPE DEFINITIONS FOR TWO RESOURCE SYSTEMS
	â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	This file defines types for BOTH resource systems in the game:
	
	â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
	â”‚  PERMANENT ASSETS (Collection)                                              â”‚
	â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                          â”‚
	â”‚  â€¢ BrainrotUnit  - Brainrot characters the player OWNS (InventoryManager)   â”‚
	â”‚  â€¢ Artifact      - Equipment items the player OWNS (ArtifactManager)        â”‚
	â”‚  These PERSIST forever, are saved to profile, and never get consumed.       â”‚
	â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
	â”‚  TRANSIENT RESOURCES (Factory/Production)                                   â”‚
	â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                  â”‚
	â”‚  â€¢ FactoryItem   - Resources produced by units (ItemStorageManager)         â”‚
	â”‚  These are TEMPORARY, get sold for money, and are consumed.                 â”‚
	â”‚  Flow: ItemProductionManager â†’ ItemStorageManager â†’ TransportManager â†’ Sold â”‚
	â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
]]

--------------------------------------------------------------------------------
-- PERMANENT ASSETS: Units & Artifacts (stored in InventoryManager/ArtifactManager)
--------------------------------------------------------------------------------

-- Category discriminator for collection items
export type CollectionItemType = "Unit" | "Artifact"

--[[
	BrainrotUnit: A permanent character the player owns.
	
	Stored in: InventoryManager
	Lifetime: PERMANENT - saved to profile, never consumed
	
	Examples: "Skibidi_Toilet", "Bombardiro_Crocodilo", "Sigma"
]]
export type BrainrotUnit = {
	UUID: string,               -- Unique identifier for this specific unit instance
	Type: "Unit",               -- Always "Unit" for BrainrotUnits
	Id: string,                 -- Model name (e.g. "Skibidi_Toilet")
	Name: string,               -- Display name (e.g. "Skibidi Toilet")
	Rarity: string,             -- "Normal", "Rare", "Legendary", etc.
	Icon: string,               -- TextureId or Emoji for UI display
	
	-- State
	IsPlaced: boolean,          -- true if placed on grid, false if in inventory
	
	-- Unit-specific data
	Data: {
		Level: number,                      -- Current level (1+)
		Equipment: {[string]: string}?,     -- Map of slot â†’ artifactUUID
	}
}

--[[
	Artifact: A permanent equipment item the player owns.
	
	Stored in: ArtifactManager
	Lifetime: PERMANENT - saved to profile, never consumed
	
	Examples: "Ruby_Amulet", "Speed_Boots", "Power_Ring"
]]
export type Artifact = {
	UUID: string,               -- Unique identifier for this artifact instance
	Type: "Artifact",           -- Always "Artifact" for Artifacts
	Id: string,                 -- Artifact type ID (e.g. "Ruby_Amulet")
	Name: string,               -- Display name
	Rarity: string,             -- Rarity tier
	Icon: string,               -- TextureId or Emoji
	
	-- State
	IsEquipped: boolean,        -- true if equipped to a unit
	
	-- Artifact-specific data
	Data: {
		Stats: {[string]: number}?,  -- Calculated stats (damage, speed, etc.)
		EquippedTo: string?,         -- UUID of the unit this is equipped to
	}
}

--------------------------------------------------------------------------------
-- TRANSIENT RESOURCES: Factory Production (stored in ItemStorageManager)
--------------------------------------------------------------------------------

--[[
	FactoryItem: A transient resource produced by units.
	
	Stored in: ItemStorageManager (silos/backpack)
	Lifetime: TEMPORARY - produced, stored, sold, consumed
	
	Flow: Unit produces â†’ Storage (silo) â†’ Backpack â†’ Sell at Market
	
	Examples: "ToiletPaper", "Plunger", "Firecracker", "ProteinBar"
	
	NOTE: For the full item DEFINITION (basePrice, volatility, tier, etc.),
	      see ItemConfig.luau â†’ ItemDefinition. This type is for runtime stacks.
]]
export type FactoryItem = {
	itemId: string,             -- References ItemConfig.Items[itemId]
	count: number,              -- Stack count in storage/backpack
}

--------------------------------------------------------------------------------
-- LEGACY ALIASES (for backwards compatibility, prefer specific types above)
--------------------------------------------------------------------------------

-- CollectionItem: Union type for any permanent asset (Unit OR Artifact)
-- @deprecated Prefer using BrainrotUnit or Artifact directly for strict typing
export type CollectionItem = {
	UUID: string,
	Type: CollectionItemType,
	Id: string,
	Name: string,
	Rarity: string,
	Icon: string,
	
	-- State (one will be relevant depending on Type)
	IsEquipped: boolean,  -- For artifacts
	IsPlaced: boolean,    -- For units
	
	-- Combined data (fields optional based on Type)
	Data: {
		-- Unit specific
		Level: number?, 
		Equipment: {[string]: string}?,
		
		-- Artifact specific
		Stats: {[string]: number}?,
		EquippedTo: string?,
	}
}

-- Legacy alias
export type ItemType = CollectionItemType

return {}


================================================================================
FILE: src\shared\PrestigeConfig.luau
================================================================================

local PrestigeConfig = {}

-- Meatball calculation constants
PrestigeConfig.MEATBALL_DIVISOR = 1_000_000       -- Lifetime earnings divisor
PrestigeConfig.MEATBALL_MULTIPLIER = 150          -- Square root multiplier
PrestigeConfig.MEATBALL_BONUS_RATE = 0.02         -- +2% income per meatball
PrestigeConfig.MINIMUM_PRESTIGE_GAIN = 10         -- Must gain at least 10 meatballs

-- Meatball Shop items with progressive unlock
PrestigeConfig.SHOP_ITEMS = {
    -- Tier 1: Unlocked at 0 lifetime meatballs
    { 
        Id = "GoldenBoost1",
        Name = "Golden Boost I", 
        Price = 50, 
        Effect = "IncomeMultiplier", 
        Value = 0.10, 
        UnlockAt = 0,
        Description = "Increases all income by 10%"
    },
    { 
        Id = "QuickStart1",
        Name = "Quick Start I", 
        Price = 100, 
        Effect = "StartingMoney", 
        Value = 500, 
        UnlockAt = 0,
        Description = "Start with +$500 after prestige"
    },
    
    -- Tier 2: Unlocked at 500 lifetime meatballs
    { 
        Id = "GoldenBoost2",
        Name = "Golden Boost II", 
        Price = 200, 
        Effect = "IncomeMultiplier", 
        Value = 0.25, 
        UnlockAt = 500,
        Description = "Increases all income by another 25%"
    },
    { 
        Id = "UnitBooster1",
        Name = "Unit Booster: Tier 1", 
        Price = 300, 
        Effect = "UnitBoost", 
        Value = { Tier = 1, Multiplier = 5 }, 
        UnlockAt = 500,
        Description = "Tier 1 units earn 5x income"
    },
    
    -- Tier 3: Unlocked at 2000 lifetime meatballs
    { 
        Id = "GoldenBoost3",
        Name = "Golden Boost III", 
        Price = 500, 
        Effect = "IncomeMultiplier", 
        Value = 0.50, 
        UnlockAt = 2000,
        Description = "Increases all income by another 50%"
    },
    { 
        Id = "QuickStart2",
        Name = "Quick Start II", 
        Price = 400, 
        Effect = "StartingMoney", 
        Value = 2500, 
        UnlockAt = 2000,
        Description = "Start with +$2500 after prestige"
    },
}

-- Helper to get item by ID
function PrestigeConfig.GetItem(itemId)
    for _, item in ipairs(PrestigeConfig.SHOP_ITEMS) do
        if item.Id == itemId then
            return item
        end
    end
    return nil
end

return PrestigeConfig


================================================================================
FILE: src\shared\RarityConfig.luau
================================================================================

--[[
	RarityConfig.luau

	Shared configuration for unit rarities.
	Handles rarity definitions, probabilities, and multipliers.
]]

export type RarityInfo = {
	chance: number,
	multiplier: number,
	color: Color3
}

local RARITY_CONFIG: {[string]: RarityInfo} = {
	Normal = { chance = 0.90, multiplier = 1, color = Color3.fromRGB(255, 255, 255) },
	Spicy = { chance = 0.09, multiplier = 1.5, color = Color3.fromRGB(255, 80, 80) },
	Galaxy = { chance = 0.01, multiplier = 3.0, color = Color3.fromRGB(180, 100, 255) },
}

local RARITY_ORDER = {"Normal", "Spicy", "Galaxy"}

local RarityConfig = {}

RarityConfig.CONFIG = RARITY_CONFIG
RarityConfig.ORDER = RARITY_ORDER

--[[
	Rolls a random rarity based on configured chances.
]]
function RarityConfig.RollRarity(): string
	local roll = math.random()
	local cumulative = 0
	for _, rarityName in ipairs(RARITY_ORDER) do
		local config = RARITY_CONFIG[rarityName]
		if config then
			cumulative = cumulative + config.chance
			if roll <= cumulative then return rarityName end
		end
	end
	return "Normal"
end

--[[
	Gets the numeric value/rank of a rarity (higher is better).
]]
function RarityConfig.GetRarityValue(rarityName: string): number
	for i, name in ipairs(RARITY_ORDER) do
		if name == rarityName then return i end
	end
	return 1
end

--[[
	Gets the multiplier for a given rarity.
]]
function RarityConfig.GetMultiplier(rarityName: string): number
	local config = RARITY_CONFIG[rarityName]
	return config and config.multiplier or 1
end

--[[
	Gets the color for a given rarity.
]]
function RarityConfig.GetColor(rarityName: string): Color3
	local config = RARITY_CONFIG[rarityName]
	return config and config.color or Color3.fromRGB(255, 255, 255)
end

return RarityConfig


================================================================================
FILE: src\shared\ShopConfig.luau
================================================================================

--[[
	ShopConfig ModuleScript
	
	Central database for all 74 purchasable brainrot units.
	Located in ReplicatedStorage so both Server and Client can access it.
	
	Features:
	- Auto-sorted by BasePrice (ascending)
	- Progressive unlock system (5 unlocked initially, +1 on each purchase)
	- Per-unit cost multipliers (higher tiers have steeper curves)
	- Milestone bonuses at 10/25/50/100/200/300/400/500 owned
	- Price Formula: CurrentPrice = BasePrice * (CostMultiplier ^ AmountOwned)
]]

export type UnitConfig = {
	BasePrice: number,
	BaseIncome: number,
	CycleTime: number,
	ModelName: string,
	Description: string?,
	CostMultiplier: number?, -- Optional: overrides default 1.15 multiplier
	ProjectileColor: Color3?, -- Optional: color of income projectile (defaults to white)
	ItemCost: {[string]: number}?, -- Optional: items required to purchase (burned on buy)
}

export type MilestoneInfo = {
	quantity: number,
	milestoneType: "speed" | "profit",
	multiplier: number,
}

-- Constants
local INITIAL_UNLOCKED = 5 -- How many units are unlocked from the start
local PRICE_MULTIPLIER = 1.15 -- Default 15% increase per owned unit

-- Milestone definitions (Adventure Capitalist-inspired)
-- Speed milestones halve cycle time, profit milestones multiply income
local MILESTONES: {MilestoneInfo} = {
	{quantity = 10, milestoneType = "speed", multiplier = 2},   -- x2 speed (1/2 cycle)
	{quantity = 25, milestoneType = "speed", multiplier = 2},   -- x4 speed total
	{quantity = 50, milestoneType = "speed", multiplier = 2},   -- x8 speed total
	{quantity = 100, milestoneType = "profit", multiplier = 3}, -- x3 profit
	{quantity = 200, milestoneType = "speed", multiplier = 2},  -- x16 speed total
	{quantity = 300, milestoneType = "profit", multiplier = 3}, -- x9 profit total
	{quantity = 400, milestoneType = "speed", multiplier = 2},  -- x32 speed total
	{quantity = 500, milestoneType = "profit", multiplier = 4}, -- x36 profit total
}

--[[
	All 74 brainrot units with balanced progression.
	Sorted by BasePrice ascending.
	Model names match exactly with ReplicatedStorage.Brainrots folder.
]]
local Units: {[string]: UnitConfig} = {
	-- Tier 1: Starter Units ($50 - $400)
	["Avocadini Guffo"] = {
		BasePrice = 50,
		BaseIncome = 5,
		CycleTime = 3,
		ModelName = "Avocadini Guffo",
		Description = "A quirky avocado owl friend.",
		ProjectileColor = Color3.fromRGB(255, 255, 255),
	},
	["Ballerina_Cappuccina"] = {
		BasePrice = 100,
		BaseIncome = 8,
		CycleTime = 3,
		ModelName = "Ballerina_Cappuccina",
		Description = "Dancing coffee ballerina.",
		ProjectileColor = Color3.fromRGB(255, 255, 255),
	},
	["Ballerino Lololo"] = {
		BasePrice = 175,
		BaseIncome = 12,
		CycleTime = 3,
		ModelName = "Ballerino Lololo",
		Description = "The dancing lololo!",
		ProjectileColor = Color3.fromRGB(255, 255, 255),
	},
	["Bambini_Crostini"] = {
		BasePrice = 275,
		BaseIncome = 18,
		CycleTime = 3,
		ModelName = "Bambini_Crostini",
		Description = "Crispy little ones.",
		ProjectileColor = Color3.fromRGB(255, 255, 255),
	},
	["Bananita_Dolphinita"] = {
		BasePrice = 400,
		BaseIncome = 25,
		CycleTime = 4,
		ModelName = "Bananita_Dolphinita",
		Description = "Banana dolphin vibes!",
		ProjectileColor = Color3.fromRGB(255, 255, 255),
	},
	
	-- Tier 2: Early Game ($2.5k - $22.5k)
	["Bandito_Bobritto"] = {
		BasePrice = 2500,
		BaseIncome = 150,
		CycleTime = 4,
		ModelName = "Bandito_Bobritto",
		Description = "The sneaky beaver bandit.",
		ProjectileColor = Color3.fromRGB(255, 255, 150),
	},
	["Blueberrinni_Octopusini"] = {
		BasePrice = 3750,
		BaseIncome = 210,
		CycleTime = 4,
		ModelName = "Blueberrinni_Octopusini",
		Description = "Berry tentacle power!",
		ProjectileColor = Color3.fromRGB(255, 255, 150),
	},
	["Bombardiro_Crocodilo"] = {
		BasePrice = 5500,
		BaseIncome = 280,
		CycleTime = 4,
		ModelName = "Bombardiro_Crocodilo",
		Description = "Explosive croc energy!",
		ProjectileColor = Color3.fromRGB(255, 255, 150),
	},
	["Bombombini_Gusini"] = {
		BasePrice = 7500,
		BaseIncome = 360,
		CycleTime = 4,
		ModelName = "Bombombini_Gusini",
		Description = "Boom boom goose!",
		ProjectileColor = Color3.fromRGB(255, 255, 150),
	},
	["Boneca_Ambalabu"] = {
		BasePrice = 10000,
		BaseIncome = 450,
		CycleTime = 4,
		ModelName = "Boneca_Ambalabu",
		Description = "Mysterious doll vibes.",
		ProjectileColor = Color3.fromRGB(255, 255, 150),
	},
	["Brr_Brr_Patapim"] = {
		BasePrice = 13500,
		BaseIncome = 580,
		CycleTime = 4,
		ModelName = "Brr_Brr_Patapim",
		Description = "Cold cash generator.",
		ProjectileColor = Color3.fromRGB(255, 255, 150),
	},
	["Brri_Brri_Bicus_Dicus_Bombicus"] = {
		BasePrice = 17500,
		BaseIncome = 720,
		CycleTime = 5,
		ModelName = "Brri_Brri_Bicus_Dicus_Bombicus",
		Description = "The ultimate combo name!",
		ProjectileColor = Color3.fromRGB(255, 255, 150),
	},
	["Burbaloni_Loliloli"] = {
		BasePrice = 22500,
		BaseIncome = 900,
		CycleTime = 5,
		ModelName = "Burbaloni_Loliloli",
		Description = "Bubbly personality.",
		ProjectileColor = Color3.fromRGB(255, 255, 150),
	},
	
	-- Tier 3: Mid Game ($150k - $3.2M)
	["Cacto Hipopotamo"] = {
		BasePrice = 150000,
		BaseIncome = 5000,
		CycleTime = 5,
		ModelName = "Cacto Hipopotamo",
		Description = "Prickly hippo power!",
		ProjectileColor = Color3.fromRGB(255, 215, 0),
	},
	["Cappuccino_Assassino"] = {
		BasePrice = 225000,
		BaseIncome = 7200,
		CycleTime = 5,
		ModelName = "Cappuccino_Assassino",
		Description = "Deadly coffee vibes.",
		ProjectileColor = Color3.fromRGB(255, 215, 0),
	},
	["Cavallo_Virtuoso"] = {
		BasePrice = 325000,
		BaseIncome = 10000,
		CycleTime = 5,
		ModelName = "Cavallo_Virtuoso",
		Description = "Virtuoso horse!",
		ProjectileColor = Color3.fromRGB(255, 215, 0),
	},
	["Chef_Crabracadabra"] = {
		BasePrice = 450000,
		BaseIncome = 13500,
		CycleTime = 5,
		ModelName = "Chef_Crabracadabra",
		Description = "Magic crab chef!",
		ProjectileColor = Color3.fromRGB(255, 215, 0),
	},
	["Chicleteira Bicicleteira"] = {
		BasePrice = 600000,
		BaseIncome = 17500,
		CycleTime = 5,
		ModelName = "Chicleteira Bicicleteira",
		Description = "Gum on wheels!",
		ProjectileColor = Color3.fromRGB(255, 215, 0),
	},
	["Chimpanzini Spiderini"] = {
		BasePrice = 800000,
		BaseIncome = 22500,
		CycleTime = 5,
		ModelName = "Chimpanzini Spiderini",
		Description = "Spider monkey fusion!",
		ProjectileColor = Color3.fromRGB(255, 215, 0),
	},
	["Chimpanzini_Bananini"] = {
		BasePrice = 1000000,
		BaseIncome = 27500,
		CycleTime = 6,
		ModelName = "Chimpanzini_Bananini",
		Description = "Monke banana business!",
		ProjectileColor = Color3.fromRGB(255, 215, 0),
	},
	["Cocofanto_Elefanto"] = {
		BasePrice = 1300000,
		BaseIncome = 35000,
		CycleTime = 6,
		ModelName = "Cocofanto_Elefanto",
		Description = "Coconut elephant!",
		ProjectileColor = Color3.fromRGB(255, 215, 0),
	},
	["Espresso Signora"] = {
		BasePrice = 1600000,
		BaseIncome = 42500,
		CycleTime = 6,
		ModelName = "Espresso Signora",
		Description = "The espresso lady!",
		ProjectileColor = Color3.fromRGB(255, 215, 0),
	},
	["Fluri_flura"] = {
		BasePrice = 2000000,
		BaseIncome = 52000,
		CycleTime = 6,
		ModelName = "Fluri_flura",
		Description = "Flowery friend.",
		ProjectileColor = Color3.fromRGB(255, 215, 0),
	},
	["Frigo_Camelo"] = {
		BasePrice = 2500000,
		BaseIncome = 64000,
		CycleTime = 6,
		ModelName = "Frigo_Camelo",
		Description = "Cool camel cash!",
		ProjectileColor = Color3.fromRGB(255, 215, 0),
	},
	["Gangster_Footera"] = {
		BasePrice = 3200000,
		BaseIncome = 80000,
		CycleTime = 6,
		ModelName = "Gangster_Footera",
		Description = "Gangster football!",
		ProjectileColor = Color3.fromRGB(255, 215, 0),
	},
	
	-- Tier 4: Mid-Late Game ($15M - $2.3B) - CostMultiplier: 1.20
	["Garama_and_Madundung"] = {
		BasePrice = 15000000,
		BaseIncome = 350000,
		CycleTime = 6,
		ModelName = "Garama_and_Madundung",
		Description = "Dynamic duo!",
		CostMultiplier = 1.20,
		ProjectileColor = Color3.fromRGB(255, 165, 0),
		ItemCost = { Guac1 = 100, Toast1 = 80 },
	},
	["Gattatino Neonino"] = {
		BasePrice = 25000000,
		BaseIncome = 550000,
		CycleTime = 6,
		ModelName = "Gattatino Neonino",
		Description = "Neon kitty glow!",
		CostMultiplier = 1.20,
		ProjectileColor = Color3.fromRGB(255, 165, 0),
	},
	["Gattatino_Nyanino"] = {
		BasePrice = 40000000,
		BaseIncome = 850000,
		CycleTime = 6,
		ModelName = "Gattatino_Nyanino",
		Description = "Nyan cat vibes!",
		CostMultiplier = 1.20,
		ProjectileColor = Color3.fromRGB(255, 165, 0),
	},
	["Girafa_Celestre"] = {
		BasePrice = 65000000,
		BaseIncome = 1300000,
		CycleTime = 7,
		ModelName = "Girafa_Celestre",
		Description = "Heavenly giraffe!",
		CostMultiplier = 1.20,
		ProjectileColor = Color3.fromRGB(255, 165, 0),
		ItemCost = { Cap1 = 150, Dance1 = 100 },
	},
	["Glorbo_Fruttodrillo"] = {
		BasePrice = 100000000,
		BaseIncome = 1900000,
		CycleTime = 7,
		ModelName = "Glorbo_Fruttodrillo",
		Description = "The legendary Glorbo!",
		CostMultiplier = 1.20,
		ProjectileColor = Color3.fromRGB(255, 165, 0),
	},
	["Gorillo Watermelondrillo"] = {
		BasePrice = 150000000,
		BaseIncome = 2800000,
		CycleTime = 7,
		ModelName = "Gorillo Watermelondrillo",
		Description = "Watermelon gorilla!",
		CostMultiplier = 1.20,
		ProjectileColor = Color3.fromRGB(255, 165, 0),
		ItemCost = { Taco1 = 200, BerryOcto1 = 120 },
	},
	["Graipuss_Medussi"] = {
		BasePrice = 225000000,
		BaseIncome = 4000000,
		CycleTime = 7,
		ModelName = "Graipuss_Medussi",
		Description = "Grape medusa power!",
		CostMultiplier = 1.20,
		ProjectileColor = Color3.fromRGB(255, 165, 0),
	},
	["La_Grande_Combinasion"] = {
		BasePrice = 350000000,
		BaseIncome = 6000000,
		CycleTime = 7,
		ModelName = "La_Grande_Combinasion",
		Description = "The grand combination!",
		CostMultiplier = 1.20,
		ProjectileColor = Color3.fromRGB(255, 165, 0),
		ItemCost = { CrocBomb1 = 250, Goose1 = 200, Doll1 = 150 },
	},
	["La_Vacca_Saturno_Saturnita"] = {
		BasePrice = 500000000,
		BaseIncome = 8500000,
		CycleTime = 7,
		ModelName = "La_Vacca_Saturno_Saturnita",
		Description = "Cosmic cow powers!",
		CostMultiplier = 1.20,
		ProjectileColor = Color3.fromRGB(255, 165, 0),
	},
	["Las Tralaleritas"] = {
		BasePrice = 750000000,
		BaseIncome = 12000000,
		CycleTime = 7,
		ModelName = "Las Tralaleritas",
		Description = "The little tralala girls!",
		CostMultiplier = 1.20,
		ProjectileColor = Color3.fromRGB(255, 165, 0),
		ItemCost = { Brr1 = 300, Bicus1 = 200 },
	},
	["Las Vaquitas Saturnitas"] = {
		BasePrice = 1100000000,
		BaseIncome = 17000000,
		CycleTime = 8,
		ModelName = "Las Vaquitas Saturnitas",
		Description = "Little Saturn cows!",
		CostMultiplier = 1.20,
		ProjectileColor = Color3.fromRGB(255, 165, 0),
	},
	["Lionel_Cactuseli"] = {
		BasePrice = 1600000000,
		BaseIncome = 24000000,
		CycleTime = 8,
		ModelName = "Lionel_Cactuseli",
		Description = "Cactus lion legend!",
		CostMultiplier = 1.20,
		ProjectileColor = Color3.fromRGB(255, 165, 0),
		ItemCost = { Cact1 = 400, KillerCoffee1 = 250, Horse1 = 200 },
	},
	
	-- Tier 5: Late Game ($2.5B - $175B) - CostMultiplier: 1.22
	["LirilÃ¬_LarilÃ "] = {
		BasePrice = 2500000000,
		BaseIncome = 35000000,
		CycleTime = 8,
		ModelName = "LirilÃ¬_LarilÃ ",
		Description = "Musical magic!",
		CostMultiplier = 1.22,
		ProjectileColor = Color3.fromRGB(255, 105, 180),
	},
	["Los Crocodillitos"] = {
		BasePrice = 4000000000,
		BaseIncome = 55000000,
		CycleTime = 8,
		ModelName = "Los Crocodillitos",
		Description = "Little croc gang!",
		CostMultiplier = 1.22,
		ProjectileColor = Color3.fromRGB(255, 105, 180),
	},
	["Los_Tralaleritos"] = {
		BasePrice = 6500000000,
		BaseIncome = 85000000,
		CycleTime = 8,
		ModelName = "Los_Tralaleritos",
		Description = "The tralala boys!",
		CostMultiplier = 1.22,
		ProjectileColor = Color3.fromRGB(255, 105, 180),
	},
	["Mat_teo"] = {
		BasePrice = 10000000000,
		BaseIncome = 125000000,
		CycleTime = 8,
		ModelName = "Mat_teo",
		Description = "It's Mat Teo!",
		CostMultiplier = 1.22,
		ProjectileColor = Color3.fromRGB(255, 105, 180),
	},
	["Noobini_Pizzanini"] = {
		BasePrice = 15000000000,
		BaseIncome = 180000000,
		CycleTime = 8,
		ModelName = "Noobini_Pizzanini",
		Description = "Noob pizza power!",
		CostMultiplier = 1.22,
		ProjectileColor = Color3.fromRGB(255, 105, 180),
	},
	["Nuclearo Dinossauro"] = {
		BasePrice = 22500000000,
		BaseIncome = 260000000,
		CycleTime = 8,
		ModelName = "Nuclearo Dinossauro",
		Description = "Nuclear dino!",
		CostMultiplier = 1.22,
		ProjectileColor = Color3.fromRGB(255, 105, 180),
	},
	["Odin_Din_Din_Dun"] = {
		BasePrice = 32500000000,
		BaseIncome = 360000000,
		CycleTime = 9,
		ModelName = "Odin_Din_Din_Dun",
		Description = "Norse god energy!",
		CostMultiplier = 1.22,
		ProjectileColor = Color3.fromRGB(255, 105, 180),
	},
	["Orangutini_Ananassini"] = {
		BasePrice = 45000000000,
		BaseIncome = 480000000,
		CycleTime = 9,
		ModelName = "Orangutini_Ananassini",
		Description = "Pineapple orangutan!",
		CostMultiplier = 1.22,
		ProjectileColor = Color3.fromRGB(255, 105, 180),
	},
	["Orcalero Orcala"] = {
		BasePrice = 60000000000,
		BaseIncome = 620000000,
		CycleTime = 9,
		ModelName = "Orcalero Orcala",
		Description = "Orca power!",
		CostMultiplier = 1.22,
		ProjectileColor = Color3.fromRGB(255, 105, 180),
	},
	["Pandaccini Bananini"] = {
		BasePrice = 80000000000,
		BaseIncome = 800000000,
		CycleTime = 9,
		ModelName = "Pandaccini Bananini",
		Description = "Panda banana combo!",
		CostMultiplier = 1.22,
		ProjectileColor = Color3.fromRGB(255, 105, 180),
	},
	["Perochello_Lemonchello"] = {
		BasePrice = 105000000000,
		BaseIncome = 1000000000,
		CycleTime = 9,
		ModelName = "Perochello_Lemonchello",
		Description = "Lemon parrot drinks!",
		CostMultiplier = 1.22,
		ProjectileColor = Color3.fromRGB(255, 105, 180),
	},
	["Piccione Macchina"] = {
		BasePrice = 135000000000,
		BaseIncome = 1250000000,
		CycleTime = 9,
		ModelName = "Piccione Macchina",
		Description = "Pigeon machine!",
		CostMultiplier = 1.22,
		ProjectileColor = Color3.fromRGB(255, 105, 180),
	},
	["Pipi_Kiwi"] = {
		BasePrice = 175000000000,
		BaseIncome = 1550000000,
		CycleTime = 9,
		ModelName = "Pipi_Kiwi",
		Description = "Kiwi bird vibes!",
		CostMultiplier = 1.22,
		ProjectileColor = Color3.fromRGB(255, 105, 180),
	},
	
	-- Tier 6: End Game ($500B - $650T) - CostMultiplier: 1.25
	["Pot Hotspot"] = {
		BasePrice = 500000000000,
		BaseIncome = 4000000000,
		CycleTime = 9,
		ModelName = "Pot Hotspot",
		Description = "Hot pot spot!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
		ItemCost = { Guac2 = 100, Crab2 = 80, Elephant2 = 60 },
	},
	["Rhino_Toasterino"] = {
		BasePrice = 850000000000,
		BaseIncome = 6500000000,
		CycleTime = 9,
		ModelName = "Rhino_Toasterino",
		Description = "Toaster rhino!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
	},
	["Salamino Penguino"] = {
		BasePrice = 1500000000000,
		BaseIncome = 10000000000,
		CycleTime = 9,
		ModelName = "Salamino Penguino",
		Description = "Salami penguin!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
	},
	["Sammyni_Spyderini"] = {
		BasePrice = 2500000000000,
		BaseIncome = 15000000000,
		CycleTime = 10,
		ModelName = "Sammyni_Spyderini",
		Description = "Sammy the spider!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
		ItemCost = { ChimpSpy2 = 100, Spy2 = 80, Gang2 = 60 },
	},
	["Spioniro Golubiro"] = {
		BasePrice = 4000000000000,
		BaseIncome = 22000000000,
		CycleTime = 10,
		ModelName = "Spioniro Golubiro",
		Description = "Spy pigeon!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
	},
	["Statutino Libertino"] = {
		BasePrice = 6500000000000,
		BaseIncome = 32000000000,
		CycleTime = 10,
		ModelName = "Statutino Libertino",
		Description = "Liberty statue!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
	},
	["Strawberrelli Flamingelli"] = {
		BasePrice = 10000000000000,
		BaseIncome = 45000000000,
		CycleTime = 10,
		ModelName = "Strawberrelli Flamingelli",
		Description = "Strawberry flamingo!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
	},
	["Svinina_Bombardino"] = {
		BasePrice = 15000000000000,
		BaseIncome = 60000000000,
		CycleTime = 10,
		ModelName = "Svinina_Bombardino",
		Description = "Bomber pig!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
		ItemCost = { CrocBomb2 = 120, PigBomb2 = 100, Boom2 = 80 },
	},
	["Ta_Ta_Ta_Ta_Sahur"] = {
		BasePrice = 22500000000000,
		BaseIncome = 85000000000,
		CycleTime = 10,
		ModelName = "Ta_Ta_Ta_Ta_Sahur",
		Description = "Sahur rhythm!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
	},
	["Talpa_Di_Fero"] = {
		BasePrice = 35000000000000,
		BaseIncome = 120000000000,
		CycleTime = 10,
		ModelName = "Talpa_Di_Fero",
		Description = "Iron mole!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
	},
	["Tigrilini Watermelini"] = {
		BasePrice = 50000000000000,
		BaseIncome = 160000000000,
		CycleTime = 10,
		ModelName = "Tigrilini Watermelini",
		Description = "Watermelon tiger!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
	},
	["Tigroligre Frutonni"] = {
		BasePrice = 75000000000000,
		BaseIncome = 220000000000,
		CycleTime = 10,
		ModelName = "Tigroligre Frutonni",
		Description = "Fruit tiger-lion!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
	},
	["Tim_Cheese"] = {
		BasePrice = 110000000000000,
		BaseIncome = 300000000000,
		CycleTime = 10,
		ModelName = "Tim_Cheese",
		Description = "It's Tim Cheese!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
	},
	["Torrtuginni Dragonfrutini"] = {
		BasePrice = 160000000000000,
		BaseIncome = 400000000000,
		CycleTime = 10,
		ModelName = "Torrtuginni Dragonfrutini",
		Description = "Dragonfruit turtle!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
		ItemCost = { Dragon2 = 150, Melon2 = 120, Glorbo2 = 100 },
	},
	["Tralalero_Tralala"] = {
		BasePrice = 225000000000000,
		BaseIncome = 550000000000,
		CycleTime = 10,
		ModelName = "Tralalero_Tralala",
		Description = "The OG tralala!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
	},
	["Trenostruzzo_Turbo_3000"] = {
		BasePrice = 325000000000000,
		BaseIncome = 750000000000,
		CycleTime = 10,
		ModelName = "Trenostruzzo_Turbo_3000",
		Description = "Turbo train ostrich!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
	},
	["Tric_Trac_Baraboom"] = {
		BasePrice = 450000000000000,
		BaseIncome = 1000000000000,
		CycleTime = 10,
		ModelName = "Tric_Trac_Baraboom",
		Description = "Boom tric trac!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
	},
	["Trippi_Troppi"] = {
		BasePrice = 650000000000000,
		BaseIncome = 1400000000000,
		CycleTime = 10,
		ModelName = "Trippi_Troppi",
		Description = "Trippy toppy!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
		ItemCost = { Odin3 = 50, Liri3 = 40, Trip2 = 200 },
	},
	
	-- Tier 7: Legendary ($1Qa - $10Qa) - CostMultiplier: 1.30
	["Trulimero_Trulicina"] = {
		BasePrice = 1000000000000000,
		BaseIncome = 2000000000000,
		CycleTime = 10,
		ModelName = "Trulimero_Trulicina",
		Description = "Trulli power!",
		CostMultiplier = 1.30,
		ProjectileColor = Color3.fromRGB(148, 0, 211),
		ItemCost = { Truli3 = 60, Bicus3 = 40, Combo3 = 30 },
	},
	["Tung_Tung_Tung_Sahur"] = {
		BasePrice = 2500000000000000,
		BaseIncome = 4500000000000,
		CycleTime = 10,
		ModelName = "Tung_Tung_Tung_Sahur",
		Description = "Wake up to riches!",
		CostMultiplier = 1.30,
		ProjectileColor = Color3.fromRGB(148, 0, 211),
	},
	["Unclito_Samito"] = {
		BasePrice = 5000000000000000,
		BaseIncome = 8500000000000,
		CycleTime = 10,
		ModelName = "Unclito_Samito",
		Description = "Uncle Sam power!",
		CostMultiplier = 1.30,
		ProjectileColor = Color3.fromRGB(148, 0, 211),
		ItemCost = { Sam3 = 80, Lib3 = 60, Spion3 = 50 },
	},
	["Zibra Zubra Zibralini"] = {
		BasePrice = 10000000000000000,
		BaseIncome = 16000000000000,
		CycleTime = 10,
		ModelName = "Zibra Zubra Zibralini",
		Description = "Triple zebra!",
		CostMultiplier = 1.30,
		ProjectileColor = Color3.fromRGB(148, 0, 211),
	},
	
	-- Tier 8: Lucky Blocks (Special Units) - CostMultiplier: 1.45
	["Secret Lucky Block"] = {
		BasePrice = 50000000000000000,
		BaseIncome = 75000000000000,
		CycleTime = 10,
		ModelName = "Secret Lucky Block",
		Description = "Secret lucky power!",
		CostMultiplier = 1.45,
		ProjectileColor = Color3.fromRGB(0, 255, 255),
		ItemCost = { SecLuck3 = 30, MythLuck3 = 20, NukeDino3 = 15 },
	},
	["Mythic Lucky Block"] = {
		BasePrice = 250000000000000000,
		BaseIncome = 350000000000000,
		CycleTime = 10,
		ModelName = "Mythic Lucky Block",
		Description = "Mythic luck!",
		CostMultiplier = 1.45,
		ProjectileColor = Color3.fromRGB(0, 255, 255),
	},
	["Brainrot God Lucky Block"] = {
		BasePrice = 1000000000000000000,
		BaseIncome = 1250000000000000,
		CycleTime = 10,
		ModelName = "Brainrot God Lucky Block",
		Description = "The ultimate brainrot deity!",
		CostMultiplier = 1.45,
		ProjectileColor = Color3.fromRGB(0, 255, 255),
		ItemCost = { GodLuck3 = 50, NukeDino4 = 20, Odin4 = 10 },
	},
}

-- Pre-sorted list cache
local SortedUnitsCache: {{name: string, config: UnitConfig}}? = nil

--------------------------------------------------------------------------------
-- UTILITY FUNCTIONS
--------------------------------------------------------------------------------

--[[
	Calculates the current price for a unit based on how many the player owns.
	
	Formula: BasePrice * (CostMultiplier ^ amountOwned)
	Uses per-unit CostMultiplier if defined, otherwise default 1.15.
	
	@param unitName string - The name of the unit
	@param amountOwned number - How many of this unit the player currently owns
	@return number - The calculated price (floored to integer)
]]
local function CalculatePrice(unitName: string, amountOwned: number): number
	local config = Units[unitName]
	if not config then
		warn("ShopConfig: Unknown unit " .. unitName)
		return 0
	end
	
	-- Use per-unit multiplier if defined, otherwise fall back to default
	local multiplier = config.CostMultiplier or PRICE_MULTIPLIER
	local price = config.BasePrice * (multiplier ^ amountOwned)
	return math.floor(price)
end

--[[
	Calculates the effective income for a unit with milestone bonuses.
	
	@param unitName string - The name of the unit
	@param amountOwned number - How many of this unit the player owns
	@return number - The effective income per cycle
]]
local function CalculateEffectiveIncome(unitName: string, amountOwned: number): number
	local config = Units[unitName]
	if not config then
		warn("ShopConfig: Unknown unit " .. unitName)
		return 0
	end
	
	local profitMultiplier = 1
	
	-- Apply all profit milestones that have been reached
	for _, milestone in MILESTONES do
		if amountOwned >= milestone.quantity and milestone.milestoneType == "profit" then
			profitMultiplier = profitMultiplier * milestone.multiplier
		end
	end
	
	return math.floor(config.BaseIncome * profitMultiplier)
end

--[[
	Calculates the effective cycle time for a unit with milestone bonuses.
	
	@param unitName string - The name of the unit
	@param amountOwned number - How many of this unit the player owns
	@return number - The effective cycle time in seconds
]]
local function CalculateEffectiveCycleTime(unitName: string, amountOwned: number): number
	local config = Units[unitName]
	if not config then
		warn("ShopConfig: Unknown unit " .. unitName)
		return 3 -- Default fallback
	end
	
	local speedMultiplier = 1
	
	-- Apply all speed milestones that have been reached
	for _, milestone in MILESTONES do
		if amountOwned >= milestone.quantity and milestone.milestoneType == "speed" then
			speedMultiplier = speedMultiplier * milestone.multiplier
		end
	end
	
	-- Speed multiplier reduces cycle time (higher speed = lower time)
	return math.max(0.1, config.CycleTime / speedMultiplier) -- Min 0.1s cycle
end

--[[
	Gets the next milestone info for a unit.
	
	@param amountOwned number - How many of this unit the player owns
	@return MilestoneInfo?, number - Next milestone and progress, or nil if all reached
]]
local function GetNextMilestone(amountOwned: number): (MilestoneInfo?, number)
	for _, milestone in MILESTONES do
		if amountOwned < milestone.quantity then
			return milestone, amountOwned
		end
	end
	
	return nil, amountOwned -- All milestones reached
end

--[[
	Gets all milestones that have been reached.
	
	@param amountOwned number - How many of this unit the player owns
	@return {MilestoneInfo} - Array of reached milestones
]]
local function GetMilestonesReached(amountOwned: number): {MilestoneInfo}
	local reached = {}
	
	for _, milestone in MILESTONES do
		if amountOwned >= milestone.quantity then
			table.insert(reached, milestone)
		end
	end
	
	return reached
end

--[[
	Gets the configuration for a specific unit.
	
	@param unitName string - The name of the unit
	@return UnitConfig? - The config table, or nil if not found
]]
local function GetConfig(unitName: string): UnitConfig?
	return Units[unitName]
end

--[[
	Returns an array of all units sorted by BasePrice (ascending).
	Cached for performance.
	
	@return table - Array of {name, config} pairs sorted by BasePrice
]]
local function GetAllUnitsSorted(): {{name: string, config: UnitConfig}}
	if SortedUnitsCache then
		return SortedUnitsCache
	end
	
	local sorted = {}
	
	for name, config in Units do
		table.insert(sorted, {name = name, config = config})
	end
	
	table.sort(sorted, function(a, b)
		return a.config.BasePrice < b.config.BasePrice
	end)
	
	SortedUnitsCache = sorted
	return sorted
end

--[[
	Returns which units should be visible based on unlock progress.
	Shows (unlockProgress) unlocked + 1 locked preview.
	
	@param unlockProgress number - How many units are unlocked (default: INITIAL_UNLOCKED)
	@return table - Array of {name, config, isLocked} for visible units
]]
local function GetVisibleUnits(unlockProgress: number?): {{name: string, config: UnitConfig, isLocked: boolean}}
	local progress = unlockProgress or INITIAL_UNLOCKED
	local allUnits = GetAllUnitsSorted()
	local visible = {}
	
	-- Show unlocked units + 1 locked preview
	local showCount = math.min(progress + 1, #allUnits)
	
	for i = 1, showCount do
		local unit = allUnits[i]
		table.insert(visible, {
			name = unit.name,
			config = unit.config,
			isLocked = i > progress,
		})
	end
	
	return visible
end

--[[
	Checks if a unit is unlocked based on unlock progress.
	
	@param unitName string - The name of the unit
	@param unlockProgress number - Current unlock progress
	@return boolean - Whether the unit is unlocked
]]
local function IsUnitUnlocked(unitName: string, unlockProgress: number?): boolean
	local progress = unlockProgress or INITIAL_UNLOCKED
	local allUnits = GetAllUnitsSorted()
	
	for i, unit in allUnits do
		if unit.name == unitName then
			return i <= progress
		end
	end
	
	return false
end

--[[
	Gets the total number of units available.
]]
local function GetTotalUnits(): number
	return #GetAllUnitsSorted()
end

--[[
	Gets the item cost for a unit (items burned on purchase).
	
	@param unitName string - The name of the unit
	@return {[string]: number}? - Table of { itemId = count } or nil if no item cost
]]
local function GetItemCost(unitName: string): {[string]: number}?
	local config = Units[unitName]
	if not config then return nil end
	return config.ItemCost
end

-- Return module with both data and functions
return {
	Units = Units,
	CalculatePrice = CalculatePrice,
	CalculateEffectiveIncome = CalculateEffectiveIncome,
	CalculateEffectiveCycleTime = CalculateEffectiveCycleTime,
	GetNextMilestone = GetNextMilestone,
	GetMilestonesReached = GetMilestonesReached,
	GetConfig = GetConfig,
	GetItemCost = GetItemCost,
	GetAllUnitsSorted = GetAllUnitsSorted,
	GetVisibleUnits = GetVisibleUnits,
	IsUnitUnlocked = IsUnitUnlocked,
	GetTotalUnits = GetTotalUnits,
	
	-- Constants
	PRICE_MULTIPLIER = PRICE_MULTIPLIER,
	INITIAL_UNLOCKED = INITIAL_UNLOCKED,
	MILESTONES = MILESTONES,
}


================================================================================
FILE: src\shared\SynergyConfig.luau
================================================================================

--[[
	SynergyConfig - Shared Configuration for Brainrot Synergies
	
	Defines synergy combinations that provide bonuses when requirements are met.
	
	Synergy Types:
	- Global: Affects all brainrots or player stats
	- Local: Only affects the specific brainrots involved in the synergy
	
	Requirements can specify:
	- Unit type (required)
	- Minimum count (required)
	- Specific rarity (optional - nil means any rarity counts)
]]

export type SynergyRequirement = {
	UnitName: string,           -- The brainrot type required
	MinCount: number,           -- Minimum number needed
	Rarity: string?,            -- Optional: specific rarity required (nil = any)
}

export type SynergyEffect = {
	Type: "IncomeMultiplier" | "CycleReduction" | "GlobalIncomeBoost",
	Target: "All" | "Specific",  -- All brainrots or specific units
	TargetUnits: {string}?,      -- If Target is "Specific", which units are affected
	Value: number,               -- Multiplier or percentage value
}

export type SynergyDefinition = {
	Id: string,                  -- Unique identifier
	Name: string,                -- Display name
	Description: string,         -- What the synergy does
	Icon: string,                -- Emoji icon for display
	Requirements: {SynergyRequirement}, -- What's needed to unlock
	Effects: {SynergyEffect},    -- What bonuses are applied
}

local SynergyConfig = {}

--------------------------------------------------------------------------------
-- SYNERGY DEFINITIONS
--------------------------------------------------------------------------------

SynergyConfig.Synergies = {
	--[[
		Example Synergy: Italian Brainrot Alliance
		Requires 10 Avocadini Guffo + 100 Brr_Brr_Patapim
		Result: Brr_Brr_Patapim gains 100% income multiplier
	]]
	ItalianAlliance = {
		Id = "ItalianAlliance",
		Name = "Italian Brainrot Alliance",
		Description = "Brr Brr Patapim gains +100% income!",
		Icon = "ðŸ‡®ðŸ‡¹",
		Requirements = {
			{
				UnitName = "Avocadini Guffo",
				MinCount = 10,
				Rarity = nil, -- Any rarity counts
			},
			{
				UnitName = "Brr_Brr_Patapim",
				MinCount = 100,
				Rarity = nil,
			},
		},
		Effects = {
			{
				Type = "IncomeMultiplier",
				Target = "Specific",
				TargetUnits = {"Brr_Brr_Patapim"},
				Value = 2.0, -- 2x = +100% income
			},
		},
	},
	
	--[[
		Example Synergy: Spicy Collection
		Requires 5 Spicy rarity of any brainrot type
		Result: All brainrots gain +25% income
	]]
	-- SpicyCollection = {
	-- 	Id = "SpicyCollection",
	-- 	Name = "Spicy Collection",
	-- 	Description = "All brainrots gain +25% income!",
	-- 	Icon = "ðŸŒ¶ï¸",
	-- 	Requirements = {
	-- 		{
	-- 			UnitName = "*", -- Wildcard: any unit type
	-- 			MinCount = 5,
	-- 			Rarity = "Spicy",
	-- 		},
	-- 	},
	-- 	Effects = {
	-- 		{
	-- 			Type = "IncomeMultiplier",
	-- 			Target = "All",
	-- 			TargetUnits = nil,
	-- 			Value = 1.25, -- 1.25x = +25% income
	-- 		},
	-- 	},
	-- },
}

-- Ordered list for display
SynergyConfig.SynergyOrder = {"ItalianAlliance"}

--------------------------------------------------------------------------------
-- HELPER FUNCTIONS
--------------------------------------------------------------------------------

--[[
	Gets a synergy definition by ID.
	@param synergyId string - The synergy ID
	@return SynergyDefinition? - The synergy definition or nil
]]
function SynergyConfig.GetSynergy(synergyId: string): SynergyDefinition?
	return SynergyConfig.Synergies[synergyId]
end

--[[
	Gets all synergy definitions in display order.
	@return {SynergyDefinition} - Array of synergy definitions
]]
function SynergyConfig.GetAllSynergies(): {SynergyDefinition}
	local synergies = {}
	for _, synergyId in SynergyConfig.SynergyOrder do
		local synergy = SynergyConfig.Synergies[synergyId]
		if synergy then
			table.insert(synergies, synergy)
		end
	end
	return synergies
end

--[[
	Checks if a player meets the requirements for a synergy.
	@param synergyId string - The synergy ID to check
	@param inventoryData table - Player's inventory {[unitName]: {[rarity]: {total, active}}}
	@return boolean, {[string]: {current: number, required: number}} - Met status and progress
]]
function SynergyConfig.CheckSynergyProgress(
	synergyId: string, 
	inventoryData: {[string]: {[string]: {total: number, active: number}}}
): (boolean, {[string]: {current: number, required: number}})
	local synergy = SynergyConfig.Synergies[synergyId]
	if not synergy then
		return false, {}
	end
	
	local progress = {}
	local allMet = true
	
	for _, req in synergy.Requirements do
		local current = 0
		local key = req.UnitName .. (req.Rarity and ("_" .. req.Rarity) or "")
		
		if req.UnitName == "*" then
			-- Wildcard: count all units of this rarity
			for _, unitRarities in inventoryData do
				if req.Rarity then
					local rarityData = unitRarities[req.Rarity]
					if rarityData then
						current = current + rarityData.total
					end
				else
					for _, rarityData in unitRarities do
						current = current + rarityData.total
					end
				end
			end
		else
			-- Specific unit
			local unitData = inventoryData[req.UnitName]
			if unitData then
				if req.Rarity then
					local rarityData = unitData[req.Rarity]
					if rarityData then
						current = rarityData.total
					end
				else
					-- Sum all rarities
					for _, rarityData in unitData do
						current = current + rarityData.total
					end
				end
			end
		end
		
		progress[key] = {
			current = current,
			required = req.MinCount,
			unitName = req.UnitName,
			rarity = req.Rarity,
		}
		
		if current < req.MinCount then
			allMet = false
		end
	end
	
	return allMet, progress
end

return SynergyConfig


================================================================================
FILE: src\shared\TileConfig.luau
================================================================================

local TileConfig = {}

--------------------------------------------------------------------------------
-- TILE DEFINITIONS
--------------------------------------------------------------------------------

TileConfig.Tiles = {
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- THEMED TILES (50% speed boost to units with matching name keywords)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	Lava = {
		Id = "Lava",
		Name = "Molten Floor",
		Description = "Explosive and Crocodile units work 50% faster here.",
		Icon = "ðŸŒ‹",
		BoostKeywords = {"Bombard", "Boom", "Croc", "Nuke", "Atomic"},
		SpeedMult = 1.5,
		LuckMult = 1.0,
		Color = Color3.fromRGB(255, 100, 50),
		TextureId = "",
		ParticleEffect = "Fire",
		UnlockCost = 5000,
		UnlockTier = 1,
	},
	
	Ice = {
		Id = "Ice",
		Name = "Frozen Ground",
		Description = "Cold and Winter units work 50% faster here.",
		Icon = "â„ï¸",
		BoostKeywords = {"Brr", "Ice", "Penguin", "Frosty", "Camelo", "Blueberry"},
		SpeedMult = 1.5,
		LuckMult = 1.0,
		Color = Color3.fromRGB(150, 220, 255),
		TextureId = "",
		ParticleEffect = "Snow",
		UnlockCost = 5000,
		UnlockTier = 1,
	},
	
	Stage = {
		Id = "Stage",
		Name = "Performance Stage",
		Description = "Musical and Talented units work 50% faster here.",
		Icon = "ðŸŽ­",
		BoostKeywords = {"Trala", "Dance", "Music", "Horse", "Messi", "Piano", "Sahur", "Symphony"},
		SpeedMult = 1.5,
		LuckMult = 1.0,
		Color = Color3.fromRGB(200, 150, 100),
		TextureId = "",
		ParticleEffect = "Confetti",
		UnlockCost = 5000,
		UnlockTier = 1,
	},
	
	Throne = {
		Id = "Throne",
		Name = "Throne Platform",
		Description = "Godly and Mythical units work 50% faster here.",
		Icon = "ðŸ‘‘",
		BoostKeywords = {"God", "Odin", "Mythic", "King", "Royal", "Elite", "Master"},
		SpeedMult = 1.5,
		LuckMult = 1.0,
		Color = Color3.fromRGB(100, 50, 150),
		TextureId = "",
		ParticleEffect = "Crown",
		UnlockCost = 5000,
		UnlockTier = 1,
	},
	
	Toilet = {
		Id = "Toilet",
		Name = "Bathroom Floor",
		Description = "Food and Noob units work 50% faster here.",
		Icon = "ðŸš½",
		BoostKeywords = {"Pizza", "Noob", "Toast", "Pot", "Chef", "Coffee", "Cap", "Signora"},
		SpeedMult = 1.5,
		LuckMult = 1.0,
		Color = Color3.fromRGB(200, 200, 220),
		TextureId = "",
		ParticleEffect = "Bubbles",
		UnlockCost = 5000,
		UnlockTier = 1,
	},
	
	Cozy = {
		Id = "Cozy",
		Name = "Cozy Carpet",
		Description = "Animal and Tropical units work 50% faster here.",
		Icon = "ðŸ±",
		BoostKeywords = {"Ban", "Animal", "Guffo", "Berry", "Fruit", "Mew", "Cat", "Neon", "Nyan", "Panda", "Giraffe", "Elephant"},
		SpeedMult = 1.5,
		LuckMult = 1.0,
		Color = Color3.fromRGB(255, 180, 200),
		TextureId = "",
		ParticleEffect = "Hearts",
		UnlockCost = 5000,
		UnlockTier = 1,
	},
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- UNIVERSAL TILES (Smaller bonuses to all units)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	Grass = {
		Id = "Grass",
		Name = "Grass Patch",
		Description = "All units work 10% faster here.",
		Icon = "ðŸŒ±",
		BoostKeywords = nil,  -- nil = all units
		SpeedMult = 1.1,
		LuckMult = 1.0,
		Color = Color3.fromRGB(100, 180, 80),
		TextureId = "",
		ParticleEffect = nil,
		UnlockCost = 1000,
		UnlockTier = 1,
	},
	
	Gold = {
		Id = "Gold",
		Name = "Golden Platform",
		Description = "25% higher artifact drop chance here.",
		Icon = "ðŸ’°",
		BoostKeywords = nil,
		SpeedMult = 1.0,
		LuckMult = 1.25,
		Color = Color3.fromRGB(255, 215, 0),
		TextureId = "",
		ParticleEffect = "Sparkle",
		UnlockCost = 10000,
		UnlockTier = 2,
	},
	
	Diamond = {
		Id = "Diamond",
		Name = "Diamond Floor",
		Description = "20% faster + 20% higher artifact chance.",
		Icon = "ðŸ’Ž",
		BoostKeywords = nil,
		SpeedMult = 1.2,
		LuckMult = 1.2,
		Color = Color3.fromRGB(180, 230, 255),
		TextureId = "",
		ParticleEffect = "Diamond",
		UnlockCost = 50000,
		UnlockTier = 3,
	},
}

-- Tile visual properties
TileConfig.TileHeight = 0.5  -- Studs thick
TileConfig.TileSize = 9.5   -- Slightly smaller than grid slot for visual gap

--------------------------------------------------------------------------------
-- HELPER FUNCTIONS
--------------------------------------------------------------------------------

--[[
	Gets a tile definition by ID.
	@param tileId string - The tile ID
	@return table? - The tile definition or nil
]]
function TileConfig.GetTile(tileId: string)
	return TileConfig.Tiles[tileId]
end

--[[
	Calculates the speed multiplier for a unit on a tile.
	@param tileId string - The tile ID
	@param unitType string - The unit's model name/type
	@return number - Speed multiplier (higher = faster production)
]]
function TileConfig.GetSpeedBonus(tileId: string, unitType: string)
	local tile = TileConfig.Tiles[tileId]
	if not tile then return 1.0 end
	
	-- Universal tiles apply to all units
	if tile.BoostKeywords == nil then
		return tile.SpeedMult
	end
	
	-- Check if unit matches any keywords
	if unitType then
		for _, keyword in ipairs(tile.BoostKeywords) do
			if string.find(string.lower(unitType), string.lower(keyword)) then
				return tile.SpeedMult
			end
		end
	end
	
	-- No bonus for non-matching units
	return 1.0
end

--[[
	Calculates the luck multiplier for a unit on a tile.
	@param tileId string - The tile ID
	@param unitType string - The unit's model name (ignored, but for parity)
	@return number - Luck multiplier (higher = more artifact drops)
]]
function TileConfig.GetLuckBonus(tileId: string, unitType: string?)
	local tile = TileConfig.Tiles[tileId]
	if not tile then return 1.0 end
	
	-- Luck bonus applies regardless of unit type
	return tile.LuckMult
end

--[[
	Gets all bonuses for a unit on a tile.
	@param tileId string - The tile ID
	@param unitType string - The unit's model name
	@return table - {SpeedMult, LuckMult}
]]
function TileConfig.GetBonus(tileId: string, unitType: string)
	return {
		SpeedMult = TileConfig.GetSpeedBonus(tileId, unitType),
		LuckMult = TileConfig.GetLuckBonus(tileId, unitType),
	}
end

--[[
	Gets all tiles available at a given tier.
	@param tier number - The player's tier level
	@return table - Array of tile definitions
]]
function TileConfig.GetUnlockedTiles(tier)
	local unlocked = {}
	for id, tile in pairs(TileConfig.Tiles) do
		if tile.UnlockTier <= tier then
			table.insert(unlocked, tile)
		end
	end
	return unlocked
end

--[[
	Gets all tile IDs as an array for UI iteration.
	@return table - Array of tile IDs
]]
function TileConfig.GetAllTileIds()
	local ids = {}
	for id, _ in pairs(TileConfig.Tiles) do
		table.insert(ids, id)
	end
	table.sort(ids)  -- Alphabetical for consistent ordering
	return ids
end

return TileConfig



================================================================================
FILE: src\shared\ViewportPreview.luau
================================================================================

--[[
	ViewportPreview Module
	
	Creates spinning 3D previews of models inside ViewportFrames.
	Used for inventory UI to show brainrot models instead of static images.
	
	Usage:
		local ViewportPreview = require(path.to.ViewportPreview)
		local preview = ViewportPreview.Create(model, parentFrame)
		-- Later:
		preview:Destroy()
]]

local RunService = game:GetService("RunService")

local ViewportPreview = {}
ViewportPreview.__index = ViewportPreview

-- Configuration
local CONFIG = {
	SPIN_SPEED = 30, -- degrees per second
	CAMERA_FOV = 50,
	DEFAULT_SIZE = UDim2.new(1, 0, 1, 0),
	BACKGROUND_COLOR = Color3.fromRGB(30, 25, 40),
	BACKGROUND_TRANSPARENCY = 0.5,
}

--[[
	Calculates the bounding box of a model.
	@param model Model - The model to measure
	@return CFrame, Vector3 - The center CFrame and size
]]
local function getModelBounds(model: Model): (CFrame, Vector3)
	local cf, size = model:GetBoundingBox()
	return cf, size
end

--[[
	Positions the camera to fit the model in view.
	@param camera Camera - The viewport camera
	@param model Model - The model to frame
	@param size Vector3 - The bounding box size
]]
local function positionCamera(camera: Camera, model: Model, size: Vector3)
	local cf, _ = getModelBounds(model)
	
	-- Calculate distance based on model size
	local maxDimension = math.max(size.X, size.Y, size.Z)
	local fovRad = math.rad(CONFIG.CAMERA_FOV / 2)
	local distance = (maxDimension / 2) / math.tan(fovRad) * 1.5
	
	-- Position camera higher and looking down at model center
	local cameraOffset = Vector3.new(distance * 0.6, distance * 0.6, distance * 0.6)
	
	-- Look slightly higher than center to frame the head better
	local targetPos = cf.Position + Vector3.new(0, size.Y * 0.1, 0)
	
	camera.CFrame = CFrame.new(cf.Position + cameraOffset, targetPos)
	camera.FieldOfView = CONFIG.CAMERA_FOV
end

--[[
	Creates a new ViewportPreview.
	@param model Model - The model to preview (will be cloned)
	@param parent GuiObject - The parent UI element
	@param size UDim2? - Optional size override
	@return ViewportPreview
]]
function ViewportPreview.Create(model: Model, parent: GuiObject, size: UDim2?): any
	local self = setmetatable({}, ViewportPreview)
	
	-- Create ViewportFrame
	local viewport = Instance.new("ViewportFrame")
	viewport.Name = "ModelPreview"
	viewport.Size = size or CONFIG.DEFAULT_SIZE
	viewport.Position = UDim2.new(0, 0, 0, 0)
	viewport.BackgroundColor3 = CONFIG.BACKGROUND_COLOR
	viewport.BackgroundTransparency = CONFIG.BACKGROUND_TRANSPARENCY
	viewport.BorderSizePixel = 0
	viewport.Parent = parent
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 4)
	corner.Parent = viewport
	
	-- Clone model for viewport
	local previewModel = model:Clone()
	previewModel.Parent = viewport
	
	-- Create WorldModel container (required for proper rendering)
	local worldModel = Instance.new("WorldModel")
	worldModel.Parent = viewport
	previewModel.Parent = worldModel
	
	-- Create camera
	local camera = Instance.new("Camera")
	camera.Parent = viewport
	viewport.CurrentCamera = camera
	
	-- Get model bounds and position camera
	local _, modelSize = getModelBounds(previewModel)
	positionCamera(camera, previewModel, modelSize)
	
	-- Store references
	self.viewport = viewport
	self.model = previewModel
	self.worldModel = worldModel
	self.camera = camera
	self.modelCenter, _ = getModelBounds(previewModel)
	self.rotation = 0
	self.spinConnection = nil
	
	-- Start spinning
	self:StartSpin()
	
	return self
end

--[[
	Starts the spin animation.
]]
function ViewportPreview:StartSpin()
	if self.spinConnection then return end
	
	self.spinConnection = RunService.RenderStepped:Connect(function(dt)
		if not self.model or not self.model.Parent then
			self:Destroy()
			return
		end
		
		-- Update rotation
		self.rotation = self.rotation + CONFIG.SPIN_SPEED * dt
		
		-- Rotate model around Y axis
		local centerCF = self.modelCenter
		local rotationCF = CFrame.Angles(0, math.rad(self.rotation), 0)
		self.model:PivotTo(CFrame.new(centerCF.Position) * rotationCF)
	end)
end

--[[
	Stops the spin animation.
]]
function ViewportPreview:StopSpin()
	if self.spinConnection then
		self.spinConnection:Disconnect()
		self.spinConnection = nil
	end
end

--[[
	Destroys the preview and cleans up.
]]
function ViewportPreview:Destroy()
	self:StopSpin()
	
	if self.viewport then
		self.viewport:Destroy()
		self.viewport = nil
	end
	
	self.model = nil
	self.worldModel = nil
	self.camera = nil
end

return ViewportPreview


================================================================================
FILE: default.project.json
================================================================================

{
  "name": "BrainRotClicker",
  "tree": {
    "$className": "DataModel",

    "ReplicatedStorage": {
      "Shared": {
        "$path": "src/shared"
      }
    },

    "ServerScriptService": {
      "Server": {
        "$path": "src/server"
      }
    },

    "StarterPlayer": {
      "StarterPlayerScripts": {
        "Client": {
          "$path": "src/client"
        }
      }
    },

    "Workspace": {
      "$properties": {
        "FilteringEnabled": true
      },
      "Baseplate": {
        "$className": "Part",
        "$properties": {
          "Anchored": true,
          "Color": [
            0.38823,
            0.37254,
            0.38823
          ],
          "Locked": true,
          "Position": [
            0,
            -10,
            0
          ],
          "Size": [
            512,
            20,
            512
          ]
        }
      }
    },
    "Lighting": {
      "$properties": {
        "Ambient": [
          0,
          0,
          0
        ],
        "Brightness": 2,
        "GlobalShadows": true,
        "Outlines": false,
        "Technology": "Voxel"
      }
    },
    "SoundService": {
      "$properties": {
        "RespectFilteringEnabled": true
      }
    }
  }
}


