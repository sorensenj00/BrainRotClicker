--------------------------------------------------
File: AdminPanel.client.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\client\AdminPanel.client.luau
--------------------------------------------------
--[[
	AdminPanel Client Script
	
	Provides a UI for testing commands.
	- Reset Plot
	- Add Money
	- Toggle Fly
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Wait for RemoteEvents
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local AdminAction = RemoteEvents:WaitForChild("AdminAction")

-- Configuration
local UI_CONFIG = {
	BUTTON_SIZE = UDim2.new(0, 50, 0, 50),
	PANEL_SIZE = UDim2.new(0, 200, 0, 250),
	COLOR_PRIMARY = Color3.fromRGB(40, 40, 50),
	COLOR_ACCENT = Color3.fromRGB(255, 100, 100), -- Red for dev
	TEXT_COLOR = Color3.fromRGB(255, 255, 255),
}

--------------------------------------------------------------------------------
-- UI CREATION
--------------------------------------------------------------------------------

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "AdminPanel"
screenGui.ResetOnSpawn = false
screenGui.Parent = playerGui

-- Toggle Button (Bottom Right)
local toggleBtn = Instance.new("TextButton")
toggleBtn.Name = "ToggleBtn"
toggleBtn.Size = UI_CONFIG.BUTTON_SIZE
toggleBtn.Position = UDim2.new(1, -60, 1, -60)
toggleBtn.BackgroundColor3 = UI_CONFIG.COLOR_ACCENT
toggleBtn.Text = "DEV"
toggleBtn.TextColor3 = UI_CONFIG.TEXT_COLOR
toggleBtn.Font = Enum.Font.GothamBold
toggleBtn.TextSize = 14
toggleBtn.AutoButtonColor = true
toggleBtn.Parent = screenGui

local uiCorner = Instance.new("UICorner")
uiCorner.CornerRadius = UDim.new(0.5, 0)
uiCorner.Parent = toggleBtn

-- Main Panel
local panel = Instance.new("Frame")
panel.Name = "MainPanel"
panel.Size = UI_CONFIG.PANEL_SIZE
panel.Position = UDim2.new(1, -270, 1, -320)
panel.BackgroundColor3 = UI_CONFIG.COLOR_PRIMARY
panel.Visible = false
panel.Parent = screenGui

local panelCorner = Instance.new("UICorner")
panelCorner.CornerRadius = UDim.new(0, 8)
panelCorner.Parent = panel

local listLayout = Instance.new("UIListLayout")
listLayout.Padding = UDim.new(0, 10)
listLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
listLayout.VerticalAlignment = Enum.VerticalAlignment.Top
listLayout.Parent = panel

local padding = Instance.new("UIPadding")
padding.PaddingTop = UDim.new(0, 15)
padding.PaddingBottom = UDim.new(0, 15)
padding.PaddingLeft = UDim.new(0, 15)
padding.PaddingRight = UDim.new(0, 15)
padding.Parent = panel

-- Helper to create buttons
local function createButton(text, callback)
	local btn = Instance.new("TextButton")
	btn.Size = UDim2.new(1, 0, 0, 40)
	btn.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
	btn.Text = text
	btn.TextColor3 = UI_CONFIG.TEXT_COLOR
	btn.Font = Enum.Font.GothamBold
	btn.TextSize = 14
	btn.AutoButtonColor = true
	btn.Parent = panel
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 6)
	corner.Parent = btn
	
	btn.MouseButton1Click:Connect(function()
		-- Visual feedback
		local originalColor = btn.BackgroundColor3
		btn.BackgroundColor3 = Color3.fromRGB(100, 100, 110)
		task.delay(0.1, function() btn.BackgroundColor3 = originalColor end)
		
		callback()
	end)
	
	return btn
end

-- Create Buttons
createButton("ðŸ”„ Reset Plot", function()
	local success, msg = AdminAction:InvokeServer("ResetPlot")
	print(msg)
end)

createButton("ðŸ’° Add $1M", function()
	local success, msg = AdminAction:InvokeServer("AddMoney")
	print(msg)
end)

createButton("ðŸ•Šï¸ Toggle Fly", function()
	local success, msg = AdminAction:InvokeServer("ToggleFly")
	print(msg)
end)

-- Toggle Logic
toggleBtn.MouseButton1Click:Connect(function()
	panel.Visible = not panel.Visible
end)

--------------------------------------------------------------------------------
-- FLIGHT LOGIC
--------------------------------------------------------------------------------

local flightConnection = nil
local bodyVelocity = nil
local bodyGyro = nil
local FLIGHT_SPEED = 50

local function stopFlying()
	if flightConnection then
		flightConnection:Disconnect()
		flightConnection = nil
	end
	
	if bodyVelocity then bodyVelocity:Destroy() bodyVelocity = nil end
	if bodyGyro then bodyGyro:Destroy() bodyGyro = nil end
	
	local character = player.Character
	if character then
		local humanoid = character:FindFirstChild("Humanoid")
		if humanoid then
			humanoid.PlatformStand = false
		end
	end
end

local function startFlying()
	local character = player.Character
	if not character then return end
	local hrp = character:FindFirstChild("HumanoidRootPart")
	local humanoid = character:FindFirstChild("Humanoid")
	if not hrp or not humanoid then return end
	
	-- Create physics movers
	bodyVelocity = Instance.new("BodyVelocity")
	bodyVelocity.Velocity = Vector3.new(0, 0, 0)
	bodyVelocity.MaxForce = Vector3.new(1e5, 1e5, 1e5)
	bodyVelocity.Parent = hrp
	
	bodyGyro = Instance.new("BodyGyro")
	bodyGyro.MaxTorque = Vector3.new(1e5, 1e5, 1e5)
	bodyGyro.CFrame = hrp.CFrame
	bodyGyro.Parent = hrp
	
	humanoid.PlatformStand = true
	
	flightConnection = RunService.RenderStepped:Connect(function()
		if not player:GetAttribute("IsFlying") then
			stopFlying()
			return
		end
		
		local camCFrame = workspace.CurrentCamera.CFrame
		local moveDir = Vector3.new(0, 0, 0)
		
		if UserInputService:IsKeyDown(Enum.KeyCode.W) then
			moveDir += camCFrame.LookVector
		end
		if UserInputService:IsKeyDown(Enum.KeyCode.S) then
			moveDir -= camCFrame.LookVector
		end
		if UserInputService:IsKeyDown(Enum.KeyCode.A) then
			moveDir -= camCFrame.RightVector
		end
		if UserInputService:IsKeyDown(Enum.KeyCode.D) then
			moveDir += camCFrame.RightVector
		end
		if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
			moveDir += Vector3.new(0, 1, 0)
		end
		if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
			moveDir -= Vector3.new(0, 1, 0)
		end
		
		if moveDir.Magnitude > 0 then
			moveDir = moveDir.Unit
		end
		
		bodyVelocity.Velocity = moveDir * FLIGHT_SPEED
		bodyGyro.CFrame = camCFrame
	end)
end

-- Listen for attribute change
player:GetAttributeChangedSignal("IsFlying"):Connect(function()
	if player:GetAttribute("IsFlying") then
		startFlying()
	else
		stopFlying()
	end
end)

-- Handle respawn
player.CharacterAdded:Connect(function()
	if player:GetAttribute("IsFlying") then
		task.wait(0.5)
		startFlying()
	end
end)

print("âœ“ AdminPanel loaded")



--------------------------------------------------
File: BuildModeUI.client.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\client\BuildModeUI.client.luau
--------------------------------------------------
--[[
	BuildModeUI Client Script
	
	"Architect Overlay" interface for placing and arranging brainrots.
	
	Features:
	- Press TAB to enter/exit Build Mode
	- Isometric camera view of plot
	- Grid visualization
	- KINEMATIC DRAG AND DROP (TFT Style)
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local CollectionService = game:GetService("CollectionService")

-- Player
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- Wait for remotes
local RemoteFunctions = ReplicatedStorage:WaitForChild("RemoteFunctions")
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")

local EnterBuildMode = RemoteFunctions:WaitForChild("EnterBuildMode")
local ExitBuildMode = RemoteFunctions:WaitForChild("ExitBuildMode")
local GetGrid = RemoteFunctions:WaitForChild("GetGrid")
local MoveUnit = RemoteFunctions:WaitForChild("MoveUnit")
local SwapUnits = RemoteFunctions:WaitForChild("SwapUnits")

-- Inventory remotes (RemoteFunctions but parented to RemoteEvents folder)
local GetInventoryRemote = RemoteEvents:WaitForChild("GetInventory")
local PlaceBrainrotRemote = RemoteEvents:WaitForChild("PlaceBrainrot")
local RemoveBrainrotRemote = RemoteEvents:WaitForChild("RemoveBrainrot")

-- Events
local InventoryChangedEvent = RemoteEvents:WaitForChild("InventoryChanged")
local _BuildModeChangedEvent = RemoteEvents:WaitForChild("BuildModeChanged")
local GridUpdatedEvent = RemoteEvents:WaitForChild("GridUpdated")

-- Configuration
local CONFIG = {
	-- Camera
	CAMERA_HEIGHT = 60,
	CAMERA_ANGLE = 45, -- degrees from horizontal
	CAMERA_TWEEN_TIME = 0.5,
	
	-- Grid
	TILE_SIZE = 10,
	TILE_HEIGHT = 0.1,
	
	-- Drag Physics (TFT Feel)
	DRAG_HEIGHT = 4.0,       -- How high it hovers when dragging
	DRAG_SMOOTHNESS = 20.0,  -- Position Lerp speed (Higher = Snappier, Lower = Heavier)
	TILT_STRENGTH = 0.3,     -- How much it tilts when moving
	TILT_RETURN_SPEED = 10.0,-- How fast it straightens up
	MAX_TILT_ANGLE = 25,     -- Max degrees of tilt
	
	-- Colors (more subtle)
	EMPTY_COLOR = Color3.fromRGB(100, 100, 150),
	OCCUPIED_COLOR = Color3.fromRGB(80, 200, 80),
	HOVER_COLOR = Color3.fromRGB(100, 200, 255),
	SELECTED_COLOR = Color3.fromRGB(255, 200, 50),
	INVALID_COLOR = Color3.fromRGB(255, 80, 80),
	SYNERGY_COLOR = Color3.fromRGB(200, 100, 255),
	
	-- UI
	TOOLBAR_HEIGHT = 80,
	BUTTON_SIZE = 60,
	INVENTORY_WIDTH = 220,
	
	-- Rarity colors
	RARITY_COLORS = {
		Normal = Color3.fromRGB(180, 180, 180),
		Spicy = Color3.fromRGB(255, 80, 80),
		Galaxy = Color3.fromRGB(180, 100, 255),
	},
	
	-- Modern Dark Theme (MoneyHUD Style)
	THEME_BG = Color3.fromRGB(20, 20, 30),
	THEME_STROKE = Color3.fromRGB(50, 50, 70),
	THEME_ACCENT_PURPLE = Color3.fromRGB(80, 60, 140),
	THEME_ACCENT_PINK = Color3.fromRGB(140, 80, 160),
	THEME_ACCENT_GOLD = Color3.fromRGB(200, 150, 60),
	THEME_ACCENT_BLUE = Color3.fromRGB(80, 160, 200),
	THEME_ACCENT_GREEN = Color3.fromRGB(100, 255, 100), -- For valid
	THEME_TEXT_PRIMARY = Color3.fromRGB(255, 255, 255),
	THEME_TEXT_SECONDARY = Color3.fromRGB(180, 180, 180),
	THEME_PANEL_RADIUS = 16,
	THEME_BUTTON_RADIUS = 6,
}

-- State
local isInBuildMode = false
local savedCameraCFrame = nil
local gridTiles = {}
local gridContainer = nil
local buildModeGui = nil
local selectedSlot = nil
local hoveredSlot = nil
local isDragging = false
local currentHoverConnection = nil
local gridFloorHeight = 0 -- Detected automatically

-- Drag-drop state
local draggedUnit = nil  -- {name: string, rarity: string}
local inventoryPanel = nil
local inventoryData = {}  -- {[unitName]: {[rarity]: {total, active}}}

-- Placement ghost state
local placementGhost = nil  -- The ghost model in workspace
local ghostPulseTween = nil  -- Current pulse tween
local isGhostValid = false  -- Is ghost in a valid position
local dragConnection = nil  -- Mouse move connection during drag
local ghostCenterOffset = Vector3.new() -- Offset from pivot to bounding box center

-- Modules
local ViewportPreview = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("ViewportPreview"))

-- Model folder for 3D previews
local BrainrotsFolder = ReplicatedStorage:WaitForChild("Brainrots")

-- Track inventory previews for cleanup
local inventoryPreviews = {}
-- Forward declarations
local exitBuildModeLocal
local refreshInventoryPanel
local getSlotUnderMouse
local renderBuildGrid
local startDrag
local completeDrop

-- Camera reference
local camera = workspace.CurrentCamera

--------------------------------------------------------------------------------
-- GRID VISUALIZATION
--------------------------------------------------------------------------------

--[[
	Finds all plots owned by the player.
]]
local function findAllPlayerPlots()
	local plots = {}
	local plotsFolder = workspace:FindFirstChild("Plots")
	if not plotsFolder then return plots end
	
	for _, plot in plotsFolder:GetChildren() do
		if plot:GetAttribute("OwnerId") == LocalPlayer.UserId then
			table.insert(plots, plot)
		end
	end
	
	return plots
end

--[[
	Finds the island/plot the player is currently standing on.
	Uses raycast detection from player position.
]]
local function findCurrentIsland()
	local character = LocalPlayer.Character
	if not character then return nil end
	
	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	if not humanoidRootPart then return nil end
	
	local playerPos = humanoidRootPart.Position
	
	-- Get all player's plots
	local playerPlots = findAllPlayerPlots()
	if #playerPlots == 0 then return nil end
	
	-- Find which plot the player is standing on
	local closestPlot = nil
	local closestDistance = math.huge
	
	for _, plot in playerPlots do
		local floor = plot:FindFirstChild("Island") 
			or plot:FindFirstChild("PlotFloor") 
			or plot:FindFirstChild("Floor")
			or plot:FindFirstChildWhichIsA("BasePart")
		
		if floor then
			local floorPos = floor.Position
			local floorSize = floor.Size
			
			-- Check if player is within the plot bounds (XZ)
			local dx = math.abs(playerPos.X - floorPos.X)
			local dz = math.abs(playerPos.Z - floorPos.Z)
			
			if dx <= floorSize.X / 2 + 10 and dz <= floorSize.Z / 2 + 10 then
				-- Player is on or near this plot
				local distance = (playerPos - floorPos).Magnitude
				if distance < closestDistance then
					closestDistance = distance
					closestPlot = plot
				end
			end
		end
	end
	
	-- If not standing on any, return first plot as fallback
	if not closestPlot and #playerPlots > 0 then
		closestPlot = playerPlots[1]
	end
	
	return closestPlot
end

--[[
	Finds the player's plot (for backwards compatibility - returns current island).
]]
local function findPlayerPlot()
	return findCurrentIsland()
end

--[[
	Creates a grid tile part (invisible, outline-only for selection).
]]
local function createGridTile(slotIndex, position, isOccupied, unitName)
	local tile = Instance.new("Part")
	tile.Name = "BuildTile_" .. slotIndex
	tile.Size = Vector3.new(CONFIG.TILE_SIZE - 0.5, CONFIG.TILE_HEIGHT, CONFIG.TILE_SIZE - 0.5)
	tile.Position = position
	tile.Anchored = true
	tile.CanCollide = false
	tile.Transparency = 1  -- Fully invisible
	tile:SetAttribute("SlotIndex", slotIndex)
	tile:SetAttribute("IsOccupied", isOccupied)
	tile:SetAttribute("UnitName", unitName)
	
	-- Add border/outline effect (this is all we show)
	local selectionBox = Instance.new("SelectionBox")
	selectionBox.Name = "Outline"
	selectionBox.Adornee = tile
	selectionBox.Color3 = isOccupied and CONFIG.OCCUPIED_COLOR or CONFIG.EMPTY_COLOR
	selectionBox.LineThickness = 0.03
	selectionBox.Transparency = 0.3
	selectionBox.Parent = tile
	
	-- Slot number label (small, only for empty slots)
	if not isOccupied then
		local billboard = Instance.new("BillboardGui")
		billboard.Name = "SlotLabel"
		billboard.Size = UDim2.new(1, 0, 0.5, 0)
		billboard.StudsOffset = Vector3.new(0, 0.5, 0)
		billboard.AlwaysOnTop = false
		billboard.Parent = tile
		
		local label = Instance.new("TextLabel")
		label.Size = UDim2.new(1, 0, 1, 0)
		label.BackgroundTransparency = 1
		label.Text = tostring(slotIndex)
		label.TextColor3 = Color3.fromRGB(150, 150, 150)
		label.TextScaled = true
		label.Font = Enum.Font.Gotham
		label.TextStrokeTransparency = 0.5
		label.TextStrokeColor3 = Color3.new(0, 0, 0)
		label.Parent = billboard
	end
	
	return tile
end

--[[
	Renders the build mode grid using 4 corner clusters.
]]
renderBuildGrid = function()
	-- Get grid state from server (for tracking occupancy)
	local gridState = GetGrid:InvokeServer()
	if not gridState then return end
	
	local plot = findPlayerPlot()
	if not plot then return end
	
	-- Get plot info
	local floor = plot:FindFirstChild("Island") 
		or plot:FindFirstChild("PlotFloor") 
		or plot:FindFirstChild("Floor")
		or plot:FindFirstChildWhichIsA("BasePart")
	
	if not floor then return end
	
	local plotCenter = floor.Position
	local plotSize = floor.Size
	local plotTop = Vector3.new(plotCenter.X, plotCenter.Y + plotSize.Y/2, plotCenter.Z)
	local gridY = plotTop.Y + 0.5
	gridFloorHeight = gridY -- Store for physics raycasting
	
	-- Clear any old grid container
	if gridContainer then
		gridContainer:Destroy()
	end
	
	gridContainer = Instance.new("Folder")
	gridContainer.Name = "BuildModeGrid"
	gridContainer.Parent = workspace
	
	-- Clear old tiles
	gridTiles = {}
	
	-- Corner cluster configuration (matches server)
	local CLUSTER_SIZE = 2  -- 2x2 per corner
	local TILE_SPACING = CONFIG.TILE_SIZE
	
	-- Calculate corner offsets (distance from center to corner cluster center)
	local cornerOffsetX = (plotSize.X / 2) - (CLUSTER_SIZE * TILE_SPACING / 2) - TILE_SPACING
	local cornerOffsetZ = (plotSize.Z / 2) - (CLUSTER_SIZE * TILE_SPACING / 2) - TILE_SPACING
	
	-- Corner base positions (relative to plot center)
	local cornerPositions = {
		{x = -cornerOffsetX, z = -cornerOffsetZ},  -- Top-left (slots 1-4)
		{x = cornerOffsetX, z = -cornerOffsetZ},   -- Top-right (slots 5-8)
		{x = -cornerOffsetX, z = cornerOffsetZ},   -- Bottom-left (slots 9-12)
		{x = cornerOffsetX, z = cornerOffsetZ},    -- Bottom-right (slots 13-16)
	}
	
	-- Create 16 tiles (4 corners x 4 slots each)
	for slotIndex = 1, 16 do
		local cornerIndex = math.floor((slotIndex - 1) / 4)
		local posInCorner = (slotIndex - 1) % 4
		
		local localRow = math.floor(posInCorner / 2)
		local localCol = posInCorner % 2
		
		local corner = cornerPositions[cornerIndex + 1]
		
		local posX = plotCenter.X + corner.x + (localCol - 0.5) * TILE_SPACING
		local posZ = plotCenter.Z + corner.z + (localRow - 0.5) * TILE_SPACING
		
		local unitName = gridState.slots[slotIndex]
		local isOccupied = unitName ~= nil
		local tile = createGridTile(slotIndex, Vector3.new(posX, gridY, posZ), isOccupied, unitName)
		tile.Parent = gridContainer
		
		gridTiles[slotIndex] = tile
	end
	
	print("BuildModeUI: Rendered 16 grid tiles (4 corners x 4 slots)")
	return plotTop
end

--[[
	Destroys the build grid.
]]
local function destroyBuildGrid()
	if gridContainer then
		gridContainer:Destroy()
		gridContainer = nil
		gridTiles = {}
	end
end

--[[
	Highlights a tile.
]]
local function highlightTile(slotIndex, color)
	local tile = gridTiles[slotIndex]
	if not tile then return end
	
	TweenService:Create(tile, TweenInfo.new(0.1), {
		Color = color,
		Transparency = 0.3
	}):Play()
	
	local outline = tile:FindFirstChild("Outline")
	if outline then
		outline.Color3 = color
		outline.Transparency = 0
	end
end

--[[
	Unhighlights a tile.
]]
local function unhighlightTile(slotIndex)
	local tile = gridTiles[slotIndex]
	if not tile then return end
	
	local isOccupied = tile:GetAttribute("IsOccupied")
	TweenService:Create(tile, TweenInfo.new(0.1), {
		Color = isOccupied and CONFIG.OCCUPIED_COLOR or CONFIG.EMPTY_COLOR,
		Transparency = 0.85
	}):Play()
	
	local outline = tile:FindFirstChild("Outline")
	if outline then
		outline.Color3 = Color3.fromRGB(200, 200, 200)
		outline.Transparency = 0.5
	end
end

--------------------------------------------------------------------------------
-- CAMERA CONTROLS
--------------------------------------------------------------------------------

--[[
	Tweens camera to isometric build view.
]]
local function tweenToIsometricView(plotCenter)
	savedCameraCFrame = camera.CFrame
	
	-- Calculate isometric camera position
	local angleRad = math.rad(CONFIG.CAMERA_ANGLE)
	local distance = CONFIG.CAMERA_HEIGHT / math.sin(angleRad)
	
	-- Position camera above and slightly back
	local cameraPos = plotCenter + Vector3.new(0, CONFIG.CAMERA_HEIGHT, distance * math.cos(angleRad))
	local targetCFrame = CFrame.new(cameraPos, plotCenter)
	
	-- Switch to scriptable camera
	camera.CameraType = Enum.CameraType.Scriptable
	
	-- Tween to position
	local tween = TweenService:Create(camera, TweenInfo.new(CONFIG.CAMERA_TWEEN_TIME, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		CFrame = targetCFrame
	})
	tween:Play()
	
	print("BuildModeUI: Camera tweened to isometric view")
end

--[[
	Tweens camera back to player view.
]]
local function tweenToPlayerView()
	if not savedCameraCFrame then return end
	
	-- Tween back
	local tween = TweenService:Create(camera, TweenInfo.new(CONFIG.CAMERA_TWEEN_TIME, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		CFrame = savedCameraCFrame
	})
	tween:Play()
	
	tween.Completed:Connect(function()
		camera.CameraType = Enum.CameraType.Custom
		savedCameraCFrame = nil
	end)
	
	print("BuildModeUI: Camera returned to player view")
end

--------------------------------------------------------------------------------
-- BUILD MODE UI
--------------------------------------------------------------------------------

--[[
	Creates the build mode UI overlay with Roblox STUD theme.
]]
local function createBuildModeUI()
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "BuildModeUI"
	screenGui.ResetOnSpawn = false
	screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	screenGui.DisplayOrder = 100
	
	-- Helper for rounded stroke panels (MoneyHUD style)
	local function _stylePanel(frame, radius)
		frame.BackgroundColor3 = CONFIG.THEME_BG
		frame.BackgroundTransparency = 0.1 -- Slight transparency like MoneyHUD
		frame.BorderSizePixel = 0
		
		local corner = Instance.new("UICorner")
		corner.CornerRadius = UDim.new(0, radius or CONFIG.THEME_PANEL_RADIUS)
		corner.Parent = frame
		
		local stroke = Instance.new("UIStroke")
		stroke.Color = CONFIG.THEME_STROKE
		stroke.Thickness = 2
		stroke.Parent = frame
		return frame
	end
	
	-- Top bar (transparent container)
	local topBar = Instance.new("Frame")
	topBar.Name = "TopBar"
	topBar.Size = UDim2.new(1, 0, 0, 50)
	topBar.Position = UDim2.new(0, 0, 0, 0)
	topBar.BackgroundTransparency = 1
	topBar.BorderSizePixel = 0
	topBar.Parent = screenGui
	
	-- BUILD MODE title badge
	local titleContainer = Instance.new("Frame")
	titleContainer.Name = "TitleContainer"
	titleContainer.Size = UDim2.new(0, 160, 0, 32)
	titleContainer.Position = UDim2.new(0, 140, 0.5, -16)
	titleContainer.BackgroundColor3 = CONFIG.THEME_ACCENT_PINK
	titleContainer.BorderSizePixel = 0
	titleContainer.Parent = topBar
	
	local titleCorner = Instance.new("UICorner")
	titleCorner.CornerRadius = UDim.new(0, CONFIG.THEME_BUTTON_RADIUS)
	titleCorner.Parent = titleContainer
	
	local title = Instance.new("TextLabel")
	title.Name = "Title"
	title.Size = UDim2.new(1, 0, 1, 0)
	title.Position = UDim2.new(0, 0, 0, 0)
	title.BackgroundTransparency = 1
	title.Text = "ðŸ—ï¸ BUILD MODE"
	title.TextColor3 = CONFIG.THEME_TEXT_PRIMARY
	title.TextSize = 14
	title.Font = Enum.Font.GothamBold
	title.Parent = titleContainer
	
	-- Instructions
	local instructions = Instance.new("TextLabel")
	instructions.Name = "Instructions"
	instructions.Size = UDim2.new(0, 400, 1, 0)
	instructions.Position = UDim2.new(0.5, -200, 0, 0)
	instructions.BackgroundTransparency = 1
	instructions.Text = "Click to select â€¢ Drag to move"
	instructions.TextColor3 = CONFIG.THEME_TEXT_SECONDARY
	instructions.TextSize = 14
	instructions.Font = Enum.Font.GothamBold
	instructions.Parent = topBar
	
	-- Exit button (Matching theme style)
	local exitButton = Instance.new("TextButton")
	exitButton.Name = "ExitButton"
	exitButton.Size = UDim2.new(0, 90, 0, 36)
	exitButton.Position = UDim2.new(1, -105, 0.5, -18)
	exitButton.BackgroundColor3 = CONFIG.THEME_ACCENT_PURPLE -- Matching theme button color
	exitButton.Text = "EXIT"
	exitButton.TextColor3 = CONFIG.THEME_TEXT_PRIMARY
	exitButton.TextSize = 14
	exitButton.Font = Enum.Font.GothamBold
	exitButton.Parent = topBar
	
	local exitCorner = Instance.new("UICorner")
	exitCorner.CornerRadius = UDim.new(0, CONFIG.THEME_BUTTON_RADIUS)
	exitCorner.Parent = exitButton
	
	-- Hover effect
	exitButton.MouseEnter:Connect(function()
		TweenService:Create(exitButton, TweenInfo.new(0.1), {
			BackgroundColor3 = CONFIG.THEME_ACCENT_PURPLE:Lerp(Color3.new(1,1,1), 0.1)
		}):Play()
	end)
	
	exitButton.MouseLeave:Connect(function()
		TweenService:Create(exitButton, TweenInfo.new(0.1), {
			BackgroundColor3 = CONFIG.THEME_ACCENT_PURPLE
		}):Play()
	end)
	
	-- Status bar at bottom (transparent container)
	local bottomBar = Instance.new("Frame")
	bottomBar.Name = "BottomBar"
	bottomBar.Size = UDim2.new(1, 0, 0, 36)
	bottomBar.Position = UDim2.new(0, 0, 1, -36)
	bottomBar.BackgroundTransparency = 1
	bottomBar.BorderSizePixel = 0
	bottomBar.Parent = screenGui
	
	-- Status text
	local statusLabel = Instance.new("TextLabel")
	statusLabel.Name = "Status"
	statusLabel.Size = UDim2.new(1, -40, 1, 0)
	statusLabel.Position = UDim2.new(0, 20, 0, 0)
	statusLabel.BackgroundTransparency = 1
	statusLabel.Text = "Editing Plot - Click tile or drag from inventory"
	statusLabel.TextColor3 = CONFIG.THEME_TEXT_PRIMARY
	statusLabel.TextSize = 14
	statusLabel.Font = Enum.Font.GothamBold
	statusLabel.TextXAlignment = Enum.TextXAlignment.Left
	statusLabel.Parent = bottomBar
	
	-- RIGHT SIDEBAR (Modern Style)
	local rightSidebar = Instance.new("Frame")
	rightSidebar.Name = "RightSidebar"
	rightSidebar.Size = UDim2.new(0, 180, 0, 260)
	rightSidebar.Position = UDim2.new(1, -190, 0, 70)
	_stylePanel(rightSidebar)
	rightSidebar.Parent = screenGui
	
	-- Storage display
	local storageFrame = Instance.new("Frame")
	storageFrame.Name = "StorageFrame"
	storageFrame.Size = UDim2.new(1, -20, 0, 50)
	storageFrame.Position = UDim2.new(0, 10, 0, 10)
	storageFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 50) -- Darker inner panel
	storageFrame.BorderSizePixel = 0
	storageFrame.Parent = rightSidebar
	
	local storageCorner = Instance.new("UICorner")
	storageCorner.CornerRadius = UDim.new(0, CONFIG.THEME_BUTTON_RADIUS)
	storageCorner.Parent = storageFrame
	
	local storageTitle = Instance.new("TextLabel")
	storageTitle.Name = "StorageTitle"
	storageTitle.Size = UDim2.new(1, -10, 0, 20)
	storageTitle.Position = UDim2.new(0, 5, 0, 5)
	storageTitle.BackgroundTransparency = 1
	storageTitle.Text = "ðŸ“¦ STORAGE"
	storageTitle.TextColor3 = CONFIG.THEME_TEXT_PRIMARY
	storageTitle.TextSize = 12
	storageTitle.Font = Enum.Font.GothamBold
	storageTitle.TextXAlignment = Enum.TextXAlignment.Left
	storageTitle.Parent = storageFrame
	
	local storageBar = Instance.new("Frame")
	storageBar.Name = "StorageBar"
	storageBar.Size = UDim2.new(1, -10, 0, 12)
	storageBar.Position = UDim2.new(0, 5, 0, 28)
	storageBar.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
	storageBar.BorderSizePixel = 0
	storageBar.Parent = storageFrame
	
	local storageBarCorner = Instance.new("UICorner")
	storageBarCorner.CornerRadius = UDim.new(0, 4)
	storageBarCorner.Parent = storageBar
	
	local storageFill = Instance.new("Frame")
	storageFill.Name = "Fill"
	storageFill.Size = UDim2.new(0.5, 0, 1, 0) -- Placeholder fill
	storageFill.BackgroundColor3 = CONFIG.THEME_ACCENT_BLUE
	storageFill.BorderSizePixel = 0
	storageFill.Parent = storageBar
	
	local storageFillCorner = Instance.new("UICorner")
	storageFillCorner.CornerRadius = UDim.new(0, 4)
	storageFillCorner.Parent = storageFill
	
	-- Quick Actions Title
	local actionsTitle = Instance.new("TextLabel")
	actionsTitle.Name = "ActionsTitle"
	actionsTitle.Size = UDim2.new(1, -20, 0, 20)
	actionsTitle.Position = UDim2.new(0, 10, 0, 70)
	actionsTitle.BackgroundTransparency = 1
	actionsTitle.Text = "QUICK ACTIONS"
	actionsTitle.TextColor3 = CONFIG.THEME_TEXT_SECONDARY
	actionsTitle.TextSize = 10
	actionsTitle.Font = Enum.Font.GothamBold
	actionsTitle.TextXAlignment = Enum.TextXAlignment.Left
	actionsTitle.Parent = rightSidebar
	
	-- Buttons List
	local buttons = {
		{text = "Open Shop (B)", color = CONFIG.THEME_ACCENT_PURPLE},
		{text = "Brainrots (I)", color = CONFIG.THEME_ACCENT_PINK},
		{text = "Synergies (Y)", color = CONFIG.THEME_ACCENT_GOLD},
	}
	
	for i, btn in ipairs(buttons) do
		local button = Instance.new("TextButton")
		button.Name = "QuickButton_" .. i
		button.Size = UDim2.new(1, -20, 0, 36)
		button.Position = UDim2.new(0, 10, 0, 95 + (i-1)*42)
		button.BackgroundColor3 = btn.color
		button.Text = btn.text
		button.TextColor3 = CONFIG.THEME_TEXT_PRIMARY
		button.TextSize = 12
		button.Font = Enum.Font.GothamBold
		button.Parent = rightSidebar
		
		local btnCorner = Instance.new("UICorner")
		btnCorner.CornerRadius = UDim.new(0, CONFIG.THEME_BUTTON_RADIUS)
		btnCorner.Parent = button
		
		-- Simple hover
		button.MouseEnter:Connect(function()
			button.BackgroundColor3 = btn.color:Lerp(Color3.new(1,1,1), 0.1)
		end)
		button.MouseLeave:Connect(function()
			button.BackgroundColor3 = btn.color
		end)
	end
	
	return screenGui
end

--[[
	Updates the status text.
]]
local function updateStatus(text)
	if not buildModeGui then return end
	local bottomBar = buildModeGui:FindFirstChild("BottomBar")
	if bottomBar then
		local status = bottomBar:FindFirstChild("Status")
		if status then
			status.Text = text
		end
	end
end

--------------------------------------------------------------------------------
-- INVENTORY PANEL (for Build Mode)
--------------------------------------------------------------------------------

local RARITY_ORDER = {"Normal", "Spicy", "Galaxy"}
local inventoryItems = {}  -- UI item frames

--[[
	Creates the inventory panel for Build Mode with STUD theme.
]]
local function createInventoryPanel(parent)
	local panel = Instance.new("Frame")
	panel.Name = "InventoryPanel"
	panel.Size = UDim2.new(0, CONFIG.INVENTORY_WIDTH, 1, -110)
	panel.Position = UDim2.new(0, 10, 0, 60)
	_stylePanel(panel)
	panel.Parent = parent
	
	-- Title
	local title = Instance.new("TextLabel")
	title.Name = "Title"
	title.Size = UDim2.new(1, -20, 0, 30)
	title.Position = UDim2.new(0, 10, 0, 10)
	title.BackgroundTransparency = 1
	title.Text = "ðŸ§  INVENTORY"
	title.TextColor3 = CONFIG.THEME_ACCENT_PURPLE
	title.TextSize = 16
	title.Font = Enum.Font.GothamBold
	title.TextXAlignment = Enum.TextXAlignment.Left
	title.Parent = panel
	
	-- Scrolling frame for items
	local scrollFrame = Instance.new("ScrollingFrame")
	scrollFrame.Name = "ItemsList"
	scrollFrame.Size = UDim2.new(1, -20, 1, -50)
	scrollFrame.Position = UDim2.new(0, 10, 0, 45)
	scrollFrame.BackgroundTransparency = 1
	scrollFrame.BorderSizePixel = 0
	scrollFrame.ScrollBarThickness = 4
	scrollFrame.ScrollBarImageColor3 = CONFIG.THEME_ACCENT_PURPLE
	scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
	scrollFrame.Parent = panel
	
	local listLayout = Instance.new("UIListLayout")
	listLayout.SortOrder = Enum.SortOrder.Name
	listLayout.Padding = UDim.new(0, 8)
	listLayout.Parent = scrollFrame
	
	-- Auto-resize canvas
	listLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
		scrollFrame.CanvasSize = UDim2.new(0, 0, 0, listLayout.AbsoluteContentSize.Y + 10)
	end)
	
	inventoryPanel = panel
	return panel;
end

--[[
	Populates the inventory panel with stored units.
	Called when entering build mode and after placing/removing units.
]]
refreshInventoryPanel = function()
	if not inventoryPanel then return end
	
	local scrollFrame = inventoryPanel:FindFirstChild("ItemsList")
	if not scrollFrame then return end
	
	-- Clear old entries
	for _, child in scrollFrame:GetChildren() do
		if child:IsA("Frame") then
			child:Destroy()
		end
	end
	inventoryItems = {}
	
	-- Clean up old previews
	for _, previewFrame in pairs(inventoryPreviews) do
		if previewFrame and previewFrame.Parent then
			previewFrame:Destroy()
		end
	end
	inventoryPreviews = {}
	
	-- Fetch inventory from server
	local success, inventory = pcall(function()
		return GetInventoryRemote:InvokeServer()
	end)
	
	if not success or not inventory or not inventory.units then
		return
	end
	
	-- Create an entry for each unit that is STORED (not placed)
	for unitName, unitData in pairs(inventory.units) do
		if unitData.status == "stored" then
			local rarityColor = CONFIG.RARITY_COLORS[unitData.rarity] or CONFIG.THEME_TEXT_SECONDARY
			
			-- Card container (Modern Style)
			local itemFrame = Instance.new("Frame")
			itemFrame.Name = "Item_" .. unitName
			itemFrame.Size = UDim2.new(1, 0, 0, 90) -- Slightly taller for new layout
			itemFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 50) -- Dark inner panel
			itemFrame.BorderSizePixel = 0
			itemFrame.Parent = scrollFrame
			
			local corner = Instance.new("UICorner")
			corner.CornerRadius = UDim.new(0, CONFIG.THEME_BUTTON_RADIUS)
			corner.Parent = itemFrame
			
			-- Viewport (Preview)
			local viewport = Instance.new("ViewportFrame")
			viewport.Name = "Preview"
			viewport.Size = UDim2.new(0, 70, 0, 70)
			viewport.Position = UDim2.new(0, 10, 0, 10)
			viewport.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
			viewport.BorderSizePixel = 0
			viewport.Parent = itemFrame
			
			local viewCorner = Instance.new("UICorner")
			viewCorner.CornerRadius = UDim.new(0, CONFIG.THEME_BUTTON_RADIUS)
			viewCorner.Parent = viewport
			
			-- Info Group
			local infoGroup = Instance.new("Frame")
			infoGroup.Name = "Info"
			infoGroup.Size = UDim2.new(1, -90, 1, 0)
			infoGroup.Position = UDim2.new(0, 90, 0, 0)
			infoGroup.BackgroundTransparency = 1
			infoGroup.Parent = itemFrame
			
			-- Unit Name
			local nameLabel = Instance.new("TextLabel")
			nameLabel.Name = "Name"
			nameLabel.Size = UDim2.new(1, 0, 0, 20)
			nameLabel.Position = UDim2.new(0, 0, 0, 10)
			nameLabel.BackgroundTransparency = 1
			nameLabel.Text = unitName
			nameLabel.TextColor3 = CONFIG.THEME_TEXT_PRIMARY
			nameLabel.TextSize = 14
			nameLabel.Font = Enum.Font.GothamBold
			nameLabel.TextXAlignment = Enum.TextXAlignment.Left
			nameLabel.TextTruncate = Enum.TextTruncate.AtEnd
			nameLabel.Parent = infoGroup
			
			-- Level / Rarity
			local rarityLabel = Instance.new("TextLabel")
			rarityLabel.Name = "Rarity"
			rarityLabel.Size = UDim2.new(1, 0, 0, 16)
			rarityLabel.Position = UDim2.new(0, 0, 0, 30)
			rarityLabel.BackgroundTransparency = 1
			rarityLabel.Text = string.format("Lvl %d â€¢ %s", unitData.level or 1, unitData.rarity or "Normal")
			rarityLabel.TextColor3 = rarityColor
			rarityLabel.TextSize = 11
			rarityLabel.Font = Enum.Font.Gotham
			rarityLabel.TextXAlignment = Enum.TextXAlignment.Left
			rarityLabel.Parent = infoGroup
			
			-- HP Label
			local hpLabel = Instance.new("TextLabel")
			hpLabel.Name = "HP"
			hpLabel.Size = UDim2.new(1, 0, 0, 16)
			hpLabel.Position = UDim2.new(0, 0, 0, 46)
			hpLabel.BackgroundTransparency = 1
			hpLabel.Text = "â¤ï¸ " .. tostring((unitData.level or 1) * 10 + 25) -- Example HP calculation
			hpLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
			hpLabel.TextSize = 11
			hpLabel.Font = Enum.Font.GothamBold
			hpLabel.TextXAlignment = Enum.TextXAlignment.Left
			hpLabel.Parent = infoGroup
			
			-- Place Button
			local placeButton = Instance.new("TextButton")
			placeButton.Name = "PlaceButton"
			placeButton.Size = UDim2.new(0, 50, 0, 26)
			placeButton.Position = UDim2.new(1, -60, 0, 10)
			placeButton.BackgroundColor3 = CONFIG.THEME_ACCENT_GREEN
			placeButton.Text = "PLACE"
			placeButton.TextColor3 = Color3.fromRGB(20, 20, 20)
			placeButton.TextSize = 10
			placeButton.Font = Enum.Font.GothamBold
			placeButton.Parent = itemFrame
			
			local btnCorner = Instance.new("UICorner")
			btnCorner.CornerRadius = UDim.new(0, 4)
			btnCorner.Parent = placeButton
			
			-- Hover effect for place button
			placeButton.MouseEnter:Connect(function()
				placeButton.BackgroundColor3 = CONFIG.THEME_ACCENT_GREEN:Lerp(Color3.new(1,1,1), 0.1)
			end)
			placeButton.MouseLeave:Connect(function()
				placeButton.BackgroundColor3 = CONFIG.THEME_ACCENT_GREEN
			end)
			
			-- Try to add model preview
			local template = BrainrotsFolder:FindFirstChild(unitName)
			if template then
				local previewModel = template:Clone()
				previewModel.Parent = previewFrame
				
				local previewCamera = Instance.new("Camera")
				previewCamera.Parent = previewFrame
				previewFrame.CurrentCamera = previewCamera
				
				-- Calculate bounding box to properly frame the model
				local cf, size = previewModel:GetBoundingBox()
				local maxDim = math.max(size.X, size.Y, size.Z)
				local distance = maxDim * 1.0  -- Zoomed in closer
				
				-- Position camera to look at the model from front-right, slightly above
				local cameraPos = cf.Position + Vector3.new(distance * 0.4, distance * 0.2, distance * 0.8)
				previewCamera.CFrame = CFrame.lookAt(cameraPos, cf.Position)
			end
			
			-- Place button (STUD green)
			local placeButton = Instance.new("TextButton")
			placeButton.Name = "PlaceButton"
			placeButton.Size = UDim2.new(0, 54, 0, 26)
			placeButton.Position = UDim2.new(1, -60, 0.5, -13)
			placeButton.BackgroundColor3 = CONFIG.STUD_GREEN
			placeButton.Text = "PLACE"
			placeButton.TextColor3 = CONFIG.STUD_WHITE
			placeButton.TextSize = 11
			placeButton.Font = Enum.Font.GothamBlack
			placeButton.Parent = itemFrame
			
			local placeCorner = Instance.new("UICorner")
			placeCorner.CornerRadius = UDim.new(0, 4)
			placeCorner.Parent = placeButton
			
			local placeStroke = Instance.new("UIStroke")
			placeStroke.Color = Color3.fromRGB(50, 100, 50)
			placeStroke.Thickness = 2
			placeStroke.Parent = placeButton
			
			-- Start drag on button click or frame drag
			placeButton.MouseButton1Down:Connect(function()
				startDrag(unitName, unitData.rarity or "Normal")
			end)
			
			itemFrame.InputBegan:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 then
					startDrag(unitName, unitData.rarity or "Normal")
				end
			end)
			
			inventoryItems[unitName] = itemFrame
		end
	end
end

-- Ghost colors

local GHOST_VALID_COLOR = Color3.fromRGB(100, 255, 100)

local GHOST_INVALID_COLOR = Color3.fromRGB(255, 80, 80)

--[[
	Gets the brainrot model from ReplicatedStorage.
]]
local function getBrainrotModel(unitName: string): Model?
	-- Check main Brainrots folder first (same as inventory preview)
	if BrainrotsFolder then
		local model = BrainrotsFolder:FindFirstChild(unitName)
		if model then return model end
	end
	
	-- Fallback: Check Units folder
	local unitsFolder = ReplicatedStorage:FindFirstChild("Units")
	if unitsFolder then
		local model = unitsFolder:FindFirstChild(unitName)
		if model then return model end
	end
	
	-- Fallback: Check Assets/Brainrots
	local assetsFolder = ReplicatedStorage:FindFirstChild("Assets")
	if assetsFolder then
		local brainrotsSubfolder = assetsFolder:FindFirstChild("Brainrots")
		if brainrotsSubfolder then
			local model = brainrotsSubfolder:FindFirstChild(unitName)
			if model then return model end
		end
	end
	
	return nil
end

--[[
	Sets transparency on all parts in a model (for ghost effects).
]]
local function setModelTransparency(model: Model, transparency: number)
	for _, part in model:GetDescendants() do
		if part:IsA("BasePart") then
			part.Transparency = transparency
		end
	end
end

--[[
	Sets color on all parts in a model (for ghost effects).
]]
local function setModelColor(model: Model, color: Color3)
	for _, part in model:GetDescendants() do
		if part:IsA("BasePart") then
			part.Color = color
		end
	end
	
	-- Also update highlight if present
	local highlight = model:FindFirstChildWhichIsA("Highlight")
	if highlight then
		highlight.FillColor = color
		highlight.OutlineColor = color
	end
end

--[[
	Creates a ghost preview using the MeshPart-only approach.
]]
--[[
	Creates a ghost preview using the MeshPart-only approach.
]]
--[[
	Creates a ghost preview using the MeshPart-only approach.
]]
local function createPlacementGhost(unitName: string): Model?
	local originalModel = getBrainrotModel(unitName)
	local ghost

	-- 1. Create the Clone
	if originalModel then
		ghost = originalModel:Clone()
		-- Calculate bounding box center offset from pivot
		-- This ensures the ghost is centered on the model's visual center
		local cf, _size = originalModel:GetBoundingBox()
		local pivotPos = originalModel:GetPivot().Position
		local boundingBoxCenter = cf.Position
		ghostCenterOffset = pivotPos - boundingBoxCenter
	else
		-- Fallback if model is missing
		ghost = Instance.new("Model")
		local part = Instance.new("Part")
		part.Name = "FallbackGhost"
		part.Size = Vector3.new(3, 5, 3)
		part.Transparency = 0.5
		part.Color = GHOST_VALID_COLOR
		part.Material = Enum.Material.ForceField
		part.Anchored = true
		part.CanCollide = false
		part.CastShadow = false
		part.Parent = ghost
		ghost.PrimaryPart = part
		
		ghost.Name = "PlacementGhost"
		ghost.Parent = workspace
		placementGhost = ghost
		isGhostValid = true
		ghostCenterOffset = Vector3.new()
		return ghost
	end

	ghost.Name = "PlacementGhost"

	-- 2. Clean up logic (Destroy specific types AND specific names)
	local descendants = ghost:GetDescendants()
	for _, item in descendants do
		-- Check if the item still exists (it might have been a child of a previously destroyed item)
		if not item.Parent then continue end

		-- A. Remove unwanted classes (Scripts, UI, Sounds, Humanoids)
		if item:IsA("Humanoid") 
			or item:IsA("LuaSourceContainer") 
			or item:IsA("Sound") 
			or item:IsA("Light") 
			or item:IsA("ParticleEmitter") 
			or item:IsA("Trail")
			or item:IsA("Beam")
			or item:IsA("BillboardGui")
			or item:IsA("SurfaceGui")
		then
			item:Destroy()
			continue
		end

		-- B. Remove unwanted specific Parts (The "Weird Box" fix)
		if item.Name == "FakeRootPart" 
			or item.Name == "RootPart" 
			or item.Name == "HumanoidRootPart" 
			or item.Name == "Hitbox" 
			or item.Name == "VfxInstance"
            or item.Name == "AnimationController" -- Also usually junk in ghosts
		then
			item:Destroy()
			continue
		end
		
		-- C. Apply Ghost Visuals to what remains
		if item:IsA("BasePart") then
			if item:IsA("MeshPart") then
				-- MeshPart = actual visual geometry, apply ghost effect
				item.CanCollide = false
				item.CastShadow = false
				item.Anchored = true
				item.Transparency = 0.3
				item.Color = GHOST_VALID_COLOR
				item.Material = Enum.Material.ForceField
			else
				-- Regular Parts/Unions = remaining structure - keep invisible
				-- (If any survived the delete list above)
				item.CanCollide = false
				item.CastShadow = false
				item.Anchored = true
				item.Transparency = 1
			end
		elseif item:IsA("Decal") or item:IsA("Texture") then
			item:Destroy() -- Clean up textures too for a cleaner ghost look
		end
	end

	ghost.Parent = workspace
	placementGhost = ghost
	isGhostValid = true

	return ghost
end

--[[
	Destroys the placement ghost.
]]
local function destroyPlacementGhost()
	if ghostPulseTween then
		ghostPulseTween:Cancel()
		ghostPulseTween = nil
	end
	
	if placementGhost then
		placementGhost:Destroy()
		placementGhost = nil
	end
	
	isGhostValid = false
end

--[[
	Starts the pulsing effect on ghost (valid position).
]]
local function startGhostPulse()
	if not placementGhost then return end
	
	-- Stop existing pulse
	if ghostPulseTween then
		ghostPulseTween:Cancel()
	end
	
	-- Set valid color
	setModelColor(placementGhost, GHOST_VALID_COLOR)
	isGhostValid = true
	
	-- Create pulse loop
	local pulsing = true
	local currentTransparency = 0.3
	local direction = 1
	
	task.spawn(function()
		while pulsing and placementGhost and placementGhost.Parent do
			currentTransparency = currentTransparency + (direction * 0.15 * 0.016)
			
			if currentTransparency >= 0.6 then
				direction = -1
				currentTransparency = 0.6
			elseif currentTransparency <= 0.3 then
				direction = 1
				currentTransparency = 0.3
			end
			
			setModelTransparency(placementGhost, currentTransparency)
			task.wait()
		end
	end)
end

--[[
	Stops pulsing and sets ghost to invalid (solid red).
]]
local function setGhostInvalid()
	if not placementGhost then return end
	
	if ghostPulseTween then
		ghostPulseTween:Cancel()
		ghostPulseTween = nil
	end
	
	setModelColor(placementGhost, GHOST_INVALID_COLOR)
	setModelTransparency(placementGhost, 0.5)
	isGhostValid = false
end

--------------------------------------------------------------------------------
-- DRAG AND DROP SYSTEM
--------------------------------------------------------------------------------

--[[
	Calculates the mouse position on the 3D plane at grid height.
	Allows dragging freely between tiles.
]]
local function getMousePlanePosition()
	local mouse = UserInputService:GetMouseLocation()
	local ray = camera:ViewportPointToRay(mouse.X, mouse.Y)
	
	-- Create a mathematical plane at the grid height (y = gridFloorHeight)
	-- Plane equation: (P - P0) dot Normal = 0
	-- Ray: P = Origin + Direction * t
	-- (Origin + Dir*t - P0) dot Normal = 0
	-- t = (P0 - Origin) dot Normal / (Dir dot Normal)
	
	local normal = Vector3.new(0, 1, 0)
	local p0 = Vector3.new(0, gridFloorHeight, 0)
	
	local denominator = ray.Direction:Dot(normal)
	
	if math.abs(denominator) > 0.001 then -- Prevent division by zero
		local t = (p0 - ray.Origin):Dot(normal) / denominator
		if t > 0 then
			return ray.Origin + ray.Direction * t
		end
	end
	
	return nil
end

--[[
	Starts a drag operation from inventory.
]]
startDrag = function(unitName: string, rarity: string)
	if isDragging then return end
	
	isDragging = true
	draggedUnit = {name = unitName, rarity = rarity}
	
	-- Determine Start Position
	local mousePos = getMousePlanePosition()
	local startPos = mousePos or Vector3.new(0, gridFloorHeight, 0)
	
	-- Physics State Variables
	local currentPos = startPos
	local currentVelocity = Vector3.new()
	local currentTilt = CFrame.new()
	local targetHeight = gridFloorHeight + CONFIG.DRAG_HEIGHT
	
	-- Create ghost
	local ghost = createPlacementGhost(unitName)
	if ghost then
		-- Apply offset so visual center is at the target position
		ghost:PivotTo(CFrame.new(startPos + Vector3.new(0, CONFIG.DRAG_HEIGHT, 0) + ghostCenterOffset))
		startGhostPulse()
	end
	
	updateStatus("ðŸŽ¯ Release over an empty tile to place " .. unitName)
	
	-- KINEMATIC DRAG LOOP
	dragConnection = RunService.RenderStepped:Connect(function(dt)
		if not isDragging then return end
		
		-- 1. Determine Target Position (Mouse on Floor Plane)
		local rawMousePos = getMousePlanePosition()
		if not rawMousePos then return end
		
		local targetPos = rawMousePos + Vector3.new(0, CONFIG.DRAG_HEIGHT, 0)
		
		-- 2. Smooth Position (Lag Effect)
		-- Simple Lerp is often smoother than Spring for Mouse Drag in Roblox due to update rates
		local lerpAlpha = math.clamp(dt * CONFIG.DRAG_SMOOTHNESS, 0, 1)
		local newPos = currentPos:Lerp(targetPos, lerpAlpha)
		
		-- Calculate velocity for tilt
		local velocity = (newPos - currentPos) / dt
		currentPos = newPos
		
		-- 3. Calculate Tilt (Procedural Animation)
		-- Tilt axis is perpendicular to velocity and up vector
		local tiltAxis = velocity:Cross(Vector3.yAxis)
		local speed = velocity.Magnitude
		
		-- Calculate target tilt rotation
		local targetTiltRot = CFrame.new()
		if speed > 0.1 and tiltAxis.Magnitude > 0.01 then
			-- Calculate angle based on speed (clamped)
			local tiltAngle = math.rad(math.clamp(speed * CONFIG.TILT_STRENGTH, -CONFIG.MAX_TILT_ANGLE, CONFIG.MAX_TILT_ANGLE))
			
			-- We invert the angle so it "drags" behind
			targetTiltRot = CFrame.fromAxisAngle(tiltAxis.Unit, -tiltAngle)
		end
		
		-- Smoothly interpolate tilt
		currentTilt = currentTilt:Lerp(targetTiltRot, dt * CONFIG.TILT_RETURN_SPEED)
		
		-- 4. Apply to Ghost
		if placementGhost then
			-- Apply offset so visual center follows cursor
			placementGhost:PivotTo(CFrame.new(currentPos + ghostCenterOffset) * currentTilt)
		end
		
		-- 5. Grid Interaction (Highlighting)
		local slot = getSlotUnderMouse()
		
		if slot then
			local tile = gridTiles[slot]
			local isOccupied = tile and tile:GetAttribute("IsOccupied")
			
			if isOccupied then
				if placementGhost then setGhostInvalid() end
				if tile then highlightTile(slot, CONFIG.INVALID_COLOR) end
				isGhostValid = false
			else
				if placementGhost and not isGhostValid then startGhostPulse() end
				if tile then highlightTile(slot, CONFIG.HOVER_COLOR) end
				isGhostValid = true
			end
		else
			if placementGhost then setGhostInvalid() end
			isGhostValid = false
		end
	end)
end

--[[
	Cancels the current drag operation.
]]
local function cancelDrag()
	if not isDragging then return end
	
	isDragging = false
	draggedUnit = nil
	
	if dragConnection then
		dragConnection:Disconnect()
		dragConnection = nil
	end
	
	destroyPlacementGhost()
	updateStatus("Drag cancelled")
end

--[[
	Completes a drop operation.
]]
completeDrop = function()
	if not isDragging or not draggedUnit then 
		cancelDrag()
		return 
	end
	
	-- Get slot under mouse
	local slot = getSlotUnderMouse()
	
	if slot and isGhostValid then
		-- Check if slot is empty
		local tile = gridTiles[slot]
		local isOccupied = tile and tile:GetAttribute("IsOccupied")
		
		if not isOccupied then
			-- Place the unit!
			local success, msg = PlaceBrainrotRemote:InvokeServer(draggedUnit.name, draggedUnit.rarity, slot)
			
			if success then
				updateStatus("âœ“ Placed " .. draggedUnit.name .. " at slot " .. slot)
				task.defer(renderBuildGrid)
				task.defer(refreshInventoryPanel)
			else
				updateStatus("âœ— " .. (msg or "Place failed"))
			end
		else
			updateStatus("âœ— Slot is occupied")
		end
	else
		updateStatus("âœ— Invalid drop location")
	end
	
	-- Cleanup
	isDragging = false
	draggedUnit = nil
	
	if dragConnection then
		dragConnection:Disconnect()
		dragConnection = nil
	end
	
	destroyPlacementGhost()
end

--[[
	Gets the brainrot model under the mouse cursor.
	Returns the model and its slot index if found.
]]
local function getBrainrotUnderMouse(): (Model?, number?)
	local mousePos = UserInputService:GetMouseLocation()
	
	-- Get all brainrots and check if we're clicking on any
	local brainrots = CollectionService:GetTagged("ActiveBrainrot")
	
	local closestBrainrot = nil
	local closestSlot = nil
	local closestDist = math.huge
	
	for _, brainrot in brainrots do
		local ownerId = brainrot:GetAttribute("OwnerId")
		local slotIndex = brainrot:GetAttribute("GridSlot")
		
		-- Only check brainrots owned by this player
		if ownerId ~= LocalPlayer.UserId then
			continue
		end
		
		if not slotIndex then 
			continue 
		end
		
		-- Get brainrot position
		local brainrotPos
		if brainrot:IsA("Model") then
			if brainrot.PrimaryPart then
				brainrotPos = brainrot.PrimaryPart.Position
			else
				brainrotPos = brainrot:GetPivot().Position
			end
		elseif brainrot:IsA("BasePart") then
			brainrotPos = brainrot.Position
		end
		
		if not brainrotPos then 
			continue 
		end
		
		-- Project to screen
		local screenPos, onScreen = camera:WorldToViewportPoint(brainrotPos)
		
		if not onScreen then continue end
		
		-- Check distance from mouse to brainrot's screen position
		local screenDist = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
		
		-- Use a generous click radius (80 pixels)
		if screenDist < 80 and screenDist < closestDist then
			closestDist = screenDist
			closestBrainrot = brainrot
			closestSlot = slotIndex
		end
	end
	
	return closestBrainrot, closestSlot
end

--[[
	Toggles visibility of all visual elements in a model.
]]
local function setVisualsEnabled(model: Model, enabled: boolean)
	for _, descendant in model:GetDescendants() do
		-- Skip parts that should ALWAYS remain hidden
		if descendant.Name == "FakeRootPart" 
			or descendant.Name == "VfxInstance" 
			or descendant.Name == "RootPart"
			or descendant.Name == "HumanoidRootPart"
			or descendant.Name == "Hitbox"
		then
			if descendant:IsA("BasePart") then
				descendant.Transparency = 1
			end
			continue
		end
		
		if descendant:IsA("MeshPart") then
			descendant.Transparency = enabled and 0 or 1
		elseif descendant:IsA("Part") or descendant:IsA("UnionOperation") then
			descendant.Transparency = 1
		elseif descendant:IsA("Decal") or descendant:IsA("Texture") then
			descendant.Transparency = enabled and 0 or 1
		elseif descendant:IsA("ParticleEmitter") or descendant:IsA("Trail") or descendant:IsA("Beam") then
			descendant.Enabled = enabled
		elseif descendant:IsA("LayerCollector") then
			descendant.Enabled = enabled
		end
	end
end

--[[
	Starts dragging an existing brainrot from the world.
]]
local function startDragFromWorld(brainrotModel: Model, slotIndex: number)
	if isDragging then return end
	
	isDragging = true
	draggedUnit = {
		name = brainrotModel:GetAttribute("UnitType") or brainrotModel.Name,
		rarity = brainrotModel:GetAttribute("Rarity") or "Normal",
		fromSlot = slotIndex,
		isFromWorld = true,
		originalModel = brainrotModel
	}
	
	updateStatus("ðŸŽ¯ Drag to new slot or inventory panel to store")
	
	-- Setup Physics State
	-- Start exactly where the unit currently is
	local startPos
	if brainrotModel.PrimaryPart then
		startPos = brainrotModel.PrimaryPart.Position
	else
		startPos = brainrotModel:GetPivot().Position
	end
	
	local currentPos = startPos
	local currentTilt = CFrame.new()
	
	-- Create placement ghost
	createPlacementGhost(draggedUnit.name)
	if placementGhost then
		-- Apply offset so visual center is at the start position
		placementGhost:PivotTo(CFrame.new(startPos + ghostCenterOffset))
	end
	
	-- Hide the original model while dragging
	if brainrotModel then
		setVisualsEnabled(brainrotModel, false)
	end
	
	-- Highlight the source slot
	if gridTiles[slotIndex] then
		highlightTile(slotIndex, CONFIG.SELECTED_COLOR)
	end
	
	-- KINEMATIC DRAG LOOP (World)
	dragConnection = RunService.RenderStepped:Connect(function(dt)
		if not isDragging then return end
		
		-- 1. Determine Target (Mouse on Floor Plane)
		local rawMousePos = getMousePlanePosition()
		if not rawMousePos then return end
		
		local targetPos = rawMousePos + Vector3.new(0, CONFIG.DRAG_HEIGHT, 0)
		
		-- 2. Smooth Position
		local lerpAlpha = math.clamp(dt * CONFIG.DRAG_SMOOTHNESS, 0, 1)
		local newPos = currentPos:Lerp(targetPos, lerpAlpha)
		
		local velocity = (newPos - currentPos) / dt
		currentPos = newPos
		
		-- 3. Calculate Tilt
		local tiltAxis = velocity:Cross(Vector3.yAxis)
		local speed = velocity.Magnitude
		
		local targetTiltRot = CFrame.new()
		if speed > 0.1 and tiltAxis.Magnitude > 0.01 then
			local tiltAngle = math.rad(math.clamp(speed * CONFIG.TILT_STRENGTH, -CONFIG.MAX_TILT_ANGLE, CONFIG.MAX_TILT_ANGLE))
			targetTiltRot = CFrame.fromAxisAngle(tiltAxis.Unit, -tiltAngle)
		end
		
		currentTilt = currentTilt:Lerp(targetTiltRot, dt * CONFIG.TILT_RETURN_SPEED)
		
		-- 4. Apply
		if placementGhost then
			-- Apply offset so visual center follows cursor
			placementGhost:PivotTo(CFrame.new(currentPos + ghostCenterOffset) * currentTilt)
		end
		
		-- 5. Logic Checks
		local slot = getSlotUnderMouse()
		
		if slot then
			local tile = gridTiles[slot]
			local isOccupied = tile and tile:GetAttribute("IsOccupied")
			
			if slot == draggedUnit.fromSlot then
				startGhostPulse()
			elseif isOccupied then
				setGhostInvalid()
				highlightTile(slot, CONFIG.INVALID_COLOR)
			else
				startGhostPulse()
				highlightTile(slot, CONFIG.HOVER_COLOR)
			end
		elseif placementGhost then
			-- Check inventory hover
			local mouse = LocalPlayer:GetMouse()
			if inventoryPanel then
				local panelPos = inventoryPanel.AbsolutePosition
				local panelSize = inventoryPanel.AbsoluteSize
				if mouse.X >= panelPos.X and mouse.X <= panelPos.X + panelSize.X and
				   mouse.Y >= panelPos.Y and mouse.Y <= panelPos.Y + panelSize.Y then
					startGhostPulse() -- Valid to drop on inventory
				else
					setGhostInvalid()
				end
			end
		end
	end)
end

--[[
	Completes a drag operation from world model.
]]
local function completeDragFromWorld()
	if not isDragging or not draggedUnit or not draggedUnit.isFromWorld then
		return
	end
	
	local targetSlot = getSlotUnderMouse()
	local sourceSlot = draggedUnit.fromSlot
	
	-- Check if dropped on inventory panel (store the unit)
	local mouse = LocalPlayer:GetMouse()
	if inventoryPanel then
		local panelPos = inventoryPanel.AbsolutePosition
		local panelSize = inventoryPanel.AbsoluteSize

		
		if mouse.X >= panelPos.X and mouse.X <= panelPos.X + panelSize.X and
		   mouse.Y >= panelPos.Y and mouse.Y <= panelPos.Y + panelSize.Y then
			-- Drop on inventory - remove from grid to storage
			local success, msg = RemoveBrainrotRemote:InvokeServer(draggedUnit.name, draggedUnit.rarity)
			if success then
				updateStatus("âœ“ Stored " .. draggedUnit.name .. " in inventory")
				task.defer(renderBuildGrid)
				task.defer(refreshInventoryPanel)
			else
				updateStatus("âœ— " .. (msg or "Store failed"))
			end
			
			isDragging = false
			draggedUnit = nil
			if dragConnection then
				dragConnection:Disconnect()
				dragConnection = nil
			end
			destroyPlacementGhost()
			return
		end
	end
	
	-- Check if dropped on a valid grid slot
	if targetSlot and targetSlot ~= sourceSlot then
		local tile = gridTiles[targetSlot]
		local isOccupied = tile and tile:GetAttribute("IsOccupied")
		
		if isOccupied then
			-- Swap
			local success, err = SwapUnits:InvokeServer(sourceSlot, targetSlot)
			if success then
				updateStatus("âœ“ Swapped units!")
			else
				updateStatus("âœ— " .. (err or "Swap failed"))
			end
		else
			-- Move to empty slot
			local success, err = MoveUnit:InvokeServer(sourceSlot, targetSlot)
			if success then
				updateStatus("âœ“ Moved to slot " .. targetSlot)
			else
				updateStatus("âœ— " .. (err or "Move failed"))
			end
		end
		task.defer(renderBuildGrid)
	else
		updateStatus("Drag cancelled")
	end
	
	-- Restore original model visibility
	if draggedUnit and draggedUnit.originalModel and draggedUnit.originalModel.Parent then
		setVisualsEnabled(draggedUnit.originalModel, true)
	end

	-- Cleanup
	isDragging = false
	draggedUnit = nil
	if dragConnection then
		dragConnection:Disconnect()
		dragConnection = nil
	end
	
	-- Destroy ghost
	destroyPlacementGhost()
	
	-- Unhighlight source
	if gridTiles[sourceSlot] then
		unhighlightTile(sourceSlot)
	end
end

--------------------------------------------------------------------------------
-- INTERACTION
--------------------------------------------------------------------------------

--[[
	Gets the slot under the mouse cursor.
]]
getSlotUnderMouse = function()
	if not gridContainer then return nil end
	
	local mouse = LocalPlayer:GetMouse()
	local ray = camera:ScreenPointToRay(mouse.X, mouse.Y)
	
	local raycastParams = RaycastParams.new()
	raycastParams.FilterType = Enum.RaycastFilterType.Include
	raycastParams.FilterDescendantsInstances = {gridContainer}
	
	local result = workspace:Raycast(ray.Origin, ray.Direction * 1000, raycastParams)
	if result and result.Instance then
		return result.Instance:GetAttribute("SlotIndex")
	end
	
	return nil
end

--[[
	Handles mouse click on grid.
]]
local function handleClick()
	local slot = getSlotUnderMouse()
	if not slot then return end
	
	local tile = gridTiles[slot]
	if not tile then return end
	
	if selectedSlot then
		-- If we have a selection, try to move/swap
		if slot ~= selectedSlot then
			local sourceOccupied = gridTiles[selectedSlot]:GetAttribute("IsOccupied")
			local targetOccupied = tile:GetAttribute("IsOccupied")
			
			if sourceOccupied then
				if targetOccupied then
					-- Swap
					local success, err = SwapUnits:InvokeServer(selectedSlot, slot)
					if success then
						updateStatus("âœ“ Swapped units!")
					else
						updateStatus("âœ— " .. (err or "Swap failed"))
					end
				else
					-- Move
					local success, err = MoveUnit:InvokeServer(selectedSlot, slot)
					if success then
						updateStatus("âœ“ Moved unit!")
					else
						updateStatus("âœ— " .. (err or "Move failed"))
					end
				end
				
				-- Refresh grid
				task.defer(renderBuildGrid)
			end
		end
		
		-- Deselect
		unhighlightTile(selectedSlot)
		selectedSlot = nil
	else
		-- Select this slot
		if tile:GetAttribute("IsOccupied") then
			selectedSlot = slot
			highlightTile(slot, CONFIG.SELECTED_COLOR)
			updateStatus("Selected: " .. (tile:GetAttribute("UnitName") or "Unit") .. " â€¢ Click tile to move/swap")
		else
			updateStatus("Empty slot - select an occupied tile first")
		end
	end
end

--[[
	Handles mouse hover.
]]
local function setupHoverTracking()
	if currentHoverConnection then
		currentHoverConnection:Disconnect()
	end
	
	currentHoverConnection = RunService.RenderStepped:Connect(function()
		if not isInBuildMode then return end
		
		local slot = getSlotUnderMouse()
		
		if slot ~= hoveredSlot then
			-- Unhighlight old
			if hoveredSlot and hoveredSlot ~= selectedSlot then
				unhighlightTile(hoveredSlot)
			end
			
			-- Highlight new
			if slot and slot ~= selectedSlot then
				highlightTile(slot, CONFIG.HOVER_COLOR)
			end
			
			hoveredSlot = slot
		end
	end)
end

--------------------------------------------------------------------------------
-- BUILD MODE TOGGLE
--------------------------------------------------------------------------------

--[[
	Enters build mode.
]]
local function enterBuildModeLocal()
	if isInBuildMode then return end
	
	local success, err = EnterBuildMode:InvokeServer()
	if not success then
		warn("BuildModeUI: Failed to enter - " .. tostring(err))
		return
	end
	
	isInBuildMode = true
	
	-- Get current island info
	local currentPlot = findCurrentIsland()
	local islandName = currentPlot and currentPlot.Name or "Unknown"
	
	-- Render grid and get plot center
	local plotCenter = renderBuildGrid()
	
	-- Create UI
	buildModeGui = createBuildModeUI()
	buildModeGui.Parent = PlayerGui
	
	-- Create and populate inventory panel
	createInventoryPanel(buildModeGui)
	refreshInventoryPanel()
	
	-- Update status with island name
	updateStatus("Editing: " .. islandName .. " â€¢ Click tile or Place from inventory")
	
	-- Setup exit button
	local topBar = buildModeGui:FindFirstChild("TopBar")
	if topBar then
		local exitButton = topBar:FindFirstChild("ExitButton")
		if exitButton then
			exitButton.MouseButton1Click:Connect(function()
				exitBuildModeLocal()
			end)
		end
	end
	
	-- Tween camera
	if plotCenter then
		tweenToIsometricView(plotCenter)
	end
	
	-- Setup interaction
	setupHoverTracking()
	
	-- Fire event for GridOverlay
	local buildModeToggle = ReplicatedStorage:FindFirstChild("BuildModeToggle")
	if buildModeToggle then
		buildModeToggle:Fire(true)
	end
	
	print("BuildModeUI: Entered Build Mode for " .. islandName)
end

--[[
	Exits build mode.
]]
exitBuildModeLocal = function()
	if not isInBuildMode then return end
	
	ExitBuildMode:InvokeServer()
	
	isInBuildMode = false
	
	if currentHoverConnection then
		currentHoverConnection:Disconnect()
		currentHoverConnection = nil
	end
	
	destroyBuildGrid()
	
	inventoryPanel = nil
	inventoryItems = {}
	
	if buildModeGui then
		buildModeGui:Destroy()
		buildModeGui = nil
	end
	
	tweenToPlayerView()
	
	selectedSlot = nil
	hoveredSlot = nil
	
	local buildModeToggle = ReplicatedStorage:FindFirstChild("BuildModeToggle")
	if buildModeToggle then
		buildModeToggle:Fire(false)
	end
	
	print("BuildModeUI: Exited Build Mode")
end

--[[
	Toggles build mode.
]]
local function toggleBuildMode()
	if isInBuildMode then
		exitBuildModeLocal()
	else
		enterBuildModeLocal()
	end
end

--------------------------------------------------------------------------------
-- INPUT HANDLING
--------------------------------------------------------------------------------

UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	
	if input.KeyCode == Enum.KeyCode.G or input.KeyCode == Enum.KeyCode.Tab then
		toggleBuildMode()
	elseif input.KeyCode == Enum.KeyCode.Escape and isInBuildMode then
		exitBuildModeLocal()
	end
end)

-- Mouse click handling
local mouse = LocalPlayer:GetMouse()
mouse.Button1Down:Connect(function()
	if not isInBuildMode then return end
	if isDragging then return end
	
	local brainrot, slotIndex = getBrainrotUnderMouse()
	if brainrot and slotIndex then
		startDragFromWorld(brainrot, slotIndex)
		return
	end
	
	handleClick()
end)

-- Mouse release
mouse.Button1Up:Connect(function()
	if not isInBuildMode or not isDragging then return end
	
	if draggedUnit and draggedUnit.isFromWorld then
		completeDragFromWorld()
	else
		completeDrop()
	end
end)

--------------------------------------------------------------------------------
-- LISTEN FOR GRID UPDATES
--------------------------------------------------------------------------------

GridUpdatedEvent.OnClientEvent:Connect(function(slotIndex, unitName, action)
	if isInBuildMode then
		task.defer(renderBuildGrid)
	end
end)

--------------------------------------------------------------------------------
-- LISTEN FOR INVENTORY CHANGES (when brainrots are purchased)
--------------------------------------------------------------------------------

InventoryChangedEvent.OnClientEvent:Connect(function()
	if isInBuildMode then
		task.defer(refreshInventoryPanel)
	end
end)

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

print("âœ“ BuildModeUI initialized - Press TAB to toggle Build Mode")

_G.BuildModeUI = {
	Toggle = toggleBuildMode,
	Enter = enterBuildModeLocal,
	Exit = exitBuildModeLocal,
	IsActive = function() return isInBuildMode end,
}


--------------------------------------------------
File: ConvenienceUpgradesUI.client.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\client\ConvenienceUpgradesUI.client.luau
--------------------------------------------------
--[[
	ConvenienceUpgradesUI Client Script
	
	Handles the UI for the Convenience Upgrades Shop where players can:
	1. Browse upgrades by category
	2. View owned vs available upgrades
	3. Purchase upgrades
	4. See upgrade effects
	
	Opens when player presses E near the Convenience Shop vendor.
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local CollectionService = game:GetService("CollectionService")

-- Player reference
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Modules
local ConvenienceUpgradesConfig = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("ConvenienceUpgradesConfig"))

-- Remote Events
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local PurchaseUpgradeEvent = RemoteEvents:WaitForChild("PurchaseConvenienceUpgrade")
local GetUpgradesInfoEvent = RemoteEvents:WaitForChild("GetConvenienceUpgradesInfo")

-- Configuration
local UI_CONFIG = {
	INTERACTION_DISTANCE = 20,
	TWEEN_TIME = 0.3,
	COLORS = {
		Background = Color3.fromRGB(25, 20, 35),
		Header = Color3.fromRGB(80, 50, 30),
		Card = Color3.fromRGB(40, 30, 50),
		CardOwned = Color3.fromRGB(30, 60, 40),
		CardLocked = Color3.fromRGB(50, 40, 50),
		Accent = Color3.fromRGB(255, 180, 80),
		Text = Color3.fromRGB(255, 255, 255),
		TextMuted = Color3.fromRGB(150, 150, 150),
		Green = Color3.fromRGB(100, 255, 100),
		Red = Color3.fromRGB(255, 100, 100),
	},
}

-- State
local shopOpen = false
local currentCategory = "Movement"
local ownedUpgrades: {string} = {}

--------------------------------------------------------------------------------
-- UI CREATION
--------------------------------------------------------------------------------

local function formatPrice(price: number): string
	local suffixes = {"K", "M", "B", "T", "Qa", "Qi", "Sx", "Sp", "Oc", "No", "Dc"}
	
	if price < 1000 then
		return tostring(math.floor(price))
	end
	
	-- Calculate the magnitude (power of 1000)
	local magnitude = math.floor(math.log(price, 1000))
	
	-- Cap at the largest suffix
	if magnitude > #suffixes then
		magnitude = #suffixes
	end
	
	local value = price / (1000 ^ magnitude)
	
	-- Format with 1 decimal place if < 100, otherwise no decimals
	if value < 100 and value % 1 ~= 0 then
		return string.format("%.1f%s", value, suffixes[magnitude])
	else
		return string.format("%.0f%s", value, suffixes[magnitude])
	end
end

local function createShopUI()
	-- Create ScreenGui
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "ConvenienceUpgradesUI"
	screenGui.ResetOnSpawn = false
	screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	
	-- Main container
	local mainFrame = Instance.new("Frame")
	mainFrame.Name = "MainFrame"
	mainFrame.Size = UDim2.new(0, 550, 0, 500)
	mainFrame.Position = UDim2.new(0.5, -275, 0.5, -250)
	mainFrame.BackgroundColor3 = UI_CONFIG.COLORS.Background
	mainFrame.BorderSizePixel = 0
	mainFrame.Visible = false
	mainFrame.Parent = screenGui
	
	local mainCorner = Instance.new("UICorner")
	mainCorner.CornerRadius = UDim.new(0, 16)
	mainCorner.Parent = mainFrame
	
	local mainStroke = Instance.new("UIStroke")
	mainStroke.Color = UI_CONFIG.COLORS.Accent
	mainStroke.Thickness = 2
	mainStroke.Parent = mainFrame
	
	-- Header
	local header = Instance.new("Frame")
	header.Name = "Header"
	header.Size = UDim2.new(1, 0, 0, 60)
	header.BackgroundColor3 = UI_CONFIG.COLORS.Header
	header.BorderSizePixel = 0
	header.Parent = mainFrame
	
	local headerCorner = Instance.new("UICorner")
	headerCorner.CornerRadius = UDim.new(0, 16)
	headerCorner.Parent = header
	
	local headerFix = Instance.new("Frame")
	headerFix.Size = UDim2.new(1, 0, 0, 16)
	headerFix.Position = UDim2.new(0, 0, 1, -16)
	headerFix.BackgroundColor3 = UI_CONFIG.COLORS.Header
	headerFix.BorderSizePixel = 0
	headerFix.Parent = header
	
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "Title"
	titleLabel.Size = UDim2.new(1, -60, 1, 0)
	titleLabel.Position = UDim2.new(0, 20, 0, 0)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Text = "âš¡ CONVENIENCE UPGRADES"
	titleLabel.TextColor3 = UI_CONFIG.COLORS.Accent
	titleLabel.TextSize = 24
	titleLabel.Font = Enum.Font.GothamBold
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	titleLabel.Parent = header
	
	-- Close button
	local closeButton = Instance.new("TextButton")
	closeButton.Name = "CloseButton"
	closeButton.Size = UDim2.new(0, 40, 0, 40)
	closeButton.Position = UDim2.new(1, -50, 0, 10)
	closeButton.BackgroundColor3 = Color3.fromRGB(200, 60, 60)
	closeButton.Text = "âœ•"
	closeButton.TextColor3 = Color3.new(1, 1, 1)
	closeButton.TextSize = 20
	closeButton.Font = Enum.Font.GothamBold
	closeButton.Parent = header
	
	local closeCorner = Instance.new("UICorner")
	closeCorner.CornerRadius = UDim.new(0.5, 0)
	closeCorner.Parent = closeButton
	
	-- Category tabs
	local tabsFrame = Instance.new("Frame")
	tabsFrame.Name = "TabsFrame"
	tabsFrame.Size = UDim2.new(1, -40, 0, 40)
	tabsFrame.Position = UDim2.new(0, 20, 0, 70)
	tabsFrame.BackgroundTransparency = 1
	tabsFrame.Parent = mainFrame
	
	local tabsLayout = Instance.new("UIListLayout")
	tabsLayout.FillDirection = Enum.FillDirection.Horizontal
	tabsLayout.Padding = UDim.new(0, 10)
	tabsLayout.Parent = tabsFrame
	
	-- Content area (scrolling)
	local contentFrame = Instance.new("ScrollingFrame")
	contentFrame.Name = "ContentFrame"
	contentFrame.Size = UDim2.new(1, -40, 1, -140)
	contentFrame.Position = UDim2.new(0, 20, 0, 120)
	contentFrame.BackgroundTransparency = 1
	contentFrame.ScrollBarThickness = 6
	contentFrame.ScrollBarImageColor3 = UI_CONFIG.COLORS.Accent
	contentFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
	contentFrame.Parent = mainFrame
	
	local contentLayout = Instance.new("UIListLayout")
	contentLayout.Padding = UDim.new(0, 10)
	contentLayout.Parent = contentFrame
	
	-- Message label
	local messageLabel = Instance.new("TextLabel")
	messageLabel.Name = "MessageLabel"
	messageLabel.Size = UDim2.new(1, -40, 0, 30)
	messageLabel.Position = UDim2.new(0, 20, 1, -35)
	messageLabel.BackgroundTransparency = 1
	messageLabel.Text = ""
	messageLabel.TextColor3 = UI_CONFIG.COLORS.Green
	messageLabel.TextSize = 14
	messageLabel.Font = Enum.Font.GothamBold
	messageLabel.Parent = mainFrame
	
	screenGui.Parent = playerGui
	return screenGui
end

--------------------------------------------------------------------------------
-- UI COMPONENTS
--------------------------------------------------------------------------------

local screenGui = createShopUI()
local mainFrame = screenGui:WaitForChild("MainFrame")
local tabsFrame = mainFrame:WaitForChild("TabsFrame")
local contentFrame = mainFrame:WaitForChild("ContentFrame")
local messageLabel = mainFrame:WaitForChild("MessageLabel")

local function isOwned(upgradeName: string): boolean
	for _, owned in ownedUpgrades do
		if owned == upgradeName then
			return true
		end
	end
	return false
end

local function createCategoryTab(category: string, index: number)
	local icons = {
		Movement = "ðŸƒ",
		Income = "ðŸ’°",
		Automation = "ðŸ¤–",
	}
	
	local tab = Instance.new("TextButton")
	tab.Name = "Tab_" .. category
	tab.Size = UDim2.new(0, 120, 1, 0)
	tab.BackgroundColor3 = currentCategory == category and UI_CONFIG.COLORS.Accent or UI_CONFIG.COLORS.Card
	tab.Text = (icons[category] or "ðŸ“¦") .. " " .. category
	tab.TextColor3 = UI_CONFIG.COLORS.Text
	tab.TextSize = 14
	tab.Font = Enum.Font.GothamBold
	tab.Parent = tabsFrame
	
	local tabCorner = Instance.new("UICorner")
	tabCorner.CornerRadius = UDim.new(0, 8)
	tabCorner.Parent = tab
	
	tab.MouseButton1Click:Connect(function()
		currentCategory = category
		refreshShop()
	end)
	
	return tab
end

local function createUpgradeCard(upgradeName: string, config)
	local owned = isOwned(upgradeName)
	local canPurchase, reason = ConvenienceUpgradesConfig.CanPurchase(upgradeName, ownedUpgrades)
	
	local cardColor = owned and UI_CONFIG.COLORS.CardOwned 
		or (canPurchase and UI_CONFIG.COLORS.Card or UI_CONFIG.COLORS.CardLocked)
	
	local card = Instance.new("Frame")
	card.Name = "Card_" .. upgradeName
	card.Size = UDim2.new(1, 0, 0, 90)
	card.BackgroundColor3 = cardColor
	card.Parent = contentFrame
	
	local cardCorner = Instance.new("UICorner")
	cardCorner.CornerRadius = UDim.new(0, 10)
	cardCorner.Parent = card
	
	-- Icon
	local iconLabel = Instance.new("TextLabel")
	iconLabel.Size = UDim2.new(0, 50, 0, 50)
	iconLabel.Position = UDim2.new(0, 15, 0.5, -25)
	iconLabel.BackgroundTransparency = 1
	iconLabel.Text = config.Icon
	iconLabel.TextSize = 36
	iconLabel.Parent = card
	
	-- Name
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Size = UDim2.new(0, 250, 0, 25)
	nameLabel.Position = UDim2.new(0, 75, 0, 10)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = upgradeName
	nameLabel.TextColor3 = UI_CONFIG.COLORS.Text
	nameLabel.TextSize = 16
	nameLabel.Font = Enum.Font.GothamBold
	nameLabel.TextXAlignment = Enum.TextXAlignment.Left
	nameLabel.Parent = card
	
	-- Description
	local descLabel = Instance.new("TextLabel")
	descLabel.Size = UDim2.new(0, 300, 0, 40)
	descLabel.Position = UDim2.new(0, 75, 0, 35)
	descLabel.BackgroundTransparency = 1
	descLabel.Text = config.Description
	descLabel.TextColor3 = UI_CONFIG.COLORS.TextMuted
	descLabel.TextSize = 12
	descLabel.Font = Enum.Font.Gotham
	descLabel.TextXAlignment = Enum.TextXAlignment.Left
	descLabel.TextWrapped = true
	descLabel.Parent = card
	
	-- Status/Button
	if owned then
		local ownedLabel = Instance.new("TextLabel")
		ownedLabel.Size = UDim2.new(0, 100, 0, 30)
		ownedLabel.Position = UDim2.new(1, -115, 0.5, -15)
		ownedLabel.BackgroundColor3 = UI_CONFIG.COLORS.Green
		ownedLabel.Text = "âœ“ OWNED"
		ownedLabel.TextColor3 = Color3.new(0, 0, 0)
		ownedLabel.TextSize = 14
		ownedLabel.Font = Enum.Font.GothamBold
		ownedLabel.Parent = card
		
		local ownedCorner = Instance.new("UICorner")
		ownedCorner.CornerRadius = UDim.new(0, 6)
		ownedCorner.Parent = ownedLabel
	else
		local buyButton = Instance.new("TextButton")
		buyButton.Name = "BuyButton"
		buyButton.Size = UDim2.new(0, 100, 0, 40)
		buyButton.Position = UDim2.new(1, -115, 0.5, -20)
		buyButton.BackgroundColor3 = canPurchase and UI_CONFIG.COLORS.Accent or UI_CONFIG.COLORS.CardLocked
		buyButton.Text = "$" .. formatPrice(config.Price)
		buyButton.TextColor3 = Color3.new(0, 0, 0)
		buyButton.TextSize = 14
		buyButton.Font = Enum.Font.GothamBold
		buyButton.Parent = card
		
		local buyCorner = Instance.new("UICorner")
		buyCorner.CornerRadius = UDim.new(0, 6)
		buyCorner.Parent = buyButton
		
		if not canPurchase and reason then
			local reasonLabel = Instance.new("TextLabel")
			reasonLabel.Size = UDim2.new(0, 100, 0, 15)
			reasonLabel.Position = UDim2.new(1, -115, 1, -20)
			reasonLabel.BackgroundTransparency = 1
			reasonLabel.Text = reason
			reasonLabel.TextColor3 = UI_CONFIG.COLORS.Red
			reasonLabel.TextSize = 10
			reasonLabel.Font = Enum.Font.Gotham
			reasonLabel.Parent = card
		end
		
		if canPurchase then
			buyButton.MouseButton1Click:Connect(function()
				buyButton.Text = "..."
				buyButton.BackgroundColor3 = UI_CONFIG.COLORS.CardLocked
				PurchaseUpgradeEvent:FireServer(upgradeName)
			end)
		end
	end
	
	return card
end

--------------------------------------------------------------------------------
-- SHOP LOGIC
--------------------------------------------------------------------------------

function refreshShop()
	-- Clear existing content
	for _, child in contentFrame:GetChildren() do
		if child:IsA("Frame") then
			child:Destroy()
		end
	end
	
	-- Update tabs
	for _, child in tabsFrame:GetChildren() do
		if child:IsA("TextButton") then
			child.BackgroundColor3 = child.Name == "Tab_" .. currentCategory 
				and UI_CONFIG.COLORS.Accent or UI_CONFIG.COLORS.Card
		end
	end
	
	-- Get upgrades for current category
	local categoryUpgrades = ConvenienceUpgradesConfig.GetUpgradesByCategory(currentCategory)
	
	-- Create cards
	for _, item in categoryUpgrades do
		createUpgradeCard(item.name, item.config)
	end
	
	-- Update canvas size
	local layout = contentFrame:FindFirstChild("UIListLayout")
	if layout then
		contentFrame.CanvasSize = UDim2.new(0, 0, 0, layout.AbsoluteContentSize.Y + 10)
	end
end

local function loadUpgradesInfo()
	local info = GetUpgradesInfoEvent:InvokeServer()
	if info then
		ownedUpgrades = info.OwnedUpgrades or {}
		
		-- Create category tabs
		for _, child in tabsFrame:GetChildren() do
			if child:IsA("TextButton") then
				child:Destroy()
			end
		end
		
		for i, category in info.Categories or {"Movement", "Income", "Automation"} do
			createCategoryTab(category, i)
		end
	end
end

local function openShop()
	if shopOpen then return end
	shopOpen = true
	
	loadUpgradesInfo()
	refreshShop()
	
	mainFrame.Visible = true
	mainFrame.Size = UDim2.new(0, 0, 0, 0)
	mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
	
	local tween = TweenService:Create(mainFrame, TweenInfo.new(UI_CONFIG.TWEEN_TIME, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
		Size = UDim2.new(0, 550, 0, 500),
		Position = UDim2.new(0.5, -275, 0.5, -250),
	})
	tween:Play()
end

local function closeShop()
	if not shopOpen then return end
	
	local tween = TweenService:Create(mainFrame, TweenInfo.new(UI_CONFIG.TWEEN_TIME, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
		Size = UDim2.new(0, 0, 0, 0),
		Position = UDim2.new(0.5, 0, 0.5, 0),
	})
	tween:Play()
	tween.Completed:Connect(function()
		mainFrame.Visible = false
	end)
	
	shopOpen = false
end

local function showMessage(text: string, color: Color3?)
	messageLabel.Text = text
	messageLabel.TextColor3 = color or UI_CONFIG.COLORS.Green
	
	task.delay(3, function()
		if messageLabel.Text == text then
			messageLabel.Text = ""
		end
	end)
end

--------------------------------------------------------------------------------
-- EVENT HANDLERS
--------------------------------------------------------------------------------

-- Close button
mainFrame.Header.CloseButton.MouseButton1Click:Connect(closeShop)

-- Purchase result
PurchaseUpgradeEvent.OnClientEvent:Connect(function(success, message)
	if success then
		showMessage(message, UI_CONFIG.COLORS.Green)
	else
		showMessage(message, UI_CONFIG.COLORS.Red)
	end
	
	-- Refresh the shop
	loadUpgradesInfo()
	refreshShop()
end)

--------------------------------------------------------------------------------
-- PROXIMITY DETECTION
--------------------------------------------------------------------------------

local function checkProximity(): boolean
	local character = player.Character
	if not character then return false end
	
	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	if not humanoidRootPart then return false end
	
	for _, vendor in CollectionService:GetTagged("ConvenienceShopVendor") do
		local distance = (humanoidRootPart.Position - vendor.Position).Magnitude
		if distance <= UI_CONFIG.INTERACTION_DISTANCE then
			return true
		end
	end
	
	return false
end

--------------------------------------------------------------------------------
-- INPUT HANDLING
--------------------------------------------------------------------------------

UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	
	if input.KeyCode == Enum.KeyCode.E then
		if shopOpen then
			closeShop()
		elseif checkProximity() then
			openShop()
		end
	elseif input.KeyCode == Enum.KeyCode.Escape then
		if shopOpen then
			closeShop()
		end
	elseif input.KeyCode == Enum.KeyCode.H then
		-- Teleport home if player has the upgrade
		if _G.ConvenienceUpgrades and _G.ConvenienceUpgrades.HasTeleportHome and _G.ConvenienceUpgrades.HasTeleportHome(player) then
			-- Teleport to main island
			local mainIsland = workspace:FindFirstChild("MainIsland")
			if mainIsland then
				local spawnPoint = mainIsland:FindFirstChild("Island") or mainIsland:FindFirstChildWhichIsA("BasePart")
				if spawnPoint and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
					player.Character.HumanoidRootPart.CFrame = spawnPoint.CFrame * CFrame.new(0, 10, 0)
				end
			end
		end
	end
end)

--------------------------------------------------------------------------------
-- PROXIMITY PROMPT LISTENER
--------------------------------------------------------------------------------

-- Setup listener for ProximityPrompt on Convenience Shop vendors
local function setupProximityPromptListener()
	-- Listen for any ConvenienceShopVendor that gets added
	for _, vendor in CollectionService:GetTagged("ConvenienceShopVendor") do
		local prompt = vendor:FindFirstChild("ConvenienceShopPrompt")
		if prompt and prompt:IsA("ProximityPrompt") then
			prompt.Triggered:Connect(function(playerWhoTriggered)
				if playerWhoTriggered == player then
					openShop()
				end
			end)
		end
	end
	
	-- Also listen for new vendors being added
	CollectionService:GetInstanceAddedSignal("ConvenienceShopVendor"):Connect(function(vendor)
		local prompt = vendor:WaitForChild("ConvenienceShopPrompt", 5)
		if prompt and prompt:IsA("ProximityPrompt") then
			prompt.Triggered:Connect(function(playerWhoTriggered)
				if playerWhoTriggered == player then
					openShop()
				end
			end)
		end
	end)
end

task.spawn(setupProximityPromptListener)

print("âœ“ ConvenienceUpgradesUI initialized")



--------------------------------------------------
File: IslandShopUI.client.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\client\IslandShopUI.client.luau
--------------------------------------------------
--[[
	IslandShopUI Client Script
	
	Handles the UI for the Island Shop where players can:
	1. View their current tier status
	2. Purchase tier unlocks
	
	Opens when player presses E near the Island Shop vendor.
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local CollectionService = game:GetService("CollectionService")

-- Player reference
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Remote Events
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local PurchaseTierEvent = RemoteEvents:WaitForChild("PurchaseTier")
local GetTierInfoEvent = RemoteEvents:WaitForChild("GetTierInfo")

-- Configuration
local UI_CONFIG = {
	INTERACTION_DISTANCE = 20,
	TWEEN_TIME = 0.3,
}

-- State
local shopOpen = false
local _nearVendor = false

--------------------------------------------------------------------------------
-- UI CREATION
--------------------------------------------------------------------------------

local function createShopUI()
	-- Create ScreenGui
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "IslandShopUI"
	screenGui.ResetOnSpawn = false
	screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	
	-- Main container
	local mainFrame = Instance.new("Frame")
	mainFrame.Name = "MainFrame"
	mainFrame.Size = UDim2.new(0, 400, 0, 350)
	mainFrame.Position = UDim2.new(0.5, -200, 0.5, -175)
	mainFrame.BackgroundColor3 = Color3.fromRGB(25, 15, 40)
	mainFrame.BorderSizePixel = 0
	mainFrame.Visible = false
	mainFrame.Parent = screenGui
	
	local mainCorner = Instance.new("UICorner")
	mainCorner.CornerRadius = UDim.new(0, 16)
	mainCorner.Parent = mainFrame
	
	local mainStroke = Instance.new("UIStroke")
	mainStroke.Color = Color3.fromRGB(150, 100, 200)
	mainStroke.Thickness = 2
	mainStroke.Parent = mainFrame
	
	-- Header
	local header = Instance.new("Frame")
	header.Name = "Header"
	header.Size = UDim2.new(1, 0, 0, 60)
	header.BackgroundColor3 = Color3.fromRGB(60, 30, 90)
	header.BorderSizePixel = 0
	header.Parent = mainFrame
	
	local headerCorner = Instance.new("UICorner")
	headerCorner.CornerRadius = UDim.new(0, 16)
	headerCorner.Parent = header
	
	-- Fix bottom corners of header
	local headerFix = Instance.new("Frame")
	headerFix.Size = UDim2.new(1, 0, 0, 16)
	headerFix.Position = UDim2.new(0, 0, 1, -16)
	headerFix.BackgroundColor3 = Color3.fromRGB(60, 30, 90)
	headerFix.BorderSizePixel = 0
	headerFix.Parent = header
	
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "Title"
	titleLabel.Size = UDim2.new(1, -60, 1, 0)
	titleLabel.Position = UDim2.new(0, 20, 0, 0)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Text = "ðŸï¸ ISLAND SHOP"
	titleLabel.TextColor3 = Color3.fromRGB(255, 200, 255)
	titleLabel.TextSize = 28
	titleLabel.Font = Enum.Font.GothamBold
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	titleLabel.Parent = header
	
	-- Close button
	local closeButton = Instance.new("TextButton")
	closeButton.Name = "CloseButton"
	closeButton.Size = UDim2.new(0, 40, 0, 40)
	closeButton.Position = UDim2.new(1, -50, 0, 10)
	closeButton.BackgroundColor3 = Color3.fromRGB(200, 60, 60)
	closeButton.Text = "âœ•"
	closeButton.TextColor3 = Color3.new(1, 1, 1)
	closeButton.TextSize = 20
	closeButton.Font = Enum.Font.GothamBold
	closeButton.Parent = header
	
	local closeCorner = Instance.new("UICorner")
	closeCorner.CornerRadius = UDim.new(0.5, 0)
	closeCorner.Parent = closeButton
	
	-- Content area
	local content = Instance.new("Frame")
	content.Name = "Content"
	content.Size = UDim2.new(1, -40, 1, -80)
	content.Position = UDim2.new(0, 20, 0, 70)
	content.BackgroundTransparency = 1
	content.Parent = mainFrame
	
	-- Status section
	local statusFrame = Instance.new("Frame")
	statusFrame.Name = "StatusFrame"
	statusFrame.Size = UDim2.new(1, 0, 0, 100)
	statusFrame.BackgroundColor3 = Color3.fromRGB(40, 25, 60)
	statusFrame.BorderSizePixel = 0
	statusFrame.Parent = content
	
	local statusCorner = Instance.new("UICorner")
	statusCorner.CornerRadius = UDim.new(0, 12)
	statusCorner.Parent = statusFrame
	
	local tiersLabel = Instance.new("TextLabel")
	tiersLabel.Name = "TiersLabel"
	tiersLabel.Size = UDim2.new(1, -20, 0, 30)
	tiersLabel.Position = UDim2.new(0, 10, 0, 10)
	tiersLabel.BackgroundTransparency = 1
	tiersLabel.Text = "Current Islands: 1 / 6"
	tiersLabel.TextColor3 = Color3.fromRGB(200, 200, 255)
	tiersLabel.TextSize = 18
	tiersLabel.Font = Enum.Font.GothamBold
	tiersLabel.TextXAlignment = Enum.TextXAlignment.Left
	tiersLabel.Parent = statusFrame
	
	local modelsLabel = Instance.new("TextLabel")
	modelsLabel.Name = "ModelsLabel"
	modelsLabel.Size = UDim2.new(1, -20, 0, 25)
	modelsLabel.Position = UDim2.new(0, 10, 0, 40)
	modelsLabel.BackgroundTransparency = 1
	modelsLabel.Text = "Total Models: 0"
	modelsLabel.TextColor3 = Color3.fromRGB(180, 180, 200)
	modelsLabel.TextSize = 16
	modelsLabel.Font = Enum.Font.Gotham
	modelsLabel.TextXAlignment = Enum.TextXAlignment.Left
	modelsLabel.Parent = statusFrame
	
	local fillLabel = Instance.new("TextLabel")
	fillLabel.Name = "FillLabel"
	fillLabel.Size = UDim2.new(1, -20, 0, 25)
	fillLabel.Position = UDim2.new(0, 10, 0, 65)
	fillLabel.BackgroundTransparency = 1
	fillLabel.Text = "Models per island: 12"
	fillLabel.TextColor3 = Color3.fromRGB(150, 150, 170)
	fillLabel.TextSize = 14
	fillLabel.Font = Enum.Font.Gotham
	fillLabel.TextXAlignment = Enum.TextXAlignment.Left
	fillLabel.Parent = statusFrame
	
	-- Purchase section
	local purchaseFrame = Instance.new("Frame")
	purchaseFrame.Name = "PurchaseFrame"
	purchaseFrame.Size = UDim2.new(1, 0, 0, 120)
	purchaseFrame.Position = UDim2.new(0, 0, 0, 110)
	purchaseFrame.BackgroundColor3 = Color3.fromRGB(40, 25, 60)
	purchaseFrame.BorderSizePixel = 0
	purchaseFrame.Parent = content
	
	local purchaseCorner = Instance.new("UICorner")
	purchaseCorner.CornerRadius = UDim.new(0, 12)
	purchaseCorner.Parent = purchaseFrame
	
	local purchaseTitle = Instance.new("TextLabel")
	purchaseTitle.Name = "PurchaseTitle"
	purchaseTitle.Size = UDim2.new(1, -20, 0, 30)
	purchaseTitle.Position = UDim2.new(0, 10, 0, 10)
	purchaseTitle.BackgroundTransparency = 1
	purchaseTitle.Text = "ðŸ›’ Purchase New Island"
	purchaseTitle.TextColor3 = Color3.fromRGB(255, 220, 100)
	purchaseTitle.TextSize = 18
	purchaseTitle.Font = Enum.Font.GothamBold
	purchaseTitle.TextXAlignment = Enum.TextXAlignment.Left
	purchaseTitle.Parent = purchaseFrame
	
	local priceLabel = Instance.new("TextLabel")
	priceLabel.Name = "PriceLabel"
	priceLabel.Size = UDim2.new(1, -20, 0, 25)
	priceLabel.Position = UDim2.new(0, 10, 0, 40)
	priceLabel.BackgroundTransparency = 1
	priceLabel.Text = "Price: $5,000"
	priceLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
	priceLabel.TextSize = 16
	priceLabel.Font = Enum.Font.GothamBold
	priceLabel.TextXAlignment = Enum.TextXAlignment.Left
	priceLabel.Parent = purchaseFrame
	
	local purchaseButton = Instance.new("TextButton")
	purchaseButton.Name = "PurchaseButton"
	purchaseButton.Size = UDim2.new(1, -20, 0, 40)
	purchaseButton.Position = UDim2.new(0, 10, 0, 70)
	purchaseButton.BackgroundColor3 = Color3.fromRGB(80, 180, 80)
	purchaseButton.Text = "PURCHASE ISLAND"
	purchaseButton.TextColor3 = Color3.new(1, 1, 1)
	purchaseButton.TextSize = 18
	purchaseButton.Font = Enum.Font.GothamBold
	purchaseButton.Parent = purchaseFrame
	
	local purchaseButtonCorner = Instance.new("UICorner")
	purchaseButtonCorner.CornerRadius = UDim.new(0, 8)
	purchaseButtonCorner.Parent = purchaseButton
	
	-- Message label
	local messageLabel = Instance.new("TextLabel")
	messageLabel.Name = "MessageLabel"
	messageLabel.Size = UDim2.new(1, 0, 0, 30)
	messageLabel.Position = UDim2.new(0, 0, 1, -30)
	messageLabel.BackgroundTransparency = 1
	messageLabel.Text = ""
	messageLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
	messageLabel.TextSize = 14
	messageLabel.Font = Enum.Font.Gotham
	messageLabel.Parent = content
	
	screenGui.Parent = playerGui
	
	return screenGui
end

--------------------------------------------------------------------------------
-- UI LOGIC
--------------------------------------------------------------------------------

local screenGui = createShopUI()
local mainFrame = screenGui:WaitForChild("MainFrame")
local content = mainFrame:WaitForChild("Content")
local statusFrame = content:WaitForChild("StatusFrame")
local purchaseFrame = content:WaitForChild("PurchaseFrame")

local function formatMoney(amount: number): string
	local suffixes = {"K", "M", "B", "T", "Qa", "Qi", "Sx", "Sp", "Oc", "No", "Dc"}
	
	if amount < 1000 then
		return "$" .. tostring(math.floor(amount))
	end
	
	-- Calculate the magnitude (power of 1000)
	local magnitude = math.floor(math.log(amount, 1000))
	
	-- Cap at the largest suffix
	if magnitude > #suffixes then
		magnitude = #suffixes
	end
	
	local value = amount / (1000 ^ magnitude)
	
	-- Format with 1 decimal place if < 100, otherwise no decimals
	if value < 100 and value % 1 ~= 0 then
		return string.format("$%.1f%s", value, suffixes[magnitude])
	else
		return string.format("$%.0f%s", value, suffixes[magnitude])
	end
end

local function updateShopInfo()
	local info = GetTierInfoEvent:InvokeServer()
	if not info then return end
	
	-- Update status labels
	statusFrame.TiersLabel.Text = string.format("Current Islands: %d / %d", info.CurrentTiers, info.MaxTiers)
	statusFrame.ModelsLabel.Text = string.format("Total Models: %d", info.TotalModels)
	statusFrame.FillLabel.Text = string.format("Models per island: %d", info.ModelsPerTier)
	
	-- Update purchase section
	if info.CanPurchase then
		purchaseFrame.PriceLabel.Text = string.format("Price: %s", formatMoney(info.NextTierPrice))
		purchaseFrame.PurchaseButton.BackgroundColor3 = Color3.fromRGB(80, 180, 80)
		purchaseFrame.PurchaseButton.Text = "PURCHASE ISLAND"
	else
		purchaseFrame.PriceLabel.Text = "Max islands reached!"
		purchaseFrame.PurchaseButton.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
		purchaseFrame.PurchaseButton.Text = "MAX ISLANDS"
	end
end

local function openShop()
	if shopOpen then return end
	shopOpen = true
	
	updateShopInfo()
	
	mainFrame.Visible = true
	mainFrame.Size = UDim2.new(0, 0, 0, 0)
	mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
	
	local tween = TweenService:Create(mainFrame, TweenInfo.new(UI_CONFIG.TWEEN_TIME, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
		Size = UDim2.new(0, 400, 0, 350),
		Position = UDim2.new(0.5, -200, 0.5, -175),
	})
	tween:Play()
end

local function closeShop()
	if not shopOpen then return end
	
	local tween = TweenService:Create(mainFrame, TweenInfo.new(UI_CONFIG.TWEEN_TIME, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
		Size = UDim2.new(0, 0, 0, 0),
		Position = UDim2.new(0.5, 0, 0.5, 0),
	})
	tween:Play()
	tween.Completed:Connect(function()
		mainFrame.Visible = false
	end)
	
	shopOpen = false
end

local function showMessage(text, color)
	local messageLabel = content:FindFirstChild("MessageLabel")
	if messageLabel then
		messageLabel.Text = text
		messageLabel.TextColor3 = color or Color3.fromRGB(255, 200, 100)
		
		task.delay(3, function()
			if messageLabel.Text == text then
				messageLabel.Text = ""
			end
		end)
	end
end

--------------------------------------------------------------------------------
-- BUTTON HANDLERS
--------------------------------------------------------------------------------

-- Close button
mainFrame.Header.CloseButton.MouseButton1Click:Connect(closeShop)

-- Purchase button
purchaseFrame.PurchaseButton.MouseButton1Click:Connect(function()
	purchaseFrame.PurchaseButton.Text = "Purchasing..."
	purchaseFrame.PurchaseButton.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
	
	PurchaseTierEvent:FireServer()
end)

-- Handle purchase result
PurchaseTierEvent.OnClientEvent:Connect(function(success, message)
	if success then
		showMessage(message, Color3.fromRGB(100, 255, 100))
	else
		showMessage(message, Color3.fromRGB(255, 100, 100))
	end
	
	-- Refresh info
	updateShopInfo()
end)

--------------------------------------------------------------------------------
-- PROXIMITY DETECTION
--------------------------------------------------------------------------------

local function checkProximity()
	local character = player.Character
	if not character then return false end
	
	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	if not humanoidRootPart then return false end
	
	-- Find vendor
	for _, vendor in CollectionService:GetTagged("IslandShopVendor") do
		local distance = (humanoidRootPart.Position - vendor.Position).Magnitude
		if distance <= UI_CONFIG.INTERACTION_DISTANCE then
			return true
		end
	end
	
	return false
end

--------------------------------------------------------------------------------
-- INPUT HANDLING
--------------------------------------------------------------------------------

UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	
	if input.KeyCode == Enum.KeyCode.E then
		if shopOpen then
			closeShop()
		elseif checkProximity() then
			openShop()
		end
	elseif input.KeyCode == Enum.KeyCode.Escape then
		if shopOpen then
			closeShop()
		end
	end
end)

-- Proximity check loop for showing hints
task.spawn(function()
	while true do
		_nearVendor = checkProximity()
		task.wait(0.5)
	end
end)

--------------------------------------------------------------------------------
-- PROXIMITY PROMPT LISTENER
--------------------------------------------------------------------------------

-- Setup listener for ProximityPrompt on Island Shop vendors
local function setupProximityPromptListener()
	-- Listen for any IslandShopVendor that gets added
	for _, vendor in CollectionService:GetTagged("IslandShopVendor") do
		local prompt = vendor:FindFirstChild("IslandShopPrompt")
		if prompt and prompt:IsA("ProximityPrompt") then
			prompt.Triggered:Connect(function(playerWhoTriggered)
				if playerWhoTriggered == player then
					openShop()
				end
			end)
		end
	end
	
	-- Also listen for new vendors being added
	CollectionService:GetInstanceAddedSignal("IslandShopVendor"):Connect(function(vendor)
		local prompt = vendor:WaitForChild("IslandShopPrompt", 5)
		if prompt and prompt:IsA("ProximityPrompt") then
			prompt.Triggered:Connect(function(playerWhoTriggered)
				if playerWhoTriggered == player then
					openShop()
				end
			end)
		end
	end)
end

task.spawn(setupProximityPromptListener)

print("âœ“ IslandShopUI initialized")



--------------------------------------------------
File: MarketTerminalUI.client.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\client\MarketTerminalUI.client.luau
--------------------------------------------------
--[[
	MarketTerminalUI Client Script
	
	Handles the market terminal interface for selling items.
	
	Features:
	- Shows backpack contents
	- Displays current prices with market multiplier
	- Sell individual items or all at once
	- Price updates in real-time
	
	Opens via ProximityPrompt on Market building or M key.
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

-- Get player
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- Wait for remotes
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local RemoteFunctions = ReplicatedStorage:WaitForChild("RemoteFunctions")

-- Stock market for rate display
local stockMarketFolder = ReplicatedStorage:WaitForChild("StockMarket")

-- Market events
local ItemSoldEvent = RemoteEvents:WaitForChild("ItemSold")
local SellItemFunction = RemoteFunctions:WaitForChild("SellItem")
local SellAllFunction = RemoteFunctions:WaitForChild("SellAll")
local GetMarketPricesFunction = RemoteFunctions:WaitForChild("GetMarketPrices")

-- Backpack events
local BackpackUpdatedEvent = RemoteEvents:WaitForChild("BackpackUpdated")
local GetBackpackFunction = RemoteEvents:WaitForChild("GetBackpack")

-- Wait for ItemConfig
local Shared = ReplicatedStorage:WaitForChild("Shared")
local ItemConfig = require(Shared:WaitForChild("ItemConfig"))

-- UI Colors
local COLORS = {
	background = Color3.fromRGB(10, 10, 20),
	panel = Color3.fromRGB(20, 25, 35),
	accent = Color3.fromRGB(255, 200, 50),  -- Gold for market
	accentDark = Color3.fromRGB(200, 150, 30),
	text = Color3.fromRGB(255, 255, 255),
	textMuted = Color3.fromRGB(150, 150, 170),
	success = Color3.fromRGB(100, 255, 150),
	profit = Color3.fromRGB(50, 255, 100),
	loss = Color3.fromRGB(255, 80, 80),
	itemBg = Color3.fromRGB(30, 35, 50),
}

-- State
local isOpen = false
local currentBackpack = {}
local backpackTotal = 0
local marketRate = 1.0
local prices = {}

-- UI References
local screenGui = nil
local mainFrame = nil

--------------------------------------------------------------------------------
-- UI CREATION
--------------------------------------------------------------------------------

local function createScreenGui()
	local gui = Instance.new("ScreenGui")
	gui.Name = "MarketTerminalUI"
	gui.ResetOnSpawn = false
	gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	gui.Parent = PlayerGui
	return gui
end

local function createMainFrame(parent)
	local frame = Instance.new("Frame")
	frame.Name = "MainFrame"
	frame.Size = UDim2.new(0, 550, 0, 450)
	frame.Position = UDim2.new(0.5, -275, 0.5, -225)
	frame.BackgroundColor3 = COLORS.background
	frame.BackgroundTransparency = 0.05
	frame.BorderSizePixel = 0
	frame.Visible = false
	frame.Parent = parent
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 16)
	corner.Parent = frame
	
	local stroke = Instance.new("UIStroke")
	stroke.Color = COLORS.accent
	stroke.Thickness = 2
	stroke.Transparency = 0.3
	stroke.Parent = frame
	
	return frame
end

local function createHeader(parent)
	local header = Instance.new("Frame")
	header.Name = "Header"
	header.Size = UDim2.new(1, 0, 0, 60)
	header.BackgroundColor3 = COLORS.panel
	header.BackgroundTransparency = 0.3
	header.BorderSizePixel = 0
	header.Parent = parent
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 16)
	corner.Parent = header
	
	-- Title
	local title = Instance.new("TextLabel")
	title.Name = "Title"
	title.Size = UDim2.new(0.5, 0, 0, 30)
	title.Position = UDim2.new(0, 20, 0, 8)
	title.BackgroundTransparency = 1
	title.Text = "ðŸª MARKET TERMINAL"
	title.TextColor3 = COLORS.accent
	title.TextSize = 20
	title.Font = Enum.Font.GothamBold
	title.TextXAlignment = Enum.TextXAlignment.Left
	title.Parent = header
	
	-- Market rate display
	local rateLabel = Instance.new("TextLabel")
	rateLabel.Name = "RateLabel"
	rateLabel.Size = UDim2.new(0.5, -30, 0, 25)
	rateLabel.Position = UDim2.new(0, 20, 0, 35)
	rateLabel.BackgroundTransparency = 1
	rateLabel.Text = "ðŸ“ˆ Market Rate: 1.00x"
	rateLabel.TextColor3 = COLORS.success
	rateLabel.TextSize = 14
	rateLabel.Font = Enum.Font.GothamBold
	rateLabel.TextXAlignment = Enum.TextXAlignment.Left
	rateLabel.Parent = header
	
	-- Close button
	local closeBtn = Instance.new("TextButton")
	closeBtn.Name = "CloseButton"
	closeBtn.Size = UDim2.new(0, 40, 0, 40)
	closeBtn.Position = UDim2.new(1, -50, 0, 10)
	closeBtn.BackgroundColor3 = Color3.fromRGB(255, 80, 80)
	closeBtn.BackgroundTransparency = 0.7
	closeBtn.Text = "âœ•"
	closeBtn.TextColor3 = COLORS.text
	closeBtn.TextSize = 18
	closeBtn.Font = Enum.Font.GothamBold
	closeBtn.Parent = header
	
	local closeCorner = Instance.new("UICorner")
	closeCorner.CornerRadius = UDim.new(0, 8)
	closeCorner.Parent = closeBtn
	
	closeBtn.MouseButton1Click:Connect(function()
		closeUI()
	end)
	
	return header
end

local function createItemsPanel(parent)
	local panel = Instance.new("Frame")
	panel.Name = "ItemsPanel"
	panel.Size = UDim2.new(1, -20, 1, -130)
	panel.Position = UDim2.new(0, 10, 0, 70)
	panel.BackgroundColor3 = COLORS.panel
	panel.BackgroundTransparency = 0.5
	panel.BorderSizePixel = 0
	panel.Parent = parent
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 12)
	corner.Parent = panel
	
	-- Header row
	local headerRow = Instance.new("Frame")
	headerRow.Name = "HeaderRow"
	headerRow.Size = UDim2.new(1, -20, 0, 30)
	headerRow.Position = UDim2.new(0, 10, 0, 10)
	headerRow.BackgroundTransparency = 1
	headerRow.Parent = panel
	
	local itemHeader = Instance.new("TextLabel")
	itemHeader.Size = UDim2.new(0.35, 0, 1, 0)
	itemHeader.BackgroundTransparency = 1
	itemHeader.Text = "ITEM"
	itemHeader.TextColor3 = COLORS.textMuted
	itemHeader.TextSize = 12
	itemHeader.Font = Enum.Font.GothamBold
	itemHeader.TextXAlignment = Enum.TextXAlignment.Left
	itemHeader.Parent = headerRow
	
	local qtyHeader = Instance.new("TextLabel")
	qtyHeader.Size = UDim2.new(0.15, 0, 1, 0)
	qtyHeader.Position = UDim2.new(0.35, 0, 0, 0)
	qtyHeader.BackgroundTransparency = 1
	qtyHeader.Text = "QTY"
	qtyHeader.TextColor3 = COLORS.textMuted
	qtyHeader.TextSize = 12
	qtyHeader.Font = Enum.Font.GothamBold
	qtyHeader.Parent = headerRow
	
	local priceHeader = Instance.new("TextLabel")
	priceHeader.Size = UDim2.new(0.2, 0, 1, 0)
	priceHeader.Position = UDim2.new(0.5, 0, 0, 0)
	priceHeader.BackgroundTransparency = 1
	priceHeader.Text = "PRICE"
	priceHeader.TextColor3 = COLORS.textMuted
	priceHeader.TextSize = 12
	priceHeader.Font = Enum.Font.GothamBold
	priceHeader.Parent = headerRow
	
	local totalHeader = Instance.new("TextLabel")
	totalHeader.Size = UDim2.new(0.15, 0, 1, 0)
	totalHeader.Position = UDim2.new(0.7, 0, 0, 0)
	totalHeader.BackgroundTransparency = 1
	totalHeader.Text = "TOTAL"
	totalHeader.TextColor3 = COLORS.textMuted
	totalHeader.TextSize = 12
	totalHeader.Font = Enum.Font.GothamBold
	totalHeader.Parent = headerRow
	
	-- Scroll frame for items
	local scrollFrame = Instance.new("ScrollingFrame")
	scrollFrame.Name = "ItemList"
	scrollFrame.Size = UDim2.new(1, -20, 1, -50)
	scrollFrame.Position = UDim2.new(0, 10, 0, 45)
	scrollFrame.BackgroundTransparency = 1
	scrollFrame.ScrollBarThickness = 4
	scrollFrame.ScrollBarImageColor3 = COLORS.accent
	scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
	scrollFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
	scrollFrame.Parent = panel
	
	local listLayout = Instance.new("UIListLayout")
	listLayout.Padding = UDim.new(0, 4)
	listLayout.Parent = scrollFrame
	
	return panel
end

local function createBottomBar(parent)
	local bar = Instance.new("Frame")
	bar.Name = "BottomBar"
	bar.Size = UDim2.new(1, -20, 0, 50)
	bar.Position = UDim2.new(0, 10, 1, -55)
	bar.BackgroundColor3 = COLORS.panel
	bar.BackgroundTransparency = 0.3
	bar.BorderSizePixel = 0
	bar.Parent = parent
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 12)
	corner.Parent = bar
	
	-- Total value display
	local totalLabel = Instance.new("TextLabel")
	totalLabel.Name = "TotalValue"
	totalLabel.Size = UDim2.new(0.5, -10, 1, 0)
	totalLabel.Position = UDim2.new(0, 15, 0, 0)
	totalLabel.BackgroundTransparency = 1
	totalLabel.Text = "ðŸ’° Total Value: $0"
	totalLabel.TextColor3 = COLORS.profit
	totalLabel.TextSize = 18
	totalLabel.Font = Enum.Font.GothamBold
	totalLabel.TextXAlignment = Enum.TextXAlignment.Left
	totalLabel.Parent = bar
	
	-- Sell All button
	local sellAllBtn = Instance.new("TextButton")
	sellAllBtn.Name = "SellAllButton"
	sellAllBtn.Size = UDim2.new(0, 180, 0, 40)
	sellAllBtn.Position = UDim2.new(1, -190, 0.5, -20)
	sellAllBtn.BackgroundColor3 = COLORS.accent
	sellAllBtn.Text = "ðŸ’° SELL ALL"
	sellAllBtn.TextColor3 = COLORS.background
	sellAllBtn.TextSize = 16
	sellAllBtn.Font = Enum.Font.GothamBold
	sellAllBtn.Parent = bar
	
	local btnCorner = Instance.new("UICorner")
	btnCorner.CornerRadius = UDim.new(0, 8)
	btnCorner.Parent = sellAllBtn
	
	sellAllBtn.MouseButton1Click:Connect(function()
		local sold, earned = SellAllFunction:InvokeServer()
		if earned > 0 then
			-- Flash the button green
			sellAllBtn.BackgroundColor3 = COLORS.profit
			task.wait(0.3)
			sellAllBtn.BackgroundColor3 = COLORS.accent
		end
	end)
	
	-- Hover effect
	sellAllBtn.MouseEnter:Connect(function()
		TweenService:Create(sellAllBtn, TweenInfo.new(0.2), {BackgroundColor3 = COLORS.accentDark}):Play()
	end)
	
	sellAllBtn.MouseLeave:Connect(function()
		TweenService:Create(sellAllBtn, TweenInfo.new(0.2), {BackgroundColor3 = COLORS.accent}):Play()
	end)
	
	return bar
end

local function createItemRow(parent, itemId, count, price)
	local tierEmoji = {"âšª", "ðŸŸ¡", "ðŸŸ ", "ðŸ’Ž"}
	local itemInfo = ItemConfig.Items[itemId] or {}
	local emoji = tierEmoji[itemInfo.tier or 1] or "âšª"
	local totalValue = count * price
	
	local row = Instance.new("Frame")
	row.Name = "Item_" .. itemId
	row.Size = UDim2.new(1, 0, 0, 36)
	row.BackgroundColor3 = COLORS.itemBg
	row.BackgroundTransparency = 0.4
	row.BorderSizePixel = 0
	row.Parent = parent
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 6)
	corner.Parent = row
	
	-- Item name
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Size = UDim2.new(0.35, 0, 1, 0)
	nameLabel.Position = UDim2.new(0, 10, 0, 0)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = emoji .. " " .. itemId
	nameLabel.TextColor3 = COLORS.text
	nameLabel.TextSize = 13
	nameLabel.Font = Enum.Font.Gotham
	nameLabel.TextXAlignment = Enum.TextXAlignment.Left
	nameLabel.TextTruncate = Enum.TextTruncate.AtEnd
	nameLabel.Parent = row
	
	-- Quantity
	local qtyLabel = Instance.new("TextLabel")
	qtyLabel.Size = UDim2.new(0.12, 0, 1, 0)
	qtyLabel.Position = UDim2.new(0.35, 0, 0, 0)
	qtyLabel.BackgroundTransparency = 1
	qtyLabel.Text = "x" .. count
	qtyLabel.TextColor3 = COLORS.textMuted
	qtyLabel.TextSize = 13
	qtyLabel.Font = Enum.Font.GothamBold
	qtyLabel.Parent = row
	
	-- Price per item
	local priceLabel = Instance.new("TextLabel")
	priceLabel.Size = UDim2.new(0.18, 0, 1, 0)
	priceLabel.Position = UDim2.new(0.47, 0, 0, 0)
	priceLabel.BackgroundTransparency = 1
	priceLabel.Text = "$" .. price
	priceLabel.TextColor3 = marketRate >= 1.5 and COLORS.profit or (marketRate <= 0.7 and COLORS.loss or COLORS.text)
	priceLabel.TextSize = 13
	priceLabel.Font = Enum.Font.Gotham
	priceLabel.Parent = row
	
	-- Total value
	local totalLabel = Instance.new("TextLabel")
	totalLabel.Size = UDim2.new(0.15, 0, 1, 0)
	totalLabel.Position = UDim2.new(0.65, 0, 0, 0)
	totalLabel.BackgroundTransparency = 1
	totalLabel.Text = "$" .. totalValue
	totalLabel.TextColor3 = COLORS.profit
	totalLabel.TextSize = 13
	totalLabel.Font = Enum.Font.GothamBold
	totalLabel.Parent = row
	
	-- Sell button
	local sellBtn = Instance.new("TextButton")
	sellBtn.Name = "SellButton"
	sellBtn.Size = UDim2.new(0, 55, 0, 26)
	sellBtn.Position = UDim2.new(1, -65, 0.5, -13)
	sellBtn.BackgroundColor3 = COLORS.accent
	sellBtn.Text = "SELL"
	sellBtn.TextColor3 = COLORS.background
	sellBtn.TextSize = 11
	sellBtn.Font = Enum.Font.GothamBold
	sellBtn.Parent = row
	
	local btnCorner = Instance.new("UICorner")
	btnCorner.CornerRadius = UDim.new(0, 5)
	btnCorner.Parent = sellBtn
	
	sellBtn.MouseButton1Click:Connect(function()
		SellItemFunction:InvokeServer(itemId, count)
	end)
	
	return row
end

--------------------------------------------------------------------------------
-- UI UPDATE
--------------------------------------------------------------------------------

local function calculateTotalValue()
	local total = 0
	for itemId, count in pairs(currentBackpack) do
		if count > 0 then
			local itemInfo = ItemConfig.Items[itemId]
			if itemInfo then
				local price = math.floor((itemInfo.basePrice or 1) * marketRate)
				total = total + (price * count)
			end
		end
	end
	return total
end

local function updateUI()
	if not mainFrame then return end
	
	-- Update market rate display
	local header = mainFrame:FindFirstChild("Header")
	if header then
		local rateLabel = header:FindFirstChild("RateLabel")
		if rateLabel then
			local rateColor = marketRate >= 1.5 and COLORS.profit or (marketRate <= 0.7 and COLORS.loss or COLORS.success)
			rateLabel.Text = string.format("ðŸ“ˆ Market Rate: %.2fx", marketRate)
			rateLabel.TextColor3 = rateColor
		end
	end
	
	-- Update item list
	local itemsPanel = mainFrame:FindFirstChild("ItemsPanel")
	if itemsPanel then
		local scrollFrame = itemsPanel:FindFirstChild("ItemList")
		if scrollFrame then
			-- Clear existing
			for _, child in scrollFrame:GetChildren() do
				if child:IsA("Frame") then
					child:Destroy()
				end
			end
			
			-- Add items
			for itemId, count in pairs(currentBackpack) do
				if count > 0 then
					local itemInfo = ItemConfig.Items[itemId]
					if itemInfo then
						local price = math.floor((itemInfo.basePrice or 1) * marketRate)
						createItemRow(scrollFrame, itemId, count, price)
					end
				end
			end
		end
	end
	
	-- Update total value
	local bottomBar = mainFrame:FindFirstChild("BottomBar")
	if bottomBar then
		local totalLabel = bottomBar:FindFirstChild("TotalValue")
		if totalLabel then
			local total = calculateTotalValue()
			totalLabel.Text = string.format("ðŸ’° Total Value: $%d", total)
		end
	end
end

--------------------------------------------------------------------------------
-- OPEN/CLOSE
--------------------------------------------------------------------------------

local function openUI()
	if isOpen then return end
	isOpen = true
	
	-- Fetch latest data
	local backpackItems, backpackTot, _ = GetBackpackFunction:InvokeServer()
	currentBackpack = backpackItems or {}
	backpackTotal = backpackTot or 0
	
	-- Get market rate
	marketRate = stockMarketFolder:GetAttribute("CurrentRate") or 1.0
	
	-- Update UI
	updateUI()
	
	-- Show with animation
	mainFrame.Visible = true
	mainFrame.Size = UDim2.new(0, 550, 0, 0)
	TweenService:Create(mainFrame, TweenInfo.new(0.3, Enum.EasingStyle.Back), {
		Size = UDim2.new(0, 550, 0, 450)
	}):Play()
end

function closeUI()
	if not isOpen then return end
	isOpen = false
	
	TweenService:Create(mainFrame, TweenInfo.new(0.2), {
		Size = UDim2.new(0, 550, 0, 0)
	}):Play()
	
	task.wait(0.2)
	mainFrame.Visible = false
end

--------------------------------------------------------------------------------
-- EVENT HANDLERS
--------------------------------------------------------------------------------

BackpackUpdatedEvent.OnClientEvent:Connect(function(items, total, capacity)
	currentBackpack = items or {}
	backpackTotal = total or 0
	
	if isOpen then
		updateUI()
	end
end)

ItemSoldEvent.OnClientEvent:Connect(function(itemId, count, earned)
	-- Refresh backpack after sale
	local backpackItems, backpackTot, _ = GetBackpackFunction:InvokeServer()
	currentBackpack = backpackItems or {}
	backpackTotal = backpackTot or 0
	
	if isOpen then
		updateUI()
	end
end)

-- Market rate updates
stockMarketFolder:GetAttributeChangedSignal("CurrentRate"):Connect(function()
	marketRate = stockMarketFolder:GetAttribute("CurrentRate") or 1.0
	if isOpen then
		updateUI()
	end
end)

-- Keyboard toggle (M key)
UserInputService.InputBegan:Connect(function(input, processed)
	if processed then return end
	
	if input.KeyCode == Enum.KeyCode.M then
		if isOpen then
			closeUI()
		else
			openUI()
		end
	end
end)

-- ProximityPrompt connection
local function setupMarketPrompt()
	-- Wait for market building
	task.spawn(function()
		local mainIsland = workspace:WaitForChild("MainIsland", 30)
		if mainIsland then
			local marketBuilding = mainIsland:WaitForChild("MarketBuilding", 30)
			if marketBuilding then
				local prompt = marketBuilding:FindFirstChild("MarketPrompt")
				if prompt then
					prompt.Triggered:Connect(function()
						openUI()
					end)
					print("MarketTerminalUI: Connected to Market prompt")
				end
			end
		end
	end)
end

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

local function initialize()
	screenGui = createScreenGui()
	mainFrame = createMainFrame(screenGui)
	createHeader(mainFrame)
	createItemsPanel(mainFrame)
	createBottomBar(mainFrame)
	
	setupMarketPrompt()
	
	print("âœ“ MarketTerminalUI initialized - Press M to open, or use Market building")
end

initialize()



--------------------------------------------------
File: MewingUI.client.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\client\MewingUI.client.luau
--------------------------------------------------
--[[
	MewingUI Client Script
	
	Displays the player's Mewing streak status.
	Shows:
	- Current streak tier and emoji
	- Time in current streak
	- Income multiplier bonus
	- Visual feedback when streak breaks
]]

-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
-- RunService not needed for this UI
local TweenService = game:GetService("TweenService")
local SoundService = game:GetService("SoundService")

-- Player
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Configuration
local CONFIG = {
	TIER_COLORS = {
		[0] = Color3.fromRGB(100, 100, 100),
		[1] = Color3.fromRGB(180, 180, 255),
		[2] = Color3.fromRGB(100, 255, 100),
		[3] = Color3.fromRGB(255, 215, 0),
	},
	SOUNDS = {
		TIER_UP = "rbxassetid://6895079853",
		BREAK = "rbxassetid://5702385985",
	},
}

-- Wait for RemoteEvents
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local MewingUpdateEvent = RemoteEvents:WaitForChild("MewingUpdate", 30)
if not MewingUpdateEvent then
	warn("MewingUI: MewingUpdate event not found!")
	return
end

--------------------------------------------------------------------------------
-- UI CREATION
--------------------------------------------------------------------------------

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "MewingUI"
screenGui.ResetOnSpawn = false
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.Parent = playerGui

-- Main container (left side, below center)
local container = Instance.new("Frame")
container.Name = "MewingContainer"
container.Size = UDim2.new(0, 160, 0, 60)
container.Position = UDim2.new(0, 20, 0.6, 0)
container.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
container.BackgroundTransparency = 0.3
container.BorderSizePixel = 0
container.Visible = false -- Hidden until streak starts
container.Parent = screenGui

local containerCorner = Instance.new("UICorner")
containerCorner.CornerRadius = UDim.new(0, 10)
containerCorner.Parent = container

local containerStroke = Instance.new("UIStroke")
containerStroke.Thickness = 2
containerStroke.Color = Color3.fromRGB(60, 60, 80)
containerStroke.Parent = container

-- Emoji / Icon
local emojiLabel = Instance.new("TextLabel")
emojiLabel.Name = "Emoji"
emojiLabel.Size = UDim2.new(0, 50, 1, 0)
emojiLabel.Position = UDim2.new(0, 0, 0, 0)
emojiLabel.BackgroundTransparency = 1
emojiLabel.Text = "ðŸ¤«"
emojiLabel.TextSize = 32
emojiLabel.Font = Enum.Font.GothamBold
emojiLabel.Parent = container

-- Status text container
local textContainer = Instance.new("Frame")
textContainer.Name = "TextContainer"
textContainer.Size = UDim2.new(1, -55, 1, 0)
textContainer.Position = UDim2.new(0, 55, 0, 0)
textContainer.BackgroundTransparency = 1
textContainer.Parent = container

-- Tier name
local tierLabel = Instance.new("TextLabel")
tierLabel.Name = "TierLabel"
tierLabel.Size = UDim2.new(1, 0, 0.5, 0)
tierLabel.Position = UDim2.new(0, 0, 0, 5)
tierLabel.BackgroundTransparency = 1
tierLabel.Text = "Mewing..."
tierLabel.TextColor3 = Color3.fromRGB(200, 200, 220)
tierLabel.TextSize = 14
tierLabel.Font = Enum.Font.GothamBold
tierLabel.TextXAlignment = Enum.TextXAlignment.Left
tierLabel.Parent = textContainer

-- Bonus label
local bonusLabel = Instance.new("TextLabel")
bonusLabel.Name = "BonusLabel"
bonusLabel.Size = UDim2.new(1, 0, 0.5, 0)
bonusLabel.Position = UDim2.new(0, 0, 0.5, -5)
bonusLabel.BackgroundTransparency = 1
bonusLabel.Text = "+0%"
bonusLabel.TextColor3 = Color3.fromRGB(150, 255, 150)
bonusLabel.TextSize = 12
bonusLabel.Font = Enum.Font.GothamMedium
bonusLabel.TextXAlignment = Enum.TextXAlignment.Left
bonusLabel.Parent = textContainer

--------------------------------------------------------------------------------
-- SOUND SETUP
--------------------------------------------------------------------------------

local tierUpSound = Instance.new("Sound")
tierUpSound.SoundId = CONFIG.SOUNDS.TIER_UP
tierUpSound.Volume = 0.6
tierUpSound.Parent = SoundService

local breakSound = Instance.new("Sound")
breakSound.SoundId = CONFIG.SOUNDS.BREAK
breakSound.Volume = 0.7
breakSound.Parent = SoundService

--------------------------------------------------------------------------------
-- UPDATE LOGIC
--------------------------------------------------------------------------------

local function showUI()
	if not container.Visible then
		container.Visible = true
		container.Position = UDim2.new(0, -160, 0.6, 0)
		local tween = TweenService:Create(container, TweenInfo.new(0.3, Enum.EasingStyle.Back), {
			Position = UDim2.new(0, 20, 0.6, 0)
		})
		tween:Play()
	end
end

local function hideUI()
	if container.Visible then
		local tween = TweenService:Create(container, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
			Position = UDim2.new(0, -160, 0.6, 0)
		})
		tween:Play()
		tween.Completed:Wait()
		container.Visible = false
	end
end

local function onMewingUpdate(data)
	if data.type == "tier_up" then
		showUI()
		
		-- Update visuals
		emojiLabel.Text = data.emoji or "ðŸ¤«"
		tierLabel.Text = data.name or "Mewing"
		bonusLabel.Text = string.format("+%.0f%%", (data.multiplier - 1) * 100)
		
		-- Color
		local color = CONFIG.TIER_COLORS[data.tier] or CONFIG.TIER_COLORS[1]
		containerStroke.Color = color
		tierLabel.TextColor3 = color
		
		-- Play sound
		tierUpSound:Play()
		
		-- Animate
		emojiLabel.TextSize = 24
		local tween = TweenService:Create(emojiLabel, TweenInfo.new(0.3, Enum.EasingStyle.Back), {
			TextSize = 32
		})
		tween:Play()
		
	elseif data.type == "break" then
		-- Play break sound
		breakSound:Play()
		
		-- Flash red
		local _originalColor = containerStroke.Color
		containerStroke.Color = Color3.fromRGB(255, 50, 50)
		task.wait(0.3)
		
		-- Hide UI
		hideUI()
	end
end

-- Connect event
MewingUpdateEvent.OnClientEvent:Connect(onMewingUpdate)

-- Check initial state (in case player rejoins mid-streak)
local function checkInitialState()
	local tier = player:GetAttribute("MewingTier") or 0
	local multiplier = player:GetAttribute("MewingMultiplier") or 1.0
	
	if tier > 0 then
		local tierNames = {"Streak Started", "Locked In", "GigaChad"}
		local emojis = {"ðŸ¤«", "ðŸ”’", "ðŸ—¿"}
		onMewingUpdate({
			type = "tier_up",
			tier = tier,
			name = tierNames[tier] or "Mewing",
			emoji = emojis[tier] or "ðŸ¤«",
			multiplier = multiplier,
		})
	end
end

-- Wait a bit for attributes to load
task.delay(2, checkInitialState)

print("âœ“ MewingUI initialized")



--------------------------------------------------
File: MoneyHUD.client.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\client\MoneyHUD.client.luau
--------------------------------------------------
--[[
	MoneyHUD LocalScript
	
	Displays the player's current money and money per second in a simple HUD.
	Located in the top-left area of the screen.
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

-- Player reference
local Player = Players.LocalPlayer
local PlayerGui = Player:WaitForChild("PlayerGui")

-- Wait for shared modules and remotes
local ShopConfig = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("ShopConfig"))
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local GetOwnershipRemote = RemoteEvents:WaitForChild("GetOwnership")
local OwnershipChangedEvent = RemoteEvents:WaitForChild("OwnershipChanged")

--------------------------------------------------------------------------------
-- UI CONFIGURATION
--------------------------------------------------------------------------------

local UI_CONFIG = {
	-- Panel positioning and size
	PANEL_WIDTH = 220,
	PANEL_HEIGHT = 290,  -- Increased for new buttons
	PANEL_MARGIN = 20,
	CORNER_RADIUS = 16,
	
	-- Colors
	BACKGROUND_COLOR = Color3.fromRGB(20, 20, 30),
	STROKE_COLOR = Color3.fromRGB(50, 50, 70),
	MONEY_COLOR = Color3.fromRGB(100, 255, 100),
	MPS_COLOR = Color3.fromRGB(180, 180, 180),
	LABEL_COLOR = Color3.fromRGB(120, 120, 140),
	ITEMS_BG_COLOR = Color3.fromRGB(40, 40, 50),
	ITEMS_FILL_COLOR = Color3.fromRGB(100, 180, 255),  -- Blue for items
	ITEMS_FULL_COLOR = Color3.fromRGB(255, 100, 100),
	
	-- Animation
	TWEEN_TIME = 0.2,
}

--------------------------------------------------------------------------------
-- HELPER FUNCTIONS
--------------------------------------------------------------------------------

local function formatMoney(amount: number): string
	if amount >= 1000000000 then
		return string.format("$%.2fB", amount / 1000000000)
	elseif amount >= 1000000 then
		return string.format("$%.2fM", amount / 1000000)
	elseif amount >= 1000 then
		return string.format("$%.1fK", amount / 1000)
	else
		return "$" .. tostring(math.floor(amount))
	end
end

local function addCorner(parent: GuiObject, radius: number)
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, radius)
	corner.Parent = parent
	return corner
end

local function addStroke(parent: GuiObject, color: Color3, thickness: number)
	local stroke = Instance.new("UIStroke")
	stroke.Color = color
	stroke.Thickness = thickness
	stroke.Transparency = 0.5
	stroke.Parent = parent
	return stroke
end

--------------------------------------------------------------------------------
-- UI CREATION
--------------------------------------------------------------------------------

local function createMoneyHUD(): ScreenGui
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "MoneyHUD"
	screenGui.ResetOnSpawn = false
	screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	
	-- Main HUD panel
	local hudPanel = Instance.new("Frame")
	hudPanel.Name = "HUDPanel"
	hudPanel.Size = UDim2.new(0, UI_CONFIG.PANEL_WIDTH, 0, UI_CONFIG.PANEL_HEIGHT)
	hudPanel.Position = UDim2.new(1, -UI_CONFIG.PANEL_WIDTH - UI_CONFIG.PANEL_MARGIN, 0, UI_CONFIG.PANEL_MARGIN)
	hudPanel.BackgroundColor3 = UI_CONFIG.BACKGROUND_COLOR
	hudPanel.BackgroundTransparency = 0.1
	hudPanel.BorderSizePixel = 0
	hudPanel.Parent = screenGui
	addCorner(hudPanel, UI_CONFIG.CORNER_RADIUS)
	addStroke(hudPanel, UI_CONFIG.STROKE_COLOR, 2)
	
	-- Add padding
	local padding = Instance.new("UIPadding")
	padding.PaddingLeft = UDim.new(0, 16)
	padding.PaddingRight = UDim.new(0, 16)
	padding.PaddingTop = UDim.new(0, 12)
	padding.PaddingBottom = UDim.new(0, 12)
	padding.Parent = hudPanel
	
	-- Money icon and label container
	local moneyContainer = Instance.new("Frame")
	moneyContainer.Name = "MoneyContainer"
	moneyContainer.Size = UDim2.new(1, 0, 0, 32)
	moneyContainer.Position = UDim2.new(0, 0, 0, 0)
	moneyContainer.BackgroundTransparency = 1
	moneyContainer.Parent = hudPanel
	
	-- Money icon
	local moneyIcon = Instance.new("TextLabel")
	moneyIcon.Name = "MoneyIcon"
	moneyIcon.Size = UDim2.new(0, 32, 0, 32)
	moneyIcon.Position = UDim2.new(0, 0, 0, 0)
	moneyIcon.BackgroundTransparency = 1
	moneyIcon.Text = "ðŸ’°"
	moneyIcon.TextSize = 24
	moneyIcon.Font = Enum.Font.GothamBold
	moneyIcon.Parent = moneyContainer
	
	-- Money value label
	local moneyLabel = Instance.new("TextLabel")
	moneyLabel.Name = "MoneyLabel"
	moneyLabel.Size = UDim2.new(1, -40, 0, 32)
	moneyLabel.Position = UDim2.new(0, 40, 0, 0)
	moneyLabel.BackgroundTransparency = 1
	moneyLabel.Text = "$0"
	moneyLabel.TextColor3 = UI_CONFIG.MONEY_COLOR
	moneyLabel.TextSize = 28
	moneyLabel.Font = Enum.Font.GothamBold
	moneyLabel.TextXAlignment = Enum.TextXAlignment.Left
	moneyLabel.Parent = moneyContainer
	
	-- Money per second (placeholder)
	local mpsLabel = Instance.new("TextLabel")
	mpsLabel.Name = "MPSLabel"
	mpsLabel.Size = UDim2.new(1, 0, 0, 18)
	mpsLabel.Position = UDim2.new(0, 0, 0, 38)
	mpsLabel.BackgroundTransparency = 1
	mpsLabel.Text = "+$0/s" -- Placeholder, not implemented yet
	mpsLabel.TextColor3 = UI_CONFIG.MPS_COLOR
	mpsLabel.TextSize = 14
	mpsLabel.Font = Enum.Font.Gotham
	mpsLabel.TextXAlignment = Enum.TextXAlignment.Left
	mpsLabel.Parent = hudPanel
	
	-- Item storage container
	local itemsContainer = Instance.new("Frame")
	itemsContainer.Name = "ItemsContainer"
	itemsContainer.Size = UDim2.new(1, 0, 0, 24)
	itemsContainer.Position = UDim2.new(0, 0, 0, 60)
	itemsContainer.BackgroundTransparency = 1
	itemsContainer.Parent = hudPanel
	
	-- Items bar background (fills container)
	local itemsBarBg = Instance.new("Frame")
	itemsBarBg.Name = "ItemsBarBg"
	itemsBarBg.Size = UDim2.new(1, 0, 1, 0)
	itemsBarBg.Position = UDim2.new(0, 0, 0, 0)
	itemsBarBg.BackgroundColor3 = UI_CONFIG.ITEMS_BG_COLOR
	itemsBarBg.BorderSizePixel = 0
	itemsBarBg.Parent = itemsContainer
	addCorner(itemsBarBg, 6)
	
	-- Items bar fill
	local itemsBarFill = Instance.new("Frame")
	itemsBarFill.Name = "ItemsBarFill"
	itemsBarFill.Size = UDim2.new(0, 0, 1, 0) -- Start empty
	itemsBarFill.Position = UDim2.new(0, 0, 0, 0)
	itemsBarFill.BackgroundColor3 = UI_CONFIG.ITEMS_FILL_COLOR
	itemsBarFill.BorderSizePixel = 0
	itemsBarFill.Parent = itemsBarBg
	addCorner(itemsBarFill, 6)
	
	-- Items amount text (overlay on bar)
	local itemsAmountLabel = Instance.new("TextLabel")
	itemsAmountLabel.Name = "ItemsAmount"
	itemsAmountLabel.Size = UDim2.new(1, 0, 1, 0)
	itemsAmountLabel.Position = UDim2.new(0, 0, 0, 0)
	itemsAmountLabel.BackgroundTransparency = 1
	itemsAmountLabel.Text = "ðŸ“¦ ITEMS: 0 / 2000"
	itemsAmountLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	itemsAmountLabel.TextSize = 11
	itemsAmountLabel.Font = Enum.Font.GothamBold
	itemsAmountLabel.ZIndex = 2
	itemsAmountLabel.Parent = itemsBarBg
	
	-- Shop button (cart icon) 
	local shopButton = Instance.new("TextButton")
	shopButton.Name = "ShopButton"
	shopButton.Size = UDim2.new(1, 0, 0, 28)
	shopButton.Position = UDim2.new(0, 0, 0, 92)
	shopButton.BackgroundColor3 = Color3.fromRGB(80, 60, 140)
	shopButton.BorderSizePixel = 0
	shopButton.Text = "ðŸ›’ Open Shop (B)"
	shopButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	shopButton.TextSize = 12
	shopButton.Font = Enum.Font.GothamBold
	shopButton.Parent = hudPanel
	addCorner(shopButton, 6)
	
	-- Brainrots/Inventory button
	local brainrotsButton = Instance.new("TextButton")
	brainrotsButton.Name = "BrainrotsButton"
	brainrotsButton.Size = UDim2.new(1, 0, 0, 28)
	brainrotsButton.Position = UDim2.new(0, 0, 0, 125)
	brainrotsButton.BackgroundColor3 = Color3.fromRGB(140, 80, 160)
	brainrotsButton.BorderSizePixel = 0
	brainrotsButton.Text = "ðŸ§  Brainrots (I)"
	brainrotsButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	brainrotsButton.TextSize = 12
	brainrotsButton.Font = Enum.Font.GothamBold
	brainrotsButton.Parent = hudPanel
	addCorner(brainrotsButton, 6)
	
	-- Synergies button
	local synergiesButton = Instance.new("TextButton")
	synergiesButton.Name = "SynergiesButton"
	synergiesButton.Size = UDim2.new(1, 0, 0, 28)
	synergiesButton.Position = UDim2.new(0, 0, 0, 158)
	synergiesButton.BackgroundColor3 = Color3.fromRGB(200, 150, 60)
	synergiesButton.BorderSizePixel = 0
	synergiesButton.Text = "âš¡ Synergies (Y)"
	synergiesButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	synergiesButton.TextSize = 12
	synergiesButton.Font = Enum.Font.GothamBold
	synergiesButton.Parent = hudPanel
	addCorner(synergiesButton, 6)
	
	-- Transport button (NEW)
	local transportButton = Instance.new("TextButton")
	transportButton.Name = "TransportButton"
	transportButton.Size = UDim2.new(1, 0, 0, 28)
	transportButton.Position = UDim2.new(0, 0, 0, 191)
	transportButton.BackgroundColor3 = Color3.fromRGB(80, 160, 200)
	transportButton.BorderSizePixel = 0
	transportButton.Text = "ðŸ“¦ Transport (T)"
	transportButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	transportButton.TextSize = 12
	transportButton.Font = Enum.Font.GothamBold
	transportButton.Parent = hudPanel
	addCorner(transportButton, 6)
	
	-- Market button (NEW)
	local marketButton = Instance.new("TextButton")
	marketButton.Name = "MarketButton"
	marketButton.Size = UDim2.new(1, 0, 0, 28)
	marketButton.Position = UDim2.new(0, 0, 0, 224)
	marketButton.BackgroundColor3 = Color3.fromRGB(220, 170, 50)
	marketButton.BorderSizePixel = 0
	marketButton.Text = "ðŸª Market (M)"
	marketButton.TextColor3 = Color3.fromRGB(30, 30, 30)
	marketButton.TextSize = 12
	marketButton.Font = Enum.Font.GothamBold
	marketButton.Parent = hudPanel
	addCorner(marketButton, 6)
	
	return screenGui
end

--------------------------------------------------------------------------------
-- MONEY TRACKING
--------------------------------------------------------------------------------

local MoneyHUDGui: ScreenGui
local MoneyLabel: TextLabel
local MPSLabel: TextLabel
local ItemsBarFill: Frame
local ItemsAmountLabel: TextLabel

local previousMoney: number = 0
local cachedPlot: Instance? = nil

-- Track ownership for MPS calculation
local OwnedCounts: {[string]: number} = {}

--[[
	Calculates the total money per second based on all owned units.
	Formula: Sum of (BaseIncome / CycleTime) * count for each unit
]]
local function calculateMPS(): number
	local totalMPS = 0
	
	for unitName, count in OwnedCounts do
		if count > 0 then
			local config = ShopConfig.GetConfig(unitName)
			if config then
				-- Income per second for this unit type: (BaseIncome / CycleTime) * count
				local incomePerSecond = (config.BaseIncome / config.CycleTime) * count
				totalMPS = totalMPS + incomePerSecond
			end
		end
	end
	
	return totalMPS
end

--[[
	Updates the MPS display label with the calculated value.
]]
local function updateMPSDisplay()
	if not MPSLabel then return end
	
	local mps = calculateMPS()
	
	if mps >= 1000 then
		MPSLabel.Text = string.format("+$%.1fK/s", mps / 1000)
	else
		MPSLabel.Text = string.format("+$%.1f/s", mps)
	end
end

local function updateMoneyDisplay(newMoney: number)
	if not MoneyLabel then return end
	
	local formattedMoney = formatMoney(newMoney)
	MoneyLabel.Text = formattedMoney
	
	-- Animate color flash on money change
	if newMoney > previousMoney then
		-- Money gained - flash bright green
		MoneyLabel.TextColor3 = Color3.fromRGB(150, 255, 150)
		TweenService:Create(MoneyLabel, TweenInfo.new(UI_CONFIG.TWEEN_TIME), {
			TextColor3 = UI_CONFIG.MONEY_COLOR
		}):Play()
	elseif newMoney < previousMoney then
		-- Money spent - flash red briefly
		MoneyLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
		TweenService:Create(MoneyLabel, TweenInfo.new(UI_CONFIG.TWEEN_TIME), {
			TextColor3 = UI_CONFIG.MONEY_COLOR
		}):Play()
	end
	
	previousMoney = newMoney
end

--[[
	Updates the items bar fill and text based on current item storage.
]]
local function updateItemsDisplay(currentItems: number, maxItems: number)
	if not ItemsBarFill or not ItemsAmountLabel then return end
	
	local fillPercent = math.clamp(currentItems / maxItems, 0, 1)
	
	-- Animate the fill bar width
	TweenService:Create(ItemsBarFill, TweenInfo.new(0.3, Enum.EasingStyle.Quad), {
		Size = UDim2.new(fillPercent, 0, 1, 0)
	}):Play()
	
	-- Update text
	ItemsAmountLabel.Text = string.format("ðŸ“¦ ITEMS: %d / %d", currentItems, maxItems)
	
	-- Change color based on fill level
	local targetColor
	if fillPercent >= 1 then
		targetColor = UI_CONFIG.ITEMS_FULL_COLOR
	elseif fillPercent >= 0.75 then
		-- Interpolate between fill and full color
		targetColor = UI_CONFIG.ITEMS_FILL_COLOR:Lerp(UI_CONFIG.ITEMS_FULL_COLOR, (fillPercent - 0.75) / 0.25)
	else
		targetColor = UI_CONFIG.ITEMS_FILL_COLOR
	end
	
	TweenService:Create(ItemsBarFill, TweenInfo.new(0.2), {
		BackgroundColor3 = targetColor
	}):Play()
end

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

local function initialize()
	print("MoneyHUD: Initializing...")
	
	-- Create the HUD
	MoneyHUDGui = createMoneyHUD()
	MoneyHUDGui.Parent = PlayerGui
	
	-- Get references to labels
	local hudPanel = MoneyHUDGui:FindFirstChild("HUDPanel")
	if hudPanel then
		local moneyContainer = hudPanel:FindFirstChild("MoneyContainer")
		if moneyContainer then
			MoneyLabel = moneyContainer:FindFirstChild("MoneyLabel")
		end
		MPSLabel = hudPanel:FindFirstChild("MPSLabel")
		
		-- Get items bar references (was tank bar)
		local itemsContainer = hudPanel:FindFirstChild("ItemsContainer")
		if itemsContainer then
			local itemsBarBg = itemsContainer:FindFirstChild("ItemsBarBg")
			if itemsBarBg then
				ItemsBarFill = itemsBarBg:FindFirstChild("ItemsBarFill")
				ItemsAmountLabel = itemsBarBg:FindFirstChild("ItemsAmount")
			end
		end
	end
	
	-- Get initial ownership data from server for MPS calculation
	local ownershipData = GetOwnershipRemote:InvokeServer()
	if ownershipData and ownershipData.units then
		for unitName, data in ownershipData.units do
			OwnedCounts[unitName] = data.count
		end
		updateMPSDisplay()
	end
	
	-- Listen for ownership changes to update MPS
	OwnershipChangedEvent.OnClientEvent:Connect(function(unitName: string, newCount: number)
		OwnedCounts[unitName] = newCount
		updateMPSDisplay()
	end)
	
	-- Wait for leaderstats and connect to money changes
	local leaderstats = Player:WaitForChild("leaderstats", 10)
	if leaderstats then
		local money = leaderstats:WaitForChild("Money", 5)
		if money then
			-- Initial update
			previousMoney = money.Value
			updateMoneyDisplay(money.Value)
			
			-- Listen for changes
			money:GetPropertyChangedSignal("Value"):Connect(function()
				updateMoneyDisplay(money.Value)
			end)
			
			print("MoneyHUD: Connected to money value")
		else
			warn("MoneyHUD: Could not find Money value")
		end
	else
		warn("MoneyHUD: Could not find leaderstats")
	end
	
	-- Listen for item storage updates (from ItemStorageManager)
	local StorageUpdatedEvent = RemoteEvents:FindFirstChild("StorageUpdated")
	if StorageUpdatedEvent then
		StorageUpdatedEvent.OnClientEvent:Connect(function(items, total, capacity)
			updateItemsDisplay(total or 0, capacity or 2000)
		end)
		-- Also fetch initial values
		local GetStorageFunction = RemoteEvents:FindFirstChild("GetStorage")
		if GetStorageFunction then
			task.spawn(function()
				local items, total, capacity = GetStorageFunction:InvokeServer()
				updateItemsDisplay(total or 0, capacity or 2000)
			end)
		end
	end
	
	-- Setup shop button click
	local shopHudPanel = MoneyHUDGui:FindFirstChild("HUDPanel")
	if shopHudPanel then
		local shopButton = shopHudPanel:FindFirstChild("ShopButton")
		if shopButton then
			-- Create or get the BindableEvent for shop toggle
			local shopToggleEvent = ReplicatedStorage:FindFirstChild("ShopToggleEvent")
			if not shopToggleEvent then
				shopToggleEvent = Instance.new("BindableEvent")
				shopToggleEvent.Name = "ShopToggleEvent"
				shopToggleEvent.Parent = ReplicatedStorage
			end
			
			shopButton.MouseButton1Click:Connect(function()
				shopToggleEvent:Fire()
			end)
			
			-- Hover effects
			shopButton.MouseEnter:Connect(function()
				TweenService:Create(shopButton, TweenInfo.new(0.1), {
					BackgroundColor3 = Color3.fromRGB(100, 80, 170)
				}):Play()
			end)
			
			shopButton.MouseLeave:Connect(function()
				TweenService:Create(shopButton, TweenInfo.new(0.1), {
					BackgroundColor3 = Color3.fromRGB(80, 60, 140)
				}):Play()
			end)
		end
		
		-- Setup brainrots button click
		local brainrotsButton = shopHudPanel:FindFirstChild("BrainrotsButton")
		if brainrotsButton then
			-- Create or get the BindableEvent for inventory toggle
			local inventoryToggleEvent = ReplicatedStorage:FindFirstChild("InventoryToggleEvent")
			if not inventoryToggleEvent then
				inventoryToggleEvent = Instance.new("BindableEvent")
				inventoryToggleEvent.Name = "InventoryToggleEvent"
				inventoryToggleEvent.Parent = ReplicatedStorage
			end
			
			brainrotsButton.MouseButton1Click:Connect(function()
				inventoryToggleEvent:Fire()
			end)
			
			-- Hover effects
			brainrotsButton.MouseEnter:Connect(function()
				TweenService:Create(brainrotsButton, TweenInfo.new(0.1), {
					BackgroundColor3 = Color3.fromRGB(170, 100, 190)
				}):Play()
			end)
			
			brainrotsButton.MouseLeave:Connect(function()
				TweenService:Create(brainrotsButton, TweenInfo.new(0.1), {
					BackgroundColor3 = Color3.fromRGB(140, 80, 160)
				}):Play()
			end)
		end
		
		-- Setup synergies button click
		local synergiesButton = shopHudPanel:FindFirstChild("SynergiesButton")
		if synergiesButton then
			-- Create or get the BindableEvent for synergy toggle
			local synergyToggleEvent = ReplicatedStorage:FindFirstChild("SynergyToggleEvent")
			if not synergyToggleEvent then
				synergyToggleEvent = Instance.new("BindableEvent")
				synergyToggleEvent.Name = "SynergyToggleEvent"
				synergyToggleEvent.Parent = ReplicatedStorage
			end
			
			synergiesButton.MouseButton1Click:Connect(function()
				synergyToggleEvent:Fire()
			end)
			
			-- Hover effects
			synergiesButton.MouseEnter:Connect(function()
				TweenService:Create(synergiesButton, TweenInfo.new(0.1), {
					BackgroundColor3 = Color3.fromRGB(230, 180, 80)
				}):Play()
			end)
			
			synergiesButton.MouseLeave:Connect(function()
				TweenService:Create(synergiesButton, TweenInfo.new(0.1), {
					BackgroundColor3 = Color3.fromRGB(200, 150, 60)
				}):Play()
			end)
		end
	end
	
	print("MoneyHUD: Ready!")
end

-- Start
initialize()



--------------------------------------------------
File: NotificationManager.client.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\client\NotificationManager.client.luau
--------------------------------------------------
--[[
	NotificationManager Client Script
	
	Handles visual notifications and alerts for the player.
	
	Features:
	- Toast notifications (bottom-right corner)
	- Full-width banners for important events
	- Market ticker for price changes
	- Storage full warnings
	
	Part of the "Sell a Brainrot" system.
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

-- Get player
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- Wait for events
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local StorageUpdatedEvent = RemoteEvents:WaitForChild("StorageUpdated")
local ItemSoldEvent = RemoteEvents:WaitForChild("ItemSold")
local BackpackLoadedEvent = RemoteEvents:WaitForChild("BackpackLoaded")

-- Stock market for events
local stockMarketFolder = ReplicatedStorage:WaitForChild("StockMarket")

-- UI Colors
local COLORS = {
	toast = Color3.fromRGB(30, 35, 50),
	success = Color3.fromRGB(50, 200, 100),
	warning = Color3.fromRGB(255, 180, 50),
	error = Color3.fromRGB(255, 80, 80),
	info = Color3.fromRGB(100, 180, 255),
	gold = Color3.fromRGB(255, 200, 50),
	text = Color3.fromRGB(255, 255, 255),
	textMuted = Color3.fromRGB(180, 180, 200),
}

-- Constants
local TOAST_DURATION = 3
local TOAST_WIDTH = 280
local TOAST_HEIGHT = 60
local MAX_TOASTS = 4

-- State
local activeToasts = {}
local screenGui = nil
local toastContainer = nil
local bannerFrame = nil

--------------------------------------------------------------------------------
-- TOAST NOTIFICATIONS
--------------------------------------------------------------------------------

local function createToastContainer()
	local container = Instance.new("Frame")
	container.Name = "ToastContainer"
	container.Size = UDim2.new(0, TOAST_WIDTH + 20, 1, 0)
	container.Position = UDim2.new(1, -TOAST_WIDTH - 30, 0, 0)
	container.BackgroundTransparency = 1
	container.Parent = screenGui
	
	return container
end

local function showToast(message, toastType, duration)
	toastType = toastType or "info"
	duration = duration or TOAST_DURATION
	
	local color = COLORS[toastType] or COLORS.info
	local emoji = {
		success = "âœ“",
		warning = "âš ",
		error = "âœ•",
		info = "â„¹",
		gold = "ðŸ’°",
	}
	
	-- Create toast
	local toast = Instance.new("Frame")
	toast.Name = "Toast"
	toast.Size = UDim2.new(0, TOAST_WIDTH, 0, TOAST_HEIGHT)
	toast.Position = UDim2.new(0, TOAST_WIDTH + 20, 1, -10 - (#activeToasts * (TOAST_HEIGHT + 10)))
	toast.BackgroundColor3 = COLORS.toast
	toast.BackgroundTransparency = 0.1
	toast.Parent = toastContainer
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 10)
	corner.Parent = toast
	
	local stroke = Instance.new("UIStroke")
	stroke.Color = color
	stroke.Thickness = 2
	stroke.Transparency = 0.3
	stroke.Parent = toast
	
	-- Icon
	local icon = Instance.new("TextLabel")
	icon.Size = UDim2.new(0, 40, 1, 0)
	icon.BackgroundTransparency = 1
	icon.Text = emoji[toastType] or "â„¹"
	icon.TextColor3 = color
	icon.TextSize = 22
	icon.Font = Enum.Font.GothamBold
	icon.Parent = toast
	
	-- Message
	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, -50, 1, 0)
	label.Position = UDim2.new(0, 40, 0, 0)
	label.BackgroundTransparency = 1
	label.Text = message
	label.TextColor3 = COLORS.text
	label.TextSize = 14
	label.Font = Enum.Font.Gotham
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.TextWrapped = true
	label.Parent = toast
	
	-- Slide in
	table.insert(activeToasts, toast)
	TweenService:Create(toast, TweenInfo.new(0.3, Enum.EasingStyle.Back), {
		Position = UDim2.new(0, 0, 1, -10 - ((#activeToasts - 1) * (TOAST_HEIGHT + 10)))
	}):Play()
	
	-- Auto-remove after duration
	task.delay(duration, function()
		-- Fade out
		TweenService:Create(toast, TweenInfo.new(0.3), {
			Position = UDim2.new(0, TOAST_WIDTH + 20, toast.Position.Y.Scale, toast.Position.Y.Offset)
		}):Play()
		
		task.wait(0.3)
		
		-- Remove from list and destroy
		local index = table.find(activeToasts, toast)
		if index then
			table.remove(activeToasts, index)
		end
		toast:Destroy()
		
		-- Reposition remaining toasts
		for i, t in ipairs(activeToasts) do
			TweenService:Create(t, TweenInfo.new(0.2), {
				Position = UDim2.new(0, 0, 1, -10 - ((i - 1) * (TOAST_HEIGHT + 10)))
			}):Play()
		end
	end)
	
	-- Limit max toasts
	while #activeToasts > MAX_TOASTS do
		local oldest = table.remove(activeToasts, 1)
		if oldest then oldest:Destroy() end
	end
end

--------------------------------------------------------------------------------
-- BANNER NOTIFICATIONS
--------------------------------------------------------------------------------

local function createBannerFrame()
	local banner = Instance.new("Frame")
	banner.Name = "BannerFrame"
	banner.Size = UDim2.new(1, 0, 0, 60)
	banner.Position = UDim2.new(0, 0, 0, -60)
	banner.BackgroundColor3 = COLORS.gold
	banner.BackgroundTransparency = 0.1
	banner.Visible = false
	banner.ZIndex = 10
	banner.Parent = screenGui
	
	local label = Instance.new("TextLabel")
	label.Name = "Message"
	label.Size = UDim2.new(1, -40, 1, 0)
	label.Position = UDim2.new(0, 20, 0, 0)
	label.BackgroundTransparency = 1
	label.Text = ""
	label.TextColor3 = Color3.fromRGB(20, 20, 30)
	label.TextSize = 24
	label.Font = Enum.Font.GothamBold
	label.ZIndex = 11
	label.Parent = banner
	
	return banner
end

local function showBanner(message, color, duration)
	color = color or COLORS.gold
	duration = duration or 4
	
	bannerFrame.BackgroundColor3 = color
	bannerFrame:FindFirstChild("Message").Text = message
	bannerFrame.Visible = true
	
	-- Slide down
	bannerFrame.Position = UDim2.new(0, 0, 0, -60)
	TweenService:Create(bannerFrame, TweenInfo.new(0.4, Enum.EasingStyle.Back), {
		Position = UDim2.new(0, 0, 0, 0)
	}):Play()
	
	-- Auto hide
	task.delay(duration, function()
		TweenService:Create(bannerFrame, TweenInfo.new(0.3), {
			Position = UDim2.new(0, 0, 0, -60)
		}):Play()
		
		task.wait(0.3)
		bannerFrame.Visible = false
	end)
end

--------------------------------------------------------------------------------
-- EVENT HANDLERS
--------------------------------------------------------------------------------

-- Storage full warning
StorageUpdatedEvent.OnClientEvent:Connect(function(items, total, capacity)
	if total >= capacity then
		showToast("Storage is FULL! Brainrots are sleeping.", "warning")
	elseif total >= capacity * 0.9 then
		showToast("Storage almost full (" .. total .. "/" .. capacity .. ")", "warning")
	end
end)

-- Item sold notification
ItemSoldEvent.OnClientEvent:Connect(function(itemId, count, earned)
	if earned > 0 then
		local msg = string.format("+$%d for %dx %s", earned, count, itemId or "items")
		showToast(msg, "gold", 2)
	end
end)

-- Backpack loaded notification
BackpackLoadedEvent.OnClientEvent:Connect(function(itemId, count)
	if count > 0 then
		local msg = itemId and string.format("Loaded %dx %s", count, itemId) or string.format("Loaded %d items", count)
		showToast(msg, "info", 2)
	end
end)

-- Market rate changes
local lastRate = 1.0
stockMarketFolder:GetAttributeChangedSignal("CurrentRate"):Connect(function()
	local newRate = stockMarketFolder:GetAttribute("CurrentRate") or 1.0
	
	if newRate >= 2.5 and lastRate < 2.5 then
		showBanner("ðŸ“ˆ HYPER INFLATION! Sell now for 2.5x+ prices!", COLORS.success, 5)
	elseif newRate <= 0.6 and lastRate > 0.6 then
		showBanner("ðŸ“‰ MARKET CRASH! Prices at historic lows!", COLORS.error, 5)
	end
	
	lastRate = newRate
end)

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

local function initialize()
	-- Create screen gui
	screenGui = Instance.new("ScreenGui")
	screenGui.Name = "NotificationUI"
	screenGui.ResetOnSpawn = false
	screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	screenGui.Parent = PlayerGui
	
	-- Create containers
	toastContainer = createToastContainer()
	bannerFrame = createBannerFrame()
	
	print("âœ“ NotificationManager initialized")
end

initialize()

-- Export for other scripts
_G.NotificationManager = {
	ShowToast = showToast,
	ShowBanner = showBanner,
}



--------------------------------------------------
File: PrestigeUI.client.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\client\PrestigeUI.client.luau
--------------------------------------------------
--[[
	PrestigeUI Client Script
	
	Handles the Golden Meatball Altar UI and Shop.
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Wait for shared modules
local PrestigeConfig = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("PrestigeConfig"))

-- Remote Events
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local PrestigeEvent = RemoteEvents:WaitForChild("PrestigeEvent")

-- State
local currentData = {
	totalMeatballs = 0,
	spentMeatballs = 0,
	pendingMeatballs = 0,
	lifetimeEarnings = 0,
	upgrades = {}
}

--------------------------------------------------------------------------------
-- UI CREATION
--------------------------------------------------------------------------------

local function createPrestigeUI()
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "PrestigeUI"
	screenGui.ResetOnSpawn = false
	screenGui.Enabled = false
	screenGui.Parent = playerGui
	
	-- Main Frame
	local mainFrame = Instance.new("Frame")
	mainFrame.Name = "MainFrame"
	mainFrame.Size = UDim2.new(0, 800, 0, 600)
	mainFrame.Position = UDim2.new(0.5, -400, 0.5, -300)
	mainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
	mainFrame.BorderSizePixel = 0
	mainFrame.Parent = screenGui
	
	local uiCorner = Instance.new("UICorner")
	uiCorner.CornerRadius = UDim.new(0, 12)
	uiCorner.Parent = mainFrame
	
	-- Header
	local header = Instance.new("Frame")
	header.Name = "Header"
	header.Size = UDim2.new(1, 0, 0, 80)
	header.BackgroundColor3 = Color3.fromRGB(255, 215, 0) -- Gold
	header.BorderSizePixel = 0
	header.Parent = mainFrame
	
	local headerCorner = Instance.new("UICorner")
	headerCorner.CornerRadius = UDim.new(0, 12)
	headerCorner.Parent = header
	
	-- Fix bottom corners of header
	local headerCover = Instance.new("Frame")
	headerCover.Size = UDim2.new(1, 0, 0, 20)
	headerCover.Position = UDim2.new(0, 0, 1, -20)
	headerCover.BackgroundColor3 = Color3.fromRGB(255, 215, 0)
	headerCover.BorderSizePixel = 0
	headerCover.Parent = header
	
	local title = Instance.new("TextLabel")
	title.Text = "GOLDEN MEATBALL ALTAR"
	title.Font = Enum.Font.FredokaOne
	title.TextSize = 40
	title.TextColor3 = Color3.fromRGB(100, 80, 0)
	title.Size = UDim2.new(1, 0, 1, 0)
	title.BackgroundTransparency = 1
	title.Parent = header
	
	-- Close Button
	local closeBtn = Instance.new("TextButton")
	closeBtn.Text = "X"
	closeBtn.Font = Enum.Font.FredokaOne
	closeBtn.TextSize = 24
	closeBtn.TextColor3 = Color3.fromRGB(100, 80, 0)
	closeBtn.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	closeBtn.Size = UDim2.new(0, 40, 0, 40)
	closeBtn.Position = UDim2.new(1, -50, 0.5, -20)
	closeBtn.Parent = header
	
	local closeCorner = Instance.new("UICorner")
	closeCorner.CornerRadius = UDim.new(0, 8)
	closeCorner.Parent = closeBtn
	
	closeBtn.MouseButton1Click:Connect(function()
		screenGui.Enabled = false
	end)
	
	-- Content Container
	local content = Instance.new("Frame")
	content.Name = "Content"
	content.Size = UDim2.new(1, -40, 1, -140)
	content.Position = UDim2.new(0, 20, 0, 100)
	content.BackgroundTransparency = 1
	content.Parent = mainFrame
	
	-- Left Panel: Stats & Prestige
	local leftPanel = Instance.new("Frame")
	leftPanel.Name = "LeftPanel"
	leftPanel.Size = UDim2.new(0.4, -10, 1, 0)
	leftPanel.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
	leftPanel.Parent = content
	
	local leftCorner = Instance.new("UICorner")
	leftCorner.CornerRadius = UDim.new(0, 8)
	leftCorner.Parent = leftPanel
	
	-- Stats Display
	local statsList = Instance.new("UIListLayout")
	statsList.Padding = UDim.new(0, 10)
	statsList.HorizontalAlignment = Enum.HorizontalAlignment.Center
	statsList.SortOrder = Enum.SortOrder.LayoutOrder
	statsList.Parent = leftPanel
	
	local padding = Instance.new("UIPadding")
	padding.PaddingTop = UDim.new(0, 20)
	padding.PaddingBottom = UDim.new(0, 20)
	padding.PaddingLeft = UDim.new(0, 10)
	padding.PaddingRight = UDim.new(0, 10)
	padding.Parent = leftPanel
	
	-- Current Meatballs
	local currentLabel = Instance.new("TextLabel")
	currentLabel.Name = "CurrentLabel"
	currentLabel.Text = "Your Golden Meatballs"
	currentLabel.Font = Enum.Font.GothamBold
	currentLabel.TextSize = 18
	currentLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
	currentLabel.Size = UDim2.new(1, 0, 0, 30)
	currentLabel.BackgroundTransparency = 1
	currentLabel.LayoutOrder = 1
	currentLabel.Parent = leftPanel
	
	local meatballCount = Instance.new("TextLabel")
	meatballCount.Name = "MeatballCount"
	meatballCount.Text = "0"
	meatballCount.Font = Enum.Font.FredokaOne
	meatballCount.TextSize = 48
	meatballCount.TextColor3 = Color3.fromRGB(255, 215, 0)
	meatballCount.Size = UDim2.new(1, 0, 0, 60)
	meatballCount.BackgroundTransparency = 1
	meatballCount.LayoutOrder = 2
	meatballCount.Parent = leftPanel
	
	-- Bonus Display
	local bonusLabel = Instance.new("TextLabel")
	bonusLabel.Name = "BonusLabel"
	bonusLabel.Text = "+0% Income Bonus"
	bonusLabel.Font = Enum.Font.GothamBold
	bonusLabel.TextSize = 20
	bonusLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
	bonusLabel.Size = UDim2.new(1, 0, 0, 30)
	bonusLabel.BackgroundTransparency = 1
	bonusLabel.LayoutOrder = 3
	bonusLabel.Parent = leftPanel
	
	-- Divider
	local divider = Instance.new("Frame")
	divider.Size = UDim2.new(1, 0, 0, 2)
	divider.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
	divider.BorderSizePixel = 0
	divider.LayoutOrder = 4
	divider.Parent = leftPanel
	
	-- Pending Section
	local pendingTitle = Instance.new("TextLabel")
	pendingTitle.Text = "Prestige Now To Gain:"
	pendingTitle.Font = Enum.Font.GothamBold
	pendingTitle.TextSize = 16
	pendingTitle.TextColor3 = Color3.fromRGB(200, 200, 200)
	pendingTitle.Size = UDim2.new(1, 0, 0, 30)
	pendingTitle.BackgroundTransparency = 1
	pendingTitle.LayoutOrder = 5
	pendingTitle.Parent = leftPanel
	
	local pendingCount = Instance.new("TextLabel")
	pendingCount.Name = "PendingCount"
	pendingCount.Text = "+0"
	pendingCount.Font = Enum.Font.FredokaOne
	pendingCount.TextSize = 36
	pendingCount.TextColor3 = Color3.fromRGB(255, 255, 255)
	pendingCount.Size = UDim2.new(1, 0, 0, 50)
	pendingCount.BackgroundTransparency = 1
	pendingCount.LayoutOrder = 6
	pendingCount.Parent = leftPanel
	
	-- Prestige Button
	local prestigeBtn = Instance.new("TextButton")
	prestigeBtn.Name = "PrestigeButton"
	prestigeBtn.Text = "PRESTIGE RESET"
	prestigeBtn.Font = Enum.Font.FredokaOne
	prestigeBtn.TextSize = 24
	prestigeBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
	prestigeBtn.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
	prestigeBtn.Size = UDim2.new(1, 0, 0, 60)
	prestigeBtn.LayoutOrder = 7
	prestigeBtn.Parent = leftPanel
	
	local btnCorner = Instance.new("UICorner")
	btnCorner.CornerRadius = UDim.new(0, 8)
	btnCorner.Parent = prestigeBtn
	
	local warningLabel = Instance.new("TextLabel")
	warningLabel.Text = "Resets Money, Units & Upgrades!"
	warningLabel.Font = Enum.Font.Gotham
	warningLabel.TextSize = 12
	warningLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
	warningLabel.Size = UDim2.new(1, 0, 0, 20)
	warningLabel.BackgroundTransparency = 1
	warningLabel.LayoutOrder = 8
	warningLabel.Parent = leftPanel
	
	prestigeBtn.MouseButton1Click:Connect(function()
		if currentData.pendingMeatballs >= PrestigeConfig.MINIMUM_PRESTIGE_GAIN then
			PrestigeEvent:FireServer("Prestige")
			screenGui.Enabled = false
		end
	end)
	
	-- Right Panel: Shop
	local rightPanel = Instance.new("ScrollingFrame")
	rightPanel.Name = "ShopPanel"
	rightPanel.Size = UDim2.new(0.6, -10, 1, 0)
	rightPanel.Position = UDim2.new(0.4, 10, 0, 0)
	rightPanel.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
	rightPanel.ScrollBarThickness = 6
	rightPanel.Parent = content
	
	local rightCorner = Instance.new("UICorner")
	rightCorner.CornerRadius = UDim.new(0, 8)
	rightCorner.Parent = rightPanel
	
	local shopLayout = Instance.new("UIListLayout")
	shopLayout.Padding = UDim.new(0, 10)
	shopLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	shopLayout.SortOrder = Enum.SortOrder.LayoutOrder
	shopLayout.Parent = rightPanel
	
	local shopPadding = Instance.new("UIPadding")
	shopPadding.PaddingTop = UDim.new(0, 10)
	shopPadding.PaddingBottom = UDim.new(0, 10)
	shopPadding.PaddingLeft = UDim.new(0, 10)
	shopPadding.PaddingRight = UDim.new(0, 10)
	shopPadding.Parent = rightPanel
	
	return screenGui
end

local function createShopItem(parent, item, isOwned, isLocked)
	local frame = Instance.new("Frame")
	frame.Name = item.Id
	frame.Size = UDim2.new(1, 0, 0, 80)
	frame.BackgroundColor3 = Color3.fromRGB(50, 50, 60)
	frame.Parent = parent
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 8)
	corner.Parent = frame
	
	-- Name
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Text = item.Name
	nameLabel.Font = Enum.Font.GothamBold
	nameLabel.TextSize = 16
	nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	nameLabel.Size = UDim2.new(0.6, 0, 0, 25)
	nameLabel.Position = UDim2.new(0, 10, 0, 5)
	nameLabel.TextXAlignment = Enum.TextXAlignment.Left
	nameLabel.BackgroundTransparency = 1
	nameLabel.Parent = frame
	
	-- Description
	local descLabel = Instance.new("TextLabel")
	descLabel.Text = item.Description
	descLabel.Font = Enum.Font.Gotham
	descLabel.TextSize = 12
	descLabel.TextColor3 = Color3.fromRGB(180, 180, 180)
	descLabel.Size = UDim2.new(0.6, 0, 0, 40)
	descLabel.Position = UDim2.new(0, 10, 0, 30)
	descLabel.TextXAlignment = Enum.TextXAlignment.Left
	descLabel.TextWrapped = true
	descLabel.BackgroundTransparency = 1
	descLabel.Parent = frame
	
	-- Buy Button
	local buyBtn = Instance.new("TextButton")
	buyBtn.Size = UDim2.new(0.35, 0, 0.8, 0)
	buyBtn.Position = UDim2.new(0.63, 0, 0.1, 0)
	buyBtn.Font = Enum.Font.GothamBold
	buyBtn.TextSize = 14
	buyBtn.Parent = frame
	
	local btnCorner = Instance.new("UICorner")
	btnCorner.CornerRadius = UDim.new(0, 6)
	btnCorner.Parent = buyBtn
	
	if isOwned then
		buyBtn.Text = "OWNED"
		buyBtn.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
		buyBtn.TextColor3 = Color3.fromRGB(200, 200, 200)
		buyBtn.AutoButtonColor = false
	elseif isLocked then
		buyBtn.Text = "LOCKED\nNeed " .. item.UnlockAt .. " Meatballs"
		buyBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
		buyBtn.TextColor3 = Color3.fromRGB(150, 150, 150)
		buyBtn.AutoButtonColor = false
	else
		buyBtn.Text = "BUY\n" .. item.Price .. " Meatballs"
		buyBtn.BackgroundColor3 = Color3.fromRGB(255, 215, 0)
		buyBtn.TextColor3 = Color3.fromRGB(50, 40, 0)
		
		buyBtn.MouseButton1Click:Connect(function()
			PrestigeEvent:FireServer("PurchaseUpgrade", item.Id)
		end)
	end
end

local function updateUI(gui)
	local leftPanel = gui.MainFrame.Content.LeftPanel
	local shopPanel = gui.MainFrame.Content.ShopPanel
	
	-- Update Stats
	leftPanel.MeatballCount.Text = tostring(currentData.totalMeatballs)
	
	-- Calculate bonus (unspent * 2%)
	local unspent = currentData.totalMeatballs - currentData.spentMeatballs
	local bonus = math.floor(unspent * PrestigeConfig.MEATBALL_BONUS_RATE * 100)
	leftPanel.BonusLabel.Text = "+" .. bonus .. "% Income Bonus"
	
	-- Update Pending
	leftPanel.PendingCount.Text = "+" .. currentData.pendingMeatballs
	
	-- Update Button
	local prestigeBtn = leftPanel.PrestigeButton
	if currentData.pendingMeatballs >= PrestigeConfig.MINIMUM_PRESTIGE_GAIN then
		prestigeBtn.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
		prestigeBtn.Text = "PRESTIGE RESET"
		prestigeBtn.AutoButtonColor = true
	else
		prestigeBtn.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
		prestigeBtn.Text = "Need " .. PrestigeConfig.MINIMUM_PRESTIGE_GAIN .. " to Prestige"
		prestigeBtn.AutoButtonColor = false
	end
	
	-- Update Shop
	-- Clear old items
	for _, child in shopPanel:GetChildren() do
		if child:IsA("Frame") then child:Destroy() end
	end
	
	-- Add items
	for _, item in ipairs(PrestigeConfig.SHOP_ITEMS) do
		local isOwned = false
		for _, ownedId in ipairs(currentData.upgrades) do
			if ownedId == item.Id then
				isOwned = true
				break
			end
		end
		
		local isLocked = currentData.totalMeatballs < item.UnlockAt
		
		createShopItem(shopPanel, item, isOwned, isLocked)
	end
end

--------------------------------------------------------------------------------
-- MAIN LOGIC
--------------------------------------------------------------------------------

local ui = createPrestigeUI()

PrestigeEvent.OnClientEvent:Connect(function(action, data)
	if action == "OpenMenu" then
		currentData = data
		updateUI(ui)
		ui.Enabled = true
	elseif action == "UpdateData" then
		currentData = data
		if ui.Enabled then
			updateUI(ui)
		end
	elseif action == "PrestigeCompleted" then
		-- Play cool effect?
		print("Prestige completed! Gained " .. data.gained .. " meatballs.")
	end
end)

-- HUD Integration (Optional: Add meatball counter to main HUD)
-- For now, we rely on the Altar UI.



--------------------------------------------------
File: ProjectileVisuals.client.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\client\ProjectileVisuals.client.luau
--------------------------------------------------
--[[
	ProjectileVisuals Client Script
	
	Handles visual projectile effects for brainrot units.
	Units "throw" projectiles at their island's Storage container every income cycle.
	
	This is purely visual - the server handles actual money logic.
	Inspired by The Gnorp Apologue.
	
	Features:
	- CollectionService detection for "ActiveBrainrot" tagged units
	- Per-unit coroutine loops based on CycleTime
	- Bezier curve projectile arcs
	- Storage impact effects (squash animation + particles)
	- Multi-island support
]]

-- Services
local Players = game:GetService("Players")
local CollectionService = game:GetService("CollectionService")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Get player
local LocalPlayer = Players.LocalPlayer

-- Configuration
local ShopConfig = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("ShopConfig"))

-- Tags
local BRAINROT_TAG = "ActiveBrainrot"

-- ============================================================================
-- PROJECTILE CONFIGURATION
-- Change these values to customize projectile behavior
-- ============================================================================
local PROJECTILE_CONFIG = {
	-- Projectile flight settings
	FLIGHT_TIME = 0.5,              -- Seconds to reach Storage (LOWER = FASTER)
	ARC_HEIGHT = 8,                 -- Studs above midpoint for arc peak
	STEPS = 30,                     -- Number of bezier curve samples (smoothness)
	
	-- Projectile appearance
	SIZE = Vector3.new(0.8, 0.8, 0.8),
	MATERIAL = Enum.Material.Neon,
	SHAPE = Enum.PartType.Ball,
	DEFAULT_COLOR = Color3.fromRGB(255, 255, 255), -- White fallback
	TRANSPARENCY = 0,
	
	-- Impact effects
	SQUASH_SCALE = 1.15,            -- Storage scales up by 15%
	SQUASH_DURATION = 0.1,          -- Seconds for squash animation
	PARTICLE_COUNT = 8,             -- Number of particles on impact
	PARTICLE_LIFETIME = 0.5,        -- Seconds particles last
	PARTICLE_SPEED = 15,            -- Particle velocity
	
	-- Performance
	MAX_PROJECTILES = 100,          -- Max concurrent projectiles (prevents lag)
}

-- Track active projectiles for performance limiting
local activeProjectileCount = 0

-- Track unit loops (to clean up when units are removed)
local unitLoops: {[Instance]: thread} = {}

-- Cache true original sizes for storage parts to prevent size drift
local storageOriginalSizes: {[BasePart]: Vector3} = {}

-- ============================================================================
-- MATH HELPER: BEZIER CURVE
-- ============================================================================

--[[
	Samples a point on a quadratic Bezier curve.
	Creates a natural arc from start to end with a peak in the middle.
	
	@param startPos Vector3 - Starting position (unit)
	@param endPos Vector3 - Ending position (storage)
	@param height number - Peak height of the arc above midpoint
	@param t number - Parameter from 0 to 1 (0 = start, 1 = end)
	@return Vector3 - The interpolated position on the curve
]]
local function sampleBezier(startPos: Vector3, endPos: Vector3, height: number, t: number): Vector3
	-- Control point is at the midpoint, elevated by height
	local midPoint = (startPos + endPos) / 2 + Vector3.new(0, height, 0)
	
	-- Quadratic Bezier: B(t) = (1-t)Â²P0 + 2(1-t)tP1 + tÂ²P2
	-- Simplified using nested lerps for readability:
	local p0 = startPos:Lerp(midPoint, t)
	local p1 = midPoint:Lerp(endPos, t)
	return p0:Lerp(p1, t)
end

--[[
	Calculates dynamic arc height based on distance and elevation.
	For brainrots on higher-tier islands, this creates a high-arcing trajectory
	that rises above intermediate islands before landing in the storage.
	
	@param startPos Vector3 - Starting position (brainrot unit)
	@param endPos Vector3 - Ending position (storage tank)
	@return number - The calculated arc height above the midpoint
]]
local function calculateDynamicArcHeight(startPos: Vector3, endPos: Vector3): number
	-- Calculate horizontal distance (ignoring Y)
	local horizontalDistance = (Vector3.new(endPos.X, 0, endPos.Z) - Vector3.new(startPos.X, 0, startPos.Z)).Magnitude
	
	-- Calculate elevation difference (positive if brainrot is higher than storage)
	local elevationDiff = startPos.Y - endPos.Y
	
	-- Base arc height scales with horizontal distance
	-- A projectile traveling 100 studs should arc ~25 studs high
	local distanceBasedArc = horizontalDistance * 0.25
	
	-- If brainrot is higher than storage, add extra height to create a nice lob
	-- The projectile should go UP first, then come DOWN gracefully to the storage
	local elevationBoost = math.max(0, elevationDiff * 0.5)
	
	-- Use the configured minimum as the floor
	return math.max(PROJECTILE_CONFIG.ARC_HEIGHT, distanceBasedArc + elevationBoost)
end

-- ============================================================================
-- STORAGE FINDER
-- ============================================================================

--[[
	Finds the Storage part for a given brainrot unit.
	Supports multi-island by looking at the unit's parent hierarchy.
	
	@param brainrot Instance - The brainrot unit
	@return BasePart? - The Storage part, or nil if not found
]]
local function findStorageForUnit(brainrot: Instance): BasePart?
	-- Get the unit's TierIndex to find the correct island's storage
	local _tierIndex = brainrot:GetAttribute("TierIndex")
	
	-- Walk up to find the plot/island model
	local parent = brainrot.Parent
	while parent and parent.Name ~= "Brainrots" do
		parent = parent.Parent
	end
	
	-- Go up one more level to get the plot/island
	if parent then
		local plot = parent.Parent
		if plot then
			local storage = plot:FindFirstChild("Storage")
			if storage and storage:IsA("BasePart") then
				return storage
			end
		end
	end
	
	-- Fallback: search all plots for player's storage
	local ownerId = brainrot:GetAttribute("OwnerId")
	if not ownerId then return nil end
	
	local plotsFolder = workspace:FindFirstChild("Plots")
	if plotsFolder then
		for _, plot in plotsFolder:GetChildren() do
			local plotOwnerId = plot:GetAttribute("OwnerId")
			if plotOwnerId == ownerId then
				local storage = plot:FindFirstChild("Storage")
				if storage and storage:IsA("BasePart") then
					return storage
				end
			end
		end
	end
	
	return nil
end

-- ============================================================================
-- UNIT POSITION HELPER
-- ============================================================================

--[[
	Gets the position of a brainrot unit.
	Handles both Model and Part-based units.
	
	@param brainrot Instance - The brainrot unit
	@return Vector3? - The position, or nil if not found
]]
local function getUnitPosition(brainrot: Instance): Vector3?
	if brainrot:IsA("Model") then
		if brainrot.PrimaryPart then
			return brainrot.PrimaryPart.Position
		else
			-- Try to get bounding box center
			local success, cf = pcall(function()
				return brainrot:GetPivot()
			end)
			if success then
				return cf.Position
			end
		end
	elseif brainrot:IsA("BasePart") then
		return brainrot.Position
	end
	return nil
end

-- ============================================================================
-- IMPACT EFFECTS
-- ============================================================================

--[[
	Plays a squash animation on the storage part.
	Scales up briefly then returns to normal.
	Uses cached original size to prevent compounding growth.
	
	@param storage BasePart - The storage part to animate
]]
local function playSquashAnimation(storage: BasePart)
	-- Cache the true original size on first impact (prevents size drift)
	if not storageOriginalSizes[storage] then
		storageOriginalSizes[storage] = storage.Size
	end
	
	local originalSize = storageOriginalSizes[storage]
	local squashedSize = originalSize * PROJECTILE_CONFIG.SQUASH_SCALE
	
	-- Scale up
	local squashTween = TweenService:Create(
		storage,
		TweenInfo.new(PROJECTILE_CONFIG.SQUASH_DURATION, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{Size = squashedSize}
	)
	
	-- Scale back down to the CACHED original size (not current size)
	local returnTween = TweenService:Create(
		storage,
		TweenInfo.new(PROJECTILE_CONFIG.SQUASH_DURATION, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
		{Size = originalSize}
	)
	
	squashTween:Play()
	squashTween.Completed:Wait()
	returnTween:Play()
end

--[[
	Spawns impact particles at the collision point.
	
	@param position Vector3 - Where to spawn particles
	@param color Color3 - Color of the particles
]]
local function spawnImpactParticles(position: Vector3, color: Color3)
	-- Create a temporary part for the particle emitter
	local particlePart = Instance.new("Part")
	particlePart.Size = Vector3.new(0.1, 0.1, 0.1)
	particlePart.Position = position
	particlePart.Anchored = true
	particlePart.CanCollide = false
	particlePart.Transparency = 1
	particlePart.Parent = workspace
	
	-- Create particle emitter
	local emitter = Instance.new("ParticleEmitter")
	emitter.Color = ColorSequence.new(color)
	emitter.Size = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.5),
		NumberSequenceKeypoint.new(1, 0)
	})
	emitter.Lifetime = NumberRange.new(PROJECTILE_CONFIG.PARTICLE_LIFETIME * 0.5, PROJECTILE_CONFIG.PARTICLE_LIFETIME)
	emitter.Speed = NumberRange.new(PROJECTILE_CONFIG.PARTICLE_SPEED * 0.5, PROJECTILE_CONFIG.PARTICLE_SPEED)
	emitter.SpreadAngle = Vector2.new(360, 360)
	emitter.Acceleration = Vector3.new(0, -30, 0) -- Gravity
	emitter.Rate = 0 -- We'll use Emit() instead
	emitter.Parent = particlePart
	
	-- Burst particles
	emitter:Emit(PROJECTILE_CONFIG.PARTICLE_COUNT)
	
	-- Clean up after particles fade
	task.delay(PROJECTILE_CONFIG.PARTICLE_LIFETIME + 0.1, function()
		particlePart:Destroy()
	end)
end

-- ============================================================================
-- PROJECTILE CREATION AND ANIMATION
-- ============================================================================

--[[
	Creates and animates a projectile from a unit to its storage.
	
	@param startPos Vector3 - Starting position (unit)
	@param endPos Vector3 - Ending position (storage)
	@param color Color3 - Projectile color
	@param storage BasePart - The storage part (for impact effects)
]]
local function fireProjectile(startPos: Vector3, endPos: Vector3, color: Color3, storage: BasePart)
	-- Performance check
	if activeProjectileCount >= PROJECTILE_CONFIG.MAX_PROJECTILES then
		return
	end
	
	-- Calculate dynamic arc height based on distance and elevation
	local arcHeight = calculateDynamicArcHeight(startPos, endPos)
	
	activeProjectileCount = activeProjectileCount + 1
	
	-- Create the projectile part
	local projectile = Instance.new("Part")
	projectile.Name = "IncomeProjectile"
	projectile.Size = PROJECTILE_CONFIG.SIZE
	projectile.Shape = PROJECTILE_CONFIG.SHAPE
	projectile.Material = PROJECTILE_CONFIG.MATERIAL
	projectile.Color = color
	projectile.Transparency = PROJECTILE_CONFIG.TRANSPARENCY
	projectile.Anchored = true
	projectile.CanCollide = false
	projectile.CastShadow = false
	projectile.Position = startPos
	projectile.Parent = workspace
	
	-- Add a subtle glow effect
	local pointLight = Instance.new("PointLight")
	pointLight.Color = color
	pointLight.Range = 3
	pointLight.Brightness = 0.5
	pointLight.Parent = projectile
	
	-- Animate along bezier curve
	local stepTime = PROJECTILE_CONFIG.FLIGHT_TIME / PROJECTILE_CONFIG.STEPS
	
	task.spawn(function()
		for i = 1, PROJECTILE_CONFIG.STEPS do
			local t = i / PROJECTILE_CONFIG.STEPS
			local newPos = sampleBezier(startPos, endPos, arcHeight, t)
			
			-- Use TweenService for smooth interpolation between steps
			local tween = TweenService:Create(
				projectile,
				TweenInfo.new(stepTime, Enum.EasingStyle.Linear),
				{Position = newPos}
			)
			tween:Play()
			tween.Completed:Wait()
		end
		
		-- Projectile reached storage - play impact effects
		task.spawn(function()
			playSquashAnimation(storage)
		end)
		spawnImpactParticles(endPos, color)
		
		-- Cleanup
		projectile:Destroy()
		activeProjectileCount = activeProjectileCount - 1
	end)
end

-- ============================================================================
-- UNIT LOOP MANAGEMENT
-- ============================================================================

--[[
	Gets the unit type name from a brainrot instance.
	The unit type is stored in the UnitType attribute or derived from name.
	
	@param brainrot Instance - The brainrot unit
	@return string - The unit type name
]]
local function getUnitTypeName(brainrot: Instance): string
	-- Check for UnitType attribute first
	local unitType = brainrot:GetAttribute("UnitType")
	if unitType then
		return unitType
	end
	
	-- Parse from name (format: "UnitName_UserId_Timestamp")
	local name = brainrot.Name
	local underscorePos = name:find("_[%d]+_[%d]+$")
	if underscorePos then
		return name:sub(1, underscorePos - 1)
	end
	
	return name
end

--[[
	Starts the projectile loop for a brainrot unit.
	Fires projectiles at the unit's CycleTime interval.
	
	@param brainrot Instance - The brainrot unit
]]
local function startUnitLoop(brainrot: Instance)
	-- Only process units owned by local player
	local ownerId = brainrot:GetAttribute("OwnerId")
	if not ownerId or ownerId ~= LocalPlayer.UserId then
		return
	end
	
	-- Don't start if already running
	if unitLoops[brainrot] then
		return
	end
	
	-- Get unit configuration
	local unitTypeName = getUnitTypeName(brainrot)
	local unitConfig = ShopConfig.Units[unitTypeName]
	
	-- Default values if config not found
	local cycleTime = brainrot:GetAttribute("IncomeInterval") or (unitConfig and unitConfig.CycleTime) or 3
	local projectileColor = (unitConfig and unitConfig.ProjectileColor) or PROJECTILE_CONFIG.DEFAULT_COLOR
	
	-- Start the loop
	local loopThread = task.spawn(function()
		-- Small initial delay to stagger projectiles from units spawned together
		task.wait(math.random() * 0.5)
		
		while brainrot and brainrot.Parent do
			-- Wait for cycle time
			task.wait(cycleTime)
			
			-- Get current positions
			local startPos = getUnitPosition(brainrot)
			local storage = findStorageForUnit(brainrot)
			
			if startPos and storage then
				local endPos = storage.Position
				fireProjectile(startPos, endPos, projectileColor, storage)
			end
		end
	end)
	
	unitLoops[brainrot] = loopThread
end

--[[
	Stops the projectile loop for a brainrot unit.
	
	@param brainrot Instance - The brainrot unit
]]
local function stopUnitLoop(brainrot: Instance)
	local loopThread = unitLoops[brainrot]
	if loopThread then
		task.cancel(loopThread)
		unitLoops[brainrot] = nil
	end
end

-- ============================================================================
-- INITIALIZATION
-- ============================================================================

local function initialize()
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	print("   ProjectileVisuals - Initializing")
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	
	-- Handle existing brainrots
	for _, brainrot in CollectionService:GetTagged(BRAINROT_TAG) do
		task.spawn(startUnitLoop, brainrot)
	end
	
	-- Handle new brainrots added
	CollectionService:GetInstanceAddedSignal(BRAINROT_TAG):Connect(function(brainrot)
		task.spawn(startUnitLoop, brainrot)
	end)
	
	-- Handle brainrots removed
	CollectionService:GetInstanceRemovedSignal(BRAINROT_TAG):Connect(function(brainrot)
		stopUnitLoop(brainrot)
	end)
	
	print("âœ“ ProjectileVisuals initialized")
	print(string.format("  - Flight Time: %.2fs (change FLIGHT_TIME to adjust speed)", PROJECTILE_CONFIG.FLIGHT_TIME))
	print(string.format("  - Arc Height: %d studs", PROJECTILE_CONFIG.ARC_HEIGHT))
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
end

-- Start the system
initialize()



--------------------------------------------------
File: ShopUI.client.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\client\ShopUI.client.luau
--------------------------------------------------
--[[
	ShopUI LocalScript
	
	Creates a Cookie Clicker style shop interface on the right side of the screen.
	Features progressive unlocking system.
	
	Features:
	- Scrolling shop panel
	- Live price updates
	- Ownership count display
	- Locked unit preview (blacked out)
	- Purchase sound effects
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local SoundService = game:GetService("SoundService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

-- Player reference
local Player = Players.LocalPlayer
local PlayerGui = Player:WaitForChild("PlayerGui")

-- Wait for shared modules and remotes
local ShopConfig = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("ShopConfig"))
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local BuyUnitRemote = RemoteEvents:WaitForChild("BuyUnit")
local GetOwnershipRemote = RemoteEvents:WaitForChild("GetOwnership")
local OwnershipChangedEvent = RemoteEvents:WaitForChild("OwnershipChanged")
local UnlockProgressChangedEvent = RemoteEvents:WaitForChild("UnlockProgressChanged")

--------------------------------------------------------------------------------
-- UI CONFIGURATION
--------------------------------------------------------------------------------

local UI_CONFIG = {
	-- Shop Panel
	SHOP_WIDTH = 280,
	SHOP_PADDING = 10,
	
	-- Button styling
	BUTTON_HEIGHT = 110, -- Increased to fit milestone progress
	BUTTON_SPACING = 8,
	CORNER_RADIUS = 12,
	
	-- Colors
	BACKGROUND_COLOR = Color3.fromRGB(25, 25, 35),
	PANEL_COLOR = Color3.fromRGB(35, 35, 50),
	BUTTON_COLOR = Color3.fromRGB(50, 50, 70),
	BUTTON_HOVER_COLOR = Color3.fromRGB(65, 65, 90),
	BUTTON_DISABLED_COLOR = Color3.fromRGB(40, 40, 50),
	LOCKED_COLOR = Color3.fromRGB(20, 20, 25),
	LOCKED_OVERLAY_COLOR = Color3.fromRGB(0, 0, 0),
	ACCENT_COLOR = Color3.fromRGB(100, 220, 100),
	TEXT_COLOR = Color3.fromRGB(255, 255, 255),
	SECONDARY_TEXT_COLOR = Color3.fromRGB(180, 180, 180),
	LOCKED_TEXT_COLOR = Color3.fromRGB(100, 100, 100),
	PRICE_COLOR = Color3.fromRGB(255, 215, 0),
	
	-- Animation
	TWEEN_TIME = 0.15,
}

--------------------------------------------------------------------------------
-- SOUNDS
--------------------------------------------------------------------------------

-- Create sounds
local function createSound(id: string, volume: number): Sound
	local sound = Instance.new("Sound")
	sound.SoundId = id
	sound.Volume = volume
	sound.Parent = SoundService
	return sound
end

local ChachingSound = createSound("rbxassetid://138081500", 0.5) -- Cash register sound
local ErrorSound = createSound("rbxassetid://138090596", 0.3) -- Error/deny sound

--------------------------------------------------------------------------------
-- LOCAL STATE
--------------------------------------------------------------------------------

-- Track ownership locally for UI updates
local OwnedCounts: {[string]: number} = {}
local ShopButtons: {[string]: Frame} = {}
local UnlockProgress: number = ShopConfig.INITIAL_UNLOCKED
local ShopGui: ScreenGui? = nil
local ScrollFrame: ScrollingFrame? = nil
local IsOnMainIsland: boolean = false

--------------------------------------------------------------------------------
-- UI CREATION HELPERS
--------------------------------------------------------------------------------

local function addCorner(parent: GuiObject, radius: number)
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, radius)
	corner.Parent = parent
	return corner
end

local function addStroke(parent: GuiObject, color: Color3, thickness: number)
	local stroke = Instance.new("UIStroke")
	stroke.Color = color
	stroke.Thickness = thickness
	stroke.Parent = parent
	return stroke
end

local function formatMoney(amount: number): string
	local suffixes = {"K", "M", "B", "T", "Qa", "Qi", "Sx", "Sp", "Oc", "No", "Dc"}
	
	if amount < 1000 then
		return "$" .. tostring(math.floor(amount))
	end
	
	-- Calculate the magnitude (power of 1000)
	local magnitude = math.floor(math.log(amount, 1000))
	
	-- Cap at the largest suffix
	if magnitude > #suffixes then
		magnitude = #suffixes
	end
	
	local value = amount / (1000 ^ magnitude)
	
	-- Format with 1 decimal place if < 100, otherwise no decimals
	if value < 100 and value % 1 ~= 0 then
		return string.format("$%.1f%s", value, suffixes[magnitude])
	else
		return string.format("$%.0f%s", value, suffixes[magnitude])
	end
end

--------------------------------------------------------------------------------
-- SHOP UI CREATION
--------------------------------------------------------------------------------

local function createShopGui(): ScreenGui
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "ShopUI"
	screenGui.ResetOnSpawn = false
	screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	
	-- Main shop panel (right side) - starts HIDDEN (off-screen)
	local shopPanel = Instance.new("Frame")
	shopPanel.Name = "ShopPanel"
	shopPanel.Size = UDim2.new(0, UI_CONFIG.SHOP_WIDTH, 1, -20)
	shopPanel.Position = UDim2.new(1, 10, 0, 10) -- Start off-screen
	shopPanel.BackgroundColor3 = UI_CONFIG.PANEL_COLOR
	shopPanel.BorderSizePixel = 0
	shopPanel.Parent = screenGui
	addCorner(shopPanel, UI_CONFIG.CORNER_RADIUS)
	addStroke(shopPanel, Color3.fromRGB(60, 60, 80), 2)
	
	-- Shop title
	local titleBar = Instance.new("Frame")
	titleBar.Name = "TitleBar"
	titleBar.Size = UDim2.new(1, 0, 0, 50)
	titleBar.BackgroundColor3 = UI_CONFIG.BACKGROUND_COLOR
	titleBar.BorderSizePixel = 0
	titleBar.Parent = shopPanel
	
	local titleCorner = Instance.new("UICorner")
	titleCorner.CornerRadius = UDim.new(0, UI_CONFIG.CORNER_RADIUS)
	titleCorner.Parent = titleBar
	
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "Title"
	titleLabel.Size = UDim2.new(1, -40, 1, 0)
	titleLabel.Position = UDim2.new(0, 0, 0, 0)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Text = "ðŸ§  BRAINROT SHOP"
	titleLabel.TextColor3 = UI_CONFIG.TEXT_COLOR
	titleLabel.TextSize = 20
	titleLabel.Font = Enum.Font.GothamBold
	titleLabel.Parent = titleBar
	
	-- Close button (X)
	local closeButton = Instance.new("TextButton")
	closeButton.Name = "CloseButton"
	closeButton.Size = UDim2.new(0, 36, 0, 36)
	closeButton.Position = UDim2.new(1, -42, 0.5, -18)
	closeButton.BackgroundColor3 = Color3.fromRGB(200, 60, 60)
	closeButton.Text = "âœ•"
	closeButton.TextColor3 = UI_CONFIG.TEXT_COLOR
	closeButton.TextSize = 18
	closeButton.Font = Enum.Font.GothamBold
	closeButton.Parent = titleBar
	addCorner(closeButton, 8)
	
	-- Warning banner for off-island (initially hidden)
	local warningBanner = Instance.new("Frame")
	warningBanner.Name = "WarningBanner"
	warningBanner.Size = UDim2.new(1, 0, 0, 24)
	warningBanner.Position = UDim2.new(0, 0, 0, 50)
	warningBanner.BackgroundColor3 = Color3.fromRGB(180, 80, 30)
	warningBanner.BorderSizePixel = 0
	warningBanner.Visible = false
	warningBanner.Parent = shopPanel
	
	local warningLabel = Instance.new("TextLabel")
	warningLabel.Name = "WarningText"
	warningLabel.Size = UDim2.new(1, 0, 1, 0)
	warningLabel.BackgroundTransparency = 1
	warningLabel.Text = "âš ï¸ Visit Main Island to purchase"
	warningLabel.TextColor3 = Color3.fromRGB(255, 255, 200)
	warningLabel.TextSize = 12
	warningLabel.Font = Enum.Font.GothamBold
	warningLabel.Parent = warningBanner
	
	-- Scrolling frame for items
	local scrollFrame = Instance.new("ScrollingFrame")
	scrollFrame.Name = "ItemList"
	scrollFrame.Size = UDim2.new(1, -UI_CONFIG.SHOP_PADDING * 2, 1, -60)
	scrollFrame.Position = UDim2.new(0, UI_CONFIG.SHOP_PADDING, 0, 55)
	scrollFrame.BackgroundTransparency = 1
	scrollFrame.BorderSizePixel = 0
	scrollFrame.ScrollBarThickness = 6
	scrollFrame.ScrollBarImageColor3 = UI_CONFIG.ACCENT_COLOR
	scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0) -- Will be set dynamically
	scrollFrame.Parent = shopPanel
	
	-- Layout for items
	local listLayout = Instance.new("UIListLayout")
	listLayout.Name = "Layout"
	listLayout.SortOrder = Enum.SortOrder.LayoutOrder
	listLayout.Padding = UDim.new(0, UI_CONFIG.BUTTON_SPACING)
	listLayout.Parent = scrollFrame
	
	-- Auto-resize canvas
	listLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
		scrollFrame.CanvasSize = UDim2.new(0, 0, 0, listLayout.AbsoluteContentSize.Y + 10)
	end)
	
	return screenGui
end

local function createShopButton(unitName: string, config: any, layoutOrder: number, isLocked: boolean): Frame
	local button = Instance.new("Frame")
	button.Name = unitName
	button.Size = UDim2.new(1, 0, 0, UI_CONFIG.BUTTON_HEIGHT)
	button.BackgroundColor3 = isLocked and UI_CONFIG.LOCKED_COLOR or UI_CONFIG.BUTTON_COLOR
	button.BorderSizePixel = 0
	button.LayoutOrder = layoutOrder
	addCorner(button, 8)
	
	-- Clickable button overlay (only if not locked)
	local clickButton = Instance.new("TextButton")
	clickButton.Name = "ClickArea"
	clickButton.Size = UDim2.new(1, 0, 1, 0)
	clickButton.BackgroundTransparency = 1
	clickButton.Text = ""
	clickButton.Active = not isLocked
	clickButton.Parent = button
	
	-- Left side: Icon/emoji placeholder
	local iconLabel = Instance.new("TextLabel")
	iconLabel.Name = "Icon"
	iconLabel.Size = UDim2.new(0, 50, 0, 50)
	iconLabel.Position = UDim2.new(0, 10, 0.5, -25)
	iconLabel.BackgroundColor3 = isLocked and UI_CONFIG.LOCKED_COLOR or UI_CONFIG.BACKGROUND_COLOR
	iconLabel.Text = isLocked and "ðŸ”’" or "ðŸ§ "
	iconLabel.TextSize = 28
	iconLabel.Font = Enum.Font.GothamBold
	iconLabel.Parent = button
	
	-- Unit name
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Name = "UnitName"
	nameLabel.Size = UDim2.new(1, -130, 0, 24)
	nameLabel.Position = UDim2.new(0, 70, 0, 8)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = isLocked and "???" or unitName
	nameLabel.TextColor3 = isLocked and UI_CONFIG.LOCKED_TEXT_COLOR or UI_CONFIG.TEXT_COLOR
	nameLabel.TextSize = 16
	nameLabel.Font = Enum.Font.GothamBold
	nameLabel.TextXAlignment = Enum.TextXAlignment.Left
	nameLabel.TextTruncate = Enum.TextTruncate.AtEnd
	nameLabel.Parent = button
	
	-- Owned count badge (only for unlocked)
	local ownedBadge = Instance.new("TextLabel")
	ownedBadge.Name = "OwnedBadge"
	ownedBadge.Size = UDim2.new(0, 40, 0, 22)
	ownedBadge.Position = UDim2.new(1, -50, 0, 8)
	ownedBadge.BackgroundColor3 = isLocked and UI_CONFIG.LOCKED_COLOR or UI_CONFIG.ACCENT_COLOR
	ownedBadge.Text = isLocked and "ðŸ”’" or "0"
	ownedBadge.TextColor3 = isLocked and UI_CONFIG.LOCKED_TEXT_COLOR or Color3.fromRGB(0, 0, 0)
	ownedBadge.TextSize = 14
	ownedBadge.Font = Enum.Font.GothamBold
	ownedBadge.Parent = button
	addCorner(ownedBadge, 6)
	
	-- Income info or locked message
	local incomeLabel = Instance.new("TextLabel")
	incomeLabel.Name = "Income"
	incomeLabel.Size = UDim2.new(1, -80, 0, 18)
	incomeLabel.Position = UDim2.new(0, 70, 0, 32)
	incomeLabel.BackgroundTransparency = 1
	incomeLabel.Text = isLocked and "Purchase units to unlock!" or string.format("+$%d every %ds", config.BaseIncome, config.CycleTime)
	incomeLabel.TextColor3 = isLocked and UI_CONFIG.LOCKED_TEXT_COLOR or UI_CONFIG.SECONDARY_TEXT_COLOR
	incomeLabel.TextSize = 12
	incomeLabel.Font = Enum.Font.Gotham
	incomeLabel.TextXAlignment = Enum.TextXAlignment.Left
	incomeLabel.Parent = button
	
	-- Milestone progress label (only for unlocked)
	local milestoneLabel = Instance.new("TextLabel")
	milestoneLabel.Name = "MilestoneProgress"
	milestoneLabel.Size = UDim2.new(1, -80, 0, 16)
	milestoneLabel.Position = UDim2.new(0, 70, 0, 50)
	milestoneLabel.BackgroundTransparency = 1
	milestoneLabel.Text = isLocked and "" or "0/10 to x2 Speed"
	milestoneLabel.TextColor3 = isLocked and UI_CONFIG.LOCKED_TEXT_COLOR or Color3.fromRGB(150, 200, 255)
	milestoneLabel.TextSize = 11
	milestoneLabel.Font = Enum.Font.GothamBold
	milestoneLabel.TextXAlignment = Enum.TextXAlignment.Left
	milestoneLabel.Parent = button
	
	-- Price display
	local priceLabel = Instance.new("TextLabel")
	priceLabel.Name = "Price"
	priceLabel.Size = UDim2.new(1, -80, 0, 24)
	priceLabel.Position = UDim2.new(0, 70, 1, -32)
	priceLabel.BackgroundTransparency = 1
	priceLabel.Text = isLocked and "LOCKED" or formatMoney(config.BasePrice)
	priceLabel.TextColor3 = isLocked and UI_CONFIG.LOCKED_TEXT_COLOR or UI_CONFIG.PRICE_COLOR
	priceLabel.TextSize = 18
	priceLabel.Font = Enum.Font.GothamBold
	priceLabel.TextXAlignment = Enum.TextXAlignment.Left
	priceLabel.Parent = button
	
	-- Buy indicator (only for unlocked)
	local buyIndicator = Instance.new("TextLabel")
	buyIndicator.Name = "BuyIndicator"
	buyIndicator.Size = UDim2.new(0, 80, 0, 30) -- Wider for text
	buyIndicator.Position = UDim2.new(1, -90, 1, -38)
	buyIndicator.BackgroundTransparency = 1
	local ownedCount = config.count or 0
	local buttonText = "BUY"
	if ownedCount > 0 then
		buttonText = "UPGRADE"
	end
	
	buyIndicator.Text = isLocked and "" or buttonText
	buyIndicator.TextColor3 = UI_CONFIG.ACCENT_COLOR
	buyIndicator.TextSize = 14
	buyIndicator.Font = Enum.Font.GothamBold
	buyIndicator.Parent = button
	
	-- Locked overlay effect
	if isLocked then
		local overlay = Instance.new("Frame")
		overlay.Name = "LockedOverlay"
		overlay.Size = UDim2.new(1, 0, 1, 0)
		overlay.BackgroundColor3 = UI_CONFIG.LOCKED_OVERLAY_COLOR
		overlay.BackgroundTransparency = 0.5
		overlay.ZIndex = 2
		overlay.Parent = button
		addCorner(overlay, 8)
	end
	
	return button
end

--------------------------------------------------------------------------------
-- UI LOGIC
--------------------------------------------------------------------------------

local function updateButtonPrice(unitName: string, newCount: number)
	local button = ShopButtons[unitName]
	if not button then return end
	
	local config = ShopConfig.GetConfig(unitName)
	if not config then return end
	
	local newPrice = ShopConfig.CalculatePrice(unitName, newCount)
	
	-- Update price label
	local priceLabel = button:FindFirstChild("Price")
	if priceLabel then
		priceLabel.Text = formatMoney(newPrice)
	end
	
	-- Update owned badge
	local ownedBadge = button:FindFirstChild("OwnedBadge")
	if ownedBadge then
		ownedBadge.Text = tostring(newCount)
	end
	
	-- Update income display with milestone bonuses
	local incomeLabel = button:FindFirstChild("Income")
	if incomeLabel then
		local effectiveIncome = ShopConfig.CalculateEffectiveIncome(unitName, newCount)
		local effectiveCycleTime = ShopConfig.CalculateEffectiveCycleTime(unitName, newCount)
		incomeLabel.Text = string.format("+$%d every %.1fs", effectiveIncome, effectiveCycleTime)
	end
	
	-- Update milestone progress
	local milestoneLabel = button:FindFirstChild("MilestoneProgress")
	if milestoneLabel then
		local nextMilestone, currentProgress = ShopConfig.GetNextMilestone(newCount)
		if nextMilestone then
			local bonusType = nextMilestone.milestoneType == "speed" and "x2 Speed âš¡" or string.format("x%d Profit ðŸ’°", nextMilestone.multiplier)
			milestoneLabel.Text = string.format("%d/%d to %s", currentProgress, nextMilestone.quantity, bonusType)
			milestoneLabel.TextColor3 = Color3.fromRGB(150, 200, 255)
		else
			milestoneLabel.Text = "âœ… All milestones reached!"
			milestoneLabel.TextColor3 = Color3.fromRGB(100, 255, 150)
		end
	end
	
	OwnedCounts[unitName] = newCount
end

local function canAfford(unitName: string): boolean
	local leaderstats = Player:FindFirstChild("leaderstats")
	if not leaderstats then return false end
	
	local money = leaderstats:FindFirstChild("Money")
	if not money then return false end
	
	local count = OwnedCounts[unitName] or 0
	local price = ShopConfig.CalculatePrice(unitName, count)
	
	return money.Value >= price
end

local function updateButtonAffordability()
	for unitName, button in ShopButtons do
		-- Skip locked buttons (they don't have proper styling)
		local overlay = button:FindFirstChild("LockedOverlay")
		if overlay then continue end
		
		local affordable = canAfford(unitName)
		button.BackgroundColor3 = affordable and UI_CONFIG.BUTTON_COLOR or UI_CONFIG.BUTTON_DISABLED_COLOR
		
		local buyIndicator = button:FindFirstChild("BuyIndicator")
		if buyIndicator then
			buyIndicator.TextTransparency = affordable and 0 or 0.7
		end
	end
end

local function animatePurchase(button: Frame, success: boolean)
	if success then
		-- Success animation - quick scale pop
		local originalSize = button.Size
		
		local popTween = TweenService:Create(button, TweenInfo.new(0.1), {
			Size = UDim2.new(originalSize.X.Scale, originalSize.X.Offset + 6, originalSize.Y.Scale, originalSize.Y.Offset + 4)
		})
		
		local returnTween = TweenService:Create(button, TweenInfo.new(0.15, Enum.EasingStyle.Elastic), {
			Size = originalSize
		})
		
		popTween:Play()
		popTween.Completed:Connect(function()
			returnTween:Play()
		end)
		
		-- Flash green
		local originalColor = button.BackgroundColor3
		button.BackgroundColor3 = UI_CONFIG.ACCENT_COLOR
		task.delay(0.1, function()
			TweenService:Create(button, TweenInfo.new(0.2), {BackgroundColor3 = originalColor}):Play()
		end)
		
		ChachingSound:Play()
	else
		-- Shake animation for failure
		local originalPos = button.Position
		
		for i = 1, 3 do
			local offset = i % 2 == 0 and 5 or -5
			TweenService:Create(button, TweenInfo.new(0.05), {
				Position = UDim2.new(originalPos.X.Scale, originalPos.X.Offset + offset, originalPos.Y.Scale, originalPos.Y.Offset)
			}):Play()
			task.wait(0.05)
		end
		
		button.Position = originalPos
		ErrorSound:Play()
	end
end

local function setupButtonClick(button: Frame, unitName: string)
	local clickArea = button:FindFirstChild("ClickArea")
	if not clickArea then return end
	
	local debounce = false
	
	-- Hover effects
	clickArea.MouseEnter:Connect(function()
		if canAfford(unitName) then
			TweenService:Create(button, TweenInfo.new(UI_CONFIG.TWEEN_TIME), {
				BackgroundColor3 = UI_CONFIG.BUTTON_HOVER_COLOR
			}):Play()
		end
	end)
	
	clickArea.MouseLeave:Connect(function()
		local targetColor = canAfford(unitName) and UI_CONFIG.BUTTON_COLOR or UI_CONFIG.BUTTON_DISABLED_COLOR
		TweenService:Create(button, TweenInfo.new(UI_CONFIG.TWEEN_TIME), {
			BackgroundColor3 = targetColor
		}):Play()
	end)
	
	-- Click to buy
	clickArea.MouseButton1Click:Connect(function()
		if debounce then return end
		
		-- REMOVED: Main island check - players can buy from anywhere
		-- Selling still requires visiting the Market on Main Island
		
		debounce = true
		
		local success, message = BuyUnitRemote:InvokeServer(unitName)
		animatePurchase(button, success)
		
		if not success then
			warn("Purchase failed: " .. tostring(message))
		end
		
		task.wait(0.3)
		debounce = false
	end)
end

--[[
	Refreshes the shop UI to show visible units based on unlock progress.
]]
local function refreshShopUI()
	if not ScrollFrame then return end
	
	-- Clear existing buttons
	for _, child in ScrollFrame:GetChildren() do
		if child:IsA("Frame") then
			child:Destroy()
		end
	end
	ShopButtons = {}
	
	-- Get visible units based on unlock progress
	local visibleUnits = ShopConfig.GetVisibleUnits(UnlockProgress)
	
	for i, unitData in visibleUnits do
		local unitName = unitData.name
		local config = unitData.config
		local isLocked = unitData.isLocked
		
		-- Create button
		local button = createShopButton(unitName, config, i, isLocked)
		button.Parent = ScrollFrame
		
		if not isLocked then
			ShopButtons[unitName] = button
			
			-- Update with actual owned count and price
			local count = OwnedCounts[unitName] or 0
			updateButtonPrice(unitName, count)
			
			-- Setup click handler
			setupButtonClick(button, unitName)
		end
	end
	
	-- Update affordability
	updateButtonAffordability()
end

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

local function initialize()
	print("ShopUI: Initializing...")
	
	-- Create the shop GUI
	ShopGui = createShopGui()
	if not ShopGui then return end
	local shopPanel = ShopGui:FindFirstChild("ShopPanel")
	ScrollFrame = shopPanel and shopPanel:FindFirstChild("ItemList")
	
	-- Get initial ownership data from server
	local ownershipData = GetOwnershipRemote:InvokeServer()
	
	-- Set unlock progress
	if ownershipData and ownershipData.unlockProgress then
		UnlockProgress = ownershipData.unlockProgress
	end
	
	-- Initialize owned counts
	if ownershipData and ownershipData.units then
		for unitName, data in ownershipData.units do
			OwnedCounts[unitName] = data.count
		end
	end
	
	-- Build initial shop UI
	refreshShopUI()
	
	-- Parent GUI
	ShopGui.Parent = PlayerGui
	
	-- Listen for ownership updates from server
	OwnershipChangedEvent.OnClientEvent:Connect(function(unitName: string, newCount: number, newPrice: number)
		OwnedCounts[unitName] = newCount
		updateButtonPrice(unitName, newCount)
		updateButtonAffordability()
	end)
	
	-- Listen for unlock progress updates
	UnlockProgressChangedEvent.OnClientEvent:Connect(function(newProgress: number)
		print(string.format("ShopUI: Unlock progress updated to %d", newProgress))
		UnlockProgress = newProgress
		refreshShopUI()
	end)
	
	-- Update affordability when money changes
	local leaderstats = Player:WaitForChild("leaderstats", 10)
	if leaderstats then
		local money = leaderstats:WaitForChild("Money", 5)
		if money then
			money:GetPropertyChangedSignal("Value"):Connect(updateButtonAffordability)
			updateButtonAffordability() -- Initial update
		end
	end
	
	print(string.format("ShopUI: Ready! (%d units unlocked, %d total)", UnlockProgress, ShopConfig.GetTotalUnits()))
end

-- Start
initialize()

--------------------------------------------------------------------------------
-- SHOP VISIBILITY (Controlled by B key, HUD button, or ProximityPrompt)
--------------------------------------------------------------------------------

local ShopVisible = false
local SHOP_OPEN_POSITION = UDim2.new(1, -UI_CONFIG.SHOP_WIDTH - 10, 0, 10)
local SHOP_CLOSED_POSITION = UDim2.new(1, 10, 0, 10)

--[[
	Updates the warning banner visibility based on main island status.
]]
local function updateWarningBanner()
	if not ShopGui then return end
	local shopPanel = ShopGui:FindFirstChild("ShopPanel")
	if not shopPanel then return end
	
	local warningBanner = shopPanel:FindFirstChild("WarningBanner")
	if warningBanner then
		warningBanner.Visible = not IsOnMainIsland
	end
end

local function openShop()
	if ShopVisible then return end
	if not ShopGui then return end
	local shopPanel = ShopGui:FindFirstChild("ShopPanel")
	if not shopPanel then return end
	
	ShopVisible = true
	updateWarningBanner()
	TweenService:Create(shopPanel, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Position = SHOP_OPEN_POSITION
	}):Play()
	print("ShopUI: Opened")
end

local function closeShop()
	if not ShopVisible then return end
	if not ShopGui then return end
	local shopPanel = ShopGui:FindFirstChild("ShopPanel")
	if not shopPanel then return end
	
	ShopVisible = false
	TweenService:Create(shopPanel, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Position = SHOP_CLOSED_POSITION
	}):Play()
	print("ShopUI: Closed")
end

local function toggleShop()
	if ShopVisible then
		closeShop()
	else
		openShop()
	end
end

-- Setup ProximityPrompt listener for ShopVendor on Main Island
local function setupShopVendorPrompt()
	local mainIsland = workspace:WaitForChild("MainIsland", 30)
	if not mainIsland then
		warn("ShopUI: MainIsland not found")
		return
	end
	
	-- Wait for or create ShopVendor
	local shopVendor = mainIsland:FindFirstChild("ShopVendor")
	if not shopVendor then
		-- Create ShopVendor part if it doesn't exist
		shopVendor = Instance.new("Part")
		shopVendor.Name = "ShopVendor"
		shopVendor.Size = Vector3.new(6, 8, 6)
		shopVendor.BrickColor = BrickColor.new("Bright violet")
		shopVendor.Material = Enum.Material.Neon
		shopVendor.Anchored = true
		shopVendor.CanCollide = true
		-- Position on main island (adjust as needed)
		local primaryPart = mainIsland.PrimaryPart or mainIsland:FindFirstChildWhichIsA("BasePart")
		if primaryPart then
			shopVendor.Position = primaryPart.Position + Vector3.new(20, 10, 0)
		else
			-- Fallback: main island is at height 30, so position at 40
			shopVendor.Position = Vector3.new(20, 40, 0)
		end
		shopVendor.Parent = mainIsland
		
		-- Add visual label
		local billboard = Instance.new("BillboardGui")
		billboard.Size = UDim2.new(4, 0, 2, 0)
		billboard.StudsOffset = Vector3.new(0, 6, 0)
		billboard.Parent = shopVendor
		
		local label = Instance.new("TextLabel")
		label.Size = UDim2.new(1, 0, 1, 0)
		label.BackgroundTransparency = 1
		label.Text = "ðŸ›’ SHOP"
		label.TextColor3 = Color3.fromRGB(255, 255, 255)
		label.TextScaled = true
		label.Font = Enum.Font.GothamBold
		label.Parent = billboard
	end
	
	-- Create or get ProximityPrompt
	local prompt = shopVendor:FindFirstChild("ShopPrompt")
	if not prompt then
		prompt = Instance.new("ProximityPrompt")
		prompt.Name = "ShopPrompt"
		prompt.ActionText = "Open Shop"
		prompt.ObjectText = "Shop"
		prompt.KeyboardKeyCode = Enum.KeyCode.E
		prompt.HoldDuration = 0
		prompt.MaxActivationDistance = 10
		prompt.RequiresLineOfSight = false
		prompt.Parent = shopVendor
	end
	
	-- Open shop when prompt triggered
	prompt.Triggered:Connect(function(playerWhoTriggered)
		if playerWhoTriggered == Player then
			openShop()
		end
	end)
	
	print("ShopUI: ShopVendor ProximityPrompt setup complete")
end

-- Track if player is on main island for purchase permissions
local function setupMainIslandCheck()
	local mainIsland = workspace:WaitForChild("MainIsland", 30)
	if not mainIsland then
		warn("ShopUI: MainIsland not found for proximity check")
		return
	end
	
	local primaryPart = mainIsland.PrimaryPart or mainIsland:FindFirstChildWhichIsA("BasePart")
	if not primaryPart then
		warn("ShopUI: MainIsland has no primary part")
		return
	end
	
	-- Get the island bounds (approximate based on size)
	local islandSize = primaryPart.Size
	local islandCenter = primaryPart.Position
	
	RunService.Heartbeat:Connect(function()
		local character = Player.Character
		local hrp = character and character:FindFirstChild("HumanoidRootPart")
		if not hrp then return end
		
		-- Check if player is within horizontal distance of main island
		local playerPos = hrp.Position
		local horizontalDist = math.sqrt(
			(playerPos.X - islandCenter.X)^2 + 
			(playerPos.Z - islandCenter.Z)^2
		)
		
		-- Consider player on main island if within reasonable radius (island half-size + margin)
		local islandRadius = math.max(islandSize.X, islandSize.Z) / 2 + 20
		local wasOnMainIsland = IsOnMainIsland
		IsOnMainIsland = horizontalDist <= islandRadius and playerPos.Y >= islandCenter.Y - 20
		
		-- Update warning banner if status changed while shop is open
		if wasOnMainIsland ~= IsOnMainIsland and ShopVisible then
			updateWarningBanner()
		end
	end)
end

-- Setup 'B' key to toggle shop
local function setupKeyboardToggle()
	UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed then return end
		
		if input.KeyCode == Enum.KeyCode.B then
			toggleShop()
		end
	end)
	print("ShopUI: B key toggle enabled")
end

-- Setup close button on shop panel
local function setupCloseButton()
	if not ShopGui then return end
	local shopPanel = ShopGui:FindFirstChild("ShopPanel")
	if not shopPanel then return end
	
	local titleBar = shopPanel:FindFirstChild("TitleBar")
	if not titleBar then return end
	
	local closeButton = titleBar:FindFirstChild("CloseButton")
	if closeButton then
		closeButton.MouseButton1Click:Connect(function()
			closeShop()
		end)
		
		-- Hover effects
		closeButton.MouseEnter:Connect(function()
			TweenService:Create(closeButton, TweenInfo.new(0.1), {
				BackgroundColor3 = Color3.fromRGB(255, 80, 80)
			}):Play()
		end)
		
		closeButton.MouseLeave:Connect(function()
			TweenService:Create(closeButton, TweenInfo.new(0.1), {
				BackgroundColor3 = Color3.fromRGB(200, 60, 60)
			}):Play()
		end)
	end
end

-- Setup BindableEvent listener for MoneyHUD shop button
local function setupBindableEventListener()
	-- Wait a bit for MoneyHUD to potentially create the event
	task.wait(0.5)
	
	local shopToggleEvent = ReplicatedStorage:FindFirstChild("ShopToggleEvent")
	if not shopToggleEvent then
		-- Create it ourselves if MoneyHUD hasn't yet
		shopToggleEvent = Instance.new("BindableEvent")
		shopToggleEvent.Name = "ShopToggleEvent"
		shopToggleEvent.Parent = ReplicatedStorage
	end
	
	shopToggleEvent.Event:Connect(function()
		toggleShop()
	end)
	
	print("ShopUI: BindableEvent listener setup complete")
end

-- Initialize shop vendor prompt
task.spawn(setupShopVendorPrompt)
task.spawn(setupMainIslandCheck)
task.spawn(setupCloseButton)
task.spawn(setupBindableEventListener)
setupKeyboardToggle()



--------------------------------------------------
File: StockMarketGraph.client.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\client\StockMarketGraph.client.luau
--------------------------------------------------
--!strict
--[[
	StockMarketGraph Client Script
	
	Procedural Geometry Architecture using EditableImage with scanline-based rendering.
	Renders multiple category stock lines with unique colors.
	
	Classes:
	- DataBuffer: Circular buffer for rate history
	- GraphViewport: Coordinate transformation (rate/time to pixels)
	- MeshRenderer: Scanline-based rendering for filled quads and thick lines
	
	Uses modern EditableImage API:
	- AssetService:CreateEditableImage()
	- Content.fromObject() for ImageLabel binding
	- DrawLine() and DrawCircle() for geometry
]]

-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local AssetService = game:GetService("AssetService")
local HttpService = game:GetService("HttpService")

-- Configuration
local CONFIG = {
	-- Canvas size (EditableImage max is 1024x1024, using 1024x512 for 2:1 aspect)
	CANVAS_WIDTH = 1024,
	CANVAS_HEIGHT = 512,
	PADDING = 28,
	
	-- Graph appearance
	LINE_THICKNESS = 4,   -- Thinner for multiple lines
	GLOW_THICKNESS = 10,
	GLOW_OPACITY = 0.5,
	
	-- Colors per category (from server config)
	CATEGORY_COLORS = {
		Skibidi = Color3.fromRGB(148, 103, 189),    -- Purple
		Bombardiro = Color3.fromRGB(255, 127, 14),  -- Orange
		Tralalero = Color3.fromRGB(44, 160, 44),    -- Green
		BrrBrr = Color3.fromRGB(31, 119, 180),      -- Blue
		Sigma = Color3.fromRGB(214, 39, 40),        -- Red
		Mewer = Color3.fromRGB(227, 119, 194),      -- Pink
	},
	
	FILL_OPACITY = 0.15,  -- Much lower for multiple overlapping fills
	
	-- Buffer
	MAX_HISTORY = 60,
}

-- Category order for consistent rendering
local CATEGORY_ORDER = {"Skibidi", "Bombardiro", "Tralalero", "BrrBrr", "Sigma", "Mewer"}

--------------------------------------------------------------------------------
-- DataBuffer Class: Circular buffer for rate history
--------------------------------------------------------------------------------

export type DataBufferImpl = {
	buffer: {number},
	capacity: number,
	count: number,
}

local DataBuffer = {}
DataBuffer.__index = DataBuffer

function DataBuffer.new(capacity: number): DataBufferImpl
	local self = setmetatable({}, DataBuffer) :: any
	self.buffer = table.create(capacity, 1.0)
	self.capacity = capacity
	self.count = 0
	return self :: DataBufferImpl
end

function DataBuffer.ParseAndUpdate(self: DataBufferImpl, historyStr: string)
	if not historyStr or historyStr == "" then
		return
	end
	
	local index = 0
	for value in string.gmatch(historyStr, "[^,]+") do
		index += 1
		local num = tonumber(value)
		if num and index <= self.capacity then
			self.buffer[index] = num
		end
	end
	self.count = index
end

function DataBuffer.GetPoints(self: DataBufferImpl): {number}
	local result = {}
	for i = 1, self.count do
		result[i] = self.buffer[i]
	end
	return result
end

function DataBuffer.GetCount(self: DataBufferImpl): number
	return self.count
end

--------------------------------------------------------------------------------
-- GraphViewport Class: Coordinate transformation
--------------------------------------------------------------------------------

export type ViewportImpl = {
	width: number,
	height: number,
	paddingX: number,
	paddingY: number,
	minRate: number,
	maxRate: number,
	pointCount: number,
}

local GraphViewport = {}
GraphViewport.__index = GraphViewport

function GraphViewport.new(width: number, height: number, paddingX: number, paddingY: number): ViewportImpl
	local self = setmetatable({}, GraphViewport) :: any
	self.width = width
	self.height = height
	self.paddingX = paddingX
	self.paddingY = paddingY
	self.minRate = 0.5
	self.maxRate = 3.0
	self.pointCount = 60
	return self :: ViewportImpl
end

function GraphViewport.SetBounds(self: ViewportImpl, minRate: number, maxRate: number, pointCount: number)
	self.minRate = minRate
	self.maxRate = maxRate
	self.pointCount = math.max(2, pointCount)
end

function GraphViewport.GetUsableWidth(self: ViewportImpl): number
	return self.width - self.paddingX * 2
end

function GraphViewport.GetUsableHeight(self: ViewportImpl): number
	return self.height - self.paddingY * 2
end

function GraphViewport.GetBottomY(self: ViewportImpl): number
	return self.height - self.paddingY
end

function GraphViewport.RateToY(self: ViewportImpl, rate: number): number
	local usableHeight = GraphViewport.GetUsableHeight(self)
	local normalized = (rate - self.minRate) / (self.maxRate - self.minRate)
	return self.paddingY + (1 - normalized) * usableHeight
end

function GraphViewport.IndexToX(self: ViewportImpl, index: number): number
	local usableWidth = GraphViewport.GetUsableWidth(self)
	local spacing = usableWidth / math.max(1, self.pointCount - 1)
	return self.paddingX + (index - 1) * spacing
end

function GraphViewport.ToPixelCoords(self: ViewportImpl, index: number, rate: number): Vector2
	return Vector2.new(
		GraphViewport.IndexToX(self, index),
		GraphViewport.RateToY(self, rate)
	)
end

--------------------------------------------------------------------------------
-- MeshRenderer Class: Scanline-based EditableImage rendering
--------------------------------------------------------------------------------

export type RendererImpl = {
	image: EditableImage?,
	viewport: ViewportImpl,
	width: number,
	height: number,
}

local MeshRenderer = {}
MeshRenderer.__index = MeshRenderer

function MeshRenderer.new(viewport: ViewportImpl, width: number, height: number): RendererImpl
	local self = setmetatable({}, MeshRenderer) :: any
	self.viewport = viewport
	self.width = width
	self.height = height
	self.image = nil
	return self :: RendererImpl
end

function MeshRenderer.Initialize(self: RendererImpl): boolean
	local success, result = pcall(function()
		return AssetService:CreateEditableImage({
			Size = Vector2.new(self.width, self.height)
		})
	end)
	
	if not success then
		warn("MeshRenderer: Failed to create EditableImage:", result)
		return false
	end
	
	self.image = result :: EditableImage
	return true
end

function MeshRenderer.Clear(self: RendererImpl)
	if not self.image then return end
	
	-- Fill with transparent black
	self.image:DrawRectangle(
		Vector2.new(0, 0),
		Vector2.new(self.width, self.height),
		Color3.new(0, 0, 0),
		1, -- Fully transparent
		Enum.ImageCombineType.Overwrite
	)
end

--[[
	Calculates the perpendicular normal vector for a line segment.
]]
local function calculateNormal(p1: Vector2, p2: Vector2): Vector2
	local dx = p2.X - p1.X
	local dy = p2.Y - p1.Y
	local length = math.sqrt(dx * dx + dy * dy)
	
	if length < 0.001 then
		return Vector2.new(0, 1)
	end
	
	return Vector2.new(-dy / length, dx / length)
end

--[[
	Draws a filled quad using horizontal lines (scanline approach).
]]
function MeshRenderer.DrawQuad(
	self: RendererImpl,
	p1: Vector2,
	p2: Vector2,
	p3: Vector2,
	p4: Vector2,
	color: Color3,
	transparency: number
)
	if not self.image then return end
	
	local minY = math.floor(math.min(p1.Y, p2.Y, p3.Y, p4.Y))
	local maxY = math.ceil(math.max(p1.Y, p2.Y, p3.Y, p4.Y))
	
	minY = math.max(0, minY)
	maxY = math.min(self.height - 1, maxY)
	
	local edges = {
		{p1, p2},
		{p2, p3},
		{p3, p4},
		{p4, p1}
	}
	
	for y = minY, maxY do
		local intersections: {number} = {}
		
		for _, edge in edges do
			local a, b = edge[1], edge[2]
			if (a.Y <= y and b.Y > y) or (b.Y <= y and a.Y > y) then
				local t = (y - a.Y) / (b.Y - a.Y)
				local x = a.X + t * (b.X - a.X)
				table.insert(intersections, x)
			end
		end
		
		table.sort(intersections)
		
		for i = 1, #intersections - 1, 2 do
			local x1 = math.floor(intersections[i])
			local x2 = math.ceil(intersections[i + 1])
			
			x1 = math.max(0, x1)
			x2 = math.min(self.width - 1, x2)
			
			if x2 > x1 then
				self.image:DrawLine(
					Vector2.new(x1, y),
					Vector2.new(x2, y),
					color,
					transparency,
					Enum.ImageCombineType.AlphaBlend
				)
			end
		end
	end
end

--[[
	Draws a thick line segment as a quad.
]]
function MeshRenderer.DrawThickLine(
	self: RendererImpl,
	p1: Vector2,
	p2: Vector2,
	color: Color3,
	thickness: number,
	transparency: number
)
	if not self.image then return end
	
	local normal = calculateNormal(p1, p2)
	local halfThickness = thickness / 2
	local offset = normal * halfThickness
	
	local c1 = p1 + offset
	local c2 = p2 + offset
	local c3 = p2 - offset
	local c4 = p1 - offset
	
	MeshRenderer.DrawQuad(self, c1, c2, c3, c4, color, transparency)
end

--[[
	Draws a single category's polyline with specified color.
]]
function MeshRenderer.DrawCategoryLine(self: RendererImpl, points: {Vector2}, color: Color3, drawFill: boolean)
	if not self.image or #points < 2 then return end
	
	local bottomY = GraphViewport.GetBottomY(self.viewport)
	
	-- Layer 1: Optional gradient fill (bottom layer)
	if drawFill then
		for i = 1, #points - 1 do
			local p1 = points[i]
			local p2 = points[i + 1]
			local bottom1 = Vector2.new(p1.X, bottomY)
			local bottom2 = Vector2.new(p2.X, bottomY)
			MeshRenderer.DrawQuad(self, p1, p2, bottom2, bottom1, color, CONFIG.FILL_OPACITY)
		end
	end
	
	-- Layer 2: Glow
	for i = 1, #points - 1 do
		MeshRenderer.DrawThickLine(self, points[i], points[i + 1], color, CONFIG.GLOW_THICKNESS, CONFIG.GLOW_OPACITY)
	end
	
	-- Layer 3: Main stroke
	for i = 1, #points - 1 do
		MeshRenderer.DrawThickLine(self, points[i], points[i + 1], color, CONFIG.LINE_THICKNESS, 0)
	end
end

--[[
	Draws a highlighted dot at the current position.
]]
function MeshRenderer.DrawCurrentDot(self: RendererImpl, pos: Vector2, color: Color3)
	if not self.image then return end
	
	-- Draw glow circle
	self.image:DrawCircle(pos, 10, color, 0.5, Enum.ImageCombineType.AlphaBlend)
	-- Draw main circle
	self.image:DrawCircle(pos, 6, color, 0, Enum.ImageCombineType.AlphaBlend)
	-- Draw white center
	self.image:DrawCircle(pos, 3, Color3.new(1, 1, 1), 0, Enum.ImageCombineType.AlphaBlend)
end

function MeshRenderer.GetImage(self: RendererImpl): EditableImage?
	return self.image
end

--------------------------------------------------------------------------------
-- Billboard Display Management
--------------------------------------------------------------------------------

type BillboardDisplay = {
	container: Frame,
	graphImageLabel: ImageLabel?,
	rateDisplay: TextLabel?,
	rateName: TextLabel?,
	timerDisplay: TextLabel?,
	renderer: RendererImpl?,
}

local billboardDisplays: {BillboardDisplay} = {}
local categoryBuffers: {[string]: DataBufferImpl} = {}
local stockMarketFolder: Folder? = nil

-- Initialize buffers for each category
for _, category in CATEGORY_ORDER do
	categoryBuffers[category] = DataBuffer.new(CONFIG.MAX_HISTORY)
end

--[[
	Creates an ImageLabel for the EditableImage and attaches it.
]]
local function setupImageLabel(graphLines: Frame, renderer: RendererImpl): ImageLabel?
	local existing = graphLines:FindFirstChildOfClass("ImageLabel")
	if existing then
		existing:Destroy()
	end
	
	local imageLabel = Instance.new("ImageLabel")
	imageLabel.Name = "GraphImage"
	imageLabel.Size = UDim2.new(1, 0, 1, 0)
	imageLabel.BackgroundTransparency = 1
	imageLabel.ScaleType = Enum.ScaleType.Stretch
	imageLabel.Parent = graphLines
	
	local editableImage = renderer.image
	if editableImage then
		imageLabel.ImageContent = Content.fromObject(editableImage)
	end
	
	return imageLabel
end

--[[
	Finds all billboard displays and sets up EditableImage rendering.
]]
local function findBillboards()
	billboardDisplays = {}
	
	local billboardsFolder = Workspace:WaitForChild("StockMarketBillboards", 30)
	if not billboardsFolder then
		warn("StockMarketGraph: Billboards folder not found!")
		return
	end
	
	for _, billboard in billboardsFolder:GetChildren() do
		local screen = billboard:FindFirstChild("Screen")
		if not screen then continue end
		
		local surfaceGui = screen:FindFirstChild("StockMarketDisplay")
		if not surfaceGui then continue end
		
		local container = surfaceGui:FindFirstChild("Container")
		if not container then continue end
		
		local graphContainer = container:FindFirstChild("GraphContainer")
		if not graphContainer then continue end
		
		local graphLines = graphContainer:FindFirstChild("GraphLines") :: Frame?
		if not graphLines then continue end
		
		local viewport = GraphViewport.new(CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT, CONFIG.PADDING, CONFIG.PADDING)
		local renderer = MeshRenderer.new(viewport, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT)
		
		local graphImageLabel: ImageLabel? = nil
		
		if MeshRenderer.Initialize(renderer) then
			graphImageLabel = setupImageLabel(graphLines, renderer)
			print("StockMarketGraph: Initialized EditableImage for billboard")
		else
			warn("StockMarketGraph: Failed to initialize renderer for billboard")
		end
		
		local display: BillboardDisplay = {
			container = container :: Frame,
			graphImageLabel = graphImageLabel,
			rateDisplay = container:FindFirstChild("RateDisplay") :: TextLabel?,
			rateName = container:FindFirstChild("RateName") :: TextLabel?,
			timerDisplay = container:FindFirstChild("TimerDisplay") :: TextLabel?,
			renderer = renderer,
		}
		
		table.insert(billboardDisplays, display)
	end
	
	print(string.format("StockMarketGraph: Found %d billboard displays", #billboardDisplays))
end

--[[
	Gets rate color for text labels based on rate value.
]]
local function getRateColor(rate: number): Color3
	if rate >= 2.0 then
		return Color3.fromRGB(255, 215, 0)  -- Gold
	elseif rate >= 1.0 then
		return Color3.fromRGB(100, 255, 100)  -- Green
	else
		return Color3.fromRGB(255, 70, 70)  -- Red
	end
end

--[[
	Redraws the graph on a single billboard with all category lines.
]]
local function drawGraph(display: BillboardDisplay)
	local renderer = display.renderer
	if not renderer or not renderer.image then return end
	if not stockMarketFolder then return end
	
	local minRate = stockMarketFolder:GetAttribute("MinRate") :: number? or 0.5
	local maxRate = stockMarketFolder:GetAttribute("MaxRate") :: number? or 3.0
	
	-- Find point count (use first category's count)
	local firstBuffer = categoryBuffers[CATEGORY_ORDER[1]]
	local pointCount = DataBuffer.GetCount(firstBuffer)
	
	if pointCount < 2 then return end
	
	-- Update viewport bounds
	GraphViewport.SetBounds(renderer.viewport, minRate, maxRate, pointCount)
	
	-- Clear and start drawing
	MeshRenderer.Clear(renderer)
	
	-- Track best performing category
	local bestCategory = CATEGORY_ORDER[1]
	local bestRate = 0
	
	-- Draw each category line
	for i, category in CATEGORY_ORDER do
		local buffer = categoryBuffers[category]
		local rates = DataBuffer.GetPoints(buffer)
		local count = DataBuffer.GetCount(buffer)
		
		if count >= 2 then
			-- Convert rates to pixel coordinates
			local points: {Vector2} = {}
			for j = 1, count do
				points[j] = GraphViewport.ToPixelCoords(renderer.viewport, j, rates[j])
			end
			
			-- Get color for this category
			local color = CONFIG.CATEGORY_COLORS[category] or Color3.fromRGB(200, 200, 200)
			
			-- Draw the line (first category gets fill, others don't)
			MeshRenderer.DrawCategoryLine(renderer, points, color, i == 1)
			
			-- Draw current dot
			if #points > 0 then
				local lastPoint = points[#points]
				MeshRenderer.DrawCurrentDot(renderer, lastPoint, color)
			end
			
			-- Track best rate
			local currentRate = rates[count] or 1.0
			if currentRate > bestRate then
				bestRate = currentRate
				bestCategory = category
			end
		end
	end
	
	-- Update text labels
	if display.rateDisplay then
		display.rateDisplay.Text = string.format("BEST: %.2fx", bestRate)
		display.rateDisplay.TextColor3 = CONFIG.CATEGORY_COLORS[bestCategory] or getRateColor(bestRate)
	end
	
	if display.rateName then
		display.rateName.Text = bestCategory:upper()
		display.rateName.TextColor3 = CONFIG.CATEGORY_COLORS[bestCategory] or getRateColor(bestRate)
	end
end

--[[
	Updates all billboard graphs.
]]
local function updateAllGraphs()
	for _, display in billboardDisplays do
		drawGraph(display)
	end
end

--[[
	Updates the timer display on all billboards.
]]
local function updateTimer()
	if not stockMarketFolder then return end
	
	local nextUpdate = stockMarketFolder:GetAttribute("NextUpdate") :: number? or 0
	local now = os.time()
	local remaining = math.max(0, nextUpdate - now)
	
	for _, display in billboardDisplays do
		if display.timerDisplay then
			display.timerDisplay.Text = string.format("Next update: %ds", remaining)
		end
	end
end

--[[
	Parses category histories from JSON attribute.
]]
local function parseHistories()
	if not stockMarketFolder then return end
	
	local historiesJson = stockMarketFolder:GetAttribute("CategoryHistories") :: string?
	if not historiesJson then return end
	
	local success, histories = pcall(function()
		return HttpService:JSONDecode(historiesJson)
	end)
	
	if not success or not histories then return end
	
	for category, historyStr in pairs(histories) do
		local buffer = categoryBuffers[category]
		if buffer then
			DataBuffer.ParseAndUpdate(buffer, historyStr)
		end
	end
end

--[[
	Handles rate history updates from the server.
]]
local function onHistoryChanged()
	parseHistories()
	updateAllGraphs()
end

--------------------------------------------------------------------------------
-- Initialization
--------------------------------------------------------------------------------

local function initialize()
	print("StockMarketGraph: Initializing multi-category stock display...")
	
	-- Wait for StockMarket folder
	stockMarketFolder = ReplicatedStorage:WaitForChild("StockMarket", 30) :: Folder?
	if not stockMarketFolder then
		warn("StockMarketGraph: StockMarket folder not found!")
		return
	end
	
	-- Wait for billboards to be created
	task.wait(4)
	
	-- Find and setup billboard displays
	findBillboards()
	
	if #billboardDisplays == 0 then
		warn("StockMarketGraph: No billboard displays found!")
		return
	end
	
	-- Initial parse and draw
	parseHistories()
	updateAllGraphs()
	
	-- Listen for category history changes
	stockMarketFolder:GetAttributeChangedSignal("CategoryHistories"):Connect(onHistoryChanged)
	
	-- Also listen to legacy attribute for backwards compatibility
	stockMarketFolder:GetAttributeChangedSignal("RateHistory"):Connect(onHistoryChanged)
	
	-- Timer update loop
	RunService.Heartbeat:Connect(updateTimer)
	
	print("âœ“ StockMarketGraph initialized with 6 category lines")
end

-- Start
task.spawn(initialize)



--------------------------------------------------
File: StockMarketUI.client.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\client\StockMarketUI.client.luau
--------------------------------------------------
--[[
	StockMarketUI Client Script
	
	DISABLED: Stock market is now displayed on billboards instead of HUD.
	See: StockMarketGraph.client.luau and StockMarketBillboards.server.luau
]]

-- Disabled - billboards now handle stock market display
return
--[[
-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local SoundService = game:GetService("SoundService")

-- Player
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Configuration
local CONFIG = {
	COLORS = {
		CRASH = Color3.fromRGB(255, 80, 80),
		NORMAL = Color3.fromRGB(255, 255, 255),
		STONKS = Color3.fromRGB(80, 255, 80),
		["HYPER INFLATION"] = Color3.fromRGB(255, 215, 0),
	},
	SOUNDS = {
		CRASH = "rbxassetid://15656647153",
		HYPER = "rbxassetid://1837756993",
	},
	UPDATE_INTERVAL = 30,
}

-- Wait for StockMarket folder
local stockMarketFolder = ReplicatedStorage:WaitForChild("StockMarket", 30)
if not stockMarketFolder then
	warn("StockMarketUI: StockMarket folder not found!")
	return
end

--------------------------------------------------------------------------------
-- UI CREATION
--------------------------------------------------------------------------------

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "StockMarketUI"
screenGui.ResetOnSpawn = false
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.Parent = playerGui

-- Main container (top-right corner, below the leaderboard area)
local container = Instance.new("Frame")
container.Name = "StockMarketContainer"
container.Size = UDim2.new(0, 200, 0, 100)
container.Position = UDim2.new(1, -220, 0, 120) -- Top right, below leaderboard
container.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
container.BackgroundTransparency = 0.2
container.BorderSizePixel = 0
container.Parent = screenGui

local containerCorner = Instance.new("UICorner")
containerCorner.CornerRadius = UDim.new(0, 12)
containerCorner.Parent = container

local containerStroke = Instance.new("UIStroke")
containerStroke.Thickness = 2
containerStroke.Color = Color3.fromRGB(60, 60, 80)
containerStroke.Parent = container

-- Header
local header = Instance.new("TextLabel")
header.Name = "Header"
header.Size = UDim2.new(1, 0, 0, 24)
header.Position = UDim2.new(0, 0, 0, 4)
header.BackgroundTransparency = 1
header.Text = "ðŸ“ˆ STOCK MARKET"
header.TextColor3 = Color3.fromRGB(200, 200, 220)
header.TextSize = 14
header.Font = Enum.Font.GothamBold
header.Parent = container

-- Rate Display
local rateLabel = Instance.new("TextLabel")
rateLabel.Name = "RateLabel"
rateLabel.Size = UDim2.new(1, 0, 0, 40)
rateLabel.Position = UDim2.new(0, 0, 0, 28)
rateLabel.BackgroundTransparency = 1
rateLabel.Text = "1.0x"
rateLabel.TextColor3 = CONFIG.COLORS.NORMAL
rateLabel.TextSize = 36
rateLabel.Font = Enum.Font.GothamBlack
rateLabel.Parent = container

-- Rate Name
local rateNameLabel = Instance.new("TextLabel")
rateNameLabel.Name = "RateNameLabel"
rateNameLabel.Size = UDim2.new(1, 0, 0, 18)
rateNameLabel.Position = UDim2.new(0, 0, 0, 68)
rateNameLabel.BackgroundTransparency = 1
rateNameLabel.Text = "NORMAL"
rateNameLabel.TextColor3 = Color3.fromRGB(150, 150, 170)
rateNameLabel.TextSize = 12
rateNameLabel.Font = Enum.Font.GothamMedium
rateNameLabel.Parent = container

-- Timer (bottom)
local timerLabel = Instance.new("TextLabel")
timerLabel.Name = "TimerLabel"
timerLabel.Size = UDim2.new(1, 0, 0, 16)
timerLabel.Position = UDim2.new(0, 0, 1, -18)
timerLabel.BackgroundTransparency = 1
timerLabel.Text = "Next: 30s"
timerLabel.TextColor3 = Color3.fromRGB(120, 120, 140)
timerLabel.TextSize = 11
timerLabel.Font = Enum.Font.Gotham
timerLabel.Parent = container

--------------------------------------------------------------------------------
-- SOUND SETUP
--------------------------------------------------------------------------------

local crashSound = Instance.new("Sound")
crashSound.SoundId = CONFIG.SOUNDS.CRASH
crashSound.Volume = 0.7
crashSound.Parent = SoundService

local hyperSound = Instance.new("Sound")
hyperSound.SoundId = CONFIG.SOUNDS.HYPER
hyperSound.Volume = 0.8
hyperSound.Parent = SoundService

--------------------------------------------------------------------------------
-- UPDATE LOGIC
--------------------------------------------------------------------------------

local lastRateName = "NORMAL"

local function updateDisplay()
	local currentRate = stockMarketFolder:GetAttribute("CurrentRate") or 1.0
	local rateName = stockMarketFolder:GetAttribute("RateName") or "NORMAL"
	
	-- Update text
	rateLabel.Text = string.format("%.1fx", currentRate)
	rateNameLabel.Text = rateName
	
	-- Update colors
	local color = CONFIG.COLORS[rateName] or CONFIG.COLORS.NORMAL
	rateLabel.TextColor3 = color
	containerStroke.Color = color
	
	-- Play sounds on rate change
	if rateName ~= lastRateName then
		if rateName == "CRASH" then
			crashSound:Play()
		elseif rateName == "HYPER INFLATION" then
			hyperSound:Play()
		end
		
		-- Animate the rate label
		local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
		rateLabel.TextSize = 24
		local tween = TweenService:Create(rateLabel, tweenInfo, {TextSize = 36})
		tween:Play()
		
		lastRateName = rateName
	end
end

local function updateTimer()
	local nextUpdate = stockMarketFolder:GetAttribute("NextUpdate") or 0
	local now = os.time()
	local remaining = math.max(0, nextUpdate - now)
	timerLabel.Text = string.format("Next: %ds", remaining)
end

-- Initial update
updateDisplay()

-- Listen for rate changes
stockMarketFolder:GetAttributeChangedSignal("CurrentRate"):Connect(updateDisplay)
stockMarketFolder:GetAttributeChangedSignal("RateName"):Connect(updateDisplay)

-- Timer update loop
RunService.Heartbeat:Connect(function()
	updateTimer()
end)

print("âœ“ StockMarketUI initialized")
]]



--------------------------------------------------
File: StorageMarketGlow.client.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\client\StorageMarketGlow.client.luau
--------------------------------------------------
--[[
	StorageMarketGlow Client Script
	
	Updates the Storage tank display to show the current market rate multiplier
	and adds a Highlight glow effect based on the rate.
	
	Features:
	- Shows "(1.2x)" multiplier on storage display
	- Green glow when rate >= 1.5x (good time to sell)
	- Yellow glow when rate 1.0x-1.5x (neutral)
	- Red glow when rate < 1.0x (bad time to sell)
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

-- Configuration
local CONFIG = {
	-- Glow colors
	HIGH_RATE_COLOR = Color3.fromRGB(50, 255, 100),    -- Green (>=1.5x)
	NEUTRAL_RATE_COLOR = Color3.fromRGB(255, 215, 0), -- Yellow (1.0x-1.5x)
	LOW_RATE_COLOR = Color3.fromRGB(255, 70, 70),     -- Red (<1.0x)
	
	-- Thresholds
	HIGH_RATE_THRESHOLD = 1.5,
	NEUTRAL_RATE_THRESHOLD = 1.0,
	
	-- Glow intensity
	BASE_FILL_TRANSPARENCY = 0.7,
	BASE_OUTLINE_TRANSPARENCY = 0.3,
}

-- References
local player = Players.LocalPlayer
local stockMarketFolder: Folder? = nil
local currentHighlight: Highlight? = nil
local storagePart: BasePart? = nil
local rateLabel: TextLabel? = nil

--------------------------------------------------------------------------------
-- HELPER FUNCTIONS
--------------------------------------------------------------------------------

--[[
	Gets the color based on the current market rate.
]]
local function getRateColor(rate: number): Color3
	if rate >= CONFIG.HIGH_RATE_THRESHOLD then
		return CONFIG.HIGH_RATE_COLOR
	elseif rate >= CONFIG.NEUTRAL_RATE_THRESHOLD then
		return CONFIG.NEUTRAL_RATE_COLOR
	else
		return CONFIG.LOW_RATE_COLOR
	end
end

--[[
	Finds the player's storage part by looking for their plot.
]]
local function findPlayerStorage(): BasePart?
	local plotsFolder = workspace:FindFirstChild("Plots")
	if not plotsFolder then return nil end
	
	for _, plot in plotsFolder:GetChildren() do
		local ownerId = plot:GetAttribute("OwnerId")
		if ownerId and ownerId == player.UserId then
			local storage = plot:FindFirstChild("Storage")
			if storage and storage:IsA("BasePart") then
				return storage
			end
		end
	end
	
	return nil
end

--[[
	Creates or updates the rate label on the storage BillboardGui.
]]
local function ensureRateLabel(storage: BasePart): TextLabel?
	local billboard = storage:FindFirstChild("StorageDisplay")
	if not billboard then return nil end
	
	local bgFrame = billboard:FindFirstChild("Background")
	if not bgFrame then return nil end
	
	-- Check if rate label already exists
	local existingLabel = bgFrame:FindFirstChild("RateLabel")
	if existingLabel then
		return existingLabel :: TextLabel
	end
	
	-- Create new rate label
	local label = Instance.new("TextLabel")
	label.Name = "RateLabel"
	label.Size = UDim2.new(0.4, 0, 0.3, 0)
	label.Position = UDim2.new(0.6, 0, 0.05, 0)
	label.BackgroundTransparency = 1
	label.Text = "(1.0x)"
	label.TextColor3 = CONFIG.NEUTRAL_RATE_COLOR
	label.TextScaled = true
	label.Font = Enum.Font.GothamBold
	label.Parent = bgFrame
	
	return label
end

--[[
	Creates or updates the Highlight effect on the storage.
]]
local function ensureHighlight(storage: BasePart): Highlight?
	-- Check if highlight already exists
	local existingHighlight = storage:FindFirstChild("MarketHighlight")
	if existingHighlight and existingHighlight:IsA("Highlight") then
		return existingHighlight
	end
	
	-- Create new highlight
	local highlight = Instance.new("Highlight")
	highlight.Name = "MarketHighlight"
	highlight.FillTransparency = CONFIG.BASE_FILL_TRANSPARENCY
	highlight.OutlineTransparency = CONFIG.BASE_OUTLINE_TRANSPARENCY
	highlight.FillColor = CONFIG.NEUTRAL_RATE_COLOR
	highlight.OutlineColor = CONFIG.NEUTRAL_RATE_COLOR
	highlight.Adornee = storage
	highlight.Parent = storage
	
	return highlight
end

--[[
	Updates the storage visual based on current market rate.
]]
local function updateStorageVisual()
	if not stockMarketFolder then return end
	if not storagePart then
		-- Try to find storage again
		storagePart = findPlayerStorage()
		if not storagePart then return end
		
		-- Ensure rate label exists
		rateLabel = ensureRateLabel(storagePart)
		
		-- Ensure highlight exists
		currentHighlight = ensureHighlight(storagePart)
	end
	
	-- Get current rate
	local currentRate = stockMarketFolder:GetAttribute("CurrentRate") :: number? or 1.0
	local color = getRateColor(currentRate)
	
	-- Update rate label
	if rateLabel then
		rateLabel.Text = string.format("(%.2fx)", currentRate)
		rateLabel.TextColor3 = color
	end
	
	-- Update highlight
	if currentHighlight then
		currentHighlight.FillColor = color
		currentHighlight.OutlineColor = color
		
		-- Pulse intensity based on how far from 1.0x
		local intensity = math.abs(currentRate - 1.0)
		local fillTransparency = math.clamp(0.9 - intensity * 0.3, 0.5, 0.95)
		local outlineTransparency = math.clamp(0.5 - intensity * 0.2, 0.1, 0.7)
		
		currentHighlight.FillTransparency = fillTransparency
		currentHighlight.OutlineTransparency = outlineTransparency
	end
end

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

local function initialize()
	print("StorageMarketGlow: Initializing...")
	
	-- Wait for StockMarket folder
	stockMarketFolder = ReplicatedStorage:WaitForChild("StockMarket", 30) :: Folder?
	if not stockMarketFolder then
		warn("StorageMarketGlow: StockMarket folder not found!")
		return
	end
	
	-- Wait a moment for plot to be assigned
	task.wait(2)
	
	-- Find player's storage
	storagePart = findPlayerStorage()
	if storagePart then
		rateLabel = ensureRateLabel(storagePart)
		currentHighlight = ensureHighlight(storagePart)
		print("StorageMarketGlow: Found storage, added rate display and glow")
	else
		print("StorageMarketGlow: No storage found yet, will check on rate updates")
	end
	
	-- Initial update
	updateStorageVisual()
	
	-- Listen for rate changes
	stockMarketFolder:GetAttributeChangedSignal("CurrentRate"):Connect(updateStorageVisual)
	
	-- Also poll periodically in case storage wasn't found initially
	task.spawn(function()
		while true do
			task.wait(2)
			if not storagePart then
				storagePart = findPlayerStorage()
				if storagePart then
					rateLabel = ensureRateLabel(storagePart)
					currentHighlight = ensureHighlight(storagePart)
					updateStorageVisual()
					print("StorageMarketGlow: Found storage on poll")
				end
			end
		end
	end)
	
	print("âœ“ StorageMarketGlow initialized")
end

-- Start
task.spawn(initialize)



--------------------------------------------------
File: StorageUI.client.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\client\StorageUI.client.luau
--------------------------------------------------
--[[
	StorageUI Client Script
	
	Simple storage proximity UI that shows when approaching the Storage part.
	Opens Transport UI for full storage access.
	
	Features:
	- Shows storage fill level when near Storage
	- Quick info popup
	- Press T for full Transport UI
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local CollectionService = game:GetService("CollectionService")

-- Get player
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- Wait for events
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local StorageUpdatedEvent = RemoteEvents:WaitForChild("StorageUpdated")
local GetStorageFunction = RemoteEvents:WaitForChild("GetStorage")

-- Constants
local PROXIMITY_DISTANCE = 20

-- State
local currentStorage = {}
local storageUsage = 0
local storageCapacity = 2000
local isNearStorage = false

-- UI References
local screenGui = nil
local popupFrame = nil

-- Colors
local COLORS = {
	background = Color3.fromRGB(20, 25, 35),
	accent = Color3.fromRGB(100, 200, 255),
	text = Color3.fromRGB(255, 255, 255),
	success = Color3.fromRGB(100, 255, 150),
	warning = Color3.fromRGB(255, 200, 100),
	danger = Color3.fromRGB(255, 100, 100),
}

--------------------------------------------------------------------------------
-- UI CREATION
--------------------------------------------------------------------------------

local function createScreenGui()
	local gui = Instance.new("ScreenGui")
	gui.Name = "StorageProximityUI"
	gui.ResetOnSpawn = false
	gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	gui.Parent = PlayerGui
	return gui
end

local function createPopup(parent)
	local popup = Instance.new("Frame")
	popup.Name = "StoragePopup"
	popup.Size = UDim2.new(0, 220, 0, 80)
	popup.Position = UDim2.new(0.5, -110, 0, 120)
	popup.BackgroundColor3 = COLORS.background
	popup.BackgroundTransparency = 0.15
	popup.Visible = false
	popup.Parent = parent
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 12)
	corner.Parent = popup
	
	local stroke = Instance.new("UIStroke")
	stroke.Color = COLORS.accent
	stroke.Thickness = 2
	stroke.Transparency = 0.5
	stroke.Parent = popup
	
	-- Title
	local title = Instance.new("TextLabel")
	title.Name = "Title"
	title.Size = UDim2.new(1, -20, 0, 25)
	title.Position = UDim2.new(0, 10, 0, 8)
	title.BackgroundTransparency = 1
	title.Text = "ðŸ“¦ STORAGE"
	title.TextColor3 = COLORS.accent
	title.TextSize = 16
	title.Font = Enum.Font.GothamBold
	title.TextXAlignment = Enum.TextXAlignment.Left
	title.Parent = popup
	
	-- Capacity bar
	local barBg = Instance.new("Frame")
	barBg.Name = "CapacityBarBg"
	barBg.Size = UDim2.new(1, -20, 0, 16)
	barBg.Position = UDim2.new(0, 10, 0, 35)
	barBg.BackgroundColor3 = Color3.fromRGB(40, 45, 60)
	barBg.BorderSizePixel = 0
	barBg.Parent = popup
	
	local barCorner = Instance.new("UICorner")
	barCorner.CornerRadius = UDim.new(0, 6)
	barCorner.Parent = barBg
	
	local barFill = Instance.new("Frame")
	barFill.Name = "Fill"
	barFill.Size = UDim2.new(0.5, 0, 1, 0)
	barFill.BackgroundColor3 = COLORS.accent
	barFill.BorderSizePixel = 0
	barFill.Parent = barBg
	
	local fillCorner = Instance.new("UICorner")
	fillCorner.CornerRadius = UDim.new(0, 6)
	fillCorner.Parent = barFill
	
	local barText = Instance.new("TextLabel")
	barText.Name = "Text"
	barText.Size = UDim2.new(1, 0, 1, 0)
	barText.BackgroundTransparency = 1
	barText.Text = "0 / 2000"
	barText.TextColor3 = COLORS.text
	barText.TextSize = 11
	barText.Font = Enum.Font.GothamBold
	barText.Parent = barBg
	
	-- Hint text
	local hint = Instance.new("TextLabel")
	hint.Name = "Hint"
	hint.Size = UDim2.new(1, -20, 0, 18)
	hint.Position = UDim2.new(0, 10, 0, 55)
	hint.BackgroundTransparency = 1
	hint.Text = "Press T for full inventory"
	hint.TextColor3 = Color3.fromRGB(150, 150, 170)
	hint.TextSize = 12
	hint.Font = Enum.Font.Gotham
	hint.TextXAlignment = Enum.TextXAlignment.Left
	hint.Parent = popup
	
	return popup
end

--------------------------------------------------------------------------------
-- UPDATE
--------------------------------------------------------------------------------

local function updatePopup()
	if not popupFrame then return end
	
	local barBg = popupFrame:FindFirstChild("CapacityBarBg")
	if barBg then
		local fill = barBg:FindFirstChild("Fill")
		local text = barBg:FindFirstChild("Text")
		
		local ratio = math.clamp(storageUsage / math.max(1, storageCapacity), 0, 1)
		
		if fill then
			TweenService:Create(fill, TweenInfo.new(0.3), {
				Size = UDim2.new(ratio, 0, 1, 0)
			}):Play()
			
			-- Color based on fullness
			local color = COLORS.accent
			if ratio >= 1 then
				color = COLORS.danger
			elseif ratio > 0.8 then
				color = COLORS.warning
			elseif ratio > 0.5 then
				color = COLORS.success
			end
			fill.BackgroundColor3 = color
		end
		
		if text then
			text.Text = string.format("%d / %d", storageUsage, storageCapacity)
		end
	end
end

local function showPopup()
	if not popupFrame then return end
	
	popupFrame.Visible = true
	popupFrame.Size = UDim2.new(0, 220, 0, 0)
	TweenService:Create(popupFrame, TweenInfo.new(0.2, Enum.EasingStyle.Back), {
		Size = UDim2.new(0, 220, 0, 80)
	}):Play()
end

local function hidePopup()
	if not popupFrame then return end
	
	TweenService:Create(popupFrame, TweenInfo.new(0.15), {
		Size = UDim2.new(0, 220, 0, 0)
	}):Play()
	
	task.wait(0.15)
	if popupFrame then
		popupFrame.Visible = false
	end
end

--------------------------------------------------------------------------------
-- PROXIMITY CHECK
--------------------------------------------------------------------------------

local function findPlayerStorage()
	local character = LocalPlayer.Character
	if not character then return nil end
	
	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return nil end
	
	-- Find Storage parts in plots
	local plotsFolder = workspace:FindFirstChild("Plots")
	if not plotsFolder then return nil end
	
	for _, plot in plotsFolder:GetChildren() do
		local ownerId = plot:GetAttribute("OwnerId")
		if ownerId == LocalPlayer.UserId then
			local storage = plot:FindFirstChild("Storage")
			if storage and storage:IsA("BasePart") then
				return storage
			end
		end
	end
	
	return nil
end

local function checkProximity()
	local character = LocalPlayer.Character
	if not character then return end
	
	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end
	
	local storage = findPlayerStorage()
	if not storage then return end
	
	local distance = (hrp.Position - storage.Position).Magnitude
	local wasNear = isNearStorage
	isNearStorage = distance <= PROXIMITY_DISTANCE
	
	-- Transitioned to near
	if isNearStorage and not wasNear then
		-- Fetch latest storage data
		local items, total, cap = GetStorageFunction:InvokeServer()
		currentStorage = items or {}
		storageUsage = total or 0
		storageCapacity = cap or 2000
		
		updatePopup()
		showPopup()
	-- Transitioned away
	elseif not isNearStorage and wasNear then
		hidePopup()
	end
end

--------------------------------------------------------------------------------
-- EVENT HANDLERS
--------------------------------------------------------------------------------

StorageUpdatedEvent.OnClientEvent:Connect(function(items, total, capacity)
	currentStorage = items or {}
	storageUsage = total or 0
	storageCapacity = capacity or 2000
	
	if isNearStorage then
		updatePopup()
	end
end)

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

local function initialize()
	screenGui = createScreenGui()
	popupFrame = createPopup(screenGui)
	
	-- Proximity check loop
	RunService.Heartbeat:Connect(function()
		checkProximity()
	end)
	
	print("âœ“ StorageUI initialized")
end

-- Wait for character
if LocalPlayer.Character then
	task.spawn(initialize)
else
	LocalPlayer.CharacterAdded:Wait()
	task.spawn(initialize)
end



--------------------------------------------------
File: StorageUpgradeUI.client.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\client\StorageUpgradeUI.client.luau
--------------------------------------------------
--[[
	StorageUpgradeUI LocalScript
	
	Creates a storage upgrade shop interface triggered by StorageVendor.
	Shows current storage, upgrade cost, and new storage after upgrade.
	
	Features:
	- ProximityPrompt-triggered panel
	- Live price and storage level display
	- Animated purchase feedback
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local SoundService = game:GetService("SoundService")

-- Player reference
local Player = Players.LocalPlayer
local PlayerGui = Player:WaitForChild("PlayerGui")

-- Wait for remotes
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local UpgradeStorageRemote = RemoteEvents:WaitForChild("UpgradeStorage")
local GetStorageInfoRemote = RemoteEvents:WaitForChild("GetStorageInfo")
local StorageUpgradedEvent = RemoteEvents:WaitForChild("StorageUpgraded")

--------------------------------------------------------------------------------
-- UI CONFIGURATION
--------------------------------------------------------------------------------

local UI_CONFIG = {
	-- Panel dimensions
	PANEL_WIDTH = 320,
	PANEL_HEIGHT = 280,
	CORNER_RADIUS = 16,
	
	-- Colors
	BACKGROUND_COLOR = Color3.fromRGB(35, 35, 50),
	ACCENT_COLOR = Color3.fromRGB(255, 180, 50), -- Orange for storage
	BUTTON_COLOR = Color3.fromRGB(255, 180, 50),
	BUTTON_HOVER_COLOR = Color3.fromRGB(255, 200, 100),
	BUTTON_DISABLED_COLOR = Color3.fromRGB(100, 100, 100),
	TEXT_COLOR = Color3.fromRGB(255, 255, 255),
	SECONDARY_TEXT_COLOR = Color3.fromRGB(180, 180, 180),
	PRICE_COLOR = Color3.fromRGB(255, 215, 0),
	
	-- Animation
	TWEEN_TIME = 0.25,
}

--------------------------------------------------------------------------------
-- SOUNDS
--------------------------------------------------------------------------------

local function createSound(id: string, volume: number): Sound
	local sound = Instance.new("Sound")
	sound.SoundId = id
	sound.Volume = volume
	sound.Parent = SoundService
	return sound
end

local UpgradeSound = createSound("rbxassetid://138081500", 0.5) -- Cash register
local ErrorSound = createSound("rbxassetid://138090596", 0.3) -- Error

--------------------------------------------------------------------------------
-- LOCAL STATE
--------------------------------------------------------------------------------

local StorageGui: ScreenGui? = nil
local StoragePanel: Frame? = nil
local PanelVisible = false
local CurrentStorageInfo = {
	currentMax = 500,
	upgradeLevel = 0,
	nextPrice = 100,
	nextMaxStorage = 1000,
}

--------------------------------------------------------------------------------
-- UI HELPERS
--------------------------------------------------------------------------------

local function addCorner(parent: GuiObject, radius: number)
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, radius)
	corner.Parent = parent
	return corner
end

local function addStroke(parent: GuiObject, color: Color3, thickness: number)
	local stroke = Instance.new("UIStroke")
	stroke.Color = color
	stroke.Thickness = thickness
	stroke.Parent = parent
	return stroke
end

local function formatMoney(amount: number): string
	if amount >= 1000000 then
		return string.format("$%.1fM", amount / 1000000)
	elseif amount >= 1000 then
		return string.format("$%.1fK", amount / 1000)
	else
		return "$" .. tostring(math.floor(amount))
	end
end

local function formatStorage(amount: number): string
	if amount >= 1000000 then
		return string.format("%.1fM", amount / 1000000)
	elseif amount >= 1000 then
		return string.format("%.1fK", amount / 1000)
	else
		return tostring(amount)
	end
end

local function canAfford(): boolean
	local leaderstats = Player:FindFirstChild("leaderstats")
	if not leaderstats then return false end
	
	local money = leaderstats:FindFirstChild("Money")
	if not money then return false end
	
	return money.Value >= CurrentStorageInfo.nextPrice
end

--------------------------------------------------------------------------------
-- UI CREATION
--------------------------------------------------------------------------------

local function createStorageUpgradeGui(): ScreenGui
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "StorageUpgradeUI"
	screenGui.ResetOnSpawn = false
	screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	
	-- Main panel (starts hidden in center)
	local panel = Instance.new("Frame")
	panel.Name = "StoragePanel"
	panel.Size = UDim2.new(0, UI_CONFIG.PANEL_WIDTH, 0, UI_CONFIG.PANEL_HEIGHT)
	panel.Position = UDim2.new(0.5, -UI_CONFIG.PANEL_WIDTH / 2, 0.5, -UI_CONFIG.PANEL_HEIGHT / 2)
	panel.BackgroundColor3 = UI_CONFIG.BACKGROUND_COLOR
	panel.BorderSizePixel = 0
	panel.Visible = false
	panel.Parent = screenGui
	addCorner(panel, UI_CONFIG.CORNER_RADIUS)
	addStroke(panel, UI_CONFIG.ACCENT_COLOR, 3)
	
	-- Title
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "Title"
	titleLabel.Size = UDim2.new(1, 0, 0, 50)
	titleLabel.Position = UDim2.new(0, 0, 0, 0)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Text = "ðŸ“¦ STORAGE UPGRADE"
	titleLabel.TextColor3 = UI_CONFIG.ACCENT_COLOR
	titleLabel.TextSize = 24
	titleLabel.Font = Enum.Font.GothamBold
	titleLabel.Parent = panel
	
	-- Close button
	local closeButton = Instance.new("TextButton")
	closeButton.Name = "CloseButton"
	closeButton.Size = UDim2.new(0, 36, 0, 36)
	closeButton.Position = UDim2.new(1, -44, 0, 8)
	closeButton.BackgroundColor3 = Color3.fromRGB(200, 80, 80)
	closeButton.Text = "âœ•"
	closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	closeButton.TextSize = 20
	closeButton.Font = Enum.Font.GothamBold
	closeButton.Parent = panel
	addCorner(closeButton, 8)
	
	-- Current storage display
	local currentFrame = Instance.new("Frame")
	currentFrame.Name = "CurrentFrame"
	currentFrame.Size = UDim2.new(1, -40, 0, 50)
	currentFrame.Position = UDim2.new(0, 20, 0, 55)
	currentFrame.BackgroundColor3 = Color3.fromRGB(50, 50, 70)
	currentFrame.Parent = panel
	addCorner(currentFrame, 10)
	
	local currentLabel = Instance.new("TextLabel")
	currentLabel.Name = "Label"
	currentLabel.Size = UDim2.new(0.5, 0, 1, 0)
	currentLabel.BackgroundTransparency = 1
	currentLabel.Text = "Current Storage:"
	currentLabel.TextColor3 = UI_CONFIG.SECONDARY_TEXT_COLOR
	currentLabel.TextSize = 16
	currentLabel.Font = Enum.Font.Gotham
	currentLabel.TextXAlignment = Enum.TextXAlignment.Left
	currentLabel.Parent = currentFrame
	
	local currentPadding = Instance.new("UIPadding")
	currentPadding.PaddingLeft = UDim.new(0, 15)
	currentPadding.Parent = currentLabel
	
	local currentValue = Instance.new("TextLabel")
	currentValue.Name = "Value"
	currentValue.Size = UDim2.new(0.5, -15, 1, 0)
	currentValue.Position = UDim2.new(0.5, 0, 0, 0)
	currentValue.BackgroundTransparency = 1
	currentValue.Text = "500"
	currentValue.TextColor3 = UI_CONFIG.TEXT_COLOR
	currentValue.TextSize = 22
	currentValue.Font = Enum.Font.GothamBold
	currentValue.TextXAlignment = Enum.TextXAlignment.Right
	currentValue.Parent = currentFrame
	
	-- Arrow and new storage
	local upgradeFrame = Instance.new("Frame")
	upgradeFrame.Name = "UpgradeFrame"
	upgradeFrame.Size = UDim2.new(1, -40, 0, 60)
	upgradeFrame.Position = UDim2.new(0, 20, 0, 115)
	upgradeFrame.BackgroundColor3 = Color3.fromRGB(60, 80, 60)
	upgradeFrame.Parent = panel
	addCorner(upgradeFrame, 10)
	addStroke(upgradeFrame, UI_CONFIG.ACCENT_COLOR, 2)
	
	local upgradeLabel = Instance.new("TextLabel")
	upgradeLabel.Name = "Label"
	upgradeLabel.Size = UDim2.new(1, 0, 0.4, 0)
	upgradeLabel.BackgroundTransparency = 1
	upgradeLabel.Text = "Upgrade to:"
	upgradeLabel.TextColor3 = UI_CONFIG.SECONDARY_TEXT_COLOR
	upgradeLabel.TextSize = 14
	upgradeLabel.Font = Enum.Font.Gotham
	upgradeLabel.Parent = upgradeFrame
	
	local newStorageValue = Instance.new("TextLabel")
	newStorageValue.Name = "NewValue"
	newStorageValue.Size = UDim2.new(1, 0, 0.6, 0)
	newStorageValue.Position = UDim2.new(0, 0, 0.4, 0)
	newStorageValue.BackgroundTransparency = 1
	newStorageValue.Text = "1,000 (+100%)"
	newStorageValue.TextColor3 = Color3.fromRGB(100, 255, 100)
	newStorageValue.TextSize = 24
	newStorageValue.Font = Enum.Font.GothamBold
	newStorageValue.Parent = upgradeFrame
	
	-- Price and buy button
	local buyFrame = Instance.new("Frame")
	buyFrame.Name = "BuyFrame"
	buyFrame.Size = UDim2.new(1, -40, 0, 60)
	buyFrame.Position = UDim2.new(0, 20, 0, 190)
	buyFrame.BackgroundTransparency = 1
	buyFrame.Parent = panel
	
	local priceLabel = Instance.new("TextLabel")
	priceLabel.Name = "Price"
	priceLabel.Size = UDim2.new(0.5, 0, 1, 0)
	priceLabel.BackgroundTransparency = 1
	priceLabel.Text = "$100"
	priceLabel.TextColor3 = UI_CONFIG.PRICE_COLOR
	priceLabel.TextSize = 28
	priceLabel.Font = Enum.Font.GothamBold
	priceLabel.TextXAlignment = Enum.TextXAlignment.Left
	priceLabel.Parent = buyFrame
	
	local buyButton = Instance.new("TextButton")
	buyButton.Name = "BuyButton"
	buyButton.Size = UDim2.new(0.45, 0, 1, 0)
	buyButton.Position = UDim2.new(0.55, 0, 0, 0)
	buyButton.BackgroundColor3 = UI_CONFIG.BUTTON_COLOR
	buyButton.Text = "UPGRADE"
	buyButton.TextColor3 = Color3.fromRGB(0, 0, 0)
	buyButton.TextSize = 18
	buyButton.Font = Enum.Font.GothamBold
	buyButton.Parent = buyFrame
	addCorner(buyButton, 12)
	
	-- Level indicator
	local levelLabel = Instance.new("TextLabel")
	levelLabel.Name = "Level"
	levelLabel.Size = UDim2.new(1, 0, 0, 25)
	levelLabel.Position = UDim2.new(0, 0, 1, -30)
	levelLabel.BackgroundTransparency = 1
	levelLabel.Text = "Level 0"
	levelLabel.TextColor3 = UI_CONFIG.SECONDARY_TEXT_COLOR
	levelLabel.TextSize = 14
	levelLabel.Font = Enum.Font.Gotham
	levelLabel.Parent = panel
	
	return screenGui
end

--------------------------------------------------------------------------------
-- UI LOGIC
--------------------------------------------------------------------------------

local function updateUI()
	if not StoragePanel then return end
	
	-- Update current storage
	local currentFrame = StoragePanel:FindFirstChild("CurrentFrame")
	if currentFrame then
		local valueLabel = currentFrame:FindFirstChild("Value")
		if valueLabel then
			valueLabel.Text = formatStorage(CurrentStorageInfo.currentMax)
		end
	end
	
	-- Update upgrade target
	local upgradeFrame = StoragePanel:FindFirstChild("UpgradeFrame")
	if upgradeFrame then
		local newValueLabel = upgradeFrame:FindFirstChild("NewValue")
		if newValueLabel then
			local percentIncrease = math.floor((CurrentStorageInfo.nextMaxStorage / CurrentStorageInfo.currentMax - 1) * 100)
			newValueLabel.Text = string.format("%s (+%d%%)", formatStorage(CurrentStorageInfo.nextMaxStorage), percentIncrease)
		end
	end
	
	-- Update price and button
	local buyFrame = StoragePanel:FindFirstChild("BuyFrame")
	if buyFrame then
		local priceLabel = buyFrame:FindFirstChild("Price")
		if priceLabel then
			priceLabel.Text = formatMoney(CurrentStorageInfo.nextPrice)
		end
		
		local buyButton = buyFrame:FindFirstChild("BuyButton")
		if buyButton then
			local affordable = canAfford()
			buyButton.BackgroundColor3 = affordable and UI_CONFIG.BUTTON_COLOR or UI_CONFIG.BUTTON_DISABLED_COLOR
		end
	end
	
	-- Update level
	local levelLabel = StoragePanel:FindFirstChild("Level")
	if levelLabel then
		levelLabel.Text = string.format("Level %d", CurrentStorageInfo.upgradeLevel)
	end
end

local function showPanel()
	if PanelVisible then return end
	if not StoragePanel then return end
	
	-- Get fresh data from server
	local info = GetStorageInfoRemote:InvokeServer()
	if info then
		CurrentStorageInfo = info
	end
	
	updateUI()
	
	PanelVisible = true
	StoragePanel.Visible = true
	StoragePanel.BackgroundTransparency = 1
	
	TweenService:Create(StoragePanel, TweenInfo.new(UI_CONFIG.TWEEN_TIME, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		BackgroundTransparency = 0
	}):Play()
	
	print("StorageUpgradeUI: Opened")
end

local function hidePanel()
	if not PanelVisible then return end
	if not StoragePanel then return end
	
	PanelVisible = false
	
	local tween = TweenService:Create(StoragePanel, TweenInfo.new(UI_CONFIG.TWEEN_TIME, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
		BackgroundTransparency = 1
	})
	
	tween:Play()
	tween.Completed:Connect(function()
		if not PanelVisible then
			StoragePanel.Visible = false
		end
	end)
	
	print("StorageUpgradeUI: Closed")
end

local function handleUpgrade()
	if not canAfford() then
		ErrorSound:Play()
		return
	end
	
	local success, message = UpgradeStorageRemote:InvokeServer()
	
	if success then
		UpgradeSound:Play()
		
		-- Visual feedback - flash the panel green
		if StoragePanel then
			local originalColor = StoragePanel.BackgroundColor3
			StoragePanel.BackgroundColor3 = Color3.fromRGB(80, 150, 80)
			task.delay(0.2, function()
				TweenService:Create(StoragePanel, TweenInfo.new(0.3), {BackgroundColor3 = originalColor}):Play()
			end)
		end
		
		print("StorageUpgradeUI: Upgrade successful!")
	else
		ErrorSound:Play()
		warn("StorageUpgradeUI: Upgrade failed - " .. tostring(message))
	end
end

--------------------------------------------------------------------------------
-- SETUP CONNECTIONS
--------------------------------------------------------------------------------

local function setupConnections()
	if not StoragePanel then return end
	
	-- Close button
	local closeButton = StoragePanel:FindFirstChild("CloseButton")
	if closeButton then
		closeButton.MouseButton1Click:Connect(hidePanel)
	end
	
	-- Buy button
	local buyFrame = StoragePanel:FindFirstChild("BuyFrame")
	if buyFrame then
		local buyButton = buyFrame:FindFirstChild("BuyButton")
		if buyButton then
			buyButton.MouseButton1Click:Connect(handleUpgrade)
			
			-- Hover effects
			buyButton.MouseEnter:Connect(function()
				if canAfford() then
					TweenService:Create(buyButton, TweenInfo.new(0.1), {
						BackgroundColor3 = UI_CONFIG.BUTTON_HOVER_COLOR
					}):Play()
				end
			end)
			
			buyButton.MouseLeave:Connect(function()
				local color = canAfford() and UI_CONFIG.BUTTON_COLOR or UI_CONFIG.BUTTON_DISABLED_COLOR
				TweenService:Create(buyButton, TweenInfo.new(0.1), {
					BackgroundColor3 = color
				}):Play()
			end)
		end
	end
	
	-- Listen for storage upgraded event
	StorageUpgradedEvent.OnClientEvent:Connect(function(newInfo)
		CurrentStorageInfo = newInfo
		updateUI()
	end)
	
	-- Update affordability when money changes
	local leaderstats = Player:WaitForChild("leaderstats", 10)
	if leaderstats then
		local money = leaderstats:WaitForChild("Money", 5)
		if money then
			money:GetPropertyChangedSignal("Value"):Connect(updateUI)
		end
	end
end

local function setupStorageVendorPrompt()
	local mainIsland = workspace:WaitForChild("MainIsland", 30)
	if not mainIsland then
		warn("StorageUpgradeUI: MainIsland not found")
		return
	end
	
	local storageVendor = mainIsland:WaitForChild("StorageVendor", 30)
	if not storageVendor then
		warn("StorageUpgradeUI: StorageVendor not found")
		return
	end
	
	local prompt = storageVendor:WaitForChild("StoragePrompt", 10)
	if prompt then
		prompt.Triggered:Connect(function(playerWhoTriggered)
			if playerWhoTriggered == Player then
				showPanel()
			end
		end)
		print("StorageUpgradeUI: Connected to StorageVendor prompt")
	end
end

-- Close when walking away
local function setupDistanceCheck()
	local RunService = game:GetService("RunService")
	
	RunService.Heartbeat:Connect(function()
		if not PanelVisible then return end
		
		local character = Player.Character
		local hrp = character and character:FindFirstChild("HumanoidRootPart")
		if not hrp then return end
		
		local mainIsland = workspace:FindFirstChild("MainIsland")
		local storageVendor = mainIsland and mainIsland:FindFirstChild("StorageVendor")
		if not storageVendor then return end
		
		local distance = (hrp.Position - storageVendor.Position).Magnitude
		if distance > 20 then
			hidePanel()
		end
	end)
end

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

local function initialize()
	print("StorageUpgradeUI: Initializing...")
	
	-- Create the UI
	StorageGui = createStorageUpgradeGui()
	if not StorageGui then return end
	
	StoragePanel = StorageGui:FindFirstChild("StoragePanel") :: Frame?
	
	-- Setup connections
	setupConnections()
	
	-- Parent GUI
	StorageGui.Parent = PlayerGui
	
	-- Setup vendor prompt listener
	task.spawn(setupStorageVendorPrompt)
	setupDistanceCheck()
	
	print("StorageUpgradeUI: Ready!")
end

-- Start
initialize()



--------------------------------------------------
File: SynergyHUD.client.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\client\SynergyHUD.client.luau
--------------------------------------------------
--[[
	SynergyHUD LocalScript
	
	Displays synergy requirements and progress in a dedicated HUD panel.
	Shows required brainrots with current/required counts and the resulting bonuses.
	
	Features:
	- Visual display of synergy requirements
	- Progress indicators (X/Y) in corner of each requirement
	- Active/Inactive synergy state
	- Effect descriptions when synergy is active
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

-- Player reference
local Player = Players.LocalPlayer
local PlayerGui = Player:WaitForChild("PlayerGui")

-- Wait for shared modules and remotes
local SynergyConfig = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("SynergyConfig"))
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local GetInventoryRemote = RemoteEvents:WaitForChild("GetInventory")
local InventoryChangedEvent = RemoteEvents:WaitForChild("InventoryChanged")

--------------------------------------------------------------------------------
-- UI CONFIGURATION
--------------------------------------------------------------------------------

local UI_CONFIG = {
	-- Panel styling
	PANEL_WIDTH = 300,
	PANEL_MARGIN = 20,
	CORNER_RADIUS = 12,
	
	-- Synergy card styling
	CARD_HEIGHT = 140,
	REQUIREMENT_SIZE = 60,
	
	-- Colors
	BACKGROUND_COLOR = Color3.fromRGB(30, 25, 45),
	PANEL_COLOR = Color3.fromRGB(45, 35, 60),
	CARD_COLOR = Color3.fromRGB(55, 45, 75),
	ACCENT_COLOR = Color3.fromRGB(255, 200, 100),
	ACTIVE_COLOR = Color3.fromRGB(100, 255, 100),
	INACTIVE_COLOR = Color3.fromRGB(150, 150, 150),
	TEXT_COLOR = Color3.fromRGB(255, 255, 255),
	SECONDARY_TEXT_COLOR = Color3.fromRGB(180, 180, 180),
	REQUIREMENT_MET_COLOR = Color3.fromRGB(80, 180, 80),
	REQUIREMENT_UNMET_COLOR = Color3.fromRGB(100, 80, 120),
	
	-- Rarity colors for requirement boxes
	RARITY_COLORS = {
		Normal = Color3.fromRGB(180, 180, 180),
		Spicy = Color3.fromRGB(255, 80, 80),
		Galaxy = Color3.fromRGB(180, 100, 255),
	},
}

--------------------------------------------------------------------------------
-- LOCAL STATE
--------------------------------------------------------------------------------

local SynergyGui: ScreenGui? = nil
local SynergyCards: {[string]: Frame} = {}
local InventoryData: {[string]: {[string]: {total: number, active: number}}} = {}
local SynergyVisible = false

--------------------------------------------------------------------------------
-- UI CREATION HELPERS
--------------------------------------------------------------------------------

local function addCorner(parent: GuiObject, radius: number)
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, radius)
	corner.Parent = parent
	return corner
end

local function addStroke(parent: GuiObject, color: Color3, thickness: number)
	local stroke = Instance.new("UIStroke")
	stroke.Color = color
	stroke.Thickness = thickness
	stroke.Parent = parent
	return stroke
end

--------------------------------------------------------------------------------
-- SYNERGY CARD CREATION
--------------------------------------------------------------------------------

local function createRequirementBox(req: SynergyConfig.SynergyRequirement, current: number): Frame
	local isMet = current >= req.MinCount
	local rarityColor = req.Rarity and UI_CONFIG.RARITY_COLORS[req.Rarity] or UI_CONFIG.TEXT_COLOR
	
	local box = Instance.new("Frame")
	box.Name = req.UnitName
	box.Size = UDim2.new(0, UI_CONFIG.REQUIREMENT_SIZE, 0, UI_CONFIG.REQUIREMENT_SIZE + 16)
	box.BackgroundTransparency = 1
	
	-- Icon box
	local iconFrame = Instance.new("Frame")
	iconFrame.Name = "IconFrame"
	iconFrame.Size = UDim2.new(0, UI_CONFIG.REQUIREMENT_SIZE, 0, UI_CONFIG.REQUIREMENT_SIZE)
	iconFrame.BackgroundColor3 = isMet and UI_CONFIG.REQUIREMENT_MET_COLOR or UI_CONFIG.REQUIREMENT_UNMET_COLOR
	iconFrame.Parent = box
	addCorner(iconFrame, 8)
	addStroke(iconFrame, rarityColor, req.Rarity and 2 or 1)
	
	-- Brainrot icon
	local iconLabel = Instance.new("TextLabel")
	iconLabel.Name = "Icon"
	iconLabel.Size = UDim2.new(1, 0, 1, -20)
	iconLabel.Position = UDim2.new(0, 0, 0, 0)
	iconLabel.BackgroundTransparency = 1
	iconLabel.Text = "ðŸ§ "
	iconLabel.TextSize = 28
	iconLabel.Font = Enum.Font.GothamBold
	iconLabel.TextColor3 = rarityColor
	iconLabel.Parent = iconFrame
	
	-- Count badge (bottom right corner)
	local countBadge = Instance.new("Frame")
	countBadge.Name = "CountBadge"
	countBadge.Size = UDim2.new(0, 36, 0, 18)
	countBadge.Position = UDim2.new(1, -38, 1, -20)
	countBadge.BackgroundColor3 = isMet and UI_CONFIG.ACTIVE_COLOR or UI_CONFIG.BACKGROUND_COLOR
	countBadge.Parent = iconFrame
	addCorner(countBadge, 4)
	
	local countLabel = Instance.new("TextLabel")
	countLabel.Name = "Count"
	countLabel.Size = UDim2.new(1, 0, 1, 0)
	countLabel.BackgroundTransparency = 1
	countLabel.Text = string.format("%d/%d", current, req.MinCount)
	countLabel.TextColor3 = UI_CONFIG.TEXT_COLOR
	countLabel.TextSize = 10
	countLabel.Font = Enum.Font.GothamBold
	countLabel.Parent = countBadge
	
	-- Unit name label below
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Name = "UnitName"
	nameLabel.Size = UDim2.new(1, 0, 0, 16)
	nameLabel.Position = UDim2.new(0, 0, 1, -14)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = req.UnitName:sub(1, 10) .. (req.UnitName:len() > 10 and "..." or "")
	nameLabel.TextColor3 = UI_CONFIG.SECONDARY_TEXT_COLOR
	nameLabel.TextSize = 8
	nameLabel.Font = Enum.Font.Gotham
	nameLabel.TextTruncate = Enum.TextTruncate.AtEnd
	nameLabel.Parent = box
	
	-- Rarity label if applicable
	if req.Rarity then
		local rarityLabel = Instance.new("TextLabel")
		rarityLabel.Name = "Rarity"
		rarityLabel.Size = UDim2.new(1, 0, 0, 12)
		rarityLabel.Position = UDim2.new(0, 0, 0, 2)
		rarityLabel.BackgroundTransparency = 1
		rarityLabel.Text = req.Rarity
		rarityLabel.TextColor3 = rarityColor
		rarityLabel.TextSize = 9
		rarityLabel.Font = Enum.Font.GothamBold
		rarityLabel.Parent = iconFrame
	end
	
	return box
end

local function createSynergyCard(synergy: SynergyConfig.SynergyDefinition): Frame
	local card = Instance.new("Frame")
	card.Name = synergy.Id
	card.Size = UDim2.new(1, 0, 0, UI_CONFIG.CARD_HEIGHT)
	card.BackgroundColor3 = UI_CONFIG.CARD_COLOR
	card.BorderSizePixel = 0
	addCorner(card, 10)
	
	-- Header with icon and name
	local header = Instance.new("Frame")
	header.Name = "Header"
	header.Size = UDim2.new(1, 0, 0, 30)
	header.BackgroundTransparency = 1
	header.Parent = card
	
	local iconLabel = Instance.new("TextLabel")
	iconLabel.Name = "Icon"
	iconLabel.Size = UDim2.new(0, 30, 1, 0)
	iconLabel.Position = UDim2.new(0, 8, 0, 0)
	iconLabel.BackgroundTransparency = 1
	iconLabel.Text = synergy.Icon
	iconLabel.TextSize = 20
	iconLabel.Font = Enum.Font.GothamBold
	iconLabel.Parent = header
	
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Name = "Name"
	nameLabel.Size = UDim2.new(1, -100, 1, 0)
	nameLabel.Position = UDim2.new(0, 40, 0, 0)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = synergy.Name
	nameLabel.TextColor3 = UI_CONFIG.ACCENT_COLOR
	nameLabel.TextSize = 14
	nameLabel.Font = Enum.Font.GothamBold
	nameLabel.TextXAlignment = Enum.TextXAlignment.Left
	nameLabel.Parent = header
	
	-- Status badge
	local statusBadge = Instance.new("Frame")
	statusBadge.Name = "StatusBadge"
	statusBadge.Size = UDim2.new(0, 60, 0, 20)
	statusBadge.Position = UDim2.new(1, -68, 0.5, -10)
	statusBadge.BackgroundColor3 = UI_CONFIG.INACTIVE_COLOR
	statusBadge.Parent = header
	addCorner(statusBadge, 4)
	
	local statusLabel = Instance.new("TextLabel")
	statusLabel.Name = "StatusText"
	statusLabel.Size = UDim2.new(1, 0, 1, 0)
	statusLabel.BackgroundTransparency = 1
	statusLabel.Text = "LOCKED"
	statusLabel.TextColor3 = UI_CONFIG.TEXT_COLOR
	statusLabel.TextSize = 10
	statusLabel.Font = Enum.Font.GothamBold
	statusLabel.Parent = statusBadge
	
	-- Requirements container
	local reqContainer = Instance.new("Frame")
	reqContainer.Name = "Requirements"
	reqContainer.Size = UDim2.new(1, -16, 0, UI_CONFIG.REQUIREMENT_SIZE + 20)
	reqContainer.Position = UDim2.new(0, 8, 0, 32)
	reqContainer.BackgroundTransparency = 1
	reqContainer.Parent = card
	
	local reqLayout = Instance.new("UIListLayout")
	reqLayout.FillDirection = Enum.FillDirection.Horizontal
	reqLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	reqLayout.Padding = UDim.new(0, 20)
	reqLayout.Parent = reqContainer
	
	-- Add "+" sign between requirements
	for i, req in synergy.Requirements do
		if i > 1 then
			local plusLabel = Instance.new("TextLabel")
			plusLabel.Name = "Plus" .. i
			plusLabel.Size = UDim2.new(0, 20, 0, UI_CONFIG.REQUIREMENT_SIZE)
			plusLabel.BackgroundTransparency = 1
			plusLabel.Text = "+"
			plusLabel.TextColor3 = UI_CONFIG.SECONDARY_TEXT_COLOR
			plusLabel.TextSize = 24
			plusLabel.Font = Enum.Font.GothamBold
			plusLabel.LayoutOrder = (i - 1) * 2
			plusLabel.Parent = reqContainer
		end
		
		local reqBox = createRequirementBox(req, 0)
		reqBox.LayoutOrder = i * 2
		reqBox.Parent = reqContainer
	end
	
	-- Effect description
	local effectLabel = Instance.new("TextLabel")
	effectLabel.Name = "Effect"
	effectLabel.Size = UDim2.new(1, -16, 0, 28)
	effectLabel.Position = UDim2.new(0, 8, 1, -32)
	effectLabel.BackgroundColor3 = UI_CONFIG.BACKGROUND_COLOR
	effectLabel.Text = "â–¶ " .. synergy.Description
	effectLabel.TextColor3 = UI_CONFIG.SECONDARY_TEXT_COLOR
	effectLabel.TextSize = 11
	effectLabel.Font = Enum.Font.GothamMedium
	effectLabel.Parent = card
	addCorner(effectLabel, 4)
	
	return card
end

--------------------------------------------------------------------------------
-- UPDATE LOGIC
--------------------------------------------------------------------------------

local function updateSynergyCard(synergyId: string)
	local card = SynergyCards[synergyId]
	if not card then return end
	
	local synergy = SynergyConfig.GetSynergy(synergyId)
	if not synergy then return end
	
	local isActive, progress = SynergyConfig.CheckSynergyProgress(synergyId, InventoryData)
	
	-- Update status badge
	local header = card:FindFirstChild("Header")
	if header then
		local statusBadge = header:FindFirstChild("StatusBadge")
		if statusBadge then
			statusBadge.BackgroundColor3 = isActive and UI_CONFIG.ACTIVE_COLOR or UI_CONFIG.INACTIVE_COLOR
			local statusText = statusBadge:FindFirstChild("StatusText")
			if statusText then
				statusText.Text = isActive and "ACTIVE" or "LOCKED"
			end
		end
	end
	
	-- Update requirement boxes
	local reqContainer = card:FindFirstChild("Requirements")
	if reqContainer then
		for _, req in synergy.Requirements do
			local key = req.UnitName .. (req.Rarity and ("_" .. req.Rarity) or "")
			local progData = progress[key]
			local current = progData and progData.current or 0
			local isMet = current >= req.MinCount
			
			-- Find the requirement box
			for _, child in reqContainer:GetChildren() do
				if child.Name == req.UnitName then
					local iconFrame = child:FindFirstChild("IconFrame")
					if iconFrame then
						-- Update background color
						iconFrame.BackgroundColor3 = isMet and UI_CONFIG.REQUIREMENT_MET_COLOR or UI_CONFIG.REQUIREMENT_UNMET_COLOR
						
						-- Update count badge
						local countBadge = iconFrame:FindFirstChild("CountBadge")
						if countBadge then
							countBadge.BackgroundColor3 = isMet and UI_CONFIG.ACTIVE_COLOR or UI_CONFIG.BACKGROUND_COLOR
							local countLabel = countBadge:FindFirstChild("Count")
							if countLabel then
								countLabel.Text = string.format("%d/%d", current, req.MinCount)
							end
						end
					end
					break
				end
			end
		end
	end
	
	-- Update effect label style
	local effectLabel = card:FindFirstChild("Effect")
	if effectLabel then
		effectLabel.TextColor3 = isActive and UI_CONFIG.ACTIVE_COLOR or UI_CONFIG.SECONDARY_TEXT_COLOR
	end
	
	-- Add glow effect when active
	local existingStroke = card:FindFirstChildOfClass("UIStroke")
	if existingStroke then
		existingStroke:Destroy()
	end
	if isActive then
		addStroke(card, UI_CONFIG.ACTIVE_COLOR, 2)
	end
end

local function updateAllSynergies()
	for synergyId, _ in SynergyCards do
		updateSynergyCard(synergyId)
	end
end

--------------------------------------------------------------------------------
-- SYNERGY HUD CREATION
--------------------------------------------------------------------------------

local function createSynergyHUD(): ScreenGui
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "SynergyHUD"
	screenGui.ResetOnSpawn = false
	screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	
	-- Main panel (bottom left)
	local panel = Instance.new("Frame")
	panel.Name = "SynergyPanel"
	panel.Size = UDim2.new(0, UI_CONFIG.PANEL_WIDTH, 0, 0) -- Height auto-calculated
	panel.Position = UDim2.new(0, UI_CONFIG.PANEL_MARGIN, 1, -UI_CONFIG.PANEL_MARGIN)
	panel.AnchorPoint = Vector2.new(0, 1)
	panel.BackgroundColor3 = UI_CONFIG.PANEL_COLOR
	panel.BackgroundTransparency = 0.1
	panel.BorderSizePixel = 0
	panel.Visible = false
	panel.Parent = screenGui
	addCorner(panel, UI_CONFIG.CORNER_RADIUS)
	addStroke(panel, UI_CONFIG.ACCENT_COLOR, 2)
	
	-- Title
	local titleBar = Instance.new("Frame")
	titleBar.Name = "TitleBar"
	titleBar.Size = UDim2.new(1, 0, 0, 36)
	titleBar.BackgroundColor3 = UI_CONFIG.BACKGROUND_COLOR
	titleBar.BorderSizePixel = 0
	titleBar.Parent = panel
	addCorner(titleBar, UI_CONFIG.CORNER_RADIUS)
	
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "Title"
	titleLabel.Size = UDim2.new(1, -50, 1, 0)
	titleLabel.Position = UDim2.new(0, 12, 0, 0)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Text = "âš¡ SYNERGIES"
	titleLabel.TextColor3 = UI_CONFIG.ACCENT_COLOR
	titleLabel.TextSize = 16
	titleLabel.Font = Enum.Font.GothamBold
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	titleLabel.Parent = titleBar
	
	-- Close button
	local closeButton = Instance.new("TextButton")
	closeButton.Name = "CloseButton"
	closeButton.Size = UDim2.new(0, 28, 0, 28)
	closeButton.Position = UDim2.new(1, -34, 0.5, -14)
	closeButton.BackgroundColor3 = Color3.fromRGB(180, 80, 80)
	closeButton.Text = "âœ•"
	closeButton.TextColor3 = UI_CONFIG.TEXT_COLOR
	closeButton.TextSize = 14
	closeButton.Font = Enum.Font.GothamBold
	closeButton.Parent = titleBar
	addCorner(closeButton, 6)
	
	-- Content container
	local content = Instance.new("Frame")
	content.Name = "Content"
	content.Size = UDim2.new(1, -16, 1, -44)
	content.Position = UDim2.new(0, 8, 0, 40)
	content.BackgroundTransparency = 1
	content.Parent = panel
	
	local layout = Instance.new("UIListLayout")
	layout.SortOrder = Enum.SortOrder.LayoutOrder
	layout.Padding = UDim.new(0, 8)
	layout.Parent = content
	
	-- Create synergy cards
	local synergies = SynergyConfig.GetAllSynergies()
	for i, synergy in synergies do
		local card = createSynergyCard(synergy)
		card.LayoutOrder = i
		card.Parent = content
		SynergyCards[synergy.Id] = card
	end
	
	-- Calculate panel height
	local totalHeight = 44 + 8 -- Title + padding
	for _, synergy in synergies do
		totalHeight = totalHeight + UI_CONFIG.CARD_HEIGHT + 8
	end
	panel.Size = UDim2.new(0, UI_CONFIG.PANEL_WIDTH, 0, totalHeight)
	
	return screenGui
end

--------------------------------------------------------------------------------
-- VISIBILITY CONTROL
--------------------------------------------------------------------------------

local function openSynergyHUD()
	if SynergyVisible then return end
	if not SynergyGui then return end
	local panel = SynergyGui:FindFirstChild("SynergyPanel")
	if not panel then return end
	
	SynergyVisible = true
	
	-- Refresh inventory data
	local inventoryResult = GetInventoryRemote:InvokeServer()
	if inventoryResult then
		-- Handle both new format {[unitName]: {level, rarity, status}} and old format
		if inventoryResult.units then
			local convertedInventory = {}
			for unitName, unitData in pairs(inventoryResult.units) do
				if type(unitData) == "table" then
					-- New format: {level, rarity, status}
					if unitData.level then
						local rarity = unitData.rarity or "Normal"
						if not convertedInventory[unitName] then
							convertedInventory[unitName] = {}
						end
						convertedInventory[unitName][rarity] = {
							total = unitData.level, -- Level = how many times purchased
							active = unitData.status == "placed" and 1 or 0,
						}
					else
						-- Old format, use as-is
						convertedInventory[unitName] = unitData
					end
				end
			end
			InventoryData = convertedInventory
		else
			-- Direct inventory data (old format)
			InventoryData = inventoryResult
		end
		updateAllSynergies()
	end
	
	panel.Visible = true
	panel.Position = UDim2.new(0, -UI_CONFIG.PANEL_WIDTH, 1, -UI_CONFIG.PANEL_MARGIN)
	TweenService:Create(panel, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Position = UDim2.new(0, UI_CONFIG.PANEL_MARGIN, 1, -UI_CONFIG.PANEL_MARGIN)
	}):Play()
end

local function closeSynergyHUD()
	if not SynergyVisible then return end
	if not SynergyGui then return end
	local panel = SynergyGui:FindFirstChild("SynergyPanel")
	if not panel then return end
	
	SynergyVisible = false
	
	local tween = TweenService:Create(panel, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Position = UDim2.new(0, -UI_CONFIG.PANEL_WIDTH, 1, -UI_CONFIG.PANEL_MARGIN)
	})
	tween:Play()
	tween.Completed:Connect(function()
		if not SynergyVisible then
			panel.Visible = false
		end
	end)
end

local function toggleSynergyHUD()
	if SynergyVisible then
		closeSynergyHUD()
	else
		openSynergyHUD()
	end
end

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

local function initialize()
	print("SynergyHUD: Initializing...")
	
	-- Create the HUD
	SynergyGui = createSynergyHUD()
	if not SynergyGui then return end
	SynergyGui.Parent = PlayerGui
	
	-- Setup close button
	local panel = SynergyGui:FindFirstChild("SynergyPanel")
	if panel then
		local titleBar = panel:FindFirstChild("TitleBar")
		if titleBar then
			local closeButton = titleBar:FindFirstChild("CloseButton")
			if closeButton then
				closeButton.MouseButton1Click:Connect(closeSynergyHUD)
				
				closeButton.MouseEnter:Connect(function()
					TweenService:Create(closeButton, TweenInfo.new(0.1), {
						BackgroundColor3 = Color3.fromRGB(220, 100, 100)
					}):Play()
				end)
				
				closeButton.MouseLeave:Connect(function()
					TweenService:Create(closeButton, TweenInfo.new(0.1), {
						BackgroundColor3 = Color3.fromRGB(180, 80, 80)
					}):Play()
				end)
			end
		end
	end
	
	-- Listen for inventory changes to update synergy progress
	-- The new system fires with no arguments, so we re-fetch inventory when notified
	InventoryChangedEvent.OnClientEvent:Connect(function()
		-- Re-fetch inventory from server
		local inventoryResult = GetInventoryRemote:InvokeServer()
		if inventoryResult then
			-- Handle both new format {[unitName]: {level, rarity, status}} and old format
			if inventoryResult.units then
				-- Convert new format to old format for synergy compatibility
				local convertedInventory = {}
				for unitName, unitData in pairs(inventoryResult.units) do
					if type(unitData) == "table" then
						-- New format: {level, rarity, status}
						if unitData.level then
							local rarity = unitData.rarity or "Normal"
							if not convertedInventory[unitName] then
								convertedInventory[unitName] = {}
							end
							convertedInventory[unitName][rarity] = {
								total = unitData.level, -- Level = how many times purchased
								active = unitData.status == "placed" and 1 or 0,
							}
						else
							-- Old format, use as-is
							convertedInventory[unitName] = unitData
						end
					end
				end
				InventoryData = convertedInventory
			else
				-- Direct inventory data (old format)
				InventoryData = inventoryResult
			end
		end
		
		if SynergyVisible then
			updateAllSynergies()
		end
	end)
	
	-- Setup 'Y' key toggle
	UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed then return end
		
		if input.KeyCode == Enum.KeyCode.Y then
			toggleSynergyHUD()
		end
	end)
	
	-- Setup BindableEvent listener
	task.wait(0.5)
	
	local synergyToggleEvent = ReplicatedStorage:FindFirstChild("SynergyToggleEvent")
	if not synergyToggleEvent then
		synergyToggleEvent = Instance.new("BindableEvent")
		synergyToggleEvent.Name = "SynergyToggleEvent"
		synergyToggleEvent.Parent = ReplicatedStorage
	end
	
	synergyToggleEvent.Event:Connect(toggleSynergyHUD)
	
	print("SynergyHUD: Ready! Press 'Y' to toggle.")
end

-- Start
initialize()



--------------------------------------------------
File: TransportUI.client.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\client\TransportUI.client.luau
--------------------------------------------------
--[[
	TransportUI Client Script
	
	Handles the transport/vehicle selection UI for carrying items to market.
	
	Features:
	- Storage view with item list
	- Vehicle selection
	- "Load" and "Load Max" buttons
	- Backpack capacity display
	
	Opens when approaching the Storage on player plot.
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

-- Get player
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- Wait for remotes
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local RemoteFunctions = ReplicatedStorage:WaitForChild("RemoteFunctions")

-- Storage events
local StorageUpdatedEvent = RemoteEvents:WaitForChild("StorageUpdated")
local BackpackUpdatedEvent = RemoteEvents:WaitForChild("BackpackUpdated")
local GetStorageFunction = RemoteEvents:WaitForChild("GetStorage")
local GetBackpackFunction = RemoteEvents:WaitForChild("GetBackpack")

-- Transport events
local VehicleUpdatedEvent = RemoteEvents:WaitForChild("VehicleUpdated")
local LoadFromStorageFunction = RemoteFunctions:WaitForChild("LoadFromStorage")
local LoadMaxFromStorageFunction = RemoteFunctions:WaitForChild("LoadMaxFromStorage")
local GetVehicleInfoFunction = RemoteFunctions:WaitForChild("GetVehicleInfo")

-- Wait for ItemConfig
local Shared = ReplicatedStorage:WaitForChild("Shared")
local ItemConfig = require(Shared:WaitForChild("ItemConfig"))

-- UI Colors (glassmorphism theme)
local COLORS = {
	background = Color3.fromRGB(15, 15, 25),
	panel = Color3.fromRGB(25, 25, 40),
	accent = Color3.fromRGB(100, 200, 255),
	accentDark = Color3.fromRGB(60, 140, 200),
	text = Color3.fromRGB(255, 255, 255),
	textMuted = Color3.fromRGB(150, 150, 170),
	success = Color3.fromRGB(100, 255, 150),
	warning = Color3.fromRGB(255, 200, 100),
	danger = Color3.fromRGB(255, 100, 100),
	itemBg = Color3.fromRGB(35, 35, 55),
}

-- State
local isOpen = false
local currentStorage = {}
local currentBackpack = {}
local storageCapacity = 2000
local storageUsage = 0
local backpackCapacity = 100
local backpackUsage = 0

-- UI References
local screenGui = nil
local mainFrame = nil

--------------------------------------------------------------------------------
-- UI CREATION
--------------------------------------------------------------------------------

local function createScreenGui()
	local gui = Instance.new("ScreenGui")
	gui.Name = "TransportUI"
	gui.ResetOnSpawn = false
	gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	gui.Parent = PlayerGui
	return gui
end

local function createMainFrame(parent)
	local frame = Instance.new("Frame")
	frame.Name = "MainFrame"
	frame.Size = UDim2.new(0, 700, 0, 500)
	frame.Position = UDim2.new(0.5, -350, 0.5, -250)
	frame.BackgroundColor3 = COLORS.background
	frame.BackgroundTransparency = 0.1
	frame.BorderSizePixel = 0
	frame.Visible = false
	frame.Parent = parent
	
	-- Corner rounding
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 16)
	corner.Parent = frame
	
	-- Stroke
	local stroke = Instance.new("UIStroke")
	stroke.Color = COLORS.accent
	stroke.Thickness = 2
	stroke.Transparency = 0.5
	stroke.Parent = frame
	
	return frame
end

local function createHeader(parent)
	local header = Instance.new("Frame")
	header.Name = "Header"
	header.Size = UDim2.new(1, 0, 0, 50)
	header.BackgroundColor3 = COLORS.panel
	header.BackgroundTransparency = 0.3
	header.BorderSizePixel = 0
	header.Parent = parent
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 16)
	corner.Parent = header
	
	-- Title
	local title = Instance.new("TextLabel")
	title.Name = "Title"
	title.Size = UDim2.new(1, -60, 1, 0)
	title.Position = UDim2.new(0, 20, 0, 0)
	title.BackgroundTransparency = 1
	title.Text = "ðŸ“¦ STORAGE & TRANSPORT"
	title.TextColor3 = COLORS.text
	title.TextSize = 22
	title.Font = Enum.Font.GothamBold
	title.TextXAlignment = Enum.TextXAlignment.Left
	title.Parent = header
	
	-- Close button
	local closeBtn = Instance.new("TextButton")
	closeBtn.Name = "CloseButton"
	closeBtn.Size = UDim2.new(0, 40, 0, 40)
	closeBtn.Position = UDim2.new(1, -45, 0, 5)
	closeBtn.BackgroundColor3 = COLORS.danger
	closeBtn.BackgroundTransparency = 0.7
	closeBtn.Text = "âœ•"
	closeBtn.TextColor3 = COLORS.text
	closeBtn.TextSize = 18
	closeBtn.Font = Enum.Font.GothamBold
	closeBtn.Parent = header
	
	local closeCorner = Instance.new("UICorner")
	closeCorner.CornerRadius = UDim.new(0, 8)
	closeCorner.Parent = closeBtn
	
	closeBtn.MouseButton1Click:Connect(function()
		closeUI()
	end)
	
	return header
end

local function createStoragePanel(parent)
	local panel = Instance.new("Frame")
	panel.Name = "StoragePanel"
	panel.Size = UDim2.new(0.5, -15, 1, -120)
	panel.Position = UDim2.new(0, 10, 0, 60)
	panel.BackgroundColor3 = COLORS.panel
	panel.BackgroundTransparency = 0.5
	panel.BorderSizePixel = 0
	panel.Parent = parent
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 12)
	corner.Parent = panel
	
	-- Panel title
	local title = Instance.new("TextLabel")
	title.Name = "Title"
	title.Size = UDim2.new(1, -20, 0, 30)
	title.Position = UDim2.new(0, 10, 0, 10)
	title.BackgroundTransparency = 1
	title.Text = "ðŸ­ PLOT STORAGE"
	title.TextColor3 = COLORS.accent
	title.TextSize = 16
	title.Font = Enum.Font.GothamBold
	title.TextXAlignment = Enum.TextXAlignment.Left
	title.Parent = panel
	
	-- Capacity bar
	local capacityBar = Instance.new("Frame")
	capacityBar.Name = "CapacityBar"
	capacityBar.Size = UDim2.new(1, -20, 0, 20)
	capacityBar.Position = UDim2.new(0, 10, 0, 45)
	capacityBar.BackgroundColor3 = COLORS.itemBg
	capacityBar.BorderSizePixel = 0
	capacityBar.Parent = panel
	
	local capCorner = Instance.new("UICorner")
	capCorner.CornerRadius = UDim.new(0, 6)
	capCorner.Parent = capacityBar
	
	local capacityFill = Instance.new("Frame")
	capacityFill.Name = "Fill"
	capacityFill.Size = UDim2.new(0, 0, 1, 0)
	capacityFill.BackgroundColor3 = COLORS.accent
	capacityFill.BorderSizePixel = 0
	capacityFill.Parent = capacityBar
	
	local fillCorner = Instance.new("UICorner")
	fillCorner.CornerRadius = UDim.new(0, 6)
	fillCorner.Parent = capacityFill
	
	local capacityText = Instance.new("TextLabel")
	capacityText.Name = "Text"
	capacityText.Size = UDim2.new(1, 0, 1, 0)
	capacityText.BackgroundTransparency = 1
	capacityText.Text = "0 / 2000"
	capacityText.TextColor3 = COLORS.text
	capacityText.TextSize = 12
	capacityText.Font = Enum.Font.GothamBold
	capacityText.Parent = capacityBar
	
	-- Item list scroll
	local scrollFrame = Instance.new("ScrollingFrame")
	scrollFrame.Name = "ItemList"
	scrollFrame.Size = UDim2.new(1, -20, 1, -80)
	scrollFrame.Position = UDim2.new(0, 10, 0, 75)
	scrollFrame.BackgroundTransparency = 1
	scrollFrame.ScrollBarThickness = 4
	scrollFrame.ScrollBarImageColor3 = COLORS.accent
	scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
	scrollFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
	scrollFrame.Parent = panel
	
	local listLayout = Instance.new("UIListLayout")
	listLayout.Padding = UDim.new(0, 5)
	listLayout.Parent = scrollFrame
	
	return panel
end

local function createBackpackPanel(parent)
	local panel = Instance.new("Frame")
	panel.Name = "BackpackPanel"
	panel.Size = UDim2.new(0.5, -15, 1, -120)
	panel.Position = UDim2.new(0.5, 5, 0, 60)
	panel.BackgroundColor3 = COLORS.panel
	panel.BackgroundTransparency = 0.5
	panel.BorderSizePixel = 0
	panel.Parent = parent
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 12)
	corner.Parent = panel
	
	-- Panel title
	local title = Instance.new("TextLabel")
	title.Name = "Title"
	title.Size = UDim2.new(1, -20, 0, 30)
	title.Position = UDim2.new(0, 10, 0, 10)
	title.BackgroundTransparency = 1
	title.Text = "ðŸŽ’ BACKPACK"
	title.TextColor3 = COLORS.success
	title.TextSize = 16
	title.Font = Enum.Font.GothamBold
	title.TextXAlignment = Enum.TextXAlignment.Left
	title.Parent = panel
	
	-- Capacity bar
	local capacityBar = Instance.new("Frame")
	capacityBar.Name = "CapacityBar"
	capacityBar.Size = UDim2.new(1, -20, 0, 20)
	capacityBar.Position = UDim2.new(0, 10, 0, 45)
	capacityBar.BackgroundColor3 = COLORS.itemBg
	capacityBar.BorderSizePixel = 0
	capacityBar.Parent = panel
	
	local capCorner = Instance.new("UICorner")
	capCorner.CornerRadius = UDim.new(0, 6)
	capCorner.Parent = capacityBar
	
	local capacityFill = Instance.new("Frame")
	capacityFill.Name = "Fill"
	capacityFill.Size = UDim2.new(0, 0, 1, 0)
	capacityFill.BackgroundColor3 = COLORS.success
	capacityFill.BorderSizePixel = 0
	capacityFill.Parent = capacityBar
	
	local fillCorner = Instance.new("UICorner")
	fillCorner.CornerRadius = UDim.new(0, 6)
	fillCorner.Parent = capacityFill
	
	local capacityText = Instance.new("TextLabel")
	capacityText.Name = "Text"
	capacityText.Size = UDim2.new(1, 0, 1, 0)
	capacityText.BackgroundTransparency = 1
	capacityText.Text = "0 / 100"
	capacityText.TextColor3 = COLORS.text
	capacityText.TextSize = 12
	capacityText.Font = Enum.Font.GothamBold
	capacityText.Parent = capacityBar
	
	-- Item list scroll
	local scrollFrame = Instance.new("ScrollingFrame")
	scrollFrame.Name = "ItemList"
	scrollFrame.Size = UDim2.new(1, -20, 1, -80)
	scrollFrame.Position = UDim2.new(0, 10, 0, 75)
	scrollFrame.BackgroundTransparency = 1
	scrollFrame.ScrollBarThickness = 4
	scrollFrame.ScrollBarImageColor3 = COLORS.success
	scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
	scrollFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
	scrollFrame.Parent = panel
	
	local listLayout = Instance.new("UIListLayout")
	listLayout.Padding = UDim.new(0, 5)
	listLayout.Parent = scrollFrame
	
	return panel
end

local function createBottomBar(parent)
	local bar = Instance.new("Frame")
	bar.Name = "BottomBar"
	bar.Size = UDim2.new(1, -20, 0, 50)
	bar.Position = UDim2.new(0, 10, 1, -55)
	bar.BackgroundColor3 = COLORS.panel
	bar.BackgroundTransparency = 0.5
	bar.BorderSizePixel = 0
	bar.Parent = parent
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 12)
	corner.Parent = bar
	
	-- Load Max button
	local loadMaxBtn = Instance.new("TextButton")
	loadMaxBtn.Name = "LoadMaxButton"
	loadMaxBtn.Size = UDim2.new(0, 200, 0, 40)
	loadMaxBtn.Position = UDim2.new(0.5, -100, 0.5, -20)
	loadMaxBtn.BackgroundColor3 = COLORS.accent
	loadMaxBtn.Text = "ðŸ“¦ LOAD MAX"
	loadMaxBtn.TextColor3 = COLORS.text
	loadMaxBtn.TextSize = 16
	loadMaxBtn.Font = Enum.Font.GothamBold
	loadMaxBtn.Parent = bar
	
	local btnCorner = Instance.new("UICorner")
	btnCorner.CornerRadius = UDim.new(0, 8)
	btnCorner.Parent = loadMaxBtn
	
	loadMaxBtn.MouseButton1Click:Connect(function()
		LoadMaxFromStorageFunction:InvokeServer()
	end)
	
	-- Hover effect
	loadMaxBtn.MouseEnter:Connect(function()
		TweenService:Create(loadMaxBtn, TweenInfo.new(0.2), {BackgroundColor3 = COLORS.accentDark}):Play()
	end)
	
	loadMaxBtn.MouseLeave:Connect(function()
		TweenService:Create(loadMaxBtn, TweenInfo.new(0.2), {BackgroundColor3 = COLORS.accent}):Play()
	end)
	
	return bar
end

local function createItemRow(parent, itemId, count, isStorage)
	local itemInfo = ItemConfig.Items[itemId] or {}
	local tierEmoji = {"âšª", "ðŸŸ¡", "ðŸŸ ", "ðŸ’Ž"}
	local emoji = tierEmoji[itemInfo.tier or 1] or "âšª"
	
	local row = Instance.new("Frame")
	row.Name = "Item_" .. itemId
	row.Size = UDim2.new(1, 0, 0, 40)
	row.BackgroundColor3 = COLORS.itemBg
	row.BackgroundTransparency = 0.3
	row.BorderSizePixel = 0
	row.Parent = parent
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 8)
	corner.Parent = row
	
	-- Item name
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Name = "Name"
	nameLabel.Size = UDim2.new(0.5, -10, 1, 0)
	nameLabel.Position = UDim2.new(0, 10, 0, 0)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = emoji .. " " .. itemId
	nameLabel.TextColor3 = COLORS.text
	nameLabel.TextSize = 14
	nameLabel.Font = Enum.Font.Gotham
	nameLabel.TextXAlignment = Enum.TextXAlignment.Left
	nameLabel.TextTruncate = Enum.TextTruncate.AtEnd
	nameLabel.Parent = row
	
	-- Count
	local countLabel = Instance.new("TextLabel")
	countLabel.Name = "Count"
	countLabel.Size = UDim2.new(0, 60, 1, 0)
	countLabel.Position = UDim2.new(0.5, 0, 0, 0)
	countLabel.BackgroundTransparency = 1
	countLabel.Text = "x" .. count
	countLabel.TextColor3 = COLORS.textMuted
	countLabel.TextSize = 14
	countLabel.Font = Enum.Font.GothamBold
	countLabel.Parent = row
	
	-- Load button (only for storage items)
	if isStorage then
		local loadBtn = Instance.new("TextButton")
		loadBtn.Name = "LoadButton"
		loadBtn.Size = UDim2.new(0, 60, 0, 28)
		loadBtn.Position = UDim2.new(1, -70, 0.5, -14)
		loadBtn.BackgroundColor3 = COLORS.accent
		loadBtn.Text = "LOAD"
		loadBtn.TextColor3 = COLORS.text
		loadBtn.TextSize = 12
		loadBtn.Font = Enum.Font.GothamBold
		loadBtn.Parent = row
		
		local btnCorner = Instance.new("UICorner")
		btnCorner.CornerRadius = UDim.new(0, 6)
		btnCorner.Parent = loadBtn
		
		loadBtn.MouseButton1Click:Connect(function()
			LoadFromStorageFunction:InvokeServer(itemId, 10) -- Load 10 at a time
		end)
	end
	
	return row
end

--------------------------------------------------------------------------------
-- UI UPDATE
--------------------------------------------------------------------------------

local function updateStoragePanel()
	if not mainFrame then return end
	
	local panel = mainFrame:FindFirstChild("StoragePanel")
	if not panel then return end
	
	local scrollFrame = panel:FindFirstChild("ItemList")
	if not scrollFrame then return end
	
	-- Clear existing items
	for _, child in scrollFrame:GetChildren() do
		if child:IsA("Frame") then
			child:Destroy()
		end
	end
	
	-- Add items
	for itemId, count in pairs(currentStorage) do
		if count > 0 then
			createItemRow(scrollFrame, itemId, count, true)
		end
	end
	
	-- Update capacity bar
	local capacityBar = panel:FindFirstChild("CapacityBar")
	if capacityBar then
		local fill = capacityBar:FindFirstChild("Fill")
		local text = capacityBar:FindFirstChild("Text")
		
		local ratio = math.clamp(storageUsage / math.max(1, storageCapacity), 0, 1)
		
		if fill then
			TweenService:Create(fill, TweenInfo.new(0.3), {Size = UDim2.new(ratio, 0, 1, 0)}):Play()
			
			-- Color based on fullness
			local color = COLORS.accent
			if ratio > 0.9 then
				color = COLORS.danger
			elseif ratio > 0.7 then
				color = COLORS.warning
			end
			fill.BackgroundColor3 = color
		end
		
		if text then
			text.Text = string.format("%d / %d", storageUsage, storageCapacity)
		end
	end
end

local function updateBackpackPanel()
	if not mainFrame then return end
	
	local panel = mainFrame:FindFirstChild("BackpackPanel")
	if not panel then return end
	
	local scrollFrame = panel:FindFirstChild("ItemList")
	if not scrollFrame then return end
	
	-- Clear existing items
	for _, child in scrollFrame:GetChildren() do
		if child:IsA("Frame") then
			child:Destroy()
		end
	end
	
	-- Add items
	for itemId, count in pairs(currentBackpack) do
		if count > 0 then
			createItemRow(scrollFrame, itemId, count, false)
		end
	end
	
	-- Update capacity bar
	local capacityBar = panel:FindFirstChild("CapacityBar")
	if capacityBar then
		local fill = capacityBar:FindFirstChild("Fill")
		local text = capacityBar:FindFirstChild("Text")
		
		local ratio = math.clamp(backpackUsage / math.max(1, backpackCapacity), 0, 1)
		
		if fill then
			TweenService:Create(fill, TweenInfo.new(0.3), {Size = UDim2.new(ratio, 0, 1, 0)}):Play()
			
			-- Color based on fullness
			local color = COLORS.success
			if ratio > 0.9 then
				color = COLORS.danger
			elseif ratio > 0.7 then
				color = COLORS.warning
			end
			fill.BackgroundColor3 = color
		end
		
		if text then
			text.Text = string.format("%d / %d", backpackUsage, backpackCapacity)
		end
	end
end

--------------------------------------------------------------------------------
-- OPEN/CLOSE
--------------------------------------------------------------------------------

local function openUI()
	if isOpen then return end
	isOpen = true
	
	-- Fetch latest data
	local storageItems, storageTotal, storageCap = GetStorageFunction:InvokeServer()
	currentStorage = storageItems or {}
	storageUsage = storageTotal or 0
	storageCapacity = storageCap or 2000
	
	local backpackItems, backpackTotal, backpackCap = GetBackpackFunction:InvokeServer()
	currentBackpack = backpackItems or {}
	backpackUsage = backpackTotal or 0
	backpackCapacity = backpackCap or 100
	
	-- Update UI
	updateStoragePanel()
	updateBackpackPanel()
	
	-- Show with animation
	mainFrame.Visible = true
	mainFrame.Size = UDim2.new(0, 700, 0, 0)
	TweenService:Create(mainFrame, TweenInfo.new(0.3, Enum.EasingStyle.Back), {
		Size = UDim2.new(0, 700, 0, 500)
	}):Play()
end

function closeUI()
	if not isOpen then return end
	isOpen = false
	
	TweenService:Create(mainFrame, TweenInfo.new(0.2), {
		Size = UDim2.new(0, 700, 0, 0)
	}):Play()
	
	task.wait(0.2)
	mainFrame.Visible = false
end

--------------------------------------------------------------------------------
-- EVENT HANDLERS
--------------------------------------------------------------------------------

StorageUpdatedEvent.OnClientEvent:Connect(function(items, total, capacity)
	currentStorage = items or {}
	storageUsage = total or 0
	storageCapacity = capacity or 2000
	
	if isOpen then
		updateStoragePanel()
	end
end)

BackpackUpdatedEvent.OnClientEvent:Connect(function(items, total, capacity)
	currentBackpack = items or {}
	backpackUsage = total or 0
	backpackCapacity = capacity or 100
	
	if isOpen then
		updateBackpackPanel()
	end
end)

VehicleUpdatedEvent.OnClientEvent:Connect(function(vehicleId, newCapacity)
	backpackCapacity = newCapacity or 100
	if isOpen then
		updateBackpackPanel()
	end
end)

-- Keyboard toggle (T key)
UserInputService.InputBegan:Connect(function(input, processed)
	if processed then return end
	
	if input.KeyCode == Enum.KeyCode.T then
		if isOpen then
			closeUI()
		else
			openUI()
		end
	end
end)

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

local function initialize()
	-- Create UI
	screenGui = createScreenGui()
	mainFrame = createMainFrame(screenGui)
	createHeader(mainFrame)
	createStoragePanel(mainFrame)
	createBackpackPanel(mainFrame)
	createBottomBar(mainFrame)
	
	print("âœ“ TransportUI initialized - Press T to open")
end

initialize()



--------------------------------------------------
File: UnitHUD.client.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\client\UnitHUD.client.luau
--------------------------------------------------
--[[
	UnitHUD LocalScript
	
	Displays progress bars above brainrot units using BillboardGuis.
	Animates income cycles and shows floating "+$X" text on completion.
	
	Uses CollectionService to detect "ActiveBrainrot" tagged units.
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

-- Player reference
local Player = Players.LocalPlayer

-- Wait for ShopConfig (located in ReplicatedStorage.Shared per Rojo config)
local ShopConfig = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("ShopConfig"))
local ItemConfig = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("ItemConfig"))

-- Configuration
local HUD_CONFIG = {
	-- Billboard settings
	BILLBOARD_SIZE = UDim2.new(0, 80, 0, 30),
	BILLBOARD_OFFSET = Vector3.new(0, 4, 0), -- Above the model
	MAX_DISTANCE = 100,
	
	-- Progress bar
	BAR_HEIGHT = 8,
	BAR_BACKGROUND_COLOR = Color3.fromRGB(40, 40, 50),
	BAR_FILL_COLOR = Color3.fromRGB(100, 220, 100),
	BAR_COMPLETE_COLOR = Color3.fromRGB(255, 215, 0),
	CORNER_RADIUS = 4,
	
	-- Floating text
	FLOAT_DISTANCE = 40,
	FLOAT_DURATION = 1.2,
	TEXT_COLOR = Color3.fromRGB(100, 200, 255),  -- Blue for items
	
	-- Item tier emojis
	TIER_EMOJI = {"âšª", "ðŸŸ¡", "ðŸŸ ", "ðŸ’Ž"},
}

-- Tag
local BRAINROT_TAG = "ActiveBrainrot"

-- Track active HUDs
local ActiveHUDs: {[Instance]: {billboard: BillboardGui, startTime: number}} = {}

--------------------------------------------------------------------------------
-- HUD CREATION
--------------------------------------------------------------------------------

--[[
	Creates a BillboardGui with progress bar for a brainrot unit.
]]
local function createProgressHUD(brainrot: Instance): BillboardGui
	local billboard = Instance.new("BillboardGui")
	billboard.Name = "ProgressHUD"
	billboard.Size = HUD_CONFIG.BILLBOARD_SIZE
	billboard.StudsOffset = HUD_CONFIG.BILLBOARD_OFFSET
	billboard.AlwaysOnTop = false
	billboard.MaxDistance = HUD_CONFIG.MAX_DISTANCE
	billboard.LightInfluence = 0
	
	-- Find adornee (the model's primary part or first part)
	if brainrot:IsA("Model") then
		billboard.Adornee = brainrot.PrimaryPart or brainrot:FindFirstChildWhichIsA("BasePart")
	elseif brainrot:IsA("BasePart") then
		billboard.Adornee = brainrot
	end
	
	-- Container frame
	local container = Instance.new("Frame")
	container.Name = "Container"
	container.Size = UDim2.new(1, 0, 1, 0)
	container.BackgroundTransparency = 1
	container.Parent = billboard
	
	-- Progress bar background
	local barBg = Instance.new("Frame")
	barBg.Name = "BarBackground"
	barBg.Size = UDim2.new(1, 0, 0, HUD_CONFIG.BAR_HEIGHT)
	barBg.Position = UDim2.new(0, 0, 1, -HUD_CONFIG.BAR_HEIGHT - 5)
	barBg.BackgroundColor3 = HUD_CONFIG.BAR_BACKGROUND_COLOR
	barBg.BorderSizePixel = 0
	barBg.Parent = container
	
	local bgCorner = Instance.new("UICorner")
	bgCorner.CornerRadius = UDim.new(0, HUD_CONFIG.CORNER_RADIUS)
	bgCorner.Parent = barBg
	
	-- Progress bar fill
	local barFill = Instance.new("Frame")
	barFill.Name = "BarFill"
	barFill.Size = UDim2.new(0, 0, 1, 0) -- Starts at 0
	barFill.BackgroundColor3 = HUD_CONFIG.BAR_FILL_COLOR
	barFill.BorderSizePixel = 0
	barFill.Parent = barBg
	
	local fillCorner = Instance.new("UICorner")
	fillCorner.CornerRadius = UDim.new(0, HUD_CONFIG.CORNER_RADIUS)
	fillCorner.Parent = barFill
	
	-- Item type label (shows item name)
	local incomeLabel = Instance.new("TextLabel")
	incomeLabel.Name = "ItemLabel"
	incomeLabel.Size = UDim2.new(1, 0, 0, 16)
	incomeLabel.Position = UDim2.new(0, 0, 0, 0)
	incomeLabel.BackgroundTransparency = 1
	incomeLabel.Text = ""
	incomeLabel.TextColor3 = HUD_CONFIG.TEXT_COLOR
	incomeLabel.TextSize = 12
	incomeLabel.Font = Enum.Font.GothamBold
	incomeLabel.TextStrokeTransparency = 0.5
	incomeLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
	incomeLabel.Parent = container
	
	-- Parent to brainrot
	billboard.Parent = brainrot
	
	return billboard
end

--[[
	Creates a floating item text that rises and fades.
]]
local function createFloatingText(billboard: BillboardGui, itemId: string)
	local container = billboard:FindFirstChild("Container")
	if not container then return end
	
	-- Get item info for display
	local itemInfo = ItemConfig.Items[itemId]
	local tier = itemInfo and itemInfo.tier or 1
	local emoji = HUD_CONFIG.TIER_EMOJI[tier] or "âšª"
	
	local floatText = Instance.new("TextLabel")
	floatText.Name = "FloatText"
	floatText.Size = UDim2.new(1, 0, 0, 20)
	floatText.Position = UDim2.new(0, 0, 0.5, -10)
	floatText.BackgroundTransparency = 1
	floatText.Text = emoji .. " +1"
	floatText.TextColor3 = HUD_CONFIG.TEXT_COLOR
	floatText.TextSize = 16
	floatText.Font = Enum.Font.GothamBold
	floatText.TextStrokeTransparency = 0
	floatText.TextStrokeColor3 = Color3.new(0, 0, 0)
	floatText.Parent = container
	
	-- Animate rising and fading
	local riseTween = TweenService:Create(floatText, TweenInfo.new(HUD_CONFIG.FLOAT_DURATION, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Position = UDim2.new(0, 0, -0.5, 0),
		TextTransparency = 1,
		TextStrokeTransparency = 1,
	})
	
	riseTween:Play()
	riseTween.Completed:Connect(function()
		floatText:Destroy()
	end)
	
	-- Scale pop animation
	local originalSize = floatText.TextSize
	floatText.TextSize = originalSize * 1.5
	TweenService:Create(floatText, TweenInfo.new(0.2, Enum.EasingStyle.Elastic), {
		TextSize = originalSize
	}):Play()
end

--[[
	Pulses the progress bar when complete.
]]
local function pulseComplete(barFill: Frame)
	barFill.BackgroundColor3 = HUD_CONFIG.BAR_COMPLETE_COLOR
	
	TweenService:Create(barFill, TweenInfo.new(0.3), {
		BackgroundColor3 = HUD_CONFIG.BAR_FILL_COLOR
	}):Play()
end

--------------------------------------------------------------------------------
-- HUD LOGIC
--------------------------------------------------------------------------------

--[[
	Gets the cycle time for a brainrot from its attributes or ShopConfig.
]]
local function getCycleTime(brainrot: Instance): number
	-- First try attribute (set by server)
	local cycleTime = brainrot:GetAttribute("IncomeInterval")
	if cycleTime then
		return cycleTime
	end
	
	-- Fall back to ShopConfig based on name
	local unitType = brainrot:GetAttribute("UnitType")
	if unitType then
		local config = ShopConfig.GetConfig(unitType)
		if config then
			return config.CycleTime
		end
	end
	
	-- Default fallback
	return 3
end

--[[
	Gets the item produced by a brainrot based on its category.
]]
local function getProducedItem(brainrot: Instance): string
	local unitType = brainrot:GetAttribute("UnitType")
	if unitType then
		local category = ItemConfig.BrainrotToCategory[unitType]
		if category and ItemConfig.BrainrotItems[category] then
			-- Return tier 1 item for display
			return ItemConfig.BrainrotItems[category].tier1 or "Item"
		end
	end
	return "Item"
end

--[[
	Checks if this brainrot belongs to the local player.
]]
local function isOwnedByPlayer(brainrot: Instance): boolean
	local ownerId = brainrot:GetAttribute("OwnerId")
	return ownerId == Player.UserId
end

--[[
	Sets up a progress HUD for a brainrot.
]]
local function setupBrainrotHUD(brainrot: Instance)
	-- Only show HUD for player's own units
	if not isOwnedByPlayer(brainrot) then
		return
	end
	
	-- Skip if already has HUD
	if ActiveHUDs[brainrot] then
		return
	end
	
	local billboard = createProgressHUD(brainrot)
	local cycleTime = getCycleTime(brainrot)
	local producedItem = getProducedItem(brainrot)
	
	-- Use server's spawn time if available, otherwise use current time
	local serverSpawnTime = brainrot:GetAttribute("SpawnTime")
	local startTime = serverSpawnTime or os.time()
	
	ActiveHUDs[brainrot] = {
		billboard = billboard,
		startTime = startTime,
		cycleTime = cycleTime,
		producedItem = producedItem,
		lastCycle = 0,
	}
	
	-- Update item label
	local itemLabel = billboard.Container:FindFirstChild("ItemLabel")
	if itemLabel then
		local itemInfo = ItemConfig.Items[producedItem]
		local tier = itemInfo and itemInfo.tier or 1
		local emoji = HUD_CONFIG.TIER_EMOJI[tier] or "âšª"
		itemLabel.Text = emoji .. " " .. producedItem
	end
end

--[[
	Removes HUD when brainrot is destroyed.
]]
local function cleanupBrainrotHUD(brainrot: Instance)
	local hudData = ActiveHUDs[brainrot]
	if hudData then
		if hudData.billboard then
			hudData.billboard:Destroy()
		end
		ActiveHUDs[brainrot] = nil
	end
end

--[[
	Updates all active progress bars.
]]
local function updateProgressBars()
	local currentTime = os.clock()
	
	for brainrot, hudData in ActiveHUDs do
		-- Check if brainrot still exists
		if not brainrot or not brainrot.Parent then
			cleanupBrainrotHUD(brainrot)
			continue
		end
		
		local billboard = hudData.billboard
		if not billboard or not billboard.Parent then
			continue
		end
		
		local container = billboard:FindFirstChild("Container")
		if not container then continue end
		
		local barBg = container:FindFirstChild("BarBackground")
		if not barBg then continue end
		
		local barFill = barBg:FindFirstChild("BarFill")
		if not barFill then continue end
		
		-- Calculate progress within current cycle
		local cycleTime = hudData.cycleTime
		local elapsed = currentTime - hudData.startTime
		local cycleProgress = (elapsed % cycleTime) / cycleTime
		local currentCycle = math.floor(elapsed / cycleTime)
		
		-- Update bar width
		barFill.Size = UDim2.new(cycleProgress, 0, 1, 0)
		
		-- Check for cycle completion
		if currentCycle > hudData.lastCycle then
			hudData.lastCycle = currentCycle
			
			-- Play completion effects
			pulseComplete(barFill)
			createFloatingText(billboard, hudData.producedItem)
		end
	end
end

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

local function initialize()
	print("UnitHUD: Initializing...")
	
	-- Setup existing brainrots
	for _, brainrot in CollectionService:GetTagged(BRAINROT_TAG) do
		task.spawn(setupBrainrotHUD, brainrot)
	end
	
	-- Listen for new brainrots
	CollectionService:GetInstanceAddedSignal(BRAINROT_TAG):Connect(setupBrainrotHUD)
	
	-- Listen for removed brainrots
	CollectionService:GetInstanceRemovedSignal(BRAINROT_TAG):Connect(cleanupBrainrotHUD)
	
	-- Update progress bars every frame
	RunService.RenderStepped:Connect(updateProgressBars)
	
	print("UnitHUD: Ready!")
end

-- Start
initialize()



--------------------------------------------------
File: AdminService.server.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\server\AdminService.server.luau
--------------------------------------------------
--[[
	AdminService Server Script
	
	Handles admin commands for testing purposes.
	- Reset Plot
	- Add Money
	- Toggle Fly
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

-- Ensure RemoteEvents folder exists
local RemoteEvents = ReplicatedStorage:FindFirstChild("RemoteEvents")
if not RemoteEvents then
	RemoteEvents = Instance.new("Folder")
	RemoteEvents.Name = "RemoteEvents"
	RemoteEvents.Parent = ReplicatedStorage
end

-- Create AdminAction RemoteFunction
local AdminAction = RemoteEvents:FindFirstChild("AdminAction")
if not AdminAction then
	AdminAction = Instance.new("RemoteFunction")
	AdminAction.Name = "AdminAction"
	AdminAction.Parent = RemoteEvents
end

-- Wait for systems
local function waitForSystem(name)
	local attempts = 0
	while not _G[name] and attempts < 50 do
		attempts += 1
		task.wait(0.1)
	end
	return _G[name]
end

-- Handlers
local handlers = {}

handlers.ResetPlot = function(player)
	-- First, reset ALL DataStore data (money, upgrades, inventory, storage, prestige, etc.)
	local DataManager = waitForSystem("DataManager")
	if DataManager and DataManager.ResetPlayerData then
		-- Pass false to NOT keep prestige data - this wipes EVERYTHING
		DataManager.ResetPlayerData(player, false)
		print("âœ“ Admin: Reset all DataStore data for " .. player.Name)
	end
	
	-- Reset the physical plot
	local MapSystem = waitForSystem("MapSystem")
	if MapSystem and MapSystem.ResetPlayerPlot then
		MapSystem.ResetPlayerPlot(player)
		
		-- Also clear inventory in memory
		local BrainrotManager = waitForSystem("BrainrotManager")
		if BrainrotManager and BrainrotManager.ClearPlayerInventory then
			BrainrotManager.ClearPlayerInventory(player)
		end
		
		-- Reset convenience upgrades in memory
		local ConvenienceUpgrades = waitForSystem("ConvenienceUpgrades")
		if ConvenienceUpgrades and ConvenienceUpgrades.ResetPlayerUpgrades then
			ConvenienceUpgrades.ResetPlayerUpgrades(player)
		end
		
		-- Reset shop data in memory
		local ShopManager = waitForSystem("ShopManager")
		if ShopManager and ShopManager.ResetPlayerData then
			ShopManager.ResetPlayerData(player)
		end
		
		-- Reset prestige data in memory
		local PrestigeManager = waitForSystem("PrestigeManager")
		if PrestigeManager and PrestigeManager.ResetPlayerData then
			PrestigeManager.ResetPlayerData(player)
		end
		
		-- Update leaderstats to reflect reset
		local leaderstats = player:FindFirstChild("leaderstats")
		if leaderstats then
			local money = leaderstats:FindFirstChild("Money")
			if money then
				money.Value = 100 -- Default starting money
			end
		end
		
		return true, "Full data reset complete!"
	end
	return false, "MapSystem not available"
end

handlers.AddMoney = function(player)
	local leaderstats = player:FindFirstChild("leaderstats")
	if leaderstats then
		local money = leaderstats:FindFirstChild("Money")
		if money then
			money.Value += 1000000
			return true, "Added $1,000,000"
		end
	end
	return false, "No leaderstats found"
end

handlers.ToggleFly = function(player)
	local isFlying = player:GetAttribute("IsFlying")
	local newState = not isFlying
	player:SetAttribute("IsFlying", newState)
	
	-- Give visual feedback
	if newState then
		-- Create a force if needed, but client handles movement
		-- We just mark the player as allowed to fly
	end
	
	return true, newState and "Flight Enabled" or "Flight Disabled"
end

-- Main handler
AdminAction.OnServerInvoke = function(player, action, ...)
	-- In a real game, check for admin permissions here
	-- if not isAdmin(player) then return false, "No permission" end
	
	local handler = handlers[action]
	if handler then
		return handler(player, ...)
	end
	return false, "Unknown action"
end

print("âœ“ AdminService initialized")



--------------------------------------------------
File: BrainrotManager.server.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\server\BrainrotManager.server.luau
--------------------------------------------------
--[[
	BrainrotManager Server Script (Stacking Version)
	
	Handles:
	1. Spawning ONE unique unit per type per player.
	2. Stacking purchases to upgrade Level/Speed.
	3. Calculating item tiers based on level milestones.
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")

-- Wait for shared modules
local Shared = ReplicatedStorage:WaitForChild("Shared")
local SynergyConfig = require(Shared:WaitForChild("SynergyConfig"))
-- local ItemConfig = require(Shared:WaitForChild("ItemConfig")) -- Uncomment if needed

-- Configuration
local CONFIG = {
	BASE_INTERVAL = 5,          -- Base seconds to produce an item
	SPEED_DECAY = 0.95,         -- Each level multiplies speed by 0.95 (5% faster per level)
	MIN_INTERVAL = 0.5,         -- Cap on how fast it can go
	
	-- Level Milestones for Item Tiers
	TIER_MILESTONES = {
		[10] = 2, -- At Level 10, produce Tier 2 items
		[25] = 3, -- At Level 25, produce Tier 3 items
		[50] = 4, -- At Level 50, produce Tier 4 items
		[100] = 5, -- At Level 100, produce Tier 5 items
	}
}

-- Tags
local BRAINROT_TAG = "ActiveBrainrot"

-- References
local BrainrotsFolder = ReplicatedStorage:WaitForChild("Brainrots")
local PlotsFolder = workspace:WaitForChild("Plots")
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")

-- Events
local InventoryChangedEvent = RemoteEvents:FindFirstChild("InventoryChanged") or Instance.new("RemoteEvent")
InventoryChangedEvent.Name = "InventoryChanged"
InventoryChangedEvent.Parent = RemoteEvents

--------------------------------------------------------------------------------
-- RARITY SYSTEM
--------------------------------------------------------------------------------
local RARITY_CONFIG = {
	Normal = { chance = 0.90, multiplier = 1, color = Color3.fromRGB(255, 255, 255) },
	Spicy = { chance = 0.09, multiplier = 1.5, color = Color3.fromRGB(255, 80, 80) },
	Galaxy = { chance = 0.01, multiplier = 3.0, color = Color3.fromRGB(180, 100, 255) },
}
local RARITY_ORDER = {"Normal", "Spicy", "Galaxy"}

local function rollRarity(): string
	local roll = math.random()
	local cumulative = 0
	for _, rarityName in RARITY_ORDER do
		cumulative = cumulative + RARITY_CONFIG[rarityName].chance
		if roll <= cumulative then return rarityName end
	end
	return "Normal"
end

local function getRarityValue(rarityName)
	for i, name in ipairs(RARITY_ORDER) do
		if name == rarityName then return i end
	end
	return 1
end

--------------------------------------------------------------------------------
-- HELPER FUNCTIONS
--------------------------------------------------------------------------------

local function getPlayerPlot(player: Player): Instance?
	for _, plot in PlotsFolder:GetChildren() do
		local ownerId = plot:GetAttribute("OwnerId")
		if ownerId and ownerId == player.UserId then return plot end
	end
	return nil
end

-- Determine Item Tier based on Level
local function calculateItemTier(level: number): number
	local currentTier = 1
	-- Check milestones. If level >= milestone, set tier.
	-- We iterate in order to ensure we get the highest applicable tier.
	local milestones = {10, 25, 50, 100} 
	for _, reqLevel in ipairs(milestones) do
		if level >= reqLevel then
			currentTier = CONFIG.TIER_MILESTONES[reqLevel]
		end
	end
	return currentTier
end

-- Update the visual stats overhead (BillboardGui)
local function updateVisuals(brainrot: Model)
	local level = brainrot:GetAttribute("Level") or 1
	local tier = brainrot:GetAttribute("ItemTier") or 1
	local rarity = brainrot:GetAttribute("Rarity") or "Normal"
	
	-- Look for a BillboardGui named "StatsDisplay" inside the model
	local head = brainrot:FindFirstChild("Head") or brainrot.PrimaryPart
	if head then
		local gui = head:FindFirstChild("StatsDisplay")
		if not gui then
			-- Create GUI if missing
			gui = Instance.new("BillboardGui")
			gui.Name = "StatsDisplay"
			gui.Size = UDim2.new(4,0, 2,0)
			gui.StudsOffset = Vector3.new(0, 3, 0)
			gui.Parent = head
			
			local label = Instance.new("TextLabel")
			label.Size = UDim2.new(1,0,1,0)
			label.BackgroundTransparency = 1
			label.TextScaled = true
			label.Font = Enum.Font.FredokaOne
			label.Parent = gui
		end
		
		local label = gui:FindFirstChild("TextLabel")
		if label then
			local rarityColor = RARITY_CONFIG[rarity].color
			label.TextColor3 = rarityColor
			label.Text = string.format("Lvl %d | Tier %d\n%s", level, tier, rarity)
		end
	end
end

--------------------------------------------------------------------------------
-- CORE LOGIC
--------------------------------------------------------------------------------

--[[
	Adds a brainrot to the player.
	If they already have this unit type -> Stacks (Level Up).
	If they don't -> Spawns new.
	
	Optional arguments forceRarity and forceLevel are used for data restoration.
]]
local function addBrainrotToPlayer(player: Player, unitName: string, forceRarity: string?, forceLevel: number?): Instance?
	local plot = getPlayerPlot(player)
	if not plot then warn("No plot found for", player.Name) return end

	local brainrotsContainer = plot:FindFirstChild("Brainrots") or Instance.new("Folder", plot)
	brainrotsContainer.Name = "Brainrots"

	-- 1. Check if unit already exists
	local existingUnit = nil
	for _, child in brainrotsContainer:GetChildren() do
		if child:GetAttribute("UnitType") == unitName then
			existingUnit = child
			break
		end
	end

	-- 2. Determine Rarity (Roll or Force)
	local newRarity = forceRarity or rollRarity()

	if existingUnit then
		-------------------------------------------------------
		-- UPGRADE EXISTING UNIT
		-------------------------------------------------------
		local currentLevel = existingUnit:GetAttribute("Level") or 1
		local currentRarity = existingUnit:GetAttribute("Rarity") or "Normal"
		
		-- Update Level
		local newLevel = forceLevel or (currentLevel + 1)
		existingUnit:SetAttribute("Level", newLevel)
		
		-- Update Rarity
		if forceRarity then
			existingUnit:SetAttribute("Rarity", forceRarity)
		elseif getRarityValue(newRarity) > getRarityValue(currentRarity) then
			existingUnit:SetAttribute("Rarity", newRarity)
			print(player.Name .. " upgraded " .. unitName .. " rarity to " .. newRarity .. "!")
			-- Optional: Add visual effect for rarity upgrade here
		end

		-- Recalculate Stats
		local rarityMult = RARITY_CONFIG[existingUnit:GetAttribute("Rarity")].multiplier
		
	else
		-------------------------------------------------------
		-- SPAWN NEW UNIT
		-------------------------------------------------------
		local template = BrainrotsFolder:FindFirstChild(unitName)
		if not template then warn("Template not found:", unitName) return nil end
		
		local brainrot = template:Clone()
		brainrot.Name = unitName -- Keep name simple or unique
		
		-- Set Initial Attributes
		brainrot:SetAttribute("OwnerId", player.UserId)
		brainrot:SetAttribute("UnitType", unitName)
		brainrot:SetAttribute("Level", forceLevel or 1)
		brainrot:SetAttribute("Rarity", newRarity)
		brainrot:SetAttribute("ItemTier", 1) -- Starts at Tier 1
		
		-- Calculate Initial Speed
		local rarityMult = RARITY_CONFIG[newRarity].multiplier
		local initialInterval = CONFIG.BASE_INTERVAL / rarityMult
		brainrot:SetAttribute("IncomeInterval", initialInterval)
		
		-- Store unit hidden (Option B: player places via BuildMode)
		brainrot:SetAttribute("GridSlot", nil)
		brainrot:SetAttribute("IsStored", true)
		
		
		
		
		local plotCF = plot:GetPivot() -- Assuming Plot is a Model
		if plot.PrimaryPart then plotCF = plot.PrimaryPart.CFrame end
		
		-- Offset: Start left, move right
		local offset = Vector3.new(0, -100, 0) -- Hidden below plot until placed via BuildMode
		local spawnCF = plotCF * CFrame.new(offset)
		
		brainrot:PivotTo(spawnCF)
		
		-- Finalize
		brainrot.Parent = brainrotsContainer
		CollectionService:AddTag(brainrot, BRAINROT_TAG)
		updateVisuals(brainrot)
		
		print("Spawned new unit:", unitName)
		
		-- Notify Client (for UI updates)
		InventoryChangedEvent:FireClient(player)
		
		return brainrot
	end
	
	-- Notify Client (for UI updates)
	InventoryChangedEvent:FireClient(player)
	return existingUnit
end

--[[
	Stash a brainrot (called by GridManager).
]]
local function stashBrainrot(player: Player, brainrot: Instance)
	-- Just notify client to update inventory UI
	InventoryChangedEvent:FireClient(player)
end

--[[
	Get placement data for saving.
]]
local function getPlacementData(player: Player)
	local placements = {}
	if _G.GridManager and _G.GridManager.GetGridPositions then
		local gridPos = _G.GridManager.GetGridPositions(player)
		for slot, data in pairs(gridPos) do
			-- Create a copy to avoid modifying the original
			local entry = table.clone(data)
			entry.slotIndex = tonumber(slot)
			table.insert(placements, entry)
		end
	end
	return placements
end

--[[
	Spawn a unit from placement data (loading).
]]
local function spawnFromPlacement(player: Player, data: any)
	-- data: {unitType, rarity, level, slotIndex}
	local unit = addBrainrotToPlayer(player, data.unitType, data.rarity, data.level)
	if unit and _G.GridManager and _G.GridManager.PlaceUnit then
		_G.GridManager.PlaceUnit(player, unit, data.slotIndex)
	end
	return unit
end

--[[
	Set inventory data (Legacy support / Loading).
]]
local function setInventoryData(player: Player, inventoryData: any)
	-- inventoryData: {[unitName]: {[rarity]: {total, active}}}
	-- Convert legacy multi-unit counts to single unit levels
	for unitName, rarityData in pairs(inventoryData) do
		for rarity, counts in pairs(rarityData) do
			if counts.total > 0 then
				-- Use 'total' as the level for the new system
				addBrainrotToPlayer(player, unitName, rarity, counts.total)
			end
		end
	end
end

--------------------------------------------------------------------------------
-- REMOTE HANDLERS
--------------------------------------------------------------------------------

-- Connect this to your UI "Buy" button
local BuyBrainrotRemote = RemoteEvents:FindFirstChild("BuyBrainrot") or Instance.new("RemoteEvent")
BuyBrainrotRemote.Name = "BuyBrainrot"
BuyBrainrotRemote.Parent = RemoteEvents

BuyBrainrotRemote.OnServerEvent:Connect(function(player, unitName)
	-- TODO: Add Money Check here!
	-- local cost = ItemConfig.GetCost(unitName, currentLevel)
	-- if player.Money >= cost then ...
	
	addBrainrotToPlayer(player, unitName)
end)

local GetInventoryRemote = RemoteEvents:FindFirstChild("GetInventory") or Instance.new("RemoteFunction")
GetInventoryRemote.Name = "GetInventory"
GetInventoryRemote.Parent = RemoteEvents

-- Initialization
-- Get Inventory Data (New Structure)
local function getInventoryData(player: Player)
	local inventory = {
		units = {}
	}
	
	-- 1. Get Owned Units (Levels) from ShopManager
	local ownedUnits = {}
	if _G.ShopManager and _G.ShopManager.GetPlayerOwnership then
		local data = _G.ShopManager.GetPlayerOwnership(player)
		if data and data.units then
			for unitName, unitData in pairs(data.units) do
				ownedUnits[unitName] = {
					level = unitData.count, -- count is level now
					rarity = "Normal" -- Default, will update from actual instance if exists
				}
			end
		end
	end
	
	-- 2. Check Placed Status from GridManager
	local placedUnits = {}
	if _G.GridManager and _G.GridManager.GetGridPositions then
		local gridPositions = _G.GridManager.GetGridPositions(player)
		for _, posData in pairs(gridPositions) do
			placedUnits[posData.unitType] = true
		end
	end
	
	-- 3. Check Rarity from actual instances (Brainrots folder)
	local plot = getPlayerPlot(player)
	if plot then
		local brainrotsContainer = plot:FindFirstChild("Brainrots")
		if brainrotsContainer then
			for _, child in brainrotsContainer:GetChildren() do
				local unitName = child:GetAttribute("UnitType")
				if unitName and ownedUnits[unitName] then
					ownedUnits[unitName].rarity = child:GetAttribute("Rarity") or "Normal"
				end
			end
		end
	end
	
	-- 4. Construct Final Inventory
	for unitName, data in pairs(ownedUnits) do
		inventory.units[unitName] = {
			level = data.level,
			rarity = data.rarity,
			status = placedUnits[unitName] and "placed" or "stored"
		}
	end
	
	return inventory
end

GetInventoryRemote.OnServerInvoke = function(player)
	return getInventoryData(player)
end

local function onPlayerRemoving(player)
	-- Cleanup is handled automatically if Brainrots are parented to Plot, 
	-- but if parented elsewhere, destroy them here.
end

Players.PlayerRemoving:Connect(onPlayerRemoving)

print("âœ“ BrainrotManager (Stacking) Initialized")

-- Export API
_G.BrainrotManager = {
	AddUnit = addBrainrotToPlayer,
	SpawnBrainrot = addBrainrotToPlayer, -- Alias for compatibility
	StashBrainrot = stashBrainrot,
	GetPlacementData = getPlacementData,
	SpawnFromPlacement = spawnFromPlacement,
	SetInventoryData = setInventoryData,
	GetPlayerPlot = getPlayerPlot, -- Exposed for DataManager
	
	GetUnitLevel = function(player, unitName)
		local plot = getPlayerPlot(player)
		if not plot then return 0 end
		
		local brainrotsContainer = plot:FindFirstChild("Brainrots")
		if not brainrotsContainer then return 0 end
		
		for _, child in brainrotsContainer:GetChildren() do
			if child:GetAttribute("UnitType") == unitName then
				return child:GetAttribute("Level") or 1
			end
		end
		return 0
	end,
	
	GetInventoryData = function(player)
		return getInventoryData(player).units -- Return just the units table for DataManager compatibility
	end,
}


--------------------------------------------------
File: BuildModeManager.server.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\server\BuildModeManager.server.luau
--------------------------------------------------
--[[
	BuildModeManager Server Script
	
	Manages Build Mode state for players.
	
	Features:
	- Track when player is in Build Mode
	- Validate placement/move requests
	- Apply grid changes atomically
	
	Part of Phase 2B: Build Mode system.
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Remote events
local RemoteEvents = ReplicatedStorage:FindFirstChild("RemoteEvents")
if not RemoteEvents then
	RemoteEvents = Instance.new("Folder")
	RemoteEvents.Name = "RemoteEvents"
	RemoteEvents.Parent = ReplicatedStorage
end

local RemoteFunctions = ReplicatedStorage:FindFirstChild("RemoteFunctions")
if not RemoteFunctions then
	RemoteFunctions = Instance.new("Folder")
	RemoteFunctions.Name = "RemoteFunctions"
	RemoteFunctions.Parent = ReplicatedStorage
end

-- Create events
local BuildModeChangedEvent = RemoteEvents:FindFirstChild("BuildModeChanged") or Instance.new("RemoteEvent")
BuildModeChangedEvent.Name = "BuildModeChanged"
BuildModeChangedEvent.Parent = RemoteEvents

-- Create functions
local EnterBuildModeFunction = RemoteFunctions:FindFirstChild("EnterBuildMode") or Instance.new("RemoteFunction")
EnterBuildModeFunction.Name = "EnterBuildMode"
EnterBuildModeFunction.Parent = RemoteFunctions

local ExitBuildModeFunction = RemoteFunctions:FindFirstChild("ExitBuildMode") or Instance.new("RemoteFunction")
ExitBuildModeFunction.Name = "ExitBuildMode"
ExitBuildModeFunction.Parent = RemoteFunctions

local GetBuildModeStateFunction = RemoteFunctions:FindFirstChild("GetBuildModeState") or Instance.new("RemoteFunction")
GetBuildModeStateFunction.Name = "GetBuildModeState"
GetBuildModeStateFunction.Parent = RemoteFunctions

--------------------------------------------------------------------------------
-- BUILD MODE STATE
--------------------------------------------------------------------------------

-- { [userId] = { inBuildMode = boolean, enterTime = number } }
local PlayerBuildModeState = {}

--[[
	Gets or creates build mode state for a player.
]]
local function getPlayerState(player)
	if not PlayerBuildModeState[player.UserId] then
		PlayerBuildModeState[player.UserId] = {
			inBuildMode = false,
			enterTime = 0,
		}
	end
	return PlayerBuildModeState[player.UserId]
end

--[[
	Checks if player is in build mode.
]]
local function isInBuildMode(player)
	local state = getPlayerState(player)
	return state.inBuildMode
end

--[[
	Enters build mode for a player.
]]
local function enterBuildMode(player)
	local state = getPlayerState(player)
	
	if state.inBuildMode then
		return false, "Already in Build Mode"
	end
	
	state.inBuildMode = true
	state.enterTime = os.clock()
	
	-- Notify all clients (for visibility)
	BuildModeChangedEvent:FireAllClients(player.UserId, true)
	
	print(string.format("âœ“ %s entered Build Mode", player.Name))
	return true
end

--[[
	Exits build mode for a player.
]]
local function exitBuildMode(player)
	local state = getPlayerState(player)
	
	if not state.inBuildMode then
		return false, "Not in Build Mode"
	end
	
	state.inBuildMode = false
	
	-- Notify all clients
	BuildModeChangedEvent:FireAllClients(player.UserId, false)
	
	local duration = os.clock() - state.enterTime
	print(string.format("âœ“ %s exited Build Mode (%.1fs)", player.Name, duration))
	return true
end

--------------------------------------------------------------------------------
-- REMOTE FUNCTION HANDLERS
--------------------------------------------------------------------------------

EnterBuildModeFunction.OnServerInvoke = function(player)
	return enterBuildMode(player)
end

ExitBuildModeFunction.OnServerInvoke = function(player)
	return exitBuildMode(player)
end

GetBuildModeStateFunction.OnServerInvoke = function(player)
	local state = getPlayerState(player)
	return {
		inBuildMode = state.inBuildMode,
		enterTime = state.enterTime,
	}
end

--------------------------------------------------------------------------------
-- CLEANUP
--------------------------------------------------------------------------------

Players.PlayerRemoving:Connect(function(player)
	-- Exit build mode if active
	if isInBuildMode(player) then
		exitBuildMode(player)
	end
	PlayerBuildModeState[player.UserId] = nil
end)

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

print("âœ“ BuildModeManager initialized")

-- Export API
_G.BuildModeManager = {
	EnterBuildMode = enterBuildMode,
	ExitBuildMode = exitBuildMode,
	IsInBuildMode = isInBuildMode,
}



--------------------------------------------------
File: ConvenienceUpgradesManager.server.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\server\ConvenienceUpgradesManager.server.luau
--------------------------------------------------
--[[
	ConvenienceUpgradesManager Server Script
	
	Handles:
	1. Purchase of convenience upgrades
	2. Applying upgrade effects (walkspeed, income multipliers, etc.)
	3. Creating the Convenience Shop vendor on main island
	4. Spawning Auto-Collector bots
	5. Creating Speed Treadmill Bridge boost zones
	
	Works with ConvenienceUpgradesConfig for upgrade definitions.
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")
local _TweenService = game:GetService("TweenService")
local _RunService = game:GetService("RunService")

-- Modules
local ConvenienceUpgradesConfig = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("ConvenienceUpgradesConfig"))

-- Configuration
local SHOP_CONFIG = {
	VENDOR_SIZE = Vector3.new(6, 8, 6),
	VENDOR_POSITION_OFFSET = Vector3.new(30, 10, -30), -- Different position from Island Shop
	BOT_SPEED = 30, -- Walkspeed of collector bots
	BOT_COLLECT_INTERVAL = 5, -- Seconds between collections
}

-- Remote Events
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")

local PurchaseUpgradeEvent = RemoteEvents:FindFirstChild("PurchaseConvenienceUpgrade") or Instance.new("RemoteEvent")
PurchaseUpgradeEvent.Name = "PurchaseConvenienceUpgrade"
PurchaseUpgradeEvent.Parent = RemoteEvents

local GetUpgradesInfoEvent = RemoteEvents:FindFirstChild("GetConvenienceUpgradesInfo") or Instance.new("RemoteFunction")
GetUpgradesInfoEvent.Name = "GetConvenienceUpgradesInfo"
GetUpgradesInfoEvent.Parent = RemoteEvents

-- Player upgrade data (will be saved via DataManager)
local PlayerUpgrades: {[number]: {string}} = {} -- UserId -> list of owned upgrade names

-- Track active collector bots per player
local PlayerCollectorBots: {[number]: {Model}} = {}

--------------------------------------------------------------------------------
-- UPGRADE EFFECT CALCULATIONS
--------------------------------------------------------------------------------

--[[
	Calculates total income multiplier from owned upgrades.
	
	@param upgrades {string} - List of owned upgrade names
	@return number - Total multiplier (1.0 = base, 1.85 = +85%)
]]
local function calculateIncomeMultiplier(upgrades: {string}): number
	local multiplier = 1.0
	
	for _, upgradeName in upgrades do
		local config = ConvenienceUpgradesConfig.GetConfig(upgradeName)
		if config and config.EffectType == "IncomeMultiplier" then
			multiplier = multiplier + config.EffectValue
		end
	end
	
	return multiplier
end

--[[
	Calculates total cycle time reduction from owned upgrades.
	
	@param upgrades {string} - List of owned upgrade names
	@return number - Total reduction (0.0 = no reduction, 0.30 = 30% faster)
]]
local function calculateCycleReduction(upgrades: {string}): number
	local reduction = 0.0
	
	for _, upgradeName in upgrades do
		local config = ConvenienceUpgradesConfig.GetConfig(upgradeName)
		if config and config.EffectType == "CycleReduction" then
			reduction = reduction + config.EffectValue
		end
	end
	
	return math.min(reduction, 0.75) -- Cap at 75% reduction
end

--[[
	Calculates walkspeed multiplier from owned upgrades.
	
	@param upgrades {string} - List of owned upgrade names
	@return number - Total multiplier (1.0 = base)
]]
local function calculateWalkspeedMultiplier(upgrades: {string}): number
	local multiplier = 1.0
	
	for _, upgradeName in upgrades do
		local config = ConvenienceUpgradesConfig.GetConfig(upgradeName)
		if config and config.EffectType == "Walkspeed" then
			multiplier = multiplier + config.EffectValue
		end
	end
	
	return multiplier
end

--[[
	Gets the bridge speed multiplier.
	
	@param upgrades {string} - List of owned upgrade names
	@return number - Bridge speed multiplier (1 = normal, 2 or 3 = boosted)
]]
local function getBridgeSpeedMultiplier(upgrades: {string}): number
	local highest = 1
	
	for _, upgradeName in upgrades do
		local config = ConvenienceUpgradesConfig.GetConfig(upgradeName)
		if config and config.EffectType == "BridgeSpeed" then
			highest = math.max(highest, config.EffectValue)
		end
	end
	
	return highest
end

--[[
	Checks if player has a specific effect type.
	
	@param upgrades {string} - List of owned upgrade names
	@param effectType string - The effect type to check
	@return boolean
]]
local function hasEffect(upgrades: {string}, effectType: string): boolean
	for _, upgradeName in upgrades do
		local config = ConvenienceUpgradesConfig.GetConfig(upgradeName)
		if config and config.EffectType == effectType then
			return true
		end
	end
	return false
end

--[[
	Gets lucky chance value (for 2x bonus).
	
	@param upgrades {string} - List of owned upgrade names
	@return number - Chance (0.0 to 1.0)
]]
local function getLuckyChance(upgrades: {string}): number
	for _, upgradeName in upgrades do
		local config = ConvenienceUpgradesConfig.GetConfig(upgradeName)
		if config and config.EffectType == "LuckyChance" then
			return config.EffectValue
		end
	end
	return 0
end

--[[
	Gets critical chance value (for 5x bonus).
	
	@param upgrades {string} - List of owned upgrade names
	@return number - Chance (0.0 to 1.0)
]]
local function getCriticalChance(upgrades: {string}): number
	for _, upgradeName in upgrades do
		local config = ConvenienceUpgradesConfig.GetConfig(upgradeName)
		if config and config.EffectType == "CriticalChance" then
			return config.EffectValue
		end
	end
	return 0
end

--[[
	Counts how many auto-collector bots player should have.
	
	@param upgrades {string} - List of owned upgrade names
	@return number - Number of bots
]]
local function countAutoCollectorBots(upgrades: {string}): number
	local count = 0
	
	for _, upgradeName in upgrades do
		local config = ConvenienceUpgradesConfig.GetConfig(upgradeName)
		if config and config.EffectType == "AutoCollector" then
			count = count + config.EffectValue
		end
	end
	
	return count
end

--------------------------------------------------------------------------------
-- APPLY UPGRADE EFFECTS
--------------------------------------------------------------------------------

--[[
	Applies walkspeed and jump boosts to a player's character.
	Called when character spawns or upgrades are purchased.
	
	@param player Player - The player to apply effects to
]]
local function applyCharacterEffects(player: Player)
	local character = player.Character
	if not character then return end
	
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid then return end
	
	local upgrades = PlayerUpgrades[player.UserId] or {}
	
	-- Apply walkspeed
	local walkMultiplier = calculateWalkspeedMultiplier(upgrades)
	humanoid.WalkSpeed = 16 * walkMultiplier -- 16 is default Roblox walkspeed
	
	-- Apply jump boost
	local jumpMultiplier = 1.0
	for _, upgradeName in upgrades do
		local config = ConvenienceUpgradesConfig.GetConfig(upgradeName)
		if config and config.EffectType == "JumpPower" then
			jumpMultiplier = jumpMultiplier + config.EffectValue
		end
	end
	humanoid.JumpPower = 50 * jumpMultiplier -- 50 is default Roblox jump power
	
	print(string.format("âœ“ Applied effects to %s: WalkSpeed=%.1f, JumpPower=%.1f", 
		player.Name, humanoid.WalkSpeed, humanoid.JumpPower))
end

--------------------------------------------------------------------------------
-- AUTO-COLLECTOR BOT SYSTEM
--------------------------------------------------------------------------------

--[[
	Creates a cute collector bot model for a player.
	
	@param player Player - The bot's owner
	@param botIndex number - Which bot this is (1, 2, etc.)
	@return Model - The bot model
]]
local function createCollectorBot(player: Player, botIndex: number): Model
	local bot = Instance.new("Model")
	bot.Name = "CollectorBot_" .. botIndex
	
	-- Main body (cute cube)
	local body = Instance.new("Part")
	body.Name = "Body"
	body.Size = Vector3.new(3, 3, 3)
		local botColor = botIndex == 1 and "Bright blue" or "Bright green"
	body.BrickColor = BrickColor.new(botColor)
	body.Material = Enum.Material.SmoothPlastic
	body.Anchored = false
	body.CanCollide = false
	body.Parent = bot
	
	-- Make it round
	local mesh = Instance.new("SpecialMesh")
	mesh.MeshType = Enum.MeshType.Sphere
	mesh.Parent = body
	
	-- Eyes
	local eye1 = Instance.new("Part")
	eye1.Name = "Eye1"
	eye1.Size = Vector3.new(0.5, 0.5, 0.5)
	eye1.BrickColor = BrickColor.new("White")
	eye1.Material = Enum.Material.Neon
	eye1.Anchored = false
	eye1.CanCollide = false
	eye1.Parent = bot
	
	local eye1Mesh = Instance.new("SpecialMesh")
	eye1Mesh.MeshType = Enum.MeshType.Sphere
	eye1Mesh.Parent = eye1
	
	local eye2 = eye1:Clone()
	eye2.Name = "Eye2"
	eye2.Parent = bot
	
	-- Weld eyes to body
	local weld1 = Instance.new("WeldConstraint")
	weld1.Part0 = body
	weld1.Part1 = eye1
	weld1.Parent = body
	eye1.CFrame = body.CFrame * CFrame.new(0.6, 0.5, -1.2)
	
	local weld2 = Instance.new("WeldConstraint")
	weld2.Part0 = body
	weld2.Part1 = eye2
	weld2.Parent = body
	eye2.CFrame = body.CFrame * CFrame.new(-0.6, 0.5, -1.2)
	
	-- Billboard with cute label
	local billboard = Instance.new("BillboardGui")
	billboard.Size = UDim2.new(3, 0, 1, 0)
	billboard.StudsOffset = Vector3.new(0, 2.5, 0)
	billboard.AlwaysOnTop = false
	billboard.Parent = body
	
	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, 0, 1, 0)
	label.BackgroundTransparency = 1
	label.Text = "ðŸ¤– Collector Bot " .. botIndex
	label.TextColor3 = Color3.new(1, 1, 1)
	label.TextScaled = true
	label.Font = Enum.Font.GothamBold
	label.Parent = billboard
	
	bot.PrimaryPart = body
	
	-- Set ownership
	bot:SetAttribute("OwnerId", player.UserId)
	bot:SetAttribute("BotIndex", botIndex)
	
	-- Tag for system
	CollectionService:AddTag(bot, "CollectorBot")
	
	return bot
end

--[[
	Updates the collector bots for a player based on their upgrades.
	
	@param player Player - The player to update bots for
]]
local function updateCollectorBots(player: Player)
	local upgrades = PlayerUpgrades[player.UserId] or {}
	local neededBots = countAutoCollectorBots(upgrades)
	local currentBots = PlayerCollectorBots[player.UserId] or {}
	
	-- Get player's plot
	local plot = _G.BrainrotManager and _G.BrainrotManager.GetPlayerPlot(player)
	if not plot then
		return
	end
	
	-- Create new bots if needed
	while #currentBots < neededBots do
		local botIndex = #currentBots + 1
		local bot = createCollectorBot(player, botIndex)
		
		-- Get plot position for initial spawn
		local plotPart = plot:FindFirstChild("Island") or plot:FindFirstChildWhichIsA("BasePart")
		if plotPart then
			bot:PivotTo(plotPart.CFrame * CFrame.new(0, 10, 0))
		end
		
		bot.Parent = plot
		table.insert(currentBots, bot)
		print(string.format("âœ“ Spawned Collector Bot %d for %s", botIndex, player.Name))
	end
	
	-- Remove excess bots if player lost upgrades (shouldn't normally happen)
	while #currentBots > neededBots do
		local bot = table.remove(currentBots)
		if bot then
			bot:Destroy()
		end
	end
	
	PlayerCollectorBots[player.UserId] = currentBots
end

--------------------------------------------------------------------------------
-- VENDOR CREATION
--------------------------------------------------------------------------------

--[[
	Creates the Convenience Upgrades Shop vendor part on the main island.
]]
local function createConvenienceShopVendor()
	-- Wait for main island
	local mainIsland = workspace:WaitForChild("MainIsland", 10)
	if not mainIsland then
		warn("MainIsland not found, cannot create Convenience Shop vendor")
		return nil
	end
	
	-- Check if vendor already exists
	if mainIsland:FindFirstChild("ConvenienceShopVendor") then
		return mainIsland:FindFirstChild("ConvenienceShopVendor")
	end
	
	-- Get main island position
	local mainIslandPos = Vector3.new(0, 30, 0)
	local islandPart = mainIsland:FindFirstChild("Island") or mainIsland:FindFirstChildWhichIsA("BasePart")
	if islandPart then
		mainIslandPos = islandPart.Position
	end
	
	-- Create the vendor part
	local vendorPart = Instance.new("Part")
	vendorPart.Name = "ConvenienceShopVendor"
	vendorPart.Size = SHOP_CONFIG.VENDOR_SIZE
	vendorPart.BrickColor = BrickColor.new("Bright orange")
	vendorPart.Material = Enum.Material.Neon
	vendorPart.Anchored = true
	vendorPart.CanCollide = true
	vendorPart.Position = mainIslandPos + SHOP_CONFIG.VENDOR_POSITION_OFFSET
	
	-- Create BillboardGui for display
	local billboardGui = Instance.new("BillboardGui")
	billboardGui.Name = "ShopDisplay"
	billboardGui.Size = UDim2.new(6, 0, 3, 0)
	billboardGui.StudsOffset = Vector3.new(0, 6, 0)
	billboardGui.AlwaysOnTop = false
	billboardGui.Parent = vendorPart
	
	-- Background frame
	local bgFrame = Instance.new("Frame")
	bgFrame.Name = "Background"
	bgFrame.Size = UDim2.new(1, 0, 1, 0)
	bgFrame.BackgroundColor3 = Color3.fromRGB(60, 40, 20)
	bgFrame.BackgroundTransparency = 0.2
	bgFrame.Parent = billboardGui
	
	local uiCorner = Instance.new("UICorner")
	uiCorner.CornerRadius = UDim.new(0.1, 0)
	uiCorner.Parent = bgFrame
	
	-- Title label
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "Title"
	titleLabel.Size = UDim2.new(1, 0, 0.4, 0)
	titleLabel.Position = UDim2.new(0, 0, 0, 0)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Text = "âš¡ UPGRADES"
	titleLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
	titleLabel.TextScaled = true
	titleLabel.Font = Enum.Font.GothamBold
	titleLabel.Parent = bgFrame
	
	-- Subtitle label
	local subtitleLabel = Instance.new("TextLabel")
	subtitleLabel.Name = "Subtitle"
	subtitleLabel.Size = UDim2.new(1, 0, 0.3, 0)
	subtitleLabel.Position = UDim2.new(0, 0, 0.4, 0)
	subtitleLabel.BackgroundTransparency = 1
	subtitleLabel.Text = "Speed â€¢ Income â€¢ Bots"
	subtitleLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
	subtitleLabel.TextScaled = true
	subtitleLabel.Font = Enum.Font.Gotham
	subtitleLabel.Parent = bgFrame
	
	-- Instruction label
	local instructLabel = Instance.new("TextLabel")
	instructLabel.Name = "Instruction"
	instructLabel.Size = UDim2.new(1, 0, 0.25, 0)
	instructLabel.Position = UDim2.new(0, 0, 0.7, 0)
	instructLabel.BackgroundTransparency = 1
	instructLabel.Text = "Press E to open"
	instructLabel.TextColor3 = Color3.fromRGB(180, 180, 180)
	instructLabel.TextScaled = true
	instructLabel.Font = Enum.Font.Gotham
	instructLabel.Parent = bgFrame
	
	-- Tag for proximity detection
	CollectionService:AddTag(vendorPart, "ConvenienceShopVendor")
	
	-- Create ProximityPrompt for interaction
	local prompt = Instance.new("ProximityPrompt")
	prompt.Name = "ConvenienceShopPrompt"
	prompt.ActionText = "Open Upgrades"
	prompt.ObjectText = "Convenience Shop"
	prompt.KeyboardKeyCode = Enum.KeyCode.E
	prompt.HoldDuration = 0
	prompt.MaxActivationDistance = 10
	prompt.RequiresLineOfSight = false
	prompt.Parent = vendorPart
	
	vendorPart.Parent = mainIsland
	
	print("âœ“ Created Convenience Shop vendor on Main Island")
	return vendorPart
end

--------------------------------------------------------------------------------
-- PURCHASE HANDLING
--------------------------------------------------------------------------------

--[[
	Handles a player's request to purchase an upgrade.
	
	@param player Player - The player attempting to purchase
	@param upgradeName string - The upgrade to purchase
	@return boolean, string - Success status and message
]]
local function handleUpgradePurchase(player: Player, upgradeName: string): (boolean, string)
	-- Get player's owned upgrades
	local ownedUpgrades = PlayerUpgrades[player.UserId] or {}
	
	-- Check if can purchase
	local canPurchase, reason = ConvenienceUpgradesConfig.CanPurchase(upgradeName, ownedUpgrades)
	if not canPurchase then
		return false, reason or "Cannot purchase"
	end
	
	-- Get upgrade config
	local config = ConvenienceUpgradesConfig.GetConfig(upgradeName)
	if not config then
		return false, "Upgrade not found"
	end
	
	-- Check money
	local leaderstats = player:FindFirstChild("leaderstats")
	if not leaderstats then
		return false, "Could not find your money"
	end
	
	local money = leaderstats:FindFirstChild("Money")
	if not money then
		return false, "Could not find your money"
	end
	
	if money.Value < config.Price then
		return false, string.format("Not enough money! Need $%d, have $%d", config.Price, money.Value)
	end
	
	-- Deduct money
	money.Value = money.Value - config.Price
	
	-- Add to owned upgrades
	table.insert(ownedUpgrades, upgradeName)
	PlayerUpgrades[player.UserId] = ownedUpgrades
	
	-- Apply effects immediately
	applyCharacterEffects(player)
	updateCollectorBots(player)
	
	-- Update brainrot income/cycle if applicable
	applyBrainrotUpgrades(player)
	
	print(string.format("âœ“ %s purchased '%s' for $%d", player.Name, upgradeName, config.Price))
	
	return true, string.format("Purchased %s %s!", config.Icon, upgradeName)
end

--[[
	Applies income multiplier and cycle reduction to player's brainrots.
	
	@param player Player - The player to update
]]
function applyBrainrotUpgrades(player: Player)
	local upgrades = PlayerUpgrades[player.UserId] or {}
	local incomeMultiplier = calculateIncomeMultiplier(upgrades)
	local cycleReduction = calculateCycleReduction(upgrades)
	local luckyChance = getLuckyChance(upgrades)
	local criticalChance = getCriticalChance(upgrades)
	
	-- Store modifiers on player for BrainrotManager to read
	player:SetAttribute("IncomeMultiplier", incomeMultiplier)
	player:SetAttribute("CycleReduction", cycleReduction)
	player:SetAttribute("LuckyChance", luckyChance)
	player:SetAttribute("CriticalChance", criticalChance)
	
	print(string.format("âœ“ Updated %s's brainrot modifiers: Income=%.0f%%, Cycle=-%.0f%%, Lucky=%.0f%%, Crit=%.0f%%",
		player.Name, (incomeMultiplier - 1) * 100, cycleReduction * 100, luckyChance * 100, criticalChance * 100))
end

--------------------------------------------------------------------------------
-- REMOTE EVENT HANDLERS
--------------------------------------------------------------------------------

PurchaseUpgradeEvent.OnServerEvent:Connect(function(player, upgradeName)
	local success, message = handleUpgradePurchase(player, upgradeName)
	PurchaseUpgradeEvent:FireClient(player, success, message)
end)

GetUpgradesInfoEvent.OnServerInvoke = function(player)
	local ownedUpgrades = PlayerUpgrades[player.UserId] or {}
	
	return {
		OwnedUpgrades = ownedUpgrades,
		AllUpgrades = ConvenienceUpgradesConfig.GetAllUpgradesSorted(),
		Categories = ConvenienceUpgradesConfig.GetCategories(),
	}
end

--------------------------------------------------------------------------------
-- PLAYER EVENTS
--------------------------------------------------------------------------------

local function onPlayerAdded(player: Player)
	-- Only initialize if not already set by DataManager (avoids overwriting restored upgrades)
	if PlayerUpgrades[player.UserId] == nil then
		PlayerUpgrades[player.UserId] = {}
	end
	
	-- Apply effects when character spawns
	player.CharacterAdded:Connect(function()
		task.wait(0.5) -- Wait for humanoid
		applyCharacterEffects(player)
	end)
	
	-- Apply to existing character
	if player.Character then
		applyCharacterEffects(player)
	end
end

local function onPlayerRemoving(player: Player)
	-- Clean up bots
	local bots = PlayerCollectorBots[player.UserId]
	if bots then
		for _, bot in bots do
			bot:Destroy()
		end
	end
	PlayerCollectorBots[player.UserId] = nil
	
	-- Clear upgrades from memory (DataManager handles saving)
	PlayerUpgrades[player.UserId] = nil
end

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

local function initialize()
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	print("   ConvenienceUpgradesManager - Initializing")
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	
	-- Connect player events
	Players.PlayerAdded:Connect(onPlayerAdded)
	Players.PlayerRemoving:Connect(onPlayerRemoving)
	
	-- Handle existing players
	for _, player in Players:GetPlayers() do
		task.spawn(onPlayerAdded, player)
	end
	
	-- Wait for other systems
	task.wait(2)
	
	-- Create the vendor
	createConvenienceShopVendor()
	
	print("âœ“ ConvenienceUpgradesManager initialized")
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
end

task.spawn(initialize)

--------------------------------------------------------------------------------
-- MODULE API
--------------------------------------------------------------------------------

_G.ConvenienceUpgrades = {
	GetPlayerUpgrades = function(player: Player): {string}
		return PlayerUpgrades[player.UserId] or {}
	end,
	SetPlayerUpgrades = function(player: Player, upgrades: {string})
		PlayerUpgrades[player.UserId] = upgrades
		applyCharacterEffects(player)
		updateCollectorBots(player)
		applyBrainrotUpgrades(player)
	end,
	CalculateIncomeMultiplier = calculateIncomeMultiplier,
	CalculateCycleReduction = calculateCycleReduction,
	GetBridgeSpeedMultiplier = getBridgeSpeedMultiplier,
	HasTeleportHome = function(player: Player): boolean
		local upgrades = PlayerUpgrades[player.UserId] or {}
		return hasEffect(upgrades, "TeleportHome")
	end,
	ResetPlayerUpgrades = function(player: Player)
		-- Clear owned upgrades
		PlayerUpgrades[player.UserId] = {}
		
		-- Destroy any collector bots
		local bots = PlayerCollectorBots[player.UserId]
		if bots then
			for _, bot in bots do
				bot:Destroy()
			end
		end
		PlayerCollectorBots[player.UserId] = nil
		
		-- Reset character effects to defaults
		applyCharacterEffects(player)
		
		-- Clear modifiers
		player:SetAttribute("IncomeMultiplier", 1)
		player:SetAttribute("CycleReduction", 0)
		player:SetAttribute("LuckyChance", 0)
		player:SetAttribute("CriticalChance", 0)
		
		print(string.format("âœ“ Reset convenience upgrades for %s", player.Name))
	end,
}



--------------------------------------------------
File: DataManager.server.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\server\DataManager.server.luau
--------------------------------------------------
--[[
	DataManager Server Script
	
	Handles saving and loading player data using DataStoreService.
	
	Saves:
	- Money (from leaderstats)
	- Owned unit counts (from ShopManager)
	- Unlock progress (from ShopManager)
	
	Data is saved on:
	- Player leaving
	- Auto-save every 5 minutes
	- Game shutdown (BindToClose)
]]

-- Services
local Players = game:GetService("Players")
local DataStoreService = game:GetService("DataStoreService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Wait for shared modules
local ShopConfig = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("ShopConfig"))

-- DataStore
local PlayerDataStore = DataStoreService:GetDataStore("BrainRotClickerData_v1")

-- Configuration
local CONFIG = {
	AUTO_SAVE_INTERVAL = 300, -- 5 minutes
	DEFAULT_MONEY = 100,      -- Starting money for new players
	RETRY_ATTEMPTS = 3,
	RETRY_DELAY = 1,
}

-- Cached player data (to avoid reading twice)
local PlayerDataCache: {[Player]: {money: number, ownedUnits: {[string]: number}, unlockProgress: number, maxStorage: number}} = {}

-- Track if data has been loaded
local DataLoaded: {[Player]: boolean} = {}

-- Wait for BrainrotManager API (loaded via _G)
local function waitForBrainrotManager()
	local attempts = 0
	while not _G.BrainrotManager and attempts < 50 do
		attempts += 1
		task.wait(0.1)
	end
	return _G.BrainrotManager
end

--------------------------------------------------------------------------------
-- DATA STRUCTURE
--------------------------------------------------------------------------------

--[[
	Default data structure for new players
]]
local function getDefaultData()
	return {
		money = CONFIG.DEFAULT_MONEY,
		ownedUnits = {},
		unlockProgress = 5, -- 5 units unlocked initially (matches ShopConfig.INITIAL_UNLOCKED)
		maxStorage = 500,   -- Default max storage (legacy)
		purchasedTiers = 1, -- Number of purchased tiers (starts at 1)
		convenienceUpgrades = {}, -- Purchased convenience upgrades
		-- Prestige system data (never reset on prestige)
		lifetimeEarnings = 0,     -- Total money ever earned
		totalMeatballs = 0,       -- Lifetime accumulated meatballs
		spentMeatballs = 0,       -- Meatballs spent in shop
		prestigeCount = 0,        -- Number of times prestiged
		meatballUpgrades = {},    -- Purchased permanent upgrades
		-- Brainrot persistence data
		brainrotInventory = {},   -- Full inventory with rarities: {[unitName]: {[rarity]: {total, active}}}
		brainrotPlacements = {},  -- Array of placed brainrots with positions/attributes
		-- Item production system data (Sell a Brainrot)
		itemStorage = {},         -- Items in plot storage: {[itemId]: count}
		backpack = {},            -- Items in player's backpack: {[itemId]: count}
		storageCapacity = 2000,   -- Current storage capacity (upgradeable)
		selectedVehicle = "Sneakers", -- Currently selected transport vehicle
		vehicleCapacities = {},   -- Vehicle upgrade levels: {[vehicleId]: capacity}
		gridPositions = {},       -- Brainrot grid positions: {[slotIndex]: brainrotId}
		discoveredSynergies = {}, -- Discovered synergy recipes: {[synergyId]: true}
	}
end

--------------------------------------------------------------------------------
-- SAVE / LOAD FUNCTIONS
--------------------------------------------------------------------------------

--[[
	Loads player data from DataStore.
	Includes maxStorage for storage upgrade persistence.
	Returns the data or default data if not found.
]]
local function loadPlayerData(player: Player): {money: number, ownedUnits: {[string]: number}, unlockProgress: number}
	local userId = player.UserId
	local key = "Player_" .. userId
	
	local success, result
	for attempt = 1, CONFIG.RETRY_ATTEMPTS do
		success, result = pcall(function()
			return PlayerDataStore:GetAsync(key)
		end)
		
		if success then
			break
		else
			warn(string.format("DataManager: Load attempt %d failed for %s: %s", attempt, player.Name, tostring(result)))
			if attempt < CONFIG.RETRY_ATTEMPTS then
				task.wait(CONFIG.RETRY_DELAY)
			end
		end
	end
	
	if success and result then
		-- Ensure maxStorage exists (for older saves)
		if not result.maxStorage then
			result.maxStorage = 500
		end
		-- Ensure convenienceUpgrades exists (for older saves)
		if not result.convenienceUpgrades then
			result.convenienceUpgrades = {}
		end
		-- Ensure prestige data exists (for older saves)
		if not result.lifetimeEarnings then
			result.lifetimeEarnings = 0
		end
		if not result.totalMeatballs then
			result.totalMeatballs = 0
		end
		if not result.spentMeatballs then
			result.spentMeatballs = 0
		end
		if not result.prestigeCount then
			result.prestigeCount = 0
		end
		if not result.meatballUpgrades then
			result.meatballUpgrades = {}
		end
		-- Ensure tier and brainrot persistence data exists (for older saves)
		if not result.purchasedTiers then
			result.purchasedTiers = 1
		end
		if not result.brainrotInventory then
			result.brainrotInventory = {}
		end
		if not result.brainrotPlacements then
			result.brainrotPlacements = {}
		end
		-- Ensure item system data exists (for older saves)
		if not result.itemStorage then
			result.itemStorage = {}
		end
		if not result.backpack then
			result.backpack = {}
		end
		if not result.storageCapacity then
			result.storageCapacity = 2000
		end
		if not result.selectedVehicle then
			result.selectedVehicle = "Sneakers"
		end
		if not result.vehicleCapacities then
			result.vehicleCapacities = {}
		end
		if not result.gridPositions then
			result.gridPositions = {}
		end
		if not result.discoveredSynergies then
			result.discoveredSynergies = {}
		end
		print(string.format("âœ“ Loaded data for %s: $%d, %d units unlocked, %d max storage, %d meatballs, %d tiers", 
			player.Name, result.money or 0, result.unlockProgress or 5, result.maxStorage, result.totalMeatballs, result.purchasedTiers))
		return result
	else
		print(string.format("âœ“ No saved data for %s, using defaults", player.Name))
		return getDefaultData()
	end
end

--[[
	Saves player data to DataStore.
]]
local function savePlayerData(player: Player): boolean
	local userId = player.UserId
	local key = "Player_" .. userId
	
	-- Get current data from game state
	local data = gatherPlayerData(player)
	if not data then
		warn("DataManager: No data to save for " .. player.Name)
		return false
	end
	
	local success, result
	for attempt = 1, CONFIG.RETRY_ATTEMPTS do
		success, result = pcall(function()
			PlayerDataStore:SetAsync(key, data)
		end)
		
		if success then
			break
		else
			warn(string.format("DataManager: Save attempt %d failed for %s: %s", attempt, player.Name, tostring(result)))
			if attempt < CONFIG.RETRY_ATTEMPTS then
				task.wait(CONFIG.RETRY_DELAY)
			end
		end
	end
	
	if success then
		print(string.format("âœ“ Saved data for %s: $%d, %d units unlocked, %d max storage", player.Name, data.money, data.unlockProgress, data.maxStorage or 500))
		return true
	else
		warn(string.format("âœ— Failed to save data for %s after %d attempts", player.Name, CONFIG.RETRY_ATTEMPTS))
		return false
	end
end

--[[
	Gathers current player data from game state.
	Now includes maxStorage from the player's plot.
]]
function gatherPlayerData(player: Player): {money: number, ownedUnits: {[string]: number}, unlockProgress: number}?
	-- Get money from leaderstats
	local money = CONFIG.DEFAULT_MONEY
	local leaderstats = player:FindFirstChild("leaderstats")
	if leaderstats then
		local moneyValue = leaderstats:FindFirstChild("Money")
		if moneyValue then
			money = moneyValue.Value
		end
	end
	
	-- Get owned units and unlock progress from ShopManager
	local ownedUnits = {}
	local unlockProgress = 5
	
	if _G.ShopManager then
		-- Get unlock progress
		if _G.ShopManager.GetUnlockProgress then
			unlockProgress = _G.ShopManager.GetUnlockProgress(player)
		end
		
		-- Get owned counts
		local ownedFolder = player:FindFirstChild("OwnedUnits")
		if ownedFolder then
			for _, countValue in ownedFolder:GetChildren() do
				if countValue:IsA("IntValue") and countValue.Value > 0 then
					ownedUnits[countValue.Name] = countValue.Value
				end
			end
		end
	end
	
	-- Get maxStorage from player's plot
	local maxStorage = 500 -- default
	local BrainrotManager = _G.BrainrotManager
	if BrainrotManager and BrainrotManager.GetPlayerPlot then
		local plot = BrainrotManager.GetPlayerPlot(player)
		if plot then
			maxStorage = plot:GetAttribute("MaxStorage") or 500
		end
	end
	
	-- Get tier data from MapSystem
	local purchasedTiers = 1
	if _G.MapSystem and _G.MapSystem.GetPlayerTierSystem then
		local tierSystem = _G.MapSystem.GetPlayerTierSystem(player)
		if tierSystem then
			purchasedTiers = #tierSystem.Tiers
		end
	end
	
	-- Get convenience upgrades
	local convenienceUpgrades = {}
	if _G.ConvenienceUpgrades and _G.ConvenienceUpgrades.GetPlayerUpgrades then
		convenienceUpgrades = _G.ConvenienceUpgrades.GetPlayerUpgrades(player)
	end
	
	-- Get prestige data
	local lifetimeEarnings = 0
	local totalMeatballs = 0
	local spentMeatballs = 0
	local prestigeCount = 0
	local meatballUpgrades = {}
	if _G.PrestigeManager and _G.PrestigeManager.GetPlayerData then
		local prestigeData = _G.PrestigeManager.GetPlayerData(player)
		if prestigeData then
			lifetimeEarnings = prestigeData.lifetimeEarnings or 0
			totalMeatballs = prestigeData.totalMeatballs or 0
			spentMeatballs = prestigeData.spentMeatballs or 0
			prestigeCount = prestigeData.prestigeCount or 0
			meatballUpgrades = prestigeData.meatballUpgrades or {}
		end
	end
	
	-- Get brainrot inventory (with rarities)
	local brainrotInventory = {}
	if BrainrotManager and BrainrotManager.GetInventoryData then
		brainrotInventory = BrainrotManager.GetInventoryData(player) or {}
	end
	
	-- Get brainrot placements (for position restoration)
	local brainrotPlacements = {}
	if BrainrotManager and BrainrotManager.GetPlacementData then
		brainrotPlacements = BrainrotManager.GetPlacementData(player) or {}
	end
	
	-- Get item storage data
	local itemStorage = {}
	local backpack = {}
	local storageCapacity = 2000
	local selectedVehicle = "Sneakers"
	local vehicleCapacities = {}
	local gridPositions = {}
	local discoveredSynergies = {}
	
	if _G.ItemStorageManager then
		if _G.ItemStorageManager.GetStorageContents then
			itemStorage = _G.ItemStorageManager.GetStorageContents(player) or {}
		end
		if _G.ItemStorageManager.GetBackpackContents then
			backpack = _G.ItemStorageManager.GetBackpackContents(player) or {}
		end
		if _G.ItemStorageManager.GetStorageCapacity then
			storageCapacity = _G.ItemStorageManager.GetStorageCapacity(player) or 2000
		end
	end
	
	if _G.TransportManager then
		if _G.TransportManager.GetSelectedVehicle then
			selectedVehicle = _G.TransportManager.GetSelectedVehicle(player) or "Sneakers"
		end
		if _G.TransportManager.GetVehicleCapacities then
			vehicleCapacities = _G.TransportManager.GetVehicleCapacities(player) or {}
		end
	end
	
	if _G.GridManager then
		if _G.GridManager.GetGridPositions then
			gridPositions = _G.GridManager.GetGridPositions(player) or {}
		end
	end
	
	if _G.AdjacencySynergyManager then
		if _G.AdjacencySynergyManager.GetDiscoveredSynergies then
			discoveredSynergies = _G.AdjacencySynergyManager.GetDiscoveredSynergies(player) or {}
		end
	end
	
	return {
		money = money,
		ownedUnits = ownedUnits,
		unlockProgress = unlockProgress,
		maxStorage = maxStorage,
		purchasedTiers = purchasedTiers,
		convenienceUpgrades = convenienceUpgrades,
		lifetimeEarnings = lifetimeEarnings,
		totalMeatballs = totalMeatballs,
		spentMeatballs = spentMeatballs,
		prestigeCount = prestigeCount,
		meatballUpgrades = meatballUpgrades,
		brainrotInventory = brainrotInventory,
		brainrotPlacements = brainrotPlacements,
		-- Item system data
		itemStorage = itemStorage,
		backpack = backpack,
		storageCapacity = storageCapacity,
		selectedVehicle = selectedVehicle,
		vehicleCapacities = vehicleCapacities,
		gridPositions = gridPositions,
		discoveredSynergies = discoveredSynergies,
	}
end

--------------------------------------------------------------------------------
-- PLAYER EVENTS
--------------------------------------------------------------------------------

--[[
	Called when a player joins. Loads their data and applies it.
]]
local function onPlayerAdded(player: Player)
	-- Load saved data
	local data = loadPlayerData(player)
	PlayerDataCache[player] = data
	
	-- Create leaderstats IMMEDIATELY to prevent race conditions
	-- Other scripts depend on leaderstats existing
	local leaderstats = player:FindFirstChild("leaderstats")
	if not leaderstats then
		leaderstats = Instance.new("Folder")
		leaderstats.Name = "leaderstats"
		leaderstats.Parent = player
		
		local money = Instance.new("IntValue")
		money.Name = "Money"
		money.Value = data.money -- Apply saved money immediately
		money.Parent = leaderstats
		
		print(string.format("âœ“ Created leaderstats for %s with $%d", player.Name, data.money))
	else
		-- leaderstats exists, just update value
		local money = leaderstats:FindFirstChild("Money")
		if money then
			money.Value = data.money
			print(string.format("âœ“ Applied saved money for %s: $%d", player.Name, data.money))
		end
	end
	
	-- Restore convenience upgrades EARLY (before ConvenienceUpgradesManager initializes)
	-- This prevents the race condition where ConvenienceUpgradesManager sets empty upgrades
	if data.convenienceUpgrades and next(data.convenienceUpgrades) ~= nil then
		if _G.ConvenienceUpgrades and _G.ConvenienceUpgrades.SetPlayerUpgrades then
			_G.ConvenienceUpgrades.SetPlayerUpgrades(player, data.convenienceUpgrades)
			local upgradeCount = 0
			for _ in pairs(data.convenienceUpgrades) do
				upgradeCount += 1
			end
			print(string.format("âœ“ Early restored %d convenience upgrades for %s", upgradeCount, player.Name))
		end
	end
	
	-- Wait for ShopManager to initialize the player's data
	task.wait(1)
	
	-- Apply owned units
	if _G.ShopManager and _G.ShopManager.SetPlayerData then
		_G.ShopManager.SetPlayerData(player, data.ownedUnits, data.unlockProgress)
	else
		-- Fallback: Set the values directly
		local ownedFolder = player:FindFirstChild("OwnedUnits")
		if ownedFolder then
			for unitName, count in data.ownedUnits do
				local countValue = ownedFolder:FindFirstChild(unitName)
				if countValue then
					countValue.Value = count
				end
			end
		end
		
		local unlockValue = player:FindFirstChild("UnlockProgress")
		if unlockValue then
			unlockValue.Value = data.unlockProgress
		end
	end
	
	-- Spawn owned brainrot models on the player's plot
	task.spawn(function()
		-- Wait for BrainrotManager to be ready
		local BrainrotManager = waitForBrainrotManager()
		if not BrainrotManager then
			warn("DataManager: BrainrotManager not available, cannot spawn owned brainrots")
			return
		end
		
		-- Wait for player's plot to be assigned (max 10 seconds)
		local plot = nil
		for attempt = 1, 100 do
			plot = BrainrotManager.GetPlayerPlot(player)
			if plot then break end
			task.wait(0.1)
		end
		
		if not plot then
			warn(string.format("DataManager: No plot found for %s, cannot spawn brainrots", player.Name))
			return
		end
		
		-- Restore maxStorage on the plot FIRST
		if data.maxStorage and data.maxStorage > 500 then
			plot:SetAttribute("MaxStorage", data.maxStorage)
			-- Update visual
			local currentStorage = plot:GetAttribute("CurrentStorage") or 0
			if BrainrotManager.UpdateStorageVisual then
				BrainrotManager.UpdateStorageVisual(plot, currentStorage, data.maxStorage)
			end
			print(string.format("âœ“ Restored max storage to %d for %s", data.maxStorage, player.Name))
		end
		
		-- Restore purchased tiers BEFORE spawning brainrots
		if data.purchasedTiers and data.purchasedTiers > 1 then
			if _G.MapSystem and _G.MapSystem.RestoreTiers then
				print(string.format("Calling RestoreTiers for %s with %d tiers", player.Name, data.purchasedTiers))
				_G.MapSystem.RestoreTiers(player, data.purchasedTiers)
			else
				warn(string.format("Cannot restore tiers for %s: MapSystem not available (MapSystem=%s)", 
					player.Name, tostring(_G.MapSystem)))
			end
		end
		
		-- Small delay to ensure tiers are spawned
		task.wait(0.5)
		
		-- Restore brainrot inventory (with rarities) - this sets up the inventory tracking
		if data.brainrotInventory and next(data.brainrotInventory) ~= nil then
			-- Check if it's the new format (has 'level' field in entries)
			local firstKey, firstVal = next(data.brainrotInventory)
			local isNewFormat = (type(firstVal) == "table" and firstVal.level ~= nil)
			
			if isNewFormat then
				-- New Format: {[unitName]: {level, rarity, status}}
				for unitName, unitData in pairs(data.brainrotInventory) do
					-- Spawn/Restore unit with correct stats
					-- Note: AddUnit is idempotent, so it's safe to call even if placement spawns it later
					if BrainrotManager.AddUnit then
						BrainrotManager.AddUnit(player, unitName, unitData.rarity, unitData.level)
					end
				end
			elseif BrainrotManager.SetInventoryData then
				-- Old Format: {[unitName]: {[rarity]: {total, active}}}
				-- Reset active counts to 0 since we'll spawn them from placements
				local inventoryWithZeroActive = {}
				for unitName, rarityData in pairs(data.brainrotInventory) do
					inventoryWithZeroActive[unitName] = {}
					for rarity, counts in pairs(rarityData) do
						inventoryWithZeroActive[unitName][rarity] = {
							total = counts.total,
							active = 0  -- Will be updated as we spawn
						}
					end
				end
				BrainrotManager.SetInventoryData(player, inventoryWithZeroActive)
			end
		end
		
		-- Spawn brainrots from saved placements (preserves rarities and attributes)
		local spawnedCount = 0
		if data.brainrotPlacements and #data.brainrotPlacements > 0 then
			for _, placementData in ipairs(data.brainrotPlacements) do
				if BrainrotManager.SpawnFromPlacement then
					local spawnedUnit = BrainrotManager.SpawnFromPlacement(player, placementData)
					if spawnedUnit then
						spawnedCount += 1
						-- Update inventory active count
						local inventory = BrainrotManager.GetInventoryData and BrainrotManager.GetInventoryData(player)
						if inventory and inventory[placementData.unitType] and inventory[placementData.unitType][placementData.rarity] then
							inventory[placementData.unitType][placementData.rarity].active += 1
						end
					end
				end
			end
			if spawnedCount > 0 then
				print(string.format("âœ“ Restored %d brainrots from saved placements for %s", spawnedCount, player.Name))
			end
		elseif data.ownedUnits then
			-- Fallback: Spawn from ownedUnits if no placement data (old save format)
			local inventoryData = {}
			
			for unitName, count in data.ownedUnits do
				if count >= 1 then
					-- Initialize inventory entry
					if not inventoryData[unitName] then inventoryData[unitName] = {} end
					if not inventoryData[unitName]["Normal"] then 
						inventoryData[unitName]["Normal"] = {total = 0, active = 0} 
					end
					
					-- Update totals
					inventoryData[unitName]["Normal"].total = count
					
					-- Spawn units
					for i = 1, count do
						local unitConfig = ShopConfig.GetConfig(unitName)
						if unitConfig then
							local spawnedUnit = BrainrotManager.SpawnBrainrot(player, unitConfig.ModelName)
							if spawnedUnit then
								-- Use milestone-aware income/cycle calculations
								local effectiveIncome = ShopConfig.CalculateEffectiveIncome(unitName, count)
								local effectiveCycleTime = ShopConfig.CalculateEffectiveCycleTime(unitName, count)
								
								spawnedUnit:SetAttribute("IncomeAmount", effectiveIncome)
								spawnedUnit:SetAttribute("IncomeInterval", effectiveCycleTime)
								spawnedUnit:SetAttribute("UnitType", unitName)
								spawnedUnit:SetAttribute("Rarity", "Normal") -- Default to Normal for legacy
								spawnedCount += 1
								
								-- Update active count
								inventoryData[unitName]["Normal"].active += 1
							end
						end
					end
				end
			end
			
			-- Set the inventory data in BrainrotManager
			if BrainrotManager.SetInventoryData then
				BrainrotManager.SetInventoryData(player, inventoryData)
			end
			
			if spawnedCount > 0 then
				print(string.format("âœ“ Spawned %d owned brainrot models for %s (legacy format) and updated inventory", spawnedCount, player.Name))
			end
		end
		
		-- Restore convenience upgrades (fallback if early restoration didn't work)
		-- Check if upgrades were already restored early (before task.spawn)
		local existingUpgrades = _G.ConvenienceUpgrades and _G.ConvenienceUpgrades.GetPlayerUpgrades and _G.ConvenienceUpgrades.GetPlayerUpgrades(player)
		local alreadyRestored = existingUpgrades and next(existingUpgrades) ~= nil
		
		if not alreadyRestored and data.convenienceUpgrades and next(data.convenienceUpgrades) ~= nil then
			if _G.ConvenienceUpgrades and _G.ConvenienceUpgrades.SetPlayerUpgrades then
				_G.ConvenienceUpgrades.SetPlayerUpgrades(player, data.convenienceUpgrades)
				-- Count upgrades safely
				local upgradeCount = 0
				for _ in pairs(data.convenienceUpgrades) do
					upgradeCount += 1
				end
				print(string.format("âœ“ Late restored %d convenience upgrades for %s", upgradeCount, player.Name))
			end
		end
		
		-- Restore prestige data
		if _G.PrestigeManager and _G.PrestigeManager.InitializePlayerData then
			_G.PrestigeManager.InitializePlayerData(player, {
				lifetimeEarnings = data.lifetimeEarnings or 0,
				totalMeatballs = data.totalMeatballs or 0,
				spentMeatballs = data.spentMeatballs or 0,
				prestigeCount = data.prestigeCount or 0,
				meatballUpgrades = data.meatballUpgrades or {},
			})
			if data.totalMeatballs and data.totalMeatballs > 0 then
				print(string.format("âœ“ Restored prestige data for %s: %d meatballs, %d prestiges", player.Name, data.totalMeatballs, data.prestigeCount or 0))
			end
		end
	end)
	
	DataLoaded[player] = true
end

--[[
	Called when a player leaves. Saves their data.
]]
local function onPlayerRemoving(player: Player)
	if DataLoaded[player] then
		savePlayerData(player)
	end
	
	-- Cleanup
	PlayerDataCache[player] = nil
	DataLoaded[player] = nil
end

--------------------------------------------------------------------------------
-- AUTO-SAVE
--------------------------------------------------------------------------------

local function autoSaveAllPlayers()
	for _, player in Players:GetPlayers() do
		if DataLoaded[player] then
			task.spawn(savePlayerData, player)
		end
	end
end

-- Auto-save loop
task.spawn(function()
	while true do
		task.wait(CONFIG.AUTO_SAVE_INTERVAL)
		print("DataManager: Running auto-save...")
		autoSaveAllPlayers()
	end
end)

--------------------------------------------------------------------------------
-- GAME SHUTDOWN
--------------------------------------------------------------------------------

-- Save all players when game is closing
game:BindToClose(function()
	print("DataManager: Game closing, saving all player data...")
	
	-- In Studio, BindToClose only has limited time
	if RunService:IsStudio() then
		-- Quick save for Studio testing
		for _, player in Players:GetPlayers() do
			if DataLoaded[player] then
				savePlayerData(player)
			end
		end
	else
		-- Production: spawn all saves concurrently
		local saveTasks = {}
		for _, player in Players:GetPlayers() do
			if DataLoaded[player] then
				table.insert(saveTasks, task.spawn(savePlayerData, player))
			end
		end
		
		-- Wait for all saves to complete (max 30 seconds)
		task.wait(5)
	end
	
	print("DataManager: Shutdown save complete")
end)

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

local function initialize()
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	print("   DataManager - Initializing")
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	
	-- Connect player events
	Players.PlayerAdded:Connect(onPlayerAdded)
	Players.PlayerRemoving:Connect(onPlayerRemoving)
	
	-- Handle existing players (in case script loads late)
	for _, player in Players:GetPlayers() do
		task.spawn(onPlayerAdded, player)
	end
	
	print("âœ“ DataManager initialized")
	print("  â€¢ Auto-save interval: " .. CONFIG.AUTO_SAVE_INTERVAL .. "s")
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
end

initialize()

-- Export API
_G.DataManager = {
	SavePlayerData = savePlayerData,
	LoadPlayerData = loadPlayerData,
	GetCachedData = function(player) return PlayerDataCache[player] end,
	ResetPlayerData = function(player, keepPrestigeData)
		local currentData = PlayerDataCache[player]
		if not currentData then return end
		
		-- Default reset values
		local newData = getDefaultData()
		
		if keepPrestigeData then
			-- Preserve prestige data
			newData.lifetimeEarnings = currentData.lifetimeEarnings
			newData.totalMeatballs = currentData.totalMeatballs
			newData.spentMeatballs = currentData.spentMeatballs
			newData.prestigeCount = currentData.prestigeCount
			newData.meatballUpgrades = currentData.meatballUpgrades
			
			-- Apply "Quick Start" bonuses if any
			local startingMoney = CONFIG.DEFAULT_MONEY
			if _G.PrestigeManager and _G.PrestigeManager.GetStartingMoneyBonus then
				startingMoney = startingMoney + _G.PrestigeManager.GetStartingMoneyBonus(player)
			end
			newData.money = startingMoney
		end
		
		-- Update cache
		PlayerDataCache[player] = newData
		
		-- Save immediately
		savePlayerData(player)
		
		return newData
	end,
}



--------------------------------------------------
File: GridManager.server.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\server\GridManager.server.luau
--------------------------------------------------
--[[
	GridManager Server Script
	
	Manages grid-based brainrot placement on player plots.
	
	Features:
	- Grid sizes: 3Ã—3 (starter), 3Ã—4, 4Ã—4, 5Ã—5 (max)
	- Place, move, swap, stash operations
	- Get adjacent units for synergy detection
	- CFrame calculation for grid positions
	
	Part of Phase 2: Spatial Puzzle system.
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")

-- Constants
local BRAINROT_TAG = "ActiveBrainrot"

-- Configuration
local CONFIG = {
	-- Grid tile size in studs
	TILE_SIZE = 10,
	
	-- Grid sizes available (upgradeable)
	GRID_SIZES = {
		starter = {rows = 4, cols = 4},   -- 16 slots (default)
		bronze = {rows = 4, cols = 5},    -- 20 slots
		silver = {rows = 5, cols = 5},    -- 25 slots
		gold = {rows = 6, cols = 6},      -- 36 slots
	},
	
	-- Default grid size
	DEFAULT_GRID = "starter",
	
	-- Grid offset from plot TOP surface
	GRID_OFFSET_Y = 5, -- Height above plot top surface
}

-- Remote events
local RemoteEvents = ReplicatedStorage:FindFirstChild("RemoteEvents")
if not RemoteEvents then
	RemoteEvents = Instance.new("Folder")
	RemoteEvents.Name = "RemoteEvents"
	RemoteEvents.Parent = ReplicatedStorage
end

local RemoteFunctions = ReplicatedStorage:FindFirstChild("RemoteFunctions")
if not RemoteFunctions then
	RemoteFunctions = Instance.new("Folder")
	RemoteFunctions.Name = "RemoteFunctions"
	RemoteFunctions.Parent = ReplicatedStorage
end

-- Create events
local GridUpdatedEvent = RemoteEvents:FindFirstChild("GridUpdated") or Instance.new("RemoteEvent")
GridUpdatedEvent.Name = "GridUpdated"
GridUpdatedEvent.Parent = RemoteEvents

local UnitPlacedEvent = RemoteEvents:FindFirstChild("UnitPlaced") or Instance.new("RemoteEvent")
UnitPlacedEvent.Name = "UnitPlaced"
UnitPlacedEvent.Parent = RemoteEvents

-- Create functions
local PlaceUnitFunction = RemoteFunctions:FindFirstChild("PlaceUnit") or Instance.new("RemoteFunction")
PlaceUnitFunction.Name = "PlaceUnit"
PlaceUnitFunction.Parent = RemoteFunctions

local MoveUnitFunction = RemoteFunctions:FindFirstChild("MoveUnit") or Instance.new("RemoteFunction")
MoveUnitFunction.Name = "MoveUnit"
MoveUnitFunction.Parent = RemoteFunctions

local SwapUnitsFunction = RemoteFunctions:FindFirstChild("SwapUnits") or Instance.new("RemoteFunction")
SwapUnitsFunction.Name = "SwapUnits"
SwapUnitsFunction.Parent = RemoteFunctions

local StashUnitFunction = RemoteFunctions:FindFirstChild("StashUnit") or Instance.new("RemoteFunction")
StashUnitFunction.Name = "StashUnit"
StashUnitFunction.Parent = RemoteFunctions

local GetGridFunction = RemoteFunctions:FindFirstChild("GetGrid") or Instance.new("RemoteFunction")
GetGridFunction.Name = "GetGrid"
GetGridFunction.Parent = RemoteFunctions

-- BuildModeUI expects these as RemoteFunctions in RemoteEvents folder  
local PlaceBrainrotFunction = RemoteEvents:FindFirstChild("PlaceBrainrot") or Instance.new("RemoteFunction")
PlaceBrainrotFunction.Name = "PlaceBrainrot"
PlaceBrainrotFunction.Parent = RemoteEvents

local RemoveBrainrotFunction = RemoteEvents:FindFirstChild("RemoveBrainrot") or Instance.new("RemoteFunction")
RemoveBrainrotFunction.Name = "RemoveBrainrot"
RemoveBrainrotFunction.Parent = RemoteEvents

--------------------------------------------------------------------------------
-- PLAYER GRID DATA
--------------------------------------------------------------------------------

-- { [userId] = { gridSize = "starter", slots = { [slotIndex] = brainrotInstance } } }
local PlayerGrids = {}

--[[
	Gets or creates grid data for a player.
	@param player Player
	@return table - Grid data
]]
local function getPlayerGrid(player)
	if not PlayerGrids[player.UserId] then
		PlayerGrids[player.UserId] = {
			gridSize = CONFIG.DEFAULT_GRID,
			slots = {},  -- { [slotIndex] = brainrotInstance }
		}
	end
	return PlayerGrids[player.UserId]
end

--[[
	Gets the grid dimensions for a player.
	@param player Player
	@return number, number - rows, cols
]]
local function getGridDimensions(player)
	local gridData = getPlayerGrid(player)
	local sizeConfig = CONFIG.GRID_SIZES[gridData.gridSize] or CONFIG.GRID_SIZES.starter
	return sizeConfig.rows, sizeConfig.cols
end

--[[
	Gets the total number of slots for a player.
	@param player Player
	@return number
]]
local function getTotalSlots(player)
	local rows, cols = getGridDimensions(player)
	return rows * cols
end

--[[
	Converts slot index to row, col (0-indexed internally).
	@param slotIndex number - 1-indexed slot number
	@param rows number
	@param cols number
	@return number, number - row, col (0-indexed)
]]
local function slotToRowCol(slotIndex, rows, cols)
	local index = slotIndex - 1
	local row = math.floor(index / cols)
	local col = index % cols
	return row, col
end

--[[
	Converts row, col to slot index.
	@param row number - 0-indexed
	@param col number - 0-indexed
	@param cols number
	@return number - 1-indexed slot number
]]
local function rowColToSlot(row, col, cols)
	return (row * cols) + col + 1
end

--------------------------------------------------------------------------------
-- PLOT & POSITION HELPERS
--------------------------------------------------------------------------------

--[[
	Finds the player's plot in workspace.
	@param player Player
	@return Instance? - The plot model/part
]]
local function findPlayerPlot(player)
	local plotsFolder = workspace:FindFirstChild("Plots")
	if not plotsFolder then return nil end
	
	for _, plot in plotsFolder:GetChildren() do
		if plot:GetAttribute("OwnerId") == player.UserId then
			return plot
		end
	end
	
	return nil
end

--[[
	Gets the plot floor position (CENTER of the plot's main part).
	@param plot Instance
	@return Vector3?
]]
local function getPlotCenter(plot)
	-- Try to find the main floor part (check multiple possible names)
	local floor = plot:FindFirstChild("Island") 
		or plot:FindFirstChild("PlotFloor") 
		or plot:FindFirstChild("Floor")
		or plot:FindFirstChildWhichIsA("BasePart")
	
	if floor and floor:IsA("BasePart") then
		return floor.Position
	end
	
	-- If plot is a model, use bounding box center
	if plot:IsA("Model") then
		local cf, size = plot:GetBoundingBox()
		return cf.Position
	end
	
	-- If plot is a part
	if plot:IsA("BasePart") then
		return plot.Position
	end
	
	return Vector3.new(0, 5, 0)
end

--[[
	Gets the plot floor size.
	@param plot Instance
	@return Vector3
]]
local function getPlotSize(plot)
	-- Try to find the main floor part (check multiple possible names)
	local floor = plot:FindFirstChild("Island") 
		or plot:FindFirstChild("PlotFloor") 
		or plot:FindFirstChild("Floor")
		or plot:FindFirstChildWhichIsA("BasePart")
	
	if floor and floor:IsA("BasePart") then
		return floor.Size
	end
	
	if plot:IsA("BasePart") then
		return plot.Size
	end
	
	-- If plot is a model, use bounding box
	if plot:IsA("Model") then
		local cf, size = plot:GetBoundingBox()
		return size
	end
	
	return Vector3.new(50, 10, 50) -- Default (thick plot)
end

--[[
	Calculates the world position for a grid slot.
	Uses 4 corner clusters layout:
	- Corner 1 (top-left): slots 1-4
	- Corner 2 (top-right): slots 5-8
	- Corner 3 (bottom-left): slots 9-12
	- Corner 4 (bottom-right): slots 13-16
	
	@param player Player
	@param slotIndex number
	@return CFrame - The position and rotation for the slot
]]
local function getSlotCFrame(player, slotIndex)
	local plot = findPlayerPlot(player)
	if not plot then return CFrame.new(0, 10, 0) end
	
	local plotCenter = getPlotCenter(plot)
	local plotSize = getPlotSize(plot)
	
	-- Y position: top of plot (center + half height) + offset
	local posY = plotCenter.Y + (plotSize.Y / 2) + CONFIG.GRID_OFFSET_Y
	
	-- Corner cluster configuration
	local CLUSTER_SIZE = 2  -- 2x2 per corner
	local TILE_SPACING = CONFIG.TILE_SIZE
	
	-- Calculate corner offsets (distance from center to corner cluster center)
	local cornerOffsetX = (plotSize.X / 2) - (CLUSTER_SIZE * TILE_SPACING / 2) - TILE_SPACING
	local cornerOffsetZ = (plotSize.Z / 2) - (CLUSTER_SIZE * TILE_SPACING / 2) - TILE_SPACING
	
	-- Determine which corner (0-3) and position within corner (0-3)
	local cornerIndex = math.floor((slotIndex - 1) / 4)
	local posInCorner = (slotIndex - 1) % 4
	
	-- Position within 2x2 cluster
	local localRow = math.floor(posInCorner / 2)
	local localCol = posInCorner % 2
	
	-- Corner base positions (relative to plot center)
	local cornerPositions = {
		{x = -cornerOffsetX, z = -cornerOffsetZ},  -- Top-left
		{x = cornerOffsetX, z = -cornerOffsetZ},   -- Top-right
		{x = -cornerOffsetX, z = cornerOffsetZ},   -- Bottom-left
		{x = cornerOffsetX, z = cornerOffsetZ},    -- Bottom-right
	}
	
	local corner = cornerPositions[cornerIndex + 1] or cornerPositions[1]
	
	-- Calculate final position
	local posX = plotCenter.X + corner.x + (localCol - 0.5) * TILE_SPACING
	local posZ = plotCenter.Z + corner.z + (localRow - 0.5) * TILE_SPACING
	
	-- Calculate rotation to face plot center
	local unitPos = Vector3.new(posX, posY, posZ)
	local lookDirection = (plotCenter - unitPos) * Vector3.new(1, 0, 1) -- Flatten Y
	
	-- Face center
	local rotation = CFrame.lookAt(unitPos, unitPos + lookDirection)
	
	return rotation
end

--------------------------------------------------------------------------------
-- GRID OPERATIONS
--------------------------------------------------------------------------------

--[[
	Places a brainrot on a grid slot.
	@param player Player
	@param brainrot Instance - The brainrot model
	@param slotIndex number - Target slot (1-indexed)
	@return boolean, string? - Success, error message
]]
local function placeUnit(player, brainrot, slotIndex)
	local gridData = getPlayerGrid(player)
	local totalSlots = getTotalSlots(player)
	
	-- Validate slot index
	if slotIndex < 1 or slotIndex > totalSlots then
		return false, "Invalid slot index"
	end
	
	-- Check if slot is occupied
	if gridData.slots[slotIndex] then
		return false, "Slot is already occupied"
	end
	
	-- Check if this unit type is already placed elsewhere on the grid
	local unitType = brainrot:GetAttribute("UnitType") or brainrot.Name
	for _, otherUnit in pairs(gridData.slots) do
		local otherType = otherUnit:GetAttribute("UnitType") or otherUnit.Name
		if otherType == unitType then
			return false, "You can only place one of each unit type!"
		end
	end
	
	-- Place the brainrot
	gridData.slots[slotIndex] = brainrot
	brainrot:SetAttribute("GridSlot", slotIndex)
	brainrot:SetAttribute("IsStored", false)
	
	-- Update position
	local cframe = getSlotCFrame(player, slotIndex)
	if brainrot:IsA("Model") and brainrot.PrimaryPart then
		brainrot:SetPrimaryPartCFrame(cframe)
	elseif brainrot:IsA("BasePart") then
		brainrot.CFrame = cframe
	end
	
	-- Anchor all parts so they don't fall through the ground
	for _, part in brainrot:GetDescendants() do
		if part:IsA("BasePart") then
			part.Anchored = true
		end
	end
	
	-- Notify clients
	GridUpdatedEvent:FireClient(player, slotIndex, brainrot.Name, "placed")
	
	return true
end

--[[
	Moves a brainrot from one slot to another.
	@param player Player
	@param fromSlot number
	@param toSlot number
	@return boolean, string?
]]
local function moveUnit(player, fromSlot, toSlot)
	local gridData = getPlayerGrid(player)
	local totalSlots = getTotalSlots(player)
	
	-- Validate slots
	if fromSlot < 1 or fromSlot > totalSlots then
		return false, "Invalid source slot"
	end
	if toSlot < 1 or toSlot > totalSlots then
		return false, "Invalid target slot"
	end
	
	-- Check if source has a unit
	local brainrot = gridData.slots[fromSlot]
	if not brainrot then
		return false, "No unit in source slot"
	end
	
	-- Check if target is free
	if gridData.slots[toSlot] then
		return false, "Target slot is occupied"
	end
	
	-- Move
	gridData.slots[fromSlot] = nil
	gridData.slots[toSlot] = brainrot
	brainrot:SetAttribute("GridSlot", toSlot)
	
	-- Update position
	local cframe = getSlotCFrame(player, toSlot)
	if brainrot:IsA("Model") and brainrot.PrimaryPart then
		brainrot:SetPrimaryPartCFrame(cframe)
	elseif brainrot:IsA("BasePart") then
		brainrot.CFrame = cframe
	end
	
	-- Notify clients
	GridUpdatedEvent:FireClient(player, toSlot, brainrot.Name, "moved")
	
	return true
end

--[[
	Swaps two brainrots between slots.
	@param player Player
	@param slot1 number
	@param slot2 number
	@return boolean, string?
]]
local function swapUnits(player, slot1, slot2)
	local gridData = getPlayerGrid(player)
	local totalSlots = getTotalSlots(player)
	
	-- Validate slots
	if slot1 < 1 or slot1 > totalSlots then
		return false, "Invalid slot 1"
	end
	if slot2 < 1 or slot2 > totalSlots then
		return false, "Invalid slot 2"
	end
	
	local brainrot1 = gridData.slots[slot1]
	local brainrot2 = gridData.slots[slot2]
	
	-- Need at least one unit to swap
	if not brainrot1 and not brainrot2 then
		return false, "No units to swap"
	end
	
	-- Swap
	gridData.slots[slot1] = brainrot2
	gridData.slots[slot2] = brainrot1
	
	-- Update positions and attributes
	if brainrot1 then
		brainrot1:SetAttribute("GridSlot", slot2)
		local cframe = getSlotCFrame(player, slot2)
		if brainrot1:IsA("Model") and brainrot1.PrimaryPart then
			brainrot1:SetPrimaryPartCFrame(cframe)
		elseif brainrot1:IsA("BasePart") then
			brainrot1.CFrame = cframe
		end
	end
	
	if brainrot2 then
		brainrot2:SetAttribute("GridSlot", slot1)
		local cframe = getSlotCFrame(player, slot1)
		if brainrot2:IsA("Model") and brainrot2.PrimaryPart then
			brainrot2:SetPrimaryPartCFrame(cframe)
		elseif brainrot2:IsA("BasePart") then
			brainrot2.CFrame = cframe
		end
	end
	
	-- Notify clients
	GridUpdatedEvent:FireClient(player, slot1, brainrot2 and brainrot2.Name or nil, "swapped")
	GridUpdatedEvent:FireClient(player, slot2, brainrot1 and brainrot1.Name or nil, "swapped")
	
	return true
end

--[[
	Removes a brainrot from the grid (stashes it).
	@param player Player
	@param slotIndex number
	@return Instance?, string? - The removed brainrot, error message
]]
local function stashUnit(player, slotIndex)
	local gridData = getPlayerGrid(player)
	local totalSlots = getTotalSlots(player)
	
	if slotIndex < 1 or slotIndex > totalSlots then
		return nil, "Invalid slot index"
	end
	
	local brainrot = gridData.slots[slotIndex]
	if not brainrot then
		return nil, "No unit in slot"
	end
	
	-- Remove from grid
	gridData.slots[slotIndex] = nil
	brainrot:SetAttribute("GridSlot", nil)
	
	-- Notify clients
	GridUpdatedEvent:FireClient(player, slotIndex, nil, "stashed")
	
	return brainrot
end

--[[
	Gets adjacent slot indices for synergy detection.
	@param player Player
	@param slotIndex number
	@return table - Array of adjacent slot indices
]]
local function getAdjacentSlots(player, slotIndex)
	local rows, cols = getGridDimensions(player)
	local row, col = slotToRowCol(slotIndex, rows, cols)
	
	local adjacents = {}
	
	-- Up
	if row > 0 then
		table.insert(adjacents, rowColToSlot(row - 1, col, cols))
	end
	-- Down
	if row < rows - 1 then
		table.insert(adjacents, rowColToSlot(row + 1, col, cols))
	end
	-- Left
	if col > 0 then
		table.insert(adjacents, rowColToSlot(row, col - 1, cols))
	end
	-- Right
	if col < cols - 1 then
		table.insert(adjacents, rowColToSlot(row, col + 1, cols))
	end
	
	return adjacents
end

--[[
	Gets the brainrots in adjacent slots.
	@param player Player
	@param slotIndex number
	@return table - Array of {slot = number, brainrot = Instance}
]]
local function getAdjacentUnits(player, slotIndex)
	local gridData = getPlayerGrid(player)
	local adjacentSlots = getAdjacentSlots(player, slotIndex)
	
	local adjacentUnits = {}
	for _, adjSlot in adjacentSlots do
		local brainrot = gridData.slots[adjSlot]
		if brainrot then
			table.insert(adjacentUnits, {slot = adjSlot, brainrot = brainrot})
		end
	end
	
	return adjacentUnits
end

--[[
	Gets the full grid state for a player.
	@param player Player
	@return table - { gridSize, rows, cols, slots = { [slotIndex] = unitType } }
]]
local function getGridState(player)
	local gridData = getPlayerGrid(player)
	local rows, cols = getGridDimensions(player)
	
	local slotsState = {}
	for slotIndex, brainrot in pairs(gridData.slots) do
		slotsState[slotIndex] = brainrot:GetAttribute("UnitType") or brainrot.Name
	end
	
	return {
		gridSize = gridData.gridSize,
		rows = rows,
		cols = cols,
		slots = slotsState,
	}
end

--[[
	Finds the first empty slot.
	@param player Player
	@return number? - First empty slot index, or nil if full
]]
local function findEmptySlot(player)
	local gridData = getPlayerGrid(player)
	local totalSlots = getTotalSlots(player)
	
	for i = 1, totalSlots do
		if not gridData.slots[i] then
			return i
		end
	end
	
	return nil
end

--[[
	Sets the grid size for a player (upgrade).
	@param player Player
	@param sizeName string - "starter", "bronze", "silver", "gold"
	@return boolean
]]
local function setGridSize(player, sizeName)
	if not CONFIG.GRID_SIZES[sizeName] then
		return false
	end
	
	local gridData = getPlayerGrid(player)
	gridData.gridSize = sizeName
	
	-- Notify client
	GridUpdatedEvent:FireClient(player, 0, sizeName, "resize")
	
	return true
end

--------------------------------------------------------------------------------
-- DATA PERSISTENCE HOOKS
--------------------------------------------------------------------------------

--[[
	Gets grid data for saving.
	@param player Player
	@return table
]]
local function getGridData(player)
	local gridData = getPlayerGrid(player)
	
	-- Convert brainrot instances to slot data
	local slotsData = {}
	for slotIndex, brainrot in pairs(gridData.slots) do
		slotsData[tostring(slotIndex)] = {
			unitType = brainrot:GetAttribute("UnitType"),
			unitId = brainrot:GetAttribute("UnitId"),
		}
	end
	
	return {
		gridSize = gridData.gridSize,
		slots = slotsData,
	}
end

--[[
	Gets grid positions for DataManager persistence.
	Returns a table mapping slot indices to unit info.
	@param player Player
	@return table {[slotIndex]: {unitType, rarity}}
]]
local function getGridPositions(player)
	local gridData = getPlayerGrid(player)
	local positions = {}
	
	for slotIndex, brainrot in pairs(gridData.slots) do
		positions[tostring(slotIndex)] = {
			unitType = brainrot:GetAttribute("UnitType"),
			rarity = brainrot:GetAttribute("Rarity") or "Normal",
			level = brainrot:GetAttribute("Level") or 1,
			unitId = brainrot:GetAttribute("UnitId"),
		}
	end
	
	return positions
end

--[[
	Sets grid data from saved data.
	@param player Player
	@param data table
]]
local function setGridData(player, data)
	if not data then return end
	
	local gridData = getPlayerGrid(player)
	gridData.gridSize = data.gridSize or CONFIG.DEFAULT_GRID
	
	-- Note: Cannot restore brainrot instances here - that's handled by BrainrotManager
	-- The slots will be populated when brainrots are spawned
end

--------------------------------------------------------------------------------
-- REMOTE FUNCTION HANDLERS
--------------------------------------------------------------------------------

PlaceUnitFunction.OnServerInvoke = function(player, brainrotId, slotIndex)
	-- Find the brainrot by ID attribute
	for _, brainrot in CollectionService:GetTagged(BRAINROT_TAG) do
		if brainrot:GetAttribute("UnitId") == brainrotId 
			and brainrot:GetAttribute("OwnerId") == player.UserId then
			return placeUnit(player, brainrot, slotIndex)
		end
	end
	return false, "Brainrot not found"
end

MoveUnitFunction.OnServerInvoke = function(player, fromSlot, toSlot)
	return moveUnit(player, fromSlot, toSlot)
end

SwapUnitsFunction.OnServerInvoke = function(player, slot1, slot2)
	return swapUnits(player, slot1, slot2)
end

StashUnitFunction.OnServerInvoke = function(player, slotIndex)
	local brainrot, err = stashUnit(player, slotIndex)
	if brainrot then
		-- Notify BrainrotManager to handle stashing
		if _G.BrainrotManager and _G.BrainrotManager.StashBrainrot then
			_G.BrainrotManager.StashBrainrot(player, brainrot)
		end
		return true
	end
	return false, err
end

GetGridFunction.OnServerInvoke = function(player)
	return getGridState(player)
end

-- Handler for placing a brainrot from inventory/stash onto grid
PlaceBrainrotFunction.OnServerInvoke = function(player, unitName, rarity, slotIndex)
	-- First, find or spawn the brainrot
	local brainrot = nil
	
	-- Look for existing brainrot in player's Brainrots folder that matches type
	local plot = findPlayerPlot(player)
	if plot then
		local brainrotsContainer = plot:FindFirstChild("Brainrots")
		if brainrotsContainer then
			for _, unit in brainrotsContainer:GetChildren() do
				local unitType = unit:GetAttribute("UnitType")
				if unitType == unitName then
					brainrot = unit
					break
				end
			end
		end
	end
	
	-- If brainrot doesn't exist, spawn it using BrainrotManager
	if not brainrot then
		if _G.BrainrotManager and _G.BrainrotManager.AddUnit then
			brainrot = _G.BrainrotManager.AddUnit(player, unitName, rarity)
		end
	end
	
	if not brainrot then
		return false, "Could not find or create brainrot"
	end
	
	-- Now place on grid
	return placeUnit(player, brainrot, slotIndex)
end

-- Handler for removing/stashing a brainrot from grid
RemoveBrainrotFunction.OnServerInvoke = function(player, slotIndex)
	local brainrot, err = stashUnit(player, slotIndex)
	if brainrot then
		if _G.BrainrotManager and _G.BrainrotManager.StashBrainrot then
			_G.BrainrotManager.StashBrainrot(player, brainrot)
		end
		return true
	end
	return false, err
end

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

Players.PlayerRemoving:Connect(function(player)
	PlayerGrids[player.UserId] = nil
end)

print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
print("   GridManager - Initializing")
print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
print("âœ“ GridManager initialized")
print("  â€¢ Default grid: " .. CONFIG.DEFAULT_GRID .. " (" .. CONFIG.GRID_SIZES.starter.rows .. "x" .. CONFIG.GRID_SIZES.starter.cols .. ")")
print("  â€¢ Tile size: " .. CONFIG.TILE_SIZE .. " studs")
print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")

-- Export API
_G.GridManager = {
	-- Grid operations
	PlaceUnit = placeUnit,
	MoveUnit = moveUnit,
	SwapUnits = swapUnits,
	StashUnit = stashUnit,
	FindEmptySlot = findEmptySlot,
	
	-- Query functions
	GetGridDimensions = getGridDimensions,
	GetTotalSlots = getTotalSlots,
	GetSlotCFrame = getSlotCFrame,
	GetAdjacentSlots = getAdjacentSlots,
	GetAdjacentUnits = getAdjacentUnits,
	GetGridState = getGridState,
	
	-- Data persistence
	GetGridData = getGridData,
	GetGridPositions = getGridPositions,
	SetGridData = setGridData,
	SetGridSize = setGridSize,
	
	-- Config access
	CONFIG = CONFIG,
}



--------------------------------------------------
File: init.server.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\server\init.server.luau
--------------------------------------------------
--[[
	Map Generation and Plot Assignment Server Script
	
	This script handles:
	1. Spawning the central MainIsland hub
	2. Generating 8 player plots in a circular formation around the hub
	3. Creating bridges connecting each plot to the hub
	4. Assigning plots to players when they join
	5. Cleaning up plots when players leave
	
	Layout:
	- Central hub at origin (0, 0, 0)
	- 8 plots arranged in a circle at 400 stud radius
	- Each plot faces toward the center
]]

-- Services
local Players = game:GetService("Players")
local ServerStorage = game:GetService("ServerStorage")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Configuration
local CONFIG = {
	MAX_PLAYERS = 8,
	PLOT_RADIUS = 400,        -- Distance from center to each plot
	MAIN_ISLAND_HEIGHT = 30,  -- Y position for main island (lower than plots)
	PLOT_MIN_HEIGHT = 50,     -- Minimum Y position for player plots
	PLOT_MAX_HEIGHT = 120,     -- Maximum Y position for player plots
}

-- Tier System Configuration
local TIER_CONFIG = {
	MODELS_PER_TIER = 12,      -- Number of models before tier is full
	MAX_TIERS = 6,             -- Maximum tiers per player
	-- Height variation (always positive, new tier is higher than parent)
	TIER_HEIGHT_MIN = 20,      -- Minimum Y increase per tier
	TIER_HEIGHT_MAX = 60,      -- Maximum Y increase per tier
	-- Distance variation
	TIER_DISTANCE_MIN = 80,    -- Minimum distance from parent plot
	TIER_DISTANCE_MAX = 140,   -- Maximum distance from parent plot
	-- Stair configuration
	STAIR_WIDTH = 10,          -- Width of each stair step
	STAIR_DEPTH = 4,           -- Depth of each stair step
	STAIR_HEIGHT = 3,          -- Height of each stair step
	GRID_COLUMNS = 6,          -- Models per row
	GRID_ROWS = 2,             -- Rows per tier
	-- Sides: 0=North (+Z), 1=East (+X), 2=South (-Z), 3=West (-X)
	SIDE_OFFSETS = {
		[0] = Vector3.new(0, 0, 1),   -- North
		[1] = Vector3.new(1, 0, 0),   -- East
		[2] = Vector3.new(0, 0, -1),  -- South
		[3] = Vector3.new(-1, 0, 0),  -- West
	},
}

-- Model references (will be set up in initialization)
local MainIslandTemplate: Model
local PlayerPlotTemplate: Model
local BridgeTemplate: Model

--[[
	Plot data structure:
	{
		Index: number,           -- Plot index (1-8)
		Model: Model,            -- The cloned PlayerPlot model
		Bridge: Model,           -- The cloned Bridge model
		Position: CFrame,        -- World position of the plot
		Owner: Player?,          -- Current owner (nil if unclaimed)
		ClaimPart: BasePart,     -- The touchable claim pad
	}
]]
local Plots: {[number]: {
	Index: number,
	Model: Model,
	Bridge: Model,
	Position: CFrame,
	Owner: Player?,
	ClaimPart: BasePart,
}} = {}

-- Reverse lookup: Player -> Plot Index
local PlayerToPlot: {[Player]: number} = {}

-- Folder to hold all plots in workspace
local PlotsFolder: Folder

--[[
	Tier data structure for tracking player plot expansions
]]
export type TierPlotData = {
	TierIndex: number,         -- Which tier (1 = original, 2+ = expansions)
	Model: Model,              -- The tier's plot model
	Bridge: Model?,            -- Bridge connecting to parent (nil for tier 1)
	ParentTier: TierPlotData?, -- Reference to parent tier
	BlockedSide: number,       -- Side with incoming bridge (0-3)
	UsedSides: {number},       -- Sides with outgoing bridges to child tiers
	GridIndex: number,         -- Current grid spawn index for this tier
}

export type PlayerTierSystem = {
	BasePlotIndex: number,     -- Original plot index (1-8)
	Tiers: {TierPlotData},     -- Array of all tier plots
	CurrentTier: number,       -- Index of tier currently being filled
	TotalModels: number,       -- Total models across all tiers
}

-- Track tier systems per player
local PlayerTierSystems: {[Player]: PlayerTierSystem} = {}

--------------------------------------------------------------------------------
-- UTILITY FUNCTIONS
--------------------------------------------------------------------------------

--[[
	Calculates the CFrame position for a plot at a given index.
	
	Math explanation:
	- We have 8 plots arranged in a circle, so each plot is 360Â°/8 = 45Â° apart
	- Starting angle is 0Â° (pointing along positive X axis)
	- For plot index i (0-indexed), angle = i * (2Ï€ / 8) = i * Ï€/4
	- X position = radius * cos(angle)
	- Z position = radius * sin(angle)
	- The plot faces the center, so we rotate it by (angle + Ï€) to face inward
	- Height is randomized between PLOT_MIN_HEIGHT and PLOT_MAX_HEIGHT
	
	@param index number - The plot index (1-8)
	@return CFrame - The world CFrame for this plot
]]
local function calculatePlotCFrame(index: number): CFrame
	-- Convert to 0-indexed for the math
	local i = index - 1
	
	-- Calculate the angle for this plot position
	-- 2Ï€ radians = 360Â°, divided by 8 plots = Ï€/4 radians per plot (45Â°)
	local anglePerPlot = (2 * math.pi) / CONFIG.MAX_PLAYERS
	local angle = i * anglePerPlot
	
	-- Calculate X and Z positions on the circle
	-- cos(angle) gives us the X coordinate, sin(angle) gives us the Z coordinate
	local x = CONFIG.PLOT_RADIUS * math.cos(angle)
	local z = CONFIG.PLOT_RADIUS * math.sin(angle)
	
	-- Generate a random height for this plot between min and max
	local randomHeight = math.random(CONFIG.PLOT_MIN_HEIGHT, CONFIG.PLOT_MAX_HEIGHT)
	
	-- Create position vector at the calculated location with random height
	local position = Vector3.new(x, randomHeight, z)
	
	-- Calculate the rotation so the plot faces the center (0, 0, 0)
	-- We need to rotate by the angle + Ï€ (180Â°) to make the front face inward
	-- Using CFrame.Angles with Y rotation to spin around the vertical axis
	local rotationAngle = angle + math.pi
	local rotation = CFrame.Angles(0, -rotationAngle, 0)
	
	-- Combine position and rotation into final CFrame
	return CFrame.new(position) * rotation
end

--[[
	Calculates the CFrame and scale for a bridge connecting the hub to a plot.
	
	The bridge connects the main island (at MAIN_ISLAND_HEIGHT) to each plot
	(at their random heights). The bridge is positioned and angled to span
	the gap properly.
	
	@param plotCFrame CFrame - The CFrame of the destination plot
	@return CFrame, number - The bridge CFrame and the scale factor for length
]]
local function calculateBridgeCFrame(plotCFrame: CFrame): (CFrame, number)
	-- Get 2D direction from center to plot (on the XZ plane)
	local plotPos = plotCFrame.Position
	local direction2D = Vector3.new(plotPos.X, 0, plotPos.Z).Unit
	
	-- Bridge start point: edge of main island at main island height
	local hubRadius = 50  -- Approximate radius of hub island
	local hubEdgePos = Vector3.new(
		direction2D.X * hubRadius,
		CONFIG.MAIN_ISLAND_HEIGHT + 10, -- Slightly above island surface
		direction2D.Z * hubRadius
	)
	
	-- Bridge end point: edge of plot at plot height
	local plotRadius = 40 -- Approximate radius of plot island
	local plotEdgePos = Vector3.new(
		plotPos.X - direction2D.X * plotRadius,
		plotPos.Y + 10, -- Slightly above plot surface
		plotPos.Z - direction2D.Z * plotRadius
	)
	
	-- Midpoint between the two edge positions
	local midpoint = (hubEdgePos + plotEdgePos) / 2
	
	-- Calculate the 3D distance for the bridge length
	local distance = (plotEdgePos - hubEdgePos).Magnitude
	
	-- Create CFrame looking from hub toward plot, tilted to match height difference
	local bridgeCFrame = CFrame.new(midpoint, plotEdgePos)
	
	return bridgeCFrame, distance
end

--------------------------------------------------------------------------------
-- TIER SYSTEM FUNCTIONS
--------------------------------------------------------------------------------

--[[
	Gets a random available side for spawning a new tier.
	Excludes the blocked side (where incoming bridge is) and used sides.
	
	@param tierData TierPlotData - The tier to get an available side from
	@return number? - Side index (0-3), or nil if no sides available
]]
local function getAvailableSide(tierData: TierPlotData): number?
	local availableSides = {}
	
	for side = 0, 3 do
		local isBlocked = (side == tierData.BlockedSide)
		local isUsed = false
		
		for _, usedSide in tierData.UsedSides do
			if usedSide == side then
				isUsed = true
				break
			end
		end
		
		if not isBlocked and not isUsed then
			table.insert(availableSides, side)
		end
	end
	
	if #availableSides == 0 then
		return nil
	end
	
	-- Return random available side
	return availableSides[math.random(1, #availableSides)]
end

--[[
	Calculates the side that connects back to the parent based on direction.
	Used to determine the blocked side for a new tier.
	
	@param parentPos Vector3 - Parent plot position
	@param childPos Vector3 - Child plot position
	@return number - The side index (0-3) facing the parent
]]
local function calculateIncomingSide(parentPos: Vector3, childPos: Vector3): number
	local direction = (parentPos - childPos)
	local absX = math.abs(direction.X)
	local absZ = math.abs(direction.Z)
	
	if absZ > absX then
		-- More Z than X: North or South
		if direction.Z > 0 then
			return 0 -- North (parent is north of child)
		else
			return 2 -- South
		end
	else
		-- More X than Z: East or West
		if direction.X > 0 then
			return 1 -- East (parent is east of child)
		else
			return 3 -- West
		end
	end
end

--[[
	Calculates bridge CFrame between two tier plots.
	
	@param fromCFrame CFrame - Source tier CFrame
	@param toCFrame CFrame - Destination tier CFrame
	@return CFrame, number - Bridge CFrame and distance
]]
local function calculateTierBridgeCFrame(fromCFrame: CFrame, toCFrame: CFrame): (CFrame, number)
	local fromPos = fromCFrame.Position
	local toPos = toCFrame.Position
	
	local plotRadius = 40 -- Approximate radius of plot island
	local direction = (toPos - fromPos).Unit
	
	local fromEdge = fromPos + direction * plotRadius
	fromEdge = Vector3.new(fromEdge.X, fromPos.Y + 10, fromEdge.Z)
	
	local toEdge = toPos - direction * plotRadius
	toEdge = Vector3.new(toEdge.X, toPos.Y + 10, toEdge.Z)
	
	local midpoint = (fromEdge + toEdge) / 2
	local distance = (toEdge - fromEdge).Magnitude
	
	local bridgeCFrame = CFrame.new(midpoint, toEdge)
	
	return bridgeCFrame, distance
end

--[[
	Spawns a new tier plot for a player.
	
	@param player Player - The player to spawn the tier for
	@param parentTier TierPlotData - The parent tier to spawn from
	@return TierPlotData? - The new tier data, or nil if failed
]]
local function spawnTierPlot(player: Player, parentTier: TierPlotData): TierPlotData?
	-- Get an available side from parent
	local side = getAvailableSide(parentTier)
	if not side then
		warn("No available sides for new tier on player " .. player.Name)
		return nil
	end
	
	local tierSystem = PlayerTierSystems[player]
	if not tierSystem then
		warn("No tier system found for player " .. player.Name)
		return nil
	end
	
	local newTierIndex = #tierSystem.Tiers + 1
	if newTierIndex > TIER_CONFIG.MAX_TIERS then
		warn("Player " .. player.Name .. " has reached max tiers")
		return nil
	end
	
	-- Calculate new tier position with randomized distance and height
	local parentCFrame = parentTier.Model:GetPivot()
	local sideOffset = TIER_CONFIG.SIDE_OFFSETS[side]
	
	-- Random height (always positive, new tier is higher)
	local heightOffset = math.random(TIER_CONFIG.TIER_HEIGHT_MIN, TIER_CONFIG.TIER_HEIGHT_MAX)
	local newHeight = parentCFrame.Position.Y + heightOffset
	
	-- Random distance
	local tierDistance = math.random(TIER_CONFIG.TIER_DISTANCE_MIN, TIER_CONFIG.TIER_DISTANCE_MAX)
	local newPosition = parentCFrame.Position + (sideOffset * tierDistance)
	newPosition = Vector3.new(newPosition.X, newHeight, newPosition.Z)
	
	-- Clone the plot template
	local newPlotModel = PlayerPlotTemplate:Clone()
	newPlotModel.Name = string.format("Plot_%d_Tier_%d", tierSystem.BasePlotIndex, newTierIndex)
	
	-- Position and rotate to face parent (similar rotation logic)
	local lookDirection = (parentCFrame.Position - newPosition)
	local rotationAngle = math.atan2(lookDirection.X, lookDirection.Z)
	local newCFrame = CFrame.new(newPosition) * CFrame.Angles(0, rotationAngle, 0)
	
	if newPlotModel.PrimaryPart then
		newPlotModel:SetPrimaryPartCFrame(newCFrame)
	else
		newPlotModel:PivotTo(newCFrame)
	end
	
	newPlotModel:SetAttribute("OwnerId", player.UserId)
	newPlotModel:SetAttribute("TierIndex", newTierIndex)
	newPlotModel.Parent = PlotsFolder
	
	-- Create STAIRS between parent and new tier (instead of flat bridge)
	local stairsModel = Instance.new("Model")
	stairsModel.Name = string.format("Stairs_%d_Tier_%d", tierSystem.BasePlotIndex, newTierIndex)
	
	-- Calculate stair parameters
	local parentEdgePos = parentCFrame.Position + (sideOffset * 40) -- Edge of parent plot
	parentEdgePos = Vector3.new(parentEdgePos.X, parentCFrame.Position.Y + 2, parentEdgePos.Z) -- +2 for slight offset above surface
	
	local childEdgePos = newPosition - (sideOffset * 40) -- Edge of child plot
	childEdgePos = Vector3.new(childEdgePos.X, newPosition.Y + 2, childEdgePos.Z) -- Same offset for child
	
	local horizontalDistance = (Vector3.new(childEdgePos.X, 0, childEdgePos.Z) - Vector3.new(parentEdgePos.X, 0, parentEdgePos.Z)).Magnitude
	local verticalDistance = childEdgePos.Y - parentEdgePos.Y
	
	print(string.format("  Stairs debug: horizontal=%.1f, vertical=%.1f", horizontalDistance, verticalDistance))
	
	-- Calculate number of steps needed
	local numSteps = math.max(1, math.floor(verticalDistance / TIER_CONFIG.STAIR_HEIGHT))
	local stepHeight = verticalDistance / numSteps
	local stepDepth = horizontalDistance / numSteps
	
	print(string.format("  Stairs debug: numSteps=%d, stepHeight=%.1f, stepDepth=%.1f", numSteps, stepHeight, stepDepth))
	
	-- Direction from parent to child (normalized XZ)
	local directionVector = Vector3.new(childEdgePos.X, 0, childEdgePos.Z) - Vector3.new(parentEdgePos.X, 0, parentEdgePos.Z)
	if directionVector.Magnitude < 0.001 then
		warn("Stairs creation: direction vector is zero, cannot create stairs!")
		stairsModel.Parent = workspace -- Still parent it even if empty
	else
		local direction = directionVector.Unit
		
		-- Create each step
		for i = 0, numSteps - 1 do
			local step = Instance.new("Part")
			step.Name = "Step_" .. i
			step.Size = Vector3.new(TIER_CONFIG.STAIR_WIDTH, math.max(0.5, stepHeight), math.max(0.5, stepDepth))
			step.BrickColor = BrickColor.new("Medium stone grey")
			step.Material = Enum.Material.Concrete
			step.Anchored = true
			step.CanCollide = true
			
			-- Position each step
			local stepX = parentEdgePos.X + direction.X * (i + 0.5) * stepDepth
			local stepZ = parentEdgePos.Z + direction.Z * (i + 0.5) * stepDepth
			local stepY = parentEdgePos.Y + (i + 0.5) * stepHeight
			step.Position = Vector3.new(stepX, stepY, stepZ)
			
			-- Rotate step to align with direction
			step.CFrame = CFrame.new(step.Position) * CFrame.Angles(0, math.atan2(direction.X, direction.Z), 0)
			
			step.Parent = stairsModel
		end
		
		print(string.format("  Created %d steps in stairs model", numSteps))
	end
	
	-- Set primary part for the stairs model
	local firstStep = stairsModel:FindFirstChild("Step_0")
	if firstStep then
		stairsModel.PrimaryPart = firstStep
	end
	
	stairsModel.Parent = workspace
	print(string.format("  Stairs model '%s' parented to workspace", stairsModel.Name))
	
	-- Mark parent side as used
	table.insert(parentTier.UsedSides, side)
	
	-- Calculate incoming side for new tier
	local incomingSide = calculateIncomingSide(parentCFrame.Position, newPosition)
	
	-- Create tier data
	local newTierData: TierPlotData = {
		TierIndex = newTierIndex,
		Model = newPlotModel,
		Bridge = stairsModel, -- Now stores the stairs model instead of bridge
		ParentTier = parentTier,
		BlockedSide = incomingSide,
		UsedSides = {},
		GridIndex = 0,
	}
	
	-- Add to player's tier system
	table.insert(tierSystem.Tiers, newTierData)
	
	print(string.format("âœ“ Spawned Tier %d for %s (distance: %d, height: +%d)", newTierIndex, player.Name, tierDistance, heightOffset))
	
	return newTierData
end

--[[
	Creates a claim part (touchable pad) for a plot.
	The claim part is placed on top of the plot for players to step on.
	
	@param plotModel Model - The plot model to add the claim part to
	@return BasePart - The created claim part
]]
local function createClaimPart(plotModel: Model): BasePart
	local claimPart = Instance.new("Part")
	claimPart.Name = "ClaimPart"
	claimPart.Size = Vector3.new(10, 1, 10)
	claimPart.BrickColor = BrickColor.new("Lime green")
	claimPart.Material = Enum.Material.Neon
	claimPart.Transparency = 0.3
	claimPart.Anchored = true
	claimPart.CanCollide = false -- Players can walk through it
	
	-- Position it slightly above the plot's primary part or center
	local plotPrimary = plotModel.PrimaryPart or plotModel:FindFirstChildWhichIsA("BasePart")
	if plotPrimary then
		claimPart.Position = plotPrimary.Position + Vector3.new(0, 3, 0)
	else
		claimPart.Position = plotModel:GetPivot().Position + Vector3.new(0, 3, 0)
	end
	
	claimPart.Parent = plotModel
	
	return claimPart
end

--------------------------------------------------------------------------------
-- MAP GENERATION
--------------------------------------------------------------------------------

--[[
	Initializes the templates from storage.
	Creates placeholder models if they don't exist (for testing).
]]
local function initializeTemplates()
	-- Try ServerStorage first, then ReplicatedStorage
	MainIslandTemplate = ServerStorage:FindFirstChild("MainIsland") or ReplicatedStorage:FindFirstChild("MainIsland")
	PlayerPlotTemplate = ServerStorage:FindFirstChild("PlayerPlot") or ReplicatedStorage:FindFirstChild("PlayerPlot")
	BridgeTemplate = ServerStorage:FindFirstChild("Bridge") or ReplicatedStorage:FindFirstChild("Bridge")
	
	-- Create placeholder templates if they don't exist (for testing)
	if not MainIslandTemplate then
		warn("MainIsland template not found! Creating placeholder...")
		local newModel = Instance.new("Model")
		newModel.Name = "MainIsland"
		
		local part = Instance.new("Part")
		part.Name = "Island"
		part.Size = Vector3.new(100, 20, 100)
		part.BrickColor = BrickColor.new("Bright green")
		part.Material = Enum.Material.Grass
		part.Anchored = true
		part.Parent = newModel -- Fixed: parent to newModel, not MainIslandTemplate
		
		newModel.PrimaryPart = part
		newModel.Parent = ServerStorage
		MainIslandTemplate = newModel
	end
	
	if not PlayerPlotTemplate then
		warn("PlayerPlot template not found! Creating placeholder...")
		local newModel = Instance.new("Model")
		newModel.Name = "PlayerPlot"
		
		local part = Instance.new("Part")
		part.Name = "Island"
		part.Size = Vector3.new(80, 15, 80)
		part.BrickColor = BrickColor.new("Bright green")
		part.Material = Enum.Material.Grass
		part.Anchored = true
		part.Parent = newModel -- Fixed: parent to newModel, not PlayerPlotTemplate
		
		newModel.PrimaryPart = part
		newModel.Parent = ServerStorage
		PlayerPlotTemplate = newModel
	end
	
	if not BridgeTemplate then
		warn("Bridge template not found! Creating placeholder...")
		local newModel = Instance.new("Model")
		newModel.Name = "Bridge"
		
		local part = Instance.new("Part")
		part.Name = "BridgePart"
		part.Size = Vector3.new(10, 2, 50) -- Will be scaled to fit
		part.BrickColor = BrickColor.new("Brown")
		part.Material = Enum.Material.Wood
		part.Anchored = true
		part.Parent = newModel -- Fixed: parent to newModel, not BridgeTemplate
		
		newModel.PrimaryPart = part
		newModel.Parent = ServerStorage
		BridgeTemplate = newModel
	end
	
	print("âœ“ Templates initialized")
end

--[[
	Spawns the main central hub island at the world origin.
]]
local function spawnMainIsland()
	local mainIsland = MainIslandTemplate:Clone()
	mainIsland.Name = "MainIsland"
	
	-- Position at origin, at the configured height (lower than plots)
	local hubCFrame = CFrame.new(0, CONFIG.MAIN_ISLAND_HEIGHT, 0)
	
	if mainIsland.PrimaryPart then
		mainIsland:SetPrimaryPartCFrame(hubCFrame)
	else
		mainIsland:PivotTo(hubCFrame)
	end
	
	mainIsland.Parent = workspace
	
	print("âœ“ Main Island spawned at origin")
	return mainIsland
end

--[[
	Generates all 8 player plots around the central hub.
	Creates plots, bridges, and claim parts for each position.
]]
local function generatePlots()
	-- Create the Plots folder in Workspace
	PlotsFolder = Instance.new("Folder")
	PlotsFolder.Name = "Plots"
	PlotsFolder.Parent = workspace
	
	for i = 1, CONFIG.MAX_PLAYERS do
		-- Calculate this plot's position and rotation
		local plotCFrame = calculatePlotCFrame(i)
		
		-- Clone and position the player plot
		local plotModel = PlayerPlotTemplate:Clone()
		plotModel.Name = "Plot_" .. i
		
		if plotModel.PrimaryPart then
			plotModel:SetPrimaryPartCFrame(plotCFrame)
		else
			plotModel:PivotTo(plotCFrame)
		end
		
		plotModel.Parent = PlotsFolder
		
		-- Calculate and create the bridge
		local bridgeCFrame, bridgeDistance = calculateBridgeCFrame(plotCFrame)
		local bridgeModel = BridgeTemplate:Clone()
		bridgeModel.Name = "Bridge_" .. i
		
		-- Scale the bridge to fit the gap
		-- bridgeDistance is already the edge-to-edge distance from calculateBridgeCFrame
		
		-- Scale the bridge parts
		for _, part in bridgeModel:GetDescendants() do
			if part:IsA("BasePart") then
				-- Scale the Z axis (length) of the bridge
				part.Size = Vector3.new(part.Size.X, part.Size.Y, bridgeDistance)
			end
		end
		
		if bridgeModel.PrimaryPart then
			bridgeModel:SetPrimaryPartCFrame(bridgeCFrame)
		else
			bridgeModel:PivotTo(bridgeCFrame)
		end
		
		bridgeModel.Parent = workspace
		
		-- Create the claim part for this plot
		local claimPart = createClaimPart(plotModel)
		
		-- Store plot data
		Plots[i] = {
			Index = i,
			Model = plotModel,
			Bridge = bridgeModel,
			Position = plotCFrame,
			Owner = nil,
			ClaimPart = claimPart,
		}
		
		-- Create placeholder parts for future features
		-- Cannon placeholder (edge of plot facing Main Island)
		local cannonPlaceholder = Instance.new("Part")
		cannonPlaceholder.Name = "Cannon_Placeholder"
		cannonPlaceholder.Size = Vector3.new(4, 4, 4)
		cannonPlaceholder.BrickColor = BrickColor.new("Medium stone grey")
		cannonPlaceholder.Material = Enum.Material.SmoothPlastic
		cannonPlaceholder.Anchored = true
		cannonPlaceholder.CanCollide = false
		cannonPlaceholder.Transparency = 0.5
		cannonPlaceholder.CFrame = plotCFrame * CFrame.new(35, 5, 0)
		cannonPlaceholder.Parent = plotModel
		
		-- Zipline placeholder on Main Island (facing this plot)
		local mainIsland = workspace:FindFirstChild("MainIsland")
		if mainIsland then
			local ziplinePlaceholder = Instance.new("Part")
			ziplinePlaceholder.Name = "Zipline_Placeholder_" .. i
			ziplinePlaceholder.Size = Vector3.new(4, 8, 4)
			ziplinePlaceholder.BrickColor = BrickColor.new("Medium stone grey")
			ziplinePlaceholder.Material = Enum.Material.SmoothPlastic
			ziplinePlaceholder.Anchored = true
			ziplinePlaceholder.CanCollide = false
			ziplinePlaceholder.Transparency = 0.5
			-- Position on edge of main island facing the plot
			local directionToPlot = (plotCFrame.Position - Vector3.new(0, CONFIG.MAIN_ISLAND_HEIGHT, 0)).Unit
			ziplinePlaceholder.Position = Vector3.new(0, CONFIG.MAIN_ISLAND_HEIGHT, 0) + directionToPlot * 45
			ziplinePlaceholder.Parent = mainIsland
		end
		
		print(string.format("âœ“ Plot %d generated at angle %.1fÂ°", i, ((i-1) * 45)))
	end
	
	print("âœ“ All " .. CONFIG.MAX_PLAYERS .. " plots generated")
end

--------------------------------------------------------------------------------
-- PLAYER HANDLING
--------------------------------------------------------------------------------

--[[
	Finds the first available (unowned) plot.
	
	@return number? - The index of an available plot, or nil if all are taken
]]
local function findAvailablePlot(): number?
	for i, plotData in Plots do
		if plotData.Owner == nil then
			return i
		end
	end
	return nil
end

--[[
	Assigns a plot to a player.
	
	@param player Player - The player to assign a plot to
	@param plotIndex number - The index of the plot to assign
]]
local function assignPlotToPlayer(player: Player, plotIndex: number)
	local plotData = Plots[plotIndex]
	if not plotData then
		warn("Invalid plot index: " .. plotIndex)
		return
	end
	
	if plotData.Owner then
		warn("Plot " .. plotIndex .. " is already owned by " .. plotData.Owner.Name)
		return
	end
	
	-- Assign ownership
	plotData.Owner = player
	PlayerToPlot[player] = plotIndex
	
	-- Set OwnerId attribute on the plot model (for BrainrotManager lookups)
	plotData.Model:SetAttribute("OwnerId", player.UserId)
	plotData.Model:SetAttribute("TierIndex", 1)
	
	-- Update the claim part appearance to show it's claimed
	if plotData.ClaimPart then
		plotData.ClaimPart.BrickColor = BrickColor.new("Really red")
		plotData.ClaimPart.Transparency = 0.7
	end
	
	-- Create a folder for player's buildings on their plot
	local buildingsFolder = Instance.new("Folder")
	buildingsFolder.Name = "PlayerBuildings"
	buildingsFolder.Parent = plotData.Model
	
	-- Initialize tier system for this player
	-- Calculate blocked side (facing main island at origin)
	local plotPos = plotData.Position.Position
	local blockedSide = calculateIncomingSide(Vector3.new(0, 0, 0), plotPos)
	
	local initialTier: TierPlotData = {
		TierIndex = 1,
		Model = plotData.Model,
		Bridge = plotData.Bridge,
		ParentTier = nil,
		BlockedSide = blockedSide,
		UsedSides = {},
		GridIndex = 0,
	}
	
	PlayerTierSystems[player] = {
		BasePlotIndex = plotIndex,
		Tiers = {initialTier},
		CurrentTier = 1,
		TotalModels = 0,
	}
	
	print(string.format("âœ“ Assigned Plot %d to %s (Tier 1 initialized, blocked side: %d)", plotIndex, player.Name, blockedSide))
end

--[[
	Teleports a player's character to their assigned plot.
	
	@param player Player - The player to teleport
]]
local function teleportPlayerToPlot(player: Player)
	local plotIndex = PlayerToPlot[player]
	if not plotIndex then
		warn("Player " .. player.Name .. " has no assigned plot")
		return
	end
	
	local plotData = Plots[plotIndex]
	if not plotData then return end
	
	-- Wait for character to exist
	local character = player.Character or player.CharacterAdded:Wait()
	local humanoidRootPart = character:WaitForChild("HumanoidRootPart", 5)
	
	if humanoidRootPart then
		-- Get the actual plot model position (use PrimaryPart or pivot)
		local plotModel = plotData.Model
		local spawnPosition: Vector3
		
		if plotModel.PrimaryPart then
			-- Spawn above the PrimaryPart (the island surface)
			spawnPosition = plotModel.PrimaryPart.Position + Vector3.new(0, 10, 0)
		else
			-- Fallback to pivot position
			spawnPosition = plotModel:GetPivot().Position + Vector3.new(0, 10, 0)
		end
		
		humanoidRootPart.CFrame = CFrame.new(spawnPosition)
		
		print(string.format("âœ“ Teleported %s to Plot %d at position %s", player.Name, plotIndex, tostring(spawnPosition)))
	else
		warn("Could not find HumanoidRootPart for " .. player.Name)
	end
end

--[[
	Clears a player's data from their plot and resets it.
	Removes any buildings the player placed but keeps the island and bridge.
	
	@param player Player - The player whose plot to clear
]]
local function clearPlayerPlot(player: Player)
	local plotIndex = PlayerToPlot[player]
	if not plotIndex then return end
	
	local plotData = Plots[plotIndex]
	if not plotData then return end
	
	-- Clean up tier system
	local tierSystem = PlayerTierSystems[player]
	if tierSystem then
		-- Remove all tier plots except tier 1 (which is the base plot)
		for i = #tierSystem.Tiers, 2, -1 do
			local tierData = tierSystem.Tiers[i]
			if tierData.Bridge then
				tierData.Bridge:Destroy()
			end
			if tierData.Model then
				tierData.Model:Destroy()
			end
		end
		PlayerTierSystems[player] = nil
	end
	
	-- Remove player buildings
	local buildingsFolder = plotData.Model:FindFirstChild("PlayerBuildings")
	if buildingsFolder then
		buildingsFolder:Destroy()
	end
	
	-- Remove player's brainrots
	local brainrotsFolder = plotData.Model:FindFirstChild("Brainrots")
	if brainrotsFolder then
		brainrotsFolder:Destroy()
	end
	
	-- Reset claim part appearance
	if plotData.ClaimPart then
		plotData.ClaimPart.BrickColor = BrickColor.new("Lime green")
		plotData.ClaimPart.Transparency = 0.3
	end
	
	-- Clear ownership
	plotData.Owner = nil
	PlayerToPlot[player] = nil
	
	-- Clear OwnerId attribute (so BrainrotManager knows plot is free)
	plotData.Model:SetAttribute("OwnerId", nil)
	plotData.Model:SetAttribute("TierIndex", nil)
	
	print(string.format("âœ“ Cleared Plot %d and tiers (previously owned by %s)", plotIndex, player.Name))
end

--[[
	Handles a new player joining the game.
	Automatically assigns them to the first available plot and teleports them.
	
	@param player Player - The player who joined
]]
local function onPlayerAdded(player: Player)
	print("Player joined: " .. player.Name)
	
	-- Find an available plot
	local plotIndex = findAvailablePlot()
	
	if not plotIndex then
		warn("No available plots for " .. player.Name .. "! All " .. CONFIG.MAX_PLAYERS .. " plots are taken.")
		return
	end
	
	-- Assign the plot to this player
	assignPlotToPlayer(player, plotIndex)
	
	-- Teleport when character spawns
	local function onCharacterAdded(character)
		-- Small delay to ensure character is fully loaded
		task.wait(1)
		teleportPlayerToPlot(player)
	end
	
	-- Connect to CharacterAdded for initial spawn and respawns
	player.CharacterAdded:Connect(onCharacterAdded)
	
	-- If character already exists, teleport now
	if player.Character then
		onCharacterAdded(player.Character)
	end
end

--[[
	Handles a player leaving the game.
	Clears their plot data and resets the plot for the next player.
	
	@param player Player - The player who left
]]
local function onPlayerRemoving(player: Player)
	print("Player leaving: " .. player.Name)
	clearPlayerPlot(player)
end

--------------------------------------------------------------------------------
-- API FUNCTIONS (for other scripts to use)
--------------------------------------------------------------------------------

--[[
	Gets the plot data for a specific player.
	
	@param player Player - The player to get plot data for
	@return table? - The plot data, or nil if player has no plot
]]
local function getPlayerPlot(player: Player)
	local plotIndex = PlayerToPlot[player]
	if plotIndex then
		return Plots[plotIndex]
	end
	return nil
end

--[[
	Gets all plots data.
	
	@return table - Dictionary of all plots
]]
local function getAllPlots()
	return Plots
end

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

local function initialize()
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	print("   BrainRotClicker - Map Generation")
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	print("")
	print("Config:")
	print("  â€¢ Max Players: " .. CONFIG.MAX_PLAYERS)
	print("  â€¢ Plot Radius: " .. CONFIG.PLOT_RADIUS .. " studs")
	print("  â€¢ Main Island Height: " .. CONFIG.MAIN_ISLAND_HEIGHT .. " studs")
	print("  â€¢ Plot Heights: " .. CONFIG.PLOT_MIN_HEIGHT .. "-" .. CONFIG.PLOT_MAX_HEIGHT .. " studs (random)")
	print("")
	
	-- Initialize templates from storage
	initializeTemplates()
	
	-- Spawn the central hub
	spawnMainIsland()
	
	-- Generate all player plots
	generatePlots()
	
	-- Connect player events
	Players.PlayerAdded:Connect(onPlayerAdded)
	Players.PlayerRemoving:Connect(onPlayerRemoving)
	
	-- Handle players who joined before this script ran
	for _, player in Players:GetPlayers() do
		task.spawn(onPlayerAdded, player)
	end
	
	print("")
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	print("   âœ“ Map Generation Complete!")
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
end

-- Start the initialization
initialize()

-- Export API for other scripts (using _G for simplicity, or you could use a ModuleScript)
_G.MapSystem = {
	GetPlayerPlot = getPlayerPlot,
	GetAllPlots = getAllPlots,
	CONFIG = CONFIG,
	-- Tier System API
	TIER_CONFIG = TIER_CONFIG,
	GetPlayerTierSystem = function(player: Player): PlayerTierSystem?
		return PlayerTierSystems[player]
	end,
	SpawnTierPlot = spawnTierPlot,
	GetCurrentTier = function(player: Player): TierPlotData?
		local tierSystem = PlayerTierSystems[player]
		if tierSystem then
			return tierSystem.Tiers[tierSystem.CurrentTier]
		end
		return nil
	end,
	ResetPlayerPlot = function(player: Player)
		local plotIndex = PlayerToPlot[player]
		if plotIndex then
			print(string.format("ðŸ”„ Admin resetting plot %d for %s", plotIndex, player.Name))
			clearPlayerPlot(player)
			-- Small delay to ensure cleanup
			task.wait(0.1)
			assignPlotToPlayer(player, plotIndex)
			-- Teleport back
			task.delay(0.5, function() 
				teleportPlayerToPlot(player) 
			end)
		end
	end,
	-- Persistence: Restore tiers from saved data
	RestoreTiers = function(player: Player, tierCount: number)
		local tierSystem = PlayerTierSystems[player]
		if not tierSystem then
			warn("RestoreTiers: No tier system found for " .. player.Name)
			return
		end
		
		if tierCount <= 1 then
			print(string.format("RestoreTiers: Only base tier for %s, nothing to restore", player.Name))
			return -- Only base tier, nothing to restore
		end
		
		print(string.format("ðŸ”„ Restoring %d tiers for %s (current tiers: %d)", tierCount, player.Name, #tierSystem.Tiers))
		
		-- Spawn additional tiers up to tierCount
		for i = 2, tierCount do
			local currentTier = tierSystem.Tiers[#tierSystem.Tiers]
			if currentTier then
				print(string.format("  Spawning tier %d from parent tier %d...", i, currentTier.TierIndex))
				local newTier = spawnTierPlot(player, currentTier)
				if newTier then
					tierSystem.CurrentTier = newTier.TierIndex
					print(string.format("  âœ“ Tier %d spawned successfully (bridge/stairs: %s)", 
						i, newTier.Bridge and newTier.Bridge.Name or "nil"))
				else
					warn(string.format("RestoreTiers: Failed to spawn tier %d for %s", i, player.Name))
					break
				end
			else
				warn(string.format("RestoreTiers: No current tier found for iteration %d", i))
			end
		end
		
		print(string.format("âœ“ Restored %d tiers for %s", #tierSystem.Tiers, player.Name))
	end,
}



--------------------------------------------------
File: IslandShopManager.server.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\server\IslandShopManager.server.luau
--------------------------------------------------
--[[
	IslandShopManager Server Script
	
	Handles the Island Shop on the main island where players can:
	1. Purchase tier unlocks early (before filling 12 models)
	2. View their current tier status
	
	Pricing: 5000 * (2 ^ (tierNumber - 1))
	Tier 2: $5,000 | Tier 3: $10,000 | Tier 4: $20,000 | etc.
]]

-- Services
local _Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")

-- Configuration
local SHOP_CONFIG = {
	BASE_TIER_PRICE = 5000,      -- Base price for tier 2
	PRICE_MULTIPLIER = 2,        -- Price doubles per tier
	VENDOR_SIZE = Vector3.new(6, 8, 6),
	VENDOR_POSITION_OFFSET = Vector3.new(-30, 10, 30), -- Offset from main island center
}

-- Remote Events
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")

local PurchaseTierEvent = RemoteEvents:FindFirstChild("PurchaseTier") or Instance.new("RemoteEvent")
PurchaseTierEvent.Name = "PurchaseTier"
PurchaseTierEvent.Parent = RemoteEvents

local GetTierInfoEvent = RemoteEvents:FindFirstChild("GetTierInfo") or Instance.new("RemoteFunction")
GetTierInfoEvent.Name = "GetTierInfo"
GetTierInfoEvent.Parent = RemoteEvents

--------------------------------------------------------------------------------
-- PRICING FUNCTIONS
--------------------------------------------------------------------------------

--[[
	Calculates the price for purchasing a specific tier.
	
	@param tierNumber number - The tier number to purchase (2+)
	@return number - The price for that tier
]]
local function getTierPrice(tierNumber: number): number
	if tierNumber <= 1 then
		return 0 -- Tier 1 is free (starting tier)
	end
	
	-- Formula: 5000 * (2 ^ (tierNumber - 2))
	-- Tier 2: 5000, Tier 3: 10000, Tier 4: 20000, etc.
	return SHOP_CONFIG.BASE_TIER_PRICE * (SHOP_CONFIG.PRICE_MULTIPLIER ^ (tierNumber - 2))
end

--------------------------------------------------------------------------------
-- VENDOR CREATION
--------------------------------------------------------------------------------

--[[
	Creates the Island Shop vendor part on the main island.
]]
local function createIslandShopVendor()
	-- Wait for main island to exist
	local mainIsland = workspace:WaitForChild("MainIsland", 10)
	if not mainIsland then
		warn("MainIsland not found, cannot create Island Shop vendor")
		return nil
	end
	
	-- Check if vendor already exists
	if mainIsland:FindFirstChild("IslandShopVendor") then
		return mainIsland:FindFirstChild("IslandShopVendor")
	end
	
	-- Get main island position
	local mainIslandPos = Vector3.new(0, 30, 0) -- Default main island height
	local islandPart = mainIsland:FindFirstChild("Island") or mainIsland:FindFirstChildWhichIsA("BasePart")
	if islandPart then
		mainIslandPos = islandPart.Position
	end
	
	-- Create the vendor part
	local vendorPart = Instance.new("Part")
	vendorPart.Name = "IslandShopVendor"
	vendorPart.Size = SHOP_CONFIG.VENDOR_SIZE
	vendorPart.BrickColor = BrickColor.new("Bright violet")
	vendorPart.Material = Enum.Material.Neon
	vendorPart.Anchored = true
	vendorPart.CanCollide = true
	vendorPart.Position = mainIslandPos + SHOP_CONFIG.VENDOR_POSITION_OFFSET
	
	-- Create BillboardGui for display
	local billboardGui = Instance.new("BillboardGui")
	billboardGui.Name = "ShopDisplay"
	billboardGui.Size = UDim2.new(6, 0, 3, 0)
	billboardGui.StudsOffset = Vector3.new(0, 6, 0)
	billboardGui.AlwaysOnTop = false
	billboardGui.Parent = vendorPart
	
	-- Background frame
	local bgFrame = Instance.new("Frame")
	bgFrame.Name = "Background"
	bgFrame.Size = UDim2.new(1, 0, 1, 0)
	bgFrame.BackgroundColor3 = Color3.fromRGB(40, 20, 60)
	bgFrame.BackgroundTransparency = 0.2
	bgFrame.Parent = billboardGui
	
	local uiCorner = Instance.new("UICorner")
	uiCorner.CornerRadius = UDim.new(0.1, 0)
	uiCorner.Parent = bgFrame
	
	-- Title label
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "Title"
	titleLabel.Size = UDim2.new(1, 0, 0.4, 0)
	titleLabel.Position = UDim2.new(0, 0, 0, 0)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Text = "ðŸï¸ ISLAND SHOP"
	titleLabel.TextColor3 = Color3.fromRGB(255, 200, 255)
	titleLabel.TextScaled = true
	titleLabel.Font = Enum.Font.GothamBold
	titleLabel.Parent = bgFrame
	
	-- Subtitle label
	local subtitleLabel = Instance.new("TextLabel")
	subtitleLabel.Name = "Subtitle"
	subtitleLabel.Size = UDim2.new(1, 0, 0.3, 0)
	subtitleLabel.Position = UDim2.new(0, 0, 0.4, 0)
	subtitleLabel.BackgroundTransparency = 1
	subtitleLabel.Text = "Buy Island Unlocks"
	subtitleLabel.TextColor3 = Color3.fromRGB(200, 200, 255)
	subtitleLabel.TextScaled = true
	subtitleLabel.Font = Enum.Font.Gotham
	subtitleLabel.Parent = bgFrame
	
	-- Instruction label
	local instructLabel = Instance.new("TextLabel")
	instructLabel.Name = "Instruction"
	instructLabel.Size = UDim2.new(1, 0, 0.25, 0)
	instructLabel.Position = UDim2.new(0, 0, 0.7, 0)
	instructLabel.BackgroundTransparency = 1
	instructLabel.Text = "Press E to open"
	instructLabel.TextColor3 = Color3.fromRGB(180, 180, 180)
	instructLabel.TextScaled = true
	instructLabel.Font = Enum.Font.Gotham
	instructLabel.Parent = bgFrame
	
	-- Tag for proximity detection
	CollectionService:AddTag(vendorPart, "IslandShopVendor")
	
	-- Create ProximityPrompt for interaction
	local prompt = Instance.new("ProximityPrompt")
	prompt.Name = "IslandShopPrompt"
	prompt.ActionText = "Open Island Shop"
	prompt.ObjectText = "Island Shop"
	prompt.KeyboardKeyCode = Enum.KeyCode.E
	prompt.HoldDuration = 0
	prompt.MaxActivationDistance = 10
	prompt.RequiresLineOfSight = false
	prompt.Parent = vendorPart
	
	vendorPart.Parent = mainIsland
	
	print("âœ“ Created Island Shop vendor on Main Island")
	return vendorPart
end

--------------------------------------------------------------------------------
-- PURCHASE HANDLING
--------------------------------------------------------------------------------

--[[
	Handles a player's request to purchase a new tier.
	
	@param player Player - The player attempting to purchase
	@return boolean, string - Success status and message
]]
local function handleTierPurchase(player: Player): (boolean, string)
	-- Wait for MapSystem to be available
	if not _G.MapSystem then
		return false, "Shop system not ready"
	end
	
	local tierSystem = _G.MapSystem.GetPlayerTierSystem(player)
	if not tierSystem then
		return false, "You don't have a plot assigned"
	end
	
	local currentTierCount = #tierSystem.Tiers
	local nextTierNumber = currentTierCount + 1
	
	-- Check max tiers
	local TIER_CONFIG = _G.MapSystem.TIER_CONFIG
	if nextTierNumber > TIER_CONFIG.MAX_TIERS then
		return false, "You've reached the maximum number of islands!"
	end
	
	-- Get price
	local price = getTierPrice(nextTierNumber)
	
	-- Check if player has enough money
	local leaderstats = player:FindFirstChild("leaderstats")
	if not leaderstats then
		return false, "Could not find your money"
	end
	
	local money = leaderstats:FindFirstChild("Money")
	if not money then
		return false, "Could not find your money"
	end
	
	if money.Value < price then
		return false, string.format("Not enough money! Need $%d, have $%d", price, money.Value)
	end
	
	-- Find the tier with available sides to spawn from
	-- Prefer the most recent tier, but fall back to earlier tiers if needed
	local parentTier = nil
	for i = currentTierCount, 1, -1 do
		local tier = tierSystem.Tiers[i]
		local availableSides = 3 - #tier.UsedSides -- 3 sides available (excluding blocked)
		if availableSides > 0 then
			parentTier = tier
			break
		end
	end
	
	if not parentTier then
		return false, "No available space for a new island"
	end
	
	-- Deduct money
	money.Value = money.Value - price
	
	-- Spawn the new tier
	local newTierData = _G.MapSystem.SpawnTierPlot(player, parentTier)
	if not newTierData then
		-- Refund if spawn failed
		money.Value = money.Value + price
		return false, "Failed to create new island"
	end
	
	return true, string.format("Purchased Island %d for $%d!", nextTierNumber, price)
end

--------------------------------------------------------------------------------
-- REMOTE EVENT HANDLERS
--------------------------------------------------------------------------------

PurchaseTierEvent.OnServerEvent:Connect(function(player)
	local success, message = handleTierPurchase(player)
	
	-- Send result back to client
	PurchaseTierEvent:FireClient(player, success, message)
end)

GetTierInfoEvent.OnServerInvoke = function(player)
	if not _G.MapSystem then
		return nil
	end
	
	local tierSystem = _G.MapSystem.GetPlayerTierSystem(player)
	if not tierSystem then
		return nil
	end
	
	local currentTierCount = #tierSystem.Tiers
	local nextTierNumber = currentTierCount + 1
	local TIER_CONFIG = _G.MapSystem.TIER_CONFIG
	
	return {
		CurrentTiers = currentTierCount,
		MaxTiers = TIER_CONFIG.MAX_TIERS,
		NextTierPrice = getTierPrice(nextTierNumber),
		CanPurchase = nextTierNumber <= TIER_CONFIG.MAX_TIERS,
		TotalModels = tierSystem.TotalModels,
		ModelsPerTier = TIER_CONFIG.MODELS_PER_TIER,
	}
end

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

local function initialize()
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	print("   IslandShopManager - Initializing")
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	
	-- Wait a bit for MapSystem to initialize
	task.wait(2)
	
	-- Create the vendor on main island
	createIslandShopVendor()
	
	print("âœ“ IslandShopManager initialized")
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
end

-- Start initialization
task.spawn(initialize)

-- Export API
_G.IslandShop = {
	GetTierPrice = getTierPrice,
	SHOP_CONFIG = SHOP_CONFIG,
}



--------------------------------------------------
File: ItemProductionManager.server.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\server\ItemProductionManager.server.luau
--------------------------------------------------
--[[
	ItemProductionManager Server Script
	
	Handles item production for the Sell a Brainrot system.
	
	Features:
	- Produces items based on owned brainrot counts
	- Milestone-based tier unlocks (1/10/50/100 owned)
	- Produces to ItemStorageManager instead of money
	- Pauses production when storage is full
	
	This REPLACES the income generation in BrainrotManager.
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")

-- Wait for shared modules
local Shared = ReplicatedStorage:WaitForChild("Shared")
local ItemConfig = require(Shared:WaitForChild("ItemConfig"))

-- Constants
local CONFIG = {
	PRODUCTION_TICK = 1,  -- Check production every 1 second
	STORAGE_FULL_CHECK_INTERVAL = 5,  -- Check storage status every 5 seconds for sleeping animation
}

-- Tags
local BRAINROT_TAG = "ActiveBrainrot"

-- Production state per player
-- { [Player] = { categoryProduction = { [category] = { lastProduced = { [tier] = tick } } } } }
local PlayerProduction = {}

-- Remote events for production feedback
local RemoteEvents = ReplicatedStorage:FindFirstChild("RemoteEvents")
if not RemoteEvents then
	RemoteEvents = Instance.new("Folder")
	RemoteEvents.Name = "RemoteEvents"
	RemoteEvents.Parent = ReplicatedStorage
end

local ItemProducedEvent = RemoteEvents:FindFirstChild("ItemProduced") or Instance.new("RemoteEvent")
ItemProducedEvent.Name = "ItemProduced"
ItemProducedEvent.Parent = RemoteEvents

local StorageFullEvent = RemoteEvents:FindFirstChild("StorageFull") or Instance.new("RemoteEvent")
StorageFullEvent.Name = "StorageFull"
StorageFullEvent.Parent = RemoteEvents

--------------------------------------------------------------------------------
-- HELPER FUNCTIONS
--------------------------------------------------------------------------------

--[[
	Waits for ItemStorageManager to be available.
	@return table? - The ItemStorageManager API or nil
]]
local function waitForItemStorageManager()
	local attempts = 0
	while not _G.ItemStorageManager and attempts < 50 do
		attempts += 1
		task.wait(0.1)
	end
	return _G.ItemStorageManager
end

--[[
	Waits for BrainrotManager to be available.
	@return table? - The BrainrotManager API or nil
]]
local function waitForBrainrotManager()
	local attempts = 0
	while not _G.BrainrotManager and attempts < 50 do
		attempts += 1
		task.wait(0.1)
	end
	return _G.BrainrotManager
end

--[[
	Gets the count of brainrots per category for a player.
	Counts from actual active tagged brainrots (more reliable than inventory).
	@param player Player - The player
	@return { [category] = count } - Category counts
]]
local function getCategoryCounts(player)
	local counts = {}
	local debugOnce = not PlayerProduction[player] or not PlayerProduction[player]._debuggedCategories
	local unmappedTypes = {}
	
	-- Count from actual placed brainrots (tagged with ActiveBrainrot)
	local taggedCount = 0
	for _, brainrot in CollectionService:GetTagged(BRAINROT_TAG) do
		local ownerId = brainrot:GetAttribute("OwnerId")
		if ownerId == player.UserId then
			taggedCount = taggedCount + 1
			local unitType = brainrot:GetAttribute("UnitType")
			if unitType then
				local category = ItemConfig.GetBrainrotCategory(unitType)
				if category then
					counts[category] = (counts[category] or 0) + 1
				else
					unmappedTypes[unitType] = true
				end
			end
		end
	end
	
	-- Debug log once per player
	if debugOnce and taggedCount > 0 then
		print(string.format("ðŸ” ItemProductionManager: %s has %d tagged brainrots", player.Name, taggedCount))
		for category, count in pairs(counts) do
			print(string.format("   â€¢ %s: %d brainrots", category, count))
		end
		local unmappedList = {}
		for unitType, _ in pairs(unmappedTypes) do
			table.insert(unmappedList, unitType)
		end
		if #unmappedList > 0 then
			print(string.format("   âš ï¸ Unmapped types: %s", table.concat(unmappedList, ", ")))
		end
		if PlayerProduction[player] then
			PlayerProduction[player]._debuggedCategories = true
		end
	end
	
	return counts
end

--[[
	Initializes production state for a player.
	@param player Player - The player
]]
local function initializePlayer(player)
	PlayerProduction[player] = {
		categoryProduction = {},
		lastStorageFullWarning = 0,
	}
	print(string.format("âœ“ ItemProductionManager: Initialized for %s", player.Name))
end

--[[
	Cleans up production state for a player.
	@param player Player - The player
]]
local function cleanupPlayer(player)
	PlayerProduction[player] = nil
end

--------------------------------------------------------------------------------
-- PRODUCTION LOGIC
--------------------------------------------------------------------------------

--[[
	Produces items for a player based on their owned brainrots.
	Called every production tick.
	@param player Player - The player
]]
local function produceItems(player)
	local production = PlayerProduction[player]
	if not production then return end
	
	local ItemStorageManager = _G.ItemStorageManager
	if not ItemStorageManager then return end
	
	-- Check if storage is full
	if ItemStorageManager.IsStorageFull(player) then
		-- Notify client (throttled)
		local now = tick()
		if now - production.lastStorageFullWarning > CONFIG.STORAGE_FULL_CHECK_INTERVAL then
			production.lastStorageFullWarning = now
			StorageFullEvent:FireClient(player)
			
			-- Update brainrot sleeping animations
			updateSleepingState(player, true)
		end
		return
	else
		-- Storage not full, wake up brainrots
		updateSleepingState(player, false)
	end
	
	-- Get category counts
	local categoryCounts = getCategoryCounts(player)
	
	-- Debug: log category counts periodically
	local hasCategories = false
	for category, count in pairs(categoryCounts) do
		hasCategories = true
		-- Uncomment for debug: print(string.format("  Category %s: %d owned", category, count))
	end
	
	if not hasCategories and tick() % 10 < CONFIG.PRODUCTION_TICK then
		-- Log every ~10 seconds if no categories found
		-- print(string.format("ItemProductionManager: %s has no brainrot categories", player.Name))
	end
	
	-- Process each category
	local now = tick()
	for category, ownedCount in pairs(categoryCounts) do
		if ownedCount > 0 then
			-- Get productions for this category based on milestones
			local productions = ItemConfig.GetProductions(category, ownedCount)
			
			-- Initialize category tracking if needed
			if not production.categoryProduction[category] then
				production.categoryProduction[category] = {
					lastProduced = {},
				}
			end
			local categoryProd = production.categoryProduction[category]
			
			-- Check each tier's production
			for _, prod in ipairs(productions) do
				local tier = ItemConfig.Items[prod.itemId] and ItemConfig.Items[prod.itemId].tier or 1
				local lastProduced = categoryProd.lastProduced[tier] or 0
				local timeSinceLastProd = now - lastProduced
				
				-- Check if enough time has passed for this tier
				if timeSinceLastProd >= prod.rate then
					-- Produce the item
					local added = ItemStorageManager.AddToStorage(player, prod.itemId, 1)
					
					if added > 0 then
						-- Update last produced time
						categoryProd.lastProduced[tier] = now
						
						-- Notify client for visual feedback
						ItemProducedEvent:FireClient(player, prod.itemId, 1)
						
						-- Debug log
						print(string.format("ðŸ“¦ %s produced: %s", player.Name, prod.itemId))
					end
				end
			end
		end
	end
end

--[[
	Updates the sleeping state for all brainrots of a player.
	When storage is full, brainrots "sleep" (visual feedback).
	@param player Player - The player
	@param isSleeping boolean - Whether brainrots should be sleeping
]]
function updateSleepingState(player, isSleeping)
	local BrainrotManager = _G.BrainrotManager
	if not BrainrotManager or not BrainrotManager.GetPlayerPlot then return end
	
	local plot = BrainrotManager.GetPlayerPlot(player)
	if not plot then return end
	
	-- Find all brainrots on the plot
	for _, child in pairs(plot:GetDescendants()) do
		if child:IsA("Model") and CollectionService:HasTag(child, BRAINROT_TAG) then
			-- Set sleeping attribute
			child:SetAttribute("IsSleeping", isSleeping)
			
			-- Visual feedback: add/remove Zzz particles
			local existingZzz = child:FindFirstChild("SleepParticles")
			
			if isSleeping and not existingZzz then
				-- Add sleeping particles
				local primaryPart = child.PrimaryPart or child:FindFirstChildWhichIsA("BasePart")
				if primaryPart then
					local attachment = Instance.new("Attachment")
					attachment.Name = "SleepParticles"
					attachment.Position = Vector3.new(0, 2, 0)
					attachment.Parent = primaryPart
					
					local particles = Instance.new("ParticleEmitter")
					particles.Name = "ZzzParticles"
					particles.Texture = "rbxassetid://6576860692"  -- Z character texture
					particles.Rate = 2
					particles.Speed = NumberRange.new(1, 2)
					particles.Lifetime = NumberRange.new(1, 2)
					particles.Size = NumberSequence.new({
						NumberSequenceKeypoint.new(0, 0.5),
						NumberSequenceKeypoint.new(1, 1.5),
					})
					particles.Transparency = NumberSequence.new({
						NumberSequenceKeypoint.new(0, 0),
						NumberSequenceKeypoint.new(0.8, 0),
						NumberSequenceKeypoint.new(1, 1),
					})
					particles.SpreadAngle = Vector2.new(20, 20)
					particles.Parent = attachment
				end
			elseif not isSleeping and existingZzz then
				-- Remove sleeping particles
				existingZzz:Destroy()
			end
		end
	end
end

--------------------------------------------------------------------------------
-- PRODUCTION LOOP
--------------------------------------------------------------------------------

local function startProductionLoop()
	task.spawn(function()
		while true do
			task.wait(CONFIG.PRODUCTION_TICK)
			
			-- Process all players
			for player, _ in pairs(PlayerProduction) do
				if player.Parent then  -- Player still connected
					task.spawn(produceItems, player)
				end
			end
		end
	end)
	
	print("âœ“ ItemProductionManager: Production loop started")
end

--------------------------------------------------------------------------------
-- PLAYER EVENTS
--------------------------------------------------------------------------------

local function onPlayerAdded(player)
	-- Wait for dependencies
	task.wait(2)
	waitForItemStorageManager()
	waitForBrainrotManager()
	
	initializePlayer(player)
end

local function onPlayerRemoving(player)
	cleanupPlayer(player)
end

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

local function initialize()
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	print("   ItemProductionManager - Initializing")
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	
	-- Connect player events
	Players.PlayerAdded:Connect(onPlayerAdded)
	Players.PlayerRemoving:Connect(onPlayerRemoving)
	
	-- Handle existing players
	for _, player in Players:GetPlayers() do
		task.spawn(onPlayerAdded, player)
	end
	
	-- Start the production loop
	startProductionLoop()
	
	print("âœ“ ItemProductionManager initialized")
	print("  â€¢ Production tick: " .. CONFIG.PRODUCTION_TICK .. "s")
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
end

initialize()

-- Export API for other scripts
_G.ItemProductionManager = {
	ProduceItems = produceItems,
	GetCategoryCounts = getCategoryCounts,
	UpdateSleepingState = updateSleepingState,
}



--------------------------------------------------
File: ItemStorageManager.server.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\server\ItemStorageManager.server.luau
--------------------------------------------------
--[[
	ItemStorageManager Server Script
	
	Manages item-based storage for the Sell a Brainrot system.
	
	Features:
	- Item storage on player plots (replaces money storage)
	- Backpack system for transporting items
	- Storage capacity limits and upgrades
	- Take/deposit operations
	
	Storage format: { [itemId] = count }
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Constants
local CONFIG = {
	DEFAULT_STORAGE_CAPACITY = 2000,
	BACKPACK_CAPACITY = 200,
	
	-- Storage upgrade costs
	STORAGE_UPGRADES = {
		{capacity = 2000, cost = 0},       -- Base
		{capacity = 10000, cost = 15000},  -- Upgrade 1
		{capacity = 50000, cost = 75000},  -- Upgrade 2
		{capacity = math.huge, cost = 0},  -- Prestige (unlimited)
	},
}

-- Player data storage
local PlayerStorage = {} -- { [Player] = { items = {}, capacity = number } }
local PlayerBackpack = {} -- { [Player] = { items = {}, capacity = number } }

-- Remote events for client communication
local RemoteEvents = ReplicatedStorage:FindFirstChild("RemoteEvents")
if not RemoteEvents then
	RemoteEvents = Instance.new("Folder")
	RemoteEvents.Name = "RemoteEvents"
	RemoteEvents.Parent = ReplicatedStorage
end

-- Create remote events for item storage
local StorageUpdatedEvent = RemoteEvents:FindFirstChild("StorageUpdated") or Instance.new("RemoteEvent")
StorageUpdatedEvent.Name = "StorageUpdated"
StorageUpdatedEvent.Parent = RemoteEvents

local BackpackUpdatedEvent = RemoteEvents:FindFirstChild("BackpackUpdated") or Instance.new("RemoteEvent")
BackpackUpdatedEvent.Name = "BackpackUpdated"
BackpackUpdatedEvent.Parent = RemoteEvents

-- Create remote functions for client queries
local GetStorageFunction = RemoteEvents:FindFirstChild("GetStorage") or Instance.new("RemoteFunction")
GetStorageFunction.Name = "GetStorage"
GetStorageFunction.Parent = RemoteEvents

local GetBackpackFunction = RemoteEvents:FindFirstChild("GetBackpack") or Instance.new("RemoteFunction")
GetBackpackFunction.Name = "GetBackpack"
GetBackpackFunction.Parent = RemoteEvents

--------------------------------------------------------------------------------
-- HELPER FUNCTIONS
--------------------------------------------------------------------------------

--[[
	Calculates total item count in a storage table.
	@param items table - The items dictionary
	@return number - Total count of all items
]]
local function getTotalItemCount(items)
	local total = 0
	for _, count in pairs(items) do
		total = total + count
	end
	return total
end

--[[
	Initializes storage for a player.
	@param player Player - The player to initialize
	@param savedData table? - Optional saved data to restore
]]
local function initializePlayer(player, savedData)
	local capacity = CONFIG.DEFAULT_STORAGE_CAPACITY
	local items = {}
	local backpackItems = {}
	
	if savedData then
		items = savedData.itemStorage or {}
		backpackItems = savedData.backpack or {}
		capacity = savedData.storageCapacity or CONFIG.DEFAULT_STORAGE_CAPACITY
	end
	
	PlayerStorage[player] = {
		items = items,
		capacity = capacity,
	}
	
	PlayerBackpack[player] = {
		items = backpackItems,
		capacity = CONFIG.BACKPACK_CAPACITY,
	}
	
	print(string.format("âœ“ ItemStorageManager: Initialized for %s (Storage: %d items, Backpack: %d items)", 
		player.Name, getTotalItemCount(items), getTotalItemCount(backpackItems)))
end

--[[
	Cleans up storage for a player.
	@param player Player - The player to clean up
]]
local function cleanupPlayer(player)
	PlayerStorage[player] = nil
	PlayerBackpack[player] = nil
end

--------------------------------------------------------------------------------
-- STORAGE OPERATIONS
--------------------------------------------------------------------------------

--[[
	Adds items to a player's storage.
	@param player Player - The player
	@param itemId string - The item ID to add
	@param count number - How many to add
	@return number - How many were actually added (may be less if at capacity)
]]
local function addToStorage(player, itemId, count)
	local storage = PlayerStorage[player]
	if not storage then return 0 end
	
	local currentTotal = getTotalItemCount(storage.items)
	local spaceAvailable = storage.capacity - currentTotal
	local actualAdd = math.min(count, spaceAvailable)
	
	if actualAdd <= 0 then
		-- Storage is full
		return 0
	end
	
	storage.items[itemId] = (storage.items[itemId] or 0) + actualAdd
	
	-- Notify client
	StorageUpdatedEvent:FireClient(player, storage.items, currentTotal + actualAdd, storage.capacity)
	
	return actualAdd
end

--[[
	Removes items from a player's storage.
	@param player Player - The player
	@param itemId string - The item ID to remove
	@param count number - How many to remove
	@return number - How many were actually removed
]]
local function removeFromStorage(player, itemId, count)
	local storage = PlayerStorage[player]
	if not storage then return 0 end
	
	local currentCount = storage.items[itemId] or 0
	local actualRemove = math.min(count, currentCount)
	
	if actualRemove <= 0 then return 0 end
	
	storage.items[itemId] = currentCount - actualRemove
	if storage.items[itemId] <= 0 then
		storage.items[itemId] = nil
	end
	
	-- Notify client
	local newTotal = getTotalItemCount(storage.items)
	StorageUpdatedEvent:FireClient(player, storage.items, newTotal, storage.capacity)
	
	return actualRemove
end

--[[
	Gets the contents of a player's storage.
	@param player Player - The player
	@return table - Items dictionary { [itemId] = count }
]]
local function getStorageContents(player)
	local storage = PlayerStorage[player]
	if not storage then return {} end
	return storage.items
end

--[[
	Gets the storage capacity for a player.
	@param player Player - The player
	@return number - Current storage capacity
]]
local function getStorageCapacity(player)
	local storage = PlayerStorage[player]
	if not storage then return CONFIG.DEFAULT_STORAGE_CAPACITY end
	return storage.capacity
end

--[[
	Sets the storage capacity for a player (for upgrades).
	@param player Player - The player
	@param capacity number - New capacity
]]
local function setStorageCapacity(player, capacity)
	local storage = PlayerStorage[player]
	if not storage then return end
	storage.capacity = capacity
	
	-- Notify client
	local currentTotal = getTotalItemCount(storage.items)
	StorageUpdatedEvent:FireClient(player, storage.items, currentTotal, capacity)
end

--[[
	Checks if storage is full.
	@param player Player - The player
	@return boolean - True if storage is at capacity
]]
local function isStorageFull(player)
	local storage = PlayerStorage[player]
	if not storage then return true end
	return getTotalItemCount(storage.items) >= storage.capacity
end

--------------------------------------------------------------------------------
-- BACKPACK OPERATIONS
--------------------------------------------------------------------------------

--[[
	Adds items to a player's backpack.
	@param player Player - The player
	@param itemId string - The item ID to add
	@param count number - How many to add
	@return number - How many were actually added
]]
local function addToBackpack(player, itemId, count)
	local backpack = PlayerBackpack[player]
	if not backpack then return 0 end
	
	local currentTotal = getTotalItemCount(backpack.items)
	local spaceAvailable = backpack.capacity - currentTotal
	local actualAdd = math.min(count, spaceAvailable)
	
	if actualAdd <= 0 then return 0 end
	
	backpack.items[itemId] = (backpack.items[itemId] or 0) + actualAdd
	
	-- Notify client
	BackpackUpdatedEvent:FireClient(player, backpack.items, currentTotal + actualAdd, backpack.capacity)
	
	return actualAdd
end

--[[
	Removes items from a player's backpack.
	@param player Player - The player
	@param itemId string - The item ID to remove
	@param count number - How many to remove
	@return number - How many were actually removed
]]
local function removeFromBackpack(player, itemId, count)
	local backpack = PlayerBackpack[player]
	if not backpack then return 0 end
	
	local currentCount = backpack.items[itemId] or 0
	local actualRemove = math.min(count, currentCount)
	
	if actualRemove <= 0 then return 0 end
	
	backpack.items[itemId] = currentCount - actualRemove
	if backpack.items[itemId] <= 0 then
		backpack.items[itemId] = nil
	end
	
	-- Notify client
	local newTotal = getTotalItemCount(backpack.items)
	BackpackUpdatedEvent:FireClient(player, backpack.items, newTotal, backpack.capacity)
	
	return actualRemove
end

--[[
	Gets the contents of a player's backpack.
	@param player Player - The player
	@return table - Items dictionary { [itemId] = count }
]]
local function getBackpackContents(player)
	local backpack = PlayerBackpack[player]
	if not backpack then return {} end
	return backpack.items
end

--[[
	Gets the backpack capacity for a player.
	@param player Player - The player
	@return number - Backpack capacity
]]
local function getBackpackCapacity(player)
	local backpack = PlayerBackpack[player]
	if not backpack then return CONFIG.BACKPACK_CAPACITY end
	return backpack.capacity
end

--[[
	Sets the backpack capacity for a player (used by TransportManager for vehicle capacities).
	@param player Player - The player
	@param capacity number - New capacity
]]
local function setBackpackCapacity(player, capacity)
	local backpack = PlayerBackpack[player]
	if not backpack then return end
	backpack.capacity = capacity
	
	-- Notify client
	local currentTotal = getTotalItemCount(backpack.items)
	BackpackUpdatedEvent:FireClient(player, backpack.items, currentTotal, capacity)
end

--[[
	Checks if backpack is full.
	@param player Player - The player
	@return boolean - True if backpack is at capacity
]]
local function isBackpackFull(player)
	local backpack = PlayerBackpack[player]
	if not backpack then return true end
	return getTotalItemCount(backpack.items) >= backpack.capacity
end

--------------------------------------------------------------------------------
-- TRANSFER OPERATIONS
--------------------------------------------------------------------------------

--[[
	Transfers items from storage to backpack.
	@param player Player - The player
	@param itemId string - The item ID to transfer
	@param count number - How many to transfer
	@return number - How many were actually transferred
]]
local function takeFromStorage(player, itemId, count)
	local storage = PlayerStorage[player]
	local backpack = PlayerBackpack[player]
	if not storage or not backpack then return 0 end
	
	-- Check how many are available in storage
	local availableInStorage = storage.items[itemId] or 0
	if availableInStorage <= 0 then return 0 end
	
	-- Check how much space is in backpack
	local backpackTotal = getTotalItemCount(backpack.items)
	local backpackSpace = backpack.capacity - backpackTotal
	if backpackSpace <= 0 then return 0 end
	
	-- Calculate actual transfer amount
	local actualTransfer = math.min(count, availableInStorage, backpackSpace)
	
	-- Perform transfer
	removeFromStorage(player, itemId, actualTransfer)
	addToBackpack(player, itemId, actualTransfer)
	
	return actualTransfer
end

--[[
	Transfers all valuable items from storage to backpack ("Take Max").
	Prioritizes higher-value items.
	@param player Player - The player
	@return number - Total items transferred
]]
local function takeMaxFromStorage(player)
	local storage = PlayerStorage[player]
	local backpack = PlayerBackpack[player]
	if not storage or not backpack then return 0 end
	
	-- Get ItemConfig for price sorting
	local ItemConfig
	pcall(function()
		ItemConfig = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("ItemConfig"))
	end)
	
	-- Sort items by value (highest first)
	local sortedItems = {}
	for itemId, count in pairs(storage.items) do
		local price = 1  -- Default price
		if ItemConfig and ItemConfig.Items[itemId] then
			price = ItemConfig.Items[itemId].basePrice or 1
		end
		table.insert(sortedItems, {itemId = itemId, count = count, price = price})
	end
	table.sort(sortedItems, function(a, b) return a.price > b.price end)
	
	-- Fill backpack with highest value items
	local totalTransferred = 0
	local backpackSpace = backpack.capacity - getTotalItemCount(backpack.items)
	
	for _, itemData in ipairs(sortedItems) do
		if backpackSpace <= 0 then break end
		
		local toTransfer = math.min(itemData.count, backpackSpace)
		if toTransfer > 0 then
			removeFromStorage(player, itemData.itemId, toTransfer)
			addToBackpack(player, itemData.itemId, toTransfer)
			totalTransferred = totalTransferred + toTransfer
			backpackSpace = backpackSpace - toTransfer
		end
	end
	
	return totalTransferred
end

--[[
	Deposits items from backpack back to storage.
	@param player Player - The player
	@param itemId string - The item ID to deposit
	@param count number - How many to deposit
	@return number - How many were actually deposited
]]
local function depositToStorage(player, itemId, count)
	local backpack = PlayerBackpack[player]
	local storage = PlayerStorage[player]
	if not backpack or not storage then return 0 end
	
	-- Check how many are in backpack
	local availableInBackpack = backpack.items[itemId] or 0
	if availableInBackpack <= 0 then return 0 end
	
	-- Check storage space
	local storageTotal = getTotalItemCount(storage.items)
	local storageSpace = storage.capacity - storageTotal
	if storageSpace <= 0 then return 0 end
	
	-- Calculate actual transfer
	local actualTransfer = math.min(count, availableInBackpack, storageSpace)
	
	-- Perform transfer
	removeFromBackpack(player, itemId, actualTransfer)
	addToStorage(player, itemId, actualTransfer)
	
	return actualTransfer
end

--------------------------------------------------------------------------------
-- REMOTE FUNCTION HANDLERS
--------------------------------------------------------------------------------

GetStorageFunction.OnServerInvoke = function(player)
	local storage = PlayerStorage[player]
	if not storage then return {}, 0, CONFIG.DEFAULT_STORAGE_CAPACITY end
	return storage.items, getTotalItemCount(storage.items), storage.capacity
end

GetBackpackFunction.OnServerInvoke = function(player)
	local backpack = PlayerBackpack[player]
	if not backpack then return {}, 0, CONFIG.BACKPACK_CAPACITY end
	return backpack.items, getTotalItemCount(backpack.items), backpack.capacity
end

--------------------------------------------------------------------------------
-- PLAYER EVENTS
--------------------------------------------------------------------------------

-- Wait for DataManager to load player data
local function onPlayerAdded(player)
	-- Wait a bit for DataManager to load data
	task.wait(1.5)
	
	-- Check if DataManager has cached data
	local savedData = nil
	if _G.DataManager and _G.DataManager.GetCachedData then
		savedData = _G.DataManager.GetCachedData(player)
	end
	
	initializePlayer(player, savedData)
end

local function onPlayerRemoving(player)
	cleanupPlayer(player)
end

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

local function initialize()
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	print("   ItemStorageManager - Initializing")
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	
	-- Connect player events
	Players.PlayerAdded:Connect(onPlayerAdded)
	Players.PlayerRemoving:Connect(onPlayerRemoving)
	
	-- Handle existing players
	for _, player in Players:GetPlayers() do
		task.spawn(onPlayerAdded, player)
	end
	
	print("âœ“ ItemStorageManager initialized")
	print("  â€¢ Storage capacity: " .. CONFIG.DEFAULT_STORAGE_CAPACITY)
	print("  â€¢ Backpack capacity: " .. CONFIG.BACKPACK_CAPACITY)
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
end

initialize()

-- Export API for other scripts
_G.ItemStorageManager = {
	-- Storage operations
	AddToStorage = addToStorage,
	RemoveFromStorage = removeFromStorage,
	GetStorageContents = getStorageContents,
	GetStorageCapacity = getStorageCapacity,
	SetStorageCapacity = setStorageCapacity,
	IsStorageFull = isStorageFull,
	
	-- Backpack operations
	AddToBackpack = addToBackpack,
	RemoveFromBackpack = removeFromBackpack,
	GetBackpackContents = getBackpackContents,
	GetBackpackCapacity = getBackpackCapacity,
	IsBackpackFull = isBackpackFull,
	
	-- Transfer operations
	TakeFromStorage = takeFromStorage,
	TakeMaxFromStorage = takeMaxFromStorage,
	DepositToStorage = depositToStorage,
	TransferToBackpack = takeFromStorage,  -- Alias for TransportManager
	
	-- Capacity management
	SetBackpackCapacity = setBackpackCapacity,
	
	-- Utility
	GetTotalItemCount = getTotalItemCount,
}



--------------------------------------------------
File: MarketManager.server.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\server\MarketManager.server.luau
--------------------------------------------------
--[[
	MarketManager Server Script
	
	Handles selling items from backpack for money at market prices.
	
	Features:
	- Sell individual items or all at once
	- Uses StockMarketManager multiplier for dynamic pricing
	- Tracks price history for trend indicators
	- Creates Market building on main island
	
	Part of the "Sell a Brainrot" system.
]]

-- Services
local _Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Wait for shared modules
local Shared = ReplicatedStorage:WaitForChild("Shared")
local ItemConfig = require(Shared:WaitForChild("ItemConfig"))

-- Wait for StockMarket folder (from StockMarketManager)
local stockMarketFolder = ReplicatedStorage:WaitForChild("StockMarket")

-- Constants
local CONFIG = {
	MARKET_POSITION = Vector3.new(0, 32, -60), -- On main island
	MARKET_SIZE = Vector3.new(20, 15, 20),
}

-- Remote events and functions
local RemoteEvents = ReplicatedStorage:FindFirstChild("RemoteEvents")
if not RemoteEvents then
	RemoteEvents = Instance.new("Folder")
	RemoteEvents.Name = "RemoteEvents"
	RemoteEvents.Parent = ReplicatedStorage
end

local RemoteFunctions = ReplicatedStorage:FindFirstChild("RemoteFunctions")
if not RemoteFunctions then
	RemoteFunctions = Instance.new("Folder")
	RemoteFunctions.Name = "RemoteFunctions"
	RemoteFunctions.Parent = ReplicatedStorage
end

-- Create events
local ItemSoldEvent = RemoteEvents:FindFirstChild("ItemSold") or Instance.new("RemoteEvent")
ItemSoldEvent.Name = "ItemSold"
ItemSoldEvent.Parent = RemoteEvents

local MarketPricesEvent = RemoteEvents:FindFirstChild("MarketPrices") or Instance.new("RemoteEvent")
MarketPricesEvent.Name = "MarketPrices"
MarketPricesEvent.Parent = RemoteEvents

-- Create functions
local SellItemFunction = RemoteFunctions:FindFirstChild("SellItem") or Instance.new("RemoteFunction")
SellItemFunction.Name = "SellItem"
SellItemFunction.Parent = RemoteFunctions

local SellAllFunction = RemoteFunctions:FindFirstChild("SellAll") or Instance.new("RemoteFunction")
SellAllFunction.Name = "SellAll"
SellAllFunction.Parent = RemoteFunctions

local GetMarketPricesFunction = RemoteFunctions:FindFirstChild("GetMarketPrices") or Instance.new("RemoteFunction")
GetMarketPricesFunction.Name = "GetMarketPrices"
GetMarketPricesFunction.Parent = RemoteFunctions

--------------------------------------------------------------------------------
-- HELPER FUNCTIONS
--------------------------------------------------------------------------------

--[[
	Gets the category that produces a given item.
	@param itemId string - The item ID
	@return string? - The category name or nil
]]
local function getItemCategory(itemId: string): string?
	-- Look through all category item mappings to find which produces this item
	for category, mapping in pairs(ItemConfig.BrainrotItems) do
		if mapping.tier1 == itemId or mapping.tier2 == itemId or 
		   mapping.tier3 == itemId or mapping.tier4 == itemId then
			return category
		end
	end
	return nil
end

--[[
	Gets the current market rate multiplier for a specific item.
	Uses the item's producing category rate.
	@param itemId string? - The item ID (optional, returns average if nil)
	@return number - The market rate (0.5x to 3.0x)
]]
local function getMarketRate(itemId: string?): number
	local StockMarketManager = _G.StockMarketManager
	
	if itemId and StockMarketManager then
		local category = getItemCategory(itemId)
		if category then
			return StockMarketManager.GetCategoryRate(category) or 1.0
		end
	end
	
	-- Fallback to attribute-based rate
	return stockMarketFolder:GetAttribute("CurrentRate") or 1.0
end

--[[
	Calculates the sell price for an item using its category's market rate.
	@param itemId string - The item to price
	@return number - The current sell price
]]
local function getItemPrice(itemId)
	local itemInfo = ItemConfig.Items[itemId]
	if not itemInfo then return 0 end
	
	local basePrice = itemInfo.basePrice or 1
	local marketRate = getMarketRate(itemId)
	
	return math.floor(basePrice * marketRate)
end

--[[
	Gets all current market prices for items with category info.
	@return table - { [itemId] = {basePrice, currentPrice, tier, category, categoryRate} }
]]
local function getAllPrices()
	local prices = {}
	local StockMarketManager = _G.StockMarketManager
	
	for itemId, itemInfo in pairs(ItemConfig.Items) do
		local basePrice = itemInfo.basePrice or 1
		local category = getItemCategory(itemId)
		local categoryRate = 1.0
		
		if category and StockMarketManager then
			categoryRate = StockMarketManager.GetCategoryRate(category) or 1.0
		end
		
		prices[itemId] = {
			basePrice = basePrice,
			currentPrice = math.floor(basePrice * categoryRate),
			tier = itemInfo.tier or 1,
			category = category,
			categoryRate = categoryRate,
		}
	end
	
	return prices
end


--------------------------------------------------------------------------------
-- SELLING FUNCTIONS
--------------------------------------------------------------------------------

--[[
	Sells items from a player's backpack.
	@param player Player - The player
	@param itemId string - Item to sell
	@param count number - How many to sell
	@return number, number - Amount sold, money earned
]]
local function sellItem(player, itemId, count)
	local ItemStorageManager = _G.ItemStorageManager
	if not ItemStorageManager then return 0, 0 end
	
	-- Get how many are in backpack
	local backpack = ItemStorageManager.GetBackpackContents(player)
	local available = backpack[itemId] or 0
	
	if available <= 0 then return 0, 0 end
	
	local toSell = math.min(count, available)
	local pricePerItem = getItemPrice(itemId)
	local totalValue = toSell * pricePerItem
	
	-- Remove from backpack
	local removed = ItemStorageManager.RemoveFromBackpack(player, itemId, toSell)
	if removed <= 0 then return 0, 0 end
	
	-- Add money
	local leaderstats = player:FindFirstChild("leaderstats")
	local moneyValue = leaderstats and leaderstats:FindFirstChild("Money")
	
	if moneyValue then
		moneyValue.Value = moneyValue.Value + totalValue
	end
	
	-- Notify client
	ItemSoldEvent:FireClient(player, itemId, removed, totalValue)
	
	print(string.format("ðŸ’° %s sold %d x %s for $%d", player.Name, removed, itemId, totalValue))
	
	return removed, totalValue
end

--[[
	Sells all items in a player's backpack.
	@param player Player - The player
	@return number, number - Total items sold, total money earned
]]
local function sellAll(player)
	local ItemStorageManager = _G.ItemStorageManager
	if not ItemStorageManager then return 0, 0 end
	
	local backpack = ItemStorageManager.GetBackpackContents(player)
	local totalSold = 0
	local totalEarned = 0
	
	for itemId, count in pairs(backpack) do
		if count > 0 then
			local sold, earned = sellItem(player, itemId, count)
			totalSold = totalSold + sold
			totalEarned = totalEarned + earned
		end
	end
	
	if totalSold > 0 then
		print(string.format("ðŸ’° %s sold all: %d items for $%d total", player.Name, totalSold, totalEarned))
	end
	
	return totalSold, totalEarned
end

--------------------------------------------------------------------------------
-- MARKET BUILDING
--------------------------------------------------------------------------------

local function createMarketBuilding()
	-- Check if already exists
	local mainIsland = workspace:FindFirstChild("MainIsland")
	if mainIsland and mainIsland:FindFirstChild("MarketBuilding") then
		return mainIsland:FindFirstChild("MarketBuilding")
	end
	
	-- Create building
	local building = Instance.new("Part")
	building.Name = "MarketBuilding"
	building.Size = CONFIG.MARKET_SIZE
	building.Position = CONFIG.MARKET_POSITION
	building.Anchored = true
	building.CanCollide = true
	building.Material = Enum.Material.SmoothPlastic
	building.BrickColor = BrickColor.new("Deep orange")
	
	-- Billboard
	local billboard = Instance.new("BillboardGui")
	billboard.Name = "MarketSign"
	billboard.Size = UDim2.new(0, 200, 0, 60)
	billboard.StudsOffset = Vector3.new(0, 12, 0)
	billboard.AlwaysOnTop = false
	billboard.Parent = building
	
	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, 0, 1, 0)
	label.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
	label.BackgroundTransparency = 0.2
	label.Text = "ðŸª MARKET"
	label.TextColor3 = Color3.fromRGB(255, 200, 50)
	label.TextSize = 28
	label.Font = Enum.Font.GothamBold
	label.TextScaled = true
	label.Parent = billboard
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 12)
	corner.Parent = label
	
	-- Proximity prompt
	local prompt = Instance.new("ProximityPrompt")
	prompt.Name = "MarketPrompt"
	prompt.ActionText = "Open Market"
	prompt.ObjectText = "Market Terminal"
	prompt.KeyboardKeyCode = Enum.KeyCode.E
	prompt.HoldDuration = 0
	prompt.MaxActivationDistance = 15
	prompt.Parent = building
	
	-- Parent to main island or workspace
	if mainIsland then
		building.Parent = mainIsland
	else
		building.Parent = workspace
	end
	
	print("âœ“ MarketBuilding created at " .. tostring(CONFIG.MARKET_POSITION))
	
	return building
end

--------------------------------------------------------------------------------
-- REMOTE FUNCTION HANDLERS
--------------------------------------------------------------------------------

SellItemFunction.OnServerInvoke = function(player, itemId, count)
	return sellItem(player, itemId, count or 1)
end

SellAllFunction.OnServerInvoke = function(player)
	return sellAll(player)
end

GetMarketPricesFunction.OnServerInvoke = function(player)
	return getAllPrices(), getMarketRate()
end

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

local function initialize()
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	print("   MarketManager - Initializing")
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	
	-- Wait for main island
	task.wait(3)
	
	-- Create market building
	createMarketBuilding()
	
	print("âœ“ MarketManager initialized")
	print("  â€¢ Market rate: " .. string.format("%.2fx", getMarketRate()))
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
end

initialize()

-- Export API for other scripts
_G.MarketManager = {
	SellItem = sellItem,
	SellAll = sellAll,
	GetItemPrice = getItemPrice,
	GetAllPrices = getAllPrices,
	GetMarketRate = getMarketRate,
}



--------------------------------------------------
File: MewingManager.server.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\server\MewingManager.server.luau
--------------------------------------------------
--[[
	MewingManager Server Script
	
	Tracks and rewards players for "Mewing" (staying AFK/silent).
	
	Mechanics:
	- Tracks last activity time (chat, movement)
	- Awards streak tiers with increasing income bonuses
	- Applies GigaChad jawline cosmetic at max tier
	
	Tiers:
	- 0-60s: Nothing
	- 60s+: Streak Started (+5%)
	- 300s+: Locked In (+10%)
	- 600s+: GigaChad (+20% + Cosmetic)
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TextChatService = game:GetService("TextChatService")
local RunService = game:GetService("RunService")

-- Configuration
local CONFIG = {
	CHECK_INTERVAL = 1, -- Check every second
	MOVEMENT_THRESHOLD = 0.1, -- Velocity threshold for "moving"
	
	TIERS = {
		{ time = 60, name = "Streak Started", multiplier = 1.05, emoji = "ðŸ¤«" },
		{ time = 300, name = "Locked In", multiplier = 1.10, emoji = "ðŸ”’" },
		{ time = 600, name = "GigaChad", multiplier = 1.20, emoji = "ðŸ—¿", cosmetic = true },
	},
	
	SOUNDS = {
		STREAK_START = "rbxassetid://6895079853",
		STREAK_BREAK = "rbxassetid://5702385985", -- Bye bye sound
	},
}

-- State tracking per player
local PlayerMewingState: {[Player]: {
	LastActivityTime: number,
	CurrentTier: number,
	HasCosmetic: boolean,
	LastPosition: Vector3?,
}} = {}

-- Remote Events for client notification
local RemoteEvents = ReplicatedStorage:FindFirstChild("RemoteEvents")
if not RemoteEvents then
	RemoteEvents = Instance.new("Folder")
	RemoteEvents.Name = "RemoteEvents"
	RemoteEvents.Parent = ReplicatedStorage
end

local MewingUpdateEvent = RemoteEvents:FindFirstChild("MewingUpdate") or Instance.new("RemoteEvent")
MewingUpdateEvent.Name = "MewingUpdate"
MewingUpdateEvent.Parent = RemoteEvents

--------------------------------------------------------------------------------
-- ACTIVITY DETECTION
--------------------------------------------------------------------------------

--[[
	Resets a player's mewing streak due to activity.
]]
local function breakStreak(player: Player, reason: string)
	local state = PlayerMewingState[player]
	if not state then return end
	
	local hadStreak = state.CurrentTier > 0
	
	-- Reset state
	state.LastActivityTime = os.time()
	state.CurrentTier = 0
	
	-- Remove cosmetic if present
	if state.HasCosmetic then
		local character = player.Character
		if character then
			local jawline = character:FindFirstChild("GigaChadJawline")
			if jawline then
				jawline:Destroy()
			end
		end
		state.HasCosmetic = false
	end
	
	-- Reset player attribute
	player:SetAttribute("MewingMultiplier", 1.0)
	player:SetAttribute("MewingTier", 0)
	
	if hadStreak then
		-- Notify client
		MewingUpdateEvent:FireClient(player, {
			type = "break",
			reason = reason,
		})
		print(string.format("ðŸ¤« %s broke their Mewing streak: %s", player.Name, reason))
	end
end

--[[
	Checks if player has moved significantly.
]]
local function checkMovement(player: Player): boolean
	local state = PlayerMewingState[player]
	if not state then return false end
	
	local character = player.Character
	if not character then return false end
	
	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return false end
	
	local currentPos = hrp.Position
	
	-- Check velocity
	if hrp.AssemblyLinearVelocity.Magnitude > CONFIG.MOVEMENT_THRESHOLD then
		return true
	end
	
	-- Check position change
	if state.LastPosition then
		local delta = (currentPos - state.LastPosition).Magnitude
		if delta > 1 then -- Moved more than 1 stud
			return true
		end
	end
	
	state.LastPosition = currentPos
	return false
end

--------------------------------------------------------------------------------
-- COSMETIC SYSTEM
--------------------------------------------------------------------------------

--[[
	Applies the GigaChad jawline cosmetic to a player.
]]
local function applyGigaChadCosmetic(player: Player)
	local state = PlayerMewingState[player]
	if not state or state.HasCosmetic then return end
	
	local character = player.Character
	if not character then return end
	
	local head = character:FindFirstChild("Head")
	if not head then return end
	
	-- Create a simple jawline part (placeholder - would be a proper mesh in production)
	local jawline = Instance.new("Part")
	jawline.Name = "GigaChadJawline"
	jawline.Size = Vector3.new(1.5, 0.5, 1.2)
	jawline.BrickColor = BrickColor.new("Light orange")
	jawline.Material = Enum.Material.SmoothPlastic
	jawline.CanCollide = false
	jawline.Massless = true
	
	-- Weld to head
	local weld = Instance.new("Weld")
	weld.Part0 = head
	weld.Part1 = jawline
	weld.C0 = CFrame.new(0, -0.6, 0.1) -- Position below head
	weld.Parent = jawline
	
	jawline.Parent = character
	state.HasCosmetic = true
	
	print(string.format("ðŸ—¿ %s achieved GigaChad status!", player.Name))
end

--------------------------------------------------------------------------------
-- STREAK UPDATE LOGIC
--------------------------------------------------------------------------------

local lastCheck = 0

local function updateMewingStreaks()
	local now = os.time()
	
	-- Only check every CONFIG.CHECK_INTERVAL seconds
	if now - lastCheck < CONFIG.CHECK_INTERVAL then
		return
	end
	lastCheck = now
	
	for player, state in pairs(PlayerMewingState) do
		if not player.Parent then continue end -- Player left
		
		-- Check for movement
		if checkMovement(player) then
			breakStreak(player, "Movement detected")
			continue
		end
		
		-- Calculate streak time
		local streakTime = now - state.LastActivityTime
		
		-- Determine tier
		local newTier = 0
		local tierData = nil
		
		for i, tier in ipairs(CONFIG.TIERS) do
			if streakTime >= tier.time then
				newTier = i
				tierData = tier
			end
		end
		
		-- Tier changed
		if newTier ~= state.CurrentTier then
			state.CurrentTier = newTier
			
			if newTier > 0 and tierData then
				-- Update multiplier
				player:SetAttribute("MewingMultiplier", tierData.multiplier)
				player:SetAttribute("MewingTier", newTier)
				
				-- Apply cosmetic if GigaChad tier
				if tierData.cosmetic then
					applyGigaChadCosmetic(player)
				end
				
				-- Notify client
				MewingUpdateEvent:FireClient(player, {
					type = "tier_up",
					tier = newTier,
					name = tierData.name,
					emoji = tierData.emoji,
					multiplier = tierData.multiplier,
				})
				
				print(string.format("ðŸ¤« %s reached Mewing tier %d: %s (%.0f%%)", 
					player.Name, newTier, tierData.name, (tierData.multiplier - 1) * 100))
			end
		end
	end
end

--------------------------------------------------------------------------------
-- EVENT HANDLERS
--------------------------------------------------------------------------------

local function onPlayerAdded(player: Player)
	-- Initialize state
	PlayerMewingState[player] = {
		LastActivityTime = os.time(),
		CurrentTier = 0,
		HasCosmetic = false,
		LastPosition = nil,
	}
	
	-- Set initial attributes
	player:SetAttribute("MewingMultiplier", 1.0)
	player:SetAttribute("MewingTier", 0)
	
	print(string.format("ðŸ¤« Mewing tracking started for %s", player.Name))
end

local function onPlayerRemoving(player: Player)
	PlayerMewingState[player] = nil
end

--------------------------------------------------------------------------------
-- CHAT DETECTION
--------------------------------------------------------------------------------

-- Modern TextChatService approach
local function setupChatDetection()
	-- Try to get TextChannel for general chat
	local textChannels = TextChatService:WaitForChild("TextChannels", 5)
	if textChannels then
		local generalChannel = textChannels:FindFirstChild("RBXGeneral")
		if generalChannel then
			generalChannel.MessageReceived:Connect(function(message)
				local player = Players:GetPlayerByUserId(message.TextSource.UserId)
				if player then
					breakStreak(player, "Chatted")
				end
			end)
			print("âœ“ Chat detection via TextChatService")
			return
		end
	end
	
	-- Fallback: Legacy chat detection
	local legacyChatEvent = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
	if legacyChatEvent then
		local onMessageDone = legacyChatEvent:FindFirstChild("OnMessageDoneFiltering")
		if onMessageDone and onMessageDone:IsA("RemoteEvent") then
			onMessageDone.OnServerEvent:Connect(function(player)
				breakStreak(player, "Chatted")
			end)
			print("âœ“ Chat detection via Legacy Chat")
			return
		end
	end
	
	warn("MewingManager: Could not set up chat detection")
end

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

local function initialize()
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	print("   MewingManager - Initializing")
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	
	-- Connect player events
	Players.PlayerAdded:Connect(onPlayerAdded)
	Players.PlayerRemoving:Connect(onPlayerRemoving)
	
	-- Handle existing players
	for _, player in Players:GetPlayers() do
		task.spawn(onPlayerAdded, player)
	end
	
	-- Setup chat detection
	task.spawn(setupChatDetection)
	
	-- Start update loop
	RunService.Heartbeat:Connect(updateMewingStreaks)
	
	print("âœ“ MewingManager initialized")
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
end

initialize()

-- Export for other scripts
_G.MewingManager = {
	BreakStreak = breakStreak,
	GetPlayerState = function(player)
		return PlayerMewingState[player]
	end,
}



--------------------------------------------------
File: PrestigeManager.server.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\server\PrestigeManager.server.luau
--------------------------------------------------
--[[
	PrestigeManager Server Script
	
	Handles:
	1. Meatball calculation based on lifetime earnings
	2. Prestige execution (reset + award meatballs)
	3. Meatball Shop purchases
	4. Golden Meatball Altar creation and interaction
	5. Income multipliers from meatballs and upgrades
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local CollectionService = game:GetService("CollectionService")

-- Wait for shared modules
local PrestigeConfig = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("PrestigeConfig"))

-- Remote Events
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local PrestigeEvent = RemoteEvents:FindFirstChild("PrestigeEvent") or Instance.new("RemoteEvent")
PrestigeEvent.Name = "PrestigeEvent"
PrestigeEvent.Parent = RemoteEvents

-- Player Data Cache (mirrors DataManager but specific to prestige)
local PrestigeData = {}

--------------------------------------------------------------------------------
-- HELPER FUNCTIONS
--------------------------------------------------------------------------------

--[[
	Calculates how many meatballs a player should have based on lifetime earnings.
	Formula: 150 * sqrt(LifetimeEarnings / 1,000,000)
]]
local function calculateTotalMeatballsFromEarnings(lifetimeEarnings)
	if lifetimeEarnings < PrestigeConfig.MEATBALL_DIVISOR then
		return 0
	end
	
	local result = PrestigeConfig.MEATBALL_MULTIPLIER * math.sqrt(lifetimeEarnings / PrestigeConfig.MEATBALL_DIVISOR)
	return math.floor(result)
end

--[[
	Gets the player's prestige data, initializing if necessary.
]]
local function getPlayerData(player)
	if not PrestigeData[player] then
		PrestigeData[player] = {
			lifetimeEarnings = 0,
			totalMeatballs = 0,
			spentMeatballs = 0,
			prestigeCount = 0,
			meatballUpgrades = {},
		}
	end
	return PrestigeData[player]
end

--------------------------------------------------------------------------------
-- PUBLIC API
--------------------------------------------------------------------------------

--[[
	Calculates pending meatballs (meatballs to gain if prestige now).
	Returns: pendingAmount, newTotal
]]
local function calculatePendingMeatballs(player)
	local data = getPlayerData(player)
	local currentTotal = data.totalMeatballs
	
	-- Calculate what the total SHOULD be based on lifetime earnings
	local projectedTotal = calculateTotalMeatballsFromEarnings(data.lifetimeEarnings)
	
	-- Pending is the difference
	local pending = math.max(0, projectedTotal - currentTotal)
	
	return pending, projectedTotal
end

--[[
	Adds to lifetime earnings. Called by BrainrotManager when income is generated.
]]
local function addLifetimeEarnings(player, amount)
	local data = getPlayerData(player)
	data.lifetimeEarnings = data.lifetimeEarnings + amount
	
	-- We don't save every tick, DataManager handles saving on exit/autosave
end

--[[
	Gets the income multiplier from unspent meatballs.
	Formula: 1 + (TotalMeatballs * 0.02)
]]
local function getMeatballIncomeMultiplier(player)
	local data = getPlayerData(player)
	-- Bonus applies to TOTAL meatballs collected, not just unspent ones (Adventure Capitalist style)
	-- Or usually it's unspent. The user said "Total Golden Meatballs" in "What Gets Reset" -> "Golden Meatballs (total)" kept.
	-- "Income Boost +2% per meatball". Usually in these games, spending them loses the bonus.
	-- However, the plan says "Total Meatballs = Lifetime accumulated".
	-- Let's assume it's based on OWNED (Current) meatballs usually, but the user plan says:
	-- "Income Boost +2% per meatball (e.g., 100 meatballs = 3x income)"
	-- And "What Gets Reset: ... Kept: Golden Meatballs (total)"
	-- If I spend them, do I lose the bonus?
	-- User plan doesn't explicitly say "Unspent".
	-- But standard mechanic (AdCap) is you spend angels, you lose the bonus.
	-- Let's stick to UNSPENT meatballs for the bonus to make the choice meaningful.
	-- Unspent = Total - Spent
	
	local unspent = data.totalMeatballs - data.spentMeatballs
	return 1 + (unspent * PrestigeConfig.MEATBALL_BONUS_RATE)
end

--[[
	Gets the income multiplier from shop upgrades.
]]
local function getShopMultiplier(player)
	local data = getPlayerData(player)
	local multiplier = 1
	
	for _, upgradeId in ipairs(data.meatballUpgrades) do
		local item = PrestigeConfig.GetItem(upgradeId)
		if item and item.Effect == "IncomeMultiplier" then
			multiplier = multiplier + item.Value
		end
	end
	
	return multiplier
end

--[[
	Gets the total income multiplier (Meatballs * Shop).
]]
local function getTotalIncomeMultiplier(player)
	return getMeatballIncomeMultiplier(player) * getShopMultiplier(player)
end

--[[
	Gets starting money bonus from upgrades.
]]
local function getStartingMoneyBonus(player)
	local data = getPlayerData(player)
	local bonus = 0
	
	for _, upgradeId in ipairs(data.meatballUpgrades) do
		local item = PrestigeConfig.GetItem(upgradeId)
		if item and item.Effect == "StartingMoney" then
			bonus = bonus + item.Value
		end
	end
	
	return bonus
end

--[[
	Executes the prestige.
]]
local function executePrestige(player)
	local pending, newTotal = calculatePendingMeatballs(player)
	
	if pending < PrestigeConfig.MINIMUM_PRESTIGE_GAIN then
		return false, "Not enough meatballs to prestige (Min: " .. PrestigeConfig.MINIMUM_PRESTIGE_GAIN .. ")"
	end
	
	local data = getPlayerData(player)
	
	-- Update prestige data
	data.totalMeatballs = data.totalMeatballs + pending
	data.prestigeCount = data.prestigeCount + 1
	
	-- Reset game progress via DataManager
	if _G.DataManager and _G.DataManager.ResetPlayerData then
		_G.DataManager.ResetPlayerData(player, true) -- true = keep prestige data
	else
		warn("DataManager.ResetPlayerData not found!")
		return false, "Internal error: Could not reset data"
	end
	
	-- Respawn character to reset position
	player:LoadCharacter()
	
	-- Notify client
	PrestigeEvent:FireClient(player, "PrestigeCompleted", {
		gained = pending,
		total = data.totalMeatballs
	})
	
	print(string.format("âœ“ %s prestiged! Gained %d meatballs (Total: %d)", player.Name, pending, data.totalMeatballs))
	return true, "Success"
end

--[[
	Purchases a meatball shop upgrade.
]]
local function purchaseUpgrade(player, upgradeId)
	local data = getPlayerData(player)
	local item = PrestigeConfig.GetItem(upgradeId)
	
	if not item then
		return false, "Item not found"
	end
	
	-- Check if already owned
	for _, ownedId in ipairs(data.meatballUpgrades) do
		if ownedId == upgradeId then
			return false, "Already owned"
		end
	end
	
	-- Check unlock requirement
	if data.totalMeatballs < item.UnlockAt then
		return false, "Item locked"
	end
	
	-- Check price (Unspent meatballs)
	local unspent = data.totalMeatballs - data.spentMeatballs
	if unspent < item.Price then
		return false, "Not enough meatballs"
	end
	
	-- Deduct price
	data.spentMeatballs = data.spentMeatballs + item.Price
	
	-- Add upgrade
	table.insert(data.meatballUpgrades, upgradeId)
	
	-- Save data immediately
	if _G.DataManager and _G.DataManager.SavePlayerData then
		_G.DataManager.SavePlayerData(player)
	end
	
	print(string.format("âœ“ %s purchased meatball upgrade: %s", player.Name, item.Name))
	return true, "Success"
end

--[[
	Initializes player data from DataManager load.
]]
local function initializePlayerData(player, savedData)
	PrestigeData[player] = savedData
end

--------------------------------------------------------------------------------
-- ALTAR CREATION
--------------------------------------------------------------------------------

local function createAltar()
	-- Wait for map to load
	task.wait(2)
	
	local mainIsland = Workspace:WaitForChild("MainIsland", 10)
	if not mainIsland then
		-- Create main island if it doesn't exist (fallback)
		mainIsland = Instance.new("Part")
		mainIsland.Name = "MainIsland"
		mainIsland.Size = Vector3.new(100, 1, 100)
		mainIsland.Position = Vector3.new(0, 0, 0)
		mainIsland.Anchored = true
		mainIsland.Parent = Workspace
	end
	
	local altarModel = Instance.new("Model")
	altarModel.Name = "GoldenMeatballAltar"
	
	-- Main sphere
	local sphere = Instance.new("Part")
	sphere.Name = "Sphere"
	sphere.Size = Vector3.new(12, 12, 12)
	sphere.Shape = Enum.PartType.Ball
	sphere.Color = Color3.fromRGB(255, 215, 0) -- Gold
	sphere.Material = Enum.Material.Neon
	sphere.Anchored = true
	sphere.CanCollide = true
	sphere.Position = Vector3.new(30, 40, 50) -- Positioned at same Y as shops
	sphere.Parent = altarModel
	
	-- Add floating animation script
	-- Add floating animation
	task.spawn(function()
		local RunService = game:GetService("RunService")
		local originalY = sphere.Position.Y
		local t = 0
		local connection
		connection = RunService.Heartbeat:Connect(function(dt)
			if not sphere or not sphere.Parent then
				connection:Disconnect()
				return
			end
			t = t + dt
			sphere.Position = Vector3.new(sphere.Position.X, originalY + math.sin(t) * 2, sphere.Position.Z)
			sphere.Orientation = sphere.Orientation + Vector3.new(0, 1, 0)
		end)
	end)
	
	-- Add particles
	local particles = Instance.new("ParticleEmitter")
	particles.Texture = "rbxassetid://243098098" -- Generic sparkle
	particles.Color = ColorSequence.new(Color3.fromRGB(255, 255, 0))
	particles.Size = NumberSequence.new(0.5, 0)
	particles.Lifetime = NumberRange.new(1, 2)
	particles.Rate = 20
	particles.Speed = NumberRange.new(5, 10)
	particles.SpreadAngle = Vector2.new(360, 360)
	particles.Parent = sphere
	
	-- Add ProximityPrompt
	local prompt = Instance.new("ProximityPrompt")
	prompt.ObjectText = "Golden Meatball Altar"
	prompt.ActionText = "Open Prestige Menu"
	prompt.KeyboardKeyCode = Enum.KeyCode.E
	prompt.MaxActivationDistance = 20
	prompt.RequiresLineOfSight = false
	prompt.Parent = sphere
	
	prompt.Triggered:Connect(function(player)
		-- Send current data to client
		local pending, _ = calculatePendingMeatballs(player)
		local data = getPlayerData(player)
		
		PrestigeEvent:FireClient(player, "OpenMenu", {
			totalMeatballs = data.totalMeatballs,
			spentMeatballs = data.spentMeatballs,
			pendingMeatballs = pending,
			lifetimeEarnings = data.lifetimeEarnings,
			upgrades = data.meatballUpgrades
		})
	end)
	
	altarModel.Parent = Workspace
	print("âœ“ Golden Meatball Altar created")
end

--------------------------------------------------------------------------------
-- EVENT HANDLERS
--------------------------------------------------------------------------------

-- Handle client requests
PrestigeEvent.OnServerEvent:Connect(function(player, action, ...)
	local args = {...}
	
	if action == "Prestige" then
		executePrestige(player)
	elseif action == "PurchaseUpgrade" then
		local upgradeId = args[1]
		local success, msg = purchaseUpgrade(player, upgradeId)
		if success then
			-- Refresh client UI
			local pending, _ = calculatePendingMeatballs(player)
			local data = getPlayerData(player)
			PrestigeEvent:FireClient(player, "UpdateData", {
				totalMeatballs = data.totalMeatballs,
				spentMeatballs = data.spentMeatballs,
				pendingMeatballs = pending,
				lifetimeEarnings = data.lifetimeEarnings,
				upgrades = data.meatballUpgrades
			})
		end
	end
end)

Players.PlayerRemoving:Connect(function(player)
	PrestigeData[player] = nil
end)

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

task.spawn(createAltar)

-- Export API
_G.PrestigeManager = {
	GetPlayerData = getPlayerData,
	InitializePlayerData = initializePlayerData,
	AddLifetimeEarnings = addLifetimeEarnings,
	GetTotalIncomeMultiplier = getTotalIncomeMultiplier,
	GetStartingMoneyBonus = getStartingMoneyBonus,
	ResetPlayerData = function(player)
		-- Reset prestige data to defaults
		PrestigeData[player] = {
			lifetimeEarnings = 0,
			totalMeatballs = 0,
			spentMeatballs = 0,
			prestigeCount = 0,
			meatballUpgrades = {},
		}
		print(string.format("âœ“ Reset prestige data for %s", player.Name))
	end,
}

-- Handle players already in game (in case script loads late)
task.spawn(function()
	-- Wait a moment for DataManager to potentially load if we started at same time
	task.wait(1)
	
	for _, player in Players:GetPlayers() do
		if not PrestigeData[player] then
			if _G.DataManager and _G.DataManager.GetCachedData then
				local data = _G.DataManager.GetCachedData(player)
				if data then
					print("PrestigeManager: Pulling data for existing player " .. player.Name)
					initializePlayerData(player, {
						lifetimeEarnings = data.lifetimeEarnings or 0,
						totalMeatballs = data.totalMeatballs or 0,
						spentMeatballs = data.spentMeatballs or 0,
						prestigeCount = data.prestigeCount or 0,
						meatballUpgrades = data.meatballUpgrades or {},
					})
				end
			end
		end
	end
end)

print("âœ“ PrestigeManager initialized")



--------------------------------------------------
File: ShopManager.server.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\server\ShopManager.server.luau
--------------------------------------------------
--[[
	ShopManager Server Script
	
	Handles all purchase logic for the shop system.
	Creates RemoteFunctions for clients to buy units.
	Tracks progressive unlock progress per player.
	
	Price Formula: BasePrice * (CostMultiplier ^ AmountOwned)
	Income/CycleTime: Affected by milestones at 10/25/50/100/200/300/400/500
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Wait for shared modules
local ShopConfig = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("ShopConfig"))

-- Wait for BrainrotManager API (loaded via _G)
local function waitForBrainrotManager()
	local attempts = 0
	while not _G.BrainrotManager and attempts < 50 do
		attempts += 1
		task.wait(0.1)
	end
	return _G.BrainrotManager
end

-- Remote setup
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")

-- Create BuyUnit RemoteFunction
local BuyUnitRemote = Instance.new("RemoteFunction")
BuyUnitRemote.Name = "BuyUnit"
BuyUnitRemote.Parent = RemoteEvents

-- Create RemoteEvent for ownership updates (to sync client UI)
local OwnershipChangedEvent = Instance.new("RemoteEvent")
OwnershipChangedEvent.Name = "OwnershipChanged"
OwnershipChangedEvent.Parent = RemoteEvents

-- Create RemoteEvent for unlock progress updates
local UnlockProgressChangedEvent = Instance.new("RemoteEvent")
UnlockProgressChangedEvent.Name = "UnlockProgressChanged"
UnlockProgressChangedEvent.Parent = RemoteEvents

--------------------------------------------------------------------------------
-- PLAYER DATA
--------------------------------------------------------------------------------

--[[
	Stores how many of each unit a player owns.
	Structure: PlayerOwnedUnits[Player] = { ["Hand Gesture"] = 3, ... }
]]
local PlayerOwnedUnits: {[Player]: {[string]: number}} = {}

--[[
	Stores how many units are unlocked for each player.
	Starts at INITIAL_UNLOCKED (5).
]]
local PlayerUnlockProgress: {[Player]: number} = {}

--[[
	Initializes ownership tracking for a player.
]]
local function initializePlayerData(player: Player)
	PlayerOwnedUnits[player] = {}
	PlayerUnlockProgress[player] = ShopConfig.INITIAL_UNLOCKED
	
	-- Initialize all units to 0
	for unitName, _ in ShopConfig.Units do
		PlayerOwnedUnits[player][unitName] = 0
	end
	
	-- Create leaderstats folder with Money (CRITICAL for economy system)
	local leaderstats = player:FindFirstChild("leaderstats")
	if not leaderstats then
		leaderstats = Instance.new("Folder")
		leaderstats.Name = "leaderstats"
		leaderstats.Parent = player
		
		local money = Instance.new("IntValue")
		money.Name = "Money"
		money.Value = 100 -- Default starting money
		money.Parent = leaderstats
		
		print(string.format("âœ“ Created leaderstats for %s with $%d", player.Name, money.Value))
	end
	
	-- Create an "OwnedUnits" folder under player for easy inspection
	local ownedFolder = Instance.new("Folder")
	ownedFolder.Name = "OwnedUnits"
	ownedFolder.Parent = player
	
	-- Create IntValue for each unit type
	for unitName, _ in ShopConfig.Units do
		local countValue = Instance.new("IntValue")
		countValue.Name = unitName
		countValue.Value = 0
		countValue.Parent = ownedFolder
	end
	
	-- Create IntValue for unlock progress
	local unlockValue = Instance.new("IntValue")
	unlockValue.Name = "UnlockProgress"
	unlockValue.Value = ShopConfig.INITIAL_UNLOCKED
	unlockValue.Parent = player
	
	print(string.format("âœ“ Initialized shop data for %s (Unlocked: %d units)", player.Name, ShopConfig.INITIAL_UNLOCKED))
end

--[[
	Gets how many of a specific unit a player owns.
]]
local function getOwnedCount(player: Player, unitName: string): number
	if not PlayerOwnedUnits[player] then
		return 0
	end
	return PlayerOwnedUnits[player][unitName] or 0
end

--[[
	Gets the unlock progress for a player.
]]
local function getUnlockProgress(player: Player): number
	return PlayerUnlockProgress[player] or ShopConfig.INITIAL_UNLOCKED
end

--[[
	Increments the unlock progress for a player.
	Called when they purchase any unlocked unit.
]]
local function incrementUnlockProgress(player: Player)
	local currentProgress = getUnlockProgress(player)
	local totalUnits = ShopConfig.GetTotalUnits()
	
	-- Only increment if not at max
	if currentProgress < totalUnits then
		PlayerUnlockProgress[player] = currentProgress + 1
		
		-- Update the IntValue for debugging
		local unlockValue = player:FindFirstChild("UnlockProgress")
		if unlockValue then
			unlockValue.Value = PlayerUnlockProgress[player]
		end
		
		-- Notify client of unlock progress change
		UnlockProgressChangedEvent:FireClient(player, PlayerUnlockProgress[player])
		
		print(string.format("âœ“ %s unlocked unit #%d", player.Name, PlayerUnlockProgress[player]))
	end
end

--[[
	Increments the owned count for a unit and updates the IntValue.
]]
local function incrementOwnedCount(player: Player, unitName: string)
	if not PlayerOwnedUnits[player] then
		PlayerOwnedUnits[player] = {}
	end
	
	PlayerOwnedUnits[player][unitName] = (PlayerOwnedUnits[player][unitName] or 0) + 1
	
	-- Update the IntValue for replication
	local ownedFolder = player:FindFirstChild("OwnedUnits")
	if ownedFolder then
		local countValue = ownedFolder:FindFirstChild(unitName)
		if countValue then
			countValue.Value = PlayerOwnedUnits[player][unitName]
		end
	end
end

--[[
	Cleans up player data when they leave.
]]
local function cleanupPlayerData(player: Player)
	PlayerOwnedUnits[player] = nil
	PlayerUnlockProgress[player] = nil
end

--------------------------------------------------------------------------------
-- CURRENCY FUNCTIONS
--------------------------------------------------------------------------------

--[[
	Gets the player's current money.
]]
local function getMoney(player: Player): number
	local leaderstats = player:FindFirstChild("leaderstats")
	if leaderstats then
		local money = leaderstats:FindFirstChild("Money")
		if money then
			return money.Value
		end
	end
	return 0
end

--[[
	Deducts money from the player.
	Returns true if successful, false if not enough money.
]]
local function deductMoney(player: Player, amount: number): boolean
	local leaderstats = player:FindFirstChild("leaderstats")
	if not leaderstats then return false end
	
	local money = leaderstats:FindFirstChild("Money")
	if not money then return false end
	
	if money.Value >= amount then
		money.Value = money.Value - amount
		return true
	end
	
	return false
end

--------------------------------------------------------------------------------
-- PURCHASE LOGIC
--------------------------------------------------------------------------------

--[[
	Handles a purchase request from a client.
	
	@param player Player - The player making the purchase
	@param unitName string - The name of the unit to buy
	@return boolean, string? - Success status and optional message
]]
local function handleBuyUnit(player: Player, unitName: string): (boolean, string?)
	-- Security: Verify player is near ShopVendor on Main Island
	local mainIsland = workspace:FindFirstChild("MainIsland")
	local shopVendor = mainIsland and mainIsland:FindFirstChild("ShopVendor")
	if shopVendor then
		local character = player.Character
		local hrp = character and character:FindFirstChild("HumanoidRootPart")
		if hrp then
			local distance = (hrp.Position - shopVendor.Position).Magnitude
			if distance > 20 then
				return false, "You must be at the shop to make purchases!"
			end
		end
	end
	
	-- Validate unit exists
	local unitConfig = ShopConfig.GetConfig(unitName)
	if not unitConfig then
		return false, "Unknown unit: " .. tostring(unitName)
	end
	
	-- Check if unit is unlocked for this player
	local unlockProgress = getUnlockProgress(player)
	if not ShopConfig.IsUnitUnlocked(unitName, unlockProgress) then
		return false, "This unit is locked! Purchase other units to unlock."
	end
	
	-- Calculate current price based on owned count
	local ownedCount = getOwnedCount(player, unitName)
	local currentPrice = ShopConfig.CalculatePrice(unitName, ownedCount)
	
	-- Check if player has enough money
	local playerMoney = getMoney(player)
	if playerMoney < currentPrice then
		return false, string.format("Not enough money! Need $%d, have $%d", currentPrice, playerMoney)
	end
	
	-- Deduct money
	if not deductMoney(player, currentPrice) then
		return false, "Failed to deduct money"
	end
	
	-- Spawn or Upgrade the brainrot unit
	local BrainrotManager = waitForBrainrotManager()
	if BrainrotManager then
		-- AddUnit handles both spawning new and upgrading existing
		local unit = BrainrotManager.AddUnit(player, unitConfig.ModelName)
		
		if not unit then
			-- Refund if failed
			local leaderstats = player:FindFirstChild("leaderstats")
			if leaderstats and leaderstats:FindFirstChild("Money") then
				leaderstats.Money.Value = leaderstats.Money.Value + currentPrice
			end
			return false, "Failed to process unit transaction"
		end
		
		-- Increment owned count (which is now Level)
		incrementOwnedCount(player, unitName)
		local newLevel = getOwnedCount(player, unitName)
		
		-- Get current rarity from the unit
		local rarity = unit:GetAttribute("Rarity") or "Normal"
		local rarityMultiplier = 1
		if BrainrotManager.RARITY_CONFIG and BrainrotManager.RARITY_CONFIG[rarity] then
			rarityMultiplier = BrainrotManager.RARITY_CONFIG[rarity].multiplier or 1
		end
		
		-- Calculate income based on new level
		local effectiveIncome = ShopConfig.CalculateEffectiveIncome(unitName, newLevel)
		local effectiveCycleTime = ShopConfig.CalculateEffectiveCycleTime(unitName, newLevel)
		
		-- Apply rarity multiplier to income
		local finalIncome = effectiveIncome * rarityMultiplier
		
		-- Update unit attributes
		unit:SetAttribute("IncomeAmount", finalIncome)
		-- Note: BrainrotManager handles IncomeInterval (speed) updates internally based on level
		
		-- Check if we crossed a milestone
		local oldMilestones = ShopConfig.GetMilestonesReached(newLevel - 1)
		local newMilestones = ShopConfig.GetMilestonesReached(newLevel)
		
		if #newMilestones > #oldMilestones then
			print(string.format("â­ %s reached milestone for %s! (%dâ†’%d milestones)", 
				player.Name, unitName, #oldMilestones, #newMilestones))
		end
		
	else
		warn("BrainrotManager not available!")
		return false, "Server error: spawn system unavailable"
	end
	
	-- Increment unlock progress (unlock next unit)
	incrementUnlockProgress(player)
	
	-- Notify client of ownership change (for UI update)
	local newLevel = getOwnedCount(player, unitName)
	local newPrice = ShopConfig.CalculatePrice(unitName, newLevel)
	OwnershipChangedEvent:FireClient(player, unitName, newLevel, newPrice)
	
	print(string.format("âœ“ %s upgraded %s to Level %d for $%d", player.Name, unitName, newLevel, currentPrice))
	
	return true, "Purchase successful!"
end

--------------------------------------------------------------------------------
-- API FOR OTHER SCRIPTS
--------------------------------------------------------------------------------

--[[
	Gets all ownership data for a player (for initial UI sync).
	Now includes unlock progress.
]]
local function getPlayerOwnership(player: Player): {units: {[string]: {count: number, price: number}}, unlockProgress: number}
	local data = {
		units = {},
		unlockProgress = getUnlockProgress(player),
	}
	
	for unitName, _ in ShopConfig.Units do
		local count = getOwnedCount(player, unitName)
		local price = ShopConfig.CalculatePrice(unitName, count)
		data.units[unitName] = {
			count = count,
			price = price,
		}
	end
	
	return data
end

-- Create RemoteFunction to get initial ownership data
local GetOwnershipRemote = Instance.new("RemoteFunction")
GetOwnershipRemote.Name = "GetOwnership"
GetOwnershipRemote.Parent = RemoteEvents

GetOwnershipRemote.OnServerInvoke = function(player: Player)
	return getPlayerOwnership(player)
end

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

local function initialize()
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	print("   ShopManager - Initializing")
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	
	-- Connect player events
	Players.PlayerAdded:Connect(initializePlayerData)
	Players.PlayerRemoving:Connect(cleanupPlayerData)
	
	-- Handle existing players
	for _, player in Players:GetPlayers() do
		task.spawn(initializePlayerData, player)
	end
	
	-- Connect buy remote
	BuyUnitRemote.OnServerInvoke = handleBuyUnit
	
	print(string.format("âœ“ ShopManager initialized (%d total units)", ShopConfig.GetTotalUnits()))
	print(string.format("  â€¢ Initial unlocked: %d units", ShopConfig.INITIAL_UNLOCKED))
	print("  â€¢ BuyUnit RemoteFunction ready")
	print("  â€¢ GetOwnership RemoteFunction ready")
	print("  â€¢ OwnershipChanged RemoteEvent ready")
	print("  â€¢ UnlockProgressChanged RemoteEvent ready")
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
end

initialize()

--[[
	Sets player data from saved data (called by DataManager on load).
	
	@param player Player - The player to set data for
	@param ownedUnits table - Dictionary of {unitName: count}
	@param unlockProgress number - How many units are unlocked
]]
local function setPlayerData(player: Player, ownedUnits: {[string]: number}, unlockProgress: number)
	-- Set unlock progress
	PlayerUnlockProgress[player] = unlockProgress
	
	local unlockValue = player:FindFirstChild("UnlockProgress")
	if unlockValue then
		unlockValue.Value = unlockProgress
	end
	
	-- Set owned units
	if not PlayerOwnedUnits[player] then
		PlayerOwnedUnits[player] = {}
	end
	
	local ownedFolder = player:FindFirstChild("OwnedUnits")
	
	for unitName, count in ownedUnits do
		PlayerOwnedUnits[player][unitName] = count
		
		if ownedFolder then
			local countValue = ownedFolder:FindFirstChild(unitName)
			if countValue then
				countValue.Value = count
			end
		end
	end
	
	-- Notify client of updated unlock progress
	UnlockProgressChangedEvent:FireClient(player, unlockProgress)
	
	-- Notify client of all owned unit counts
	for unitName, count in ownedUnits do
		local price = ShopConfig.CalculatePrice(unitName, count)
		OwnershipChangedEvent:FireClient(player, unitName, count, price)
	end
	
	print(string.format("âœ“ Loaded saved data for %s: %d units unlocked", player.Name, unlockProgress))
end

-- Export for other scripts
_G.ShopManager = {
	GetOwnedCount = getOwnedCount,
	GetPlayerOwnership = getPlayerOwnership,
	GetUnlockProgress = getUnlockProgress,
	SetPlayerData = setPlayerData,
	ResetPlayerData = function(player: Player)
		-- Reset unlock progress
		PlayerUnlockProgress[player] = ShopConfig.INITIAL_UNLOCKED
		
		-- Reset owned units to 0
		PlayerOwnedUnits[player] = {}
		for unitName, _ in ShopConfig.Units do
			PlayerOwnedUnits[player][unitName] = 0
		end
		
		-- Update the IntValue for unlock progress
		local unlockValue = player:FindFirstChild("UnlockProgress")
		if unlockValue then
			unlockValue.Value = ShopConfig.INITIAL_UNLOCKED
		end
		
		-- Update owned unit IntValues
		local ownedFolder = player:FindFirstChild("OwnedUnits")
		if ownedFolder then
			for unitName, _ in ShopConfig.Units do
				local countValue = ownedFolder:FindFirstChild(unitName)
				if countValue then
					countValue.Value = 0
				end
			end
		end
		
		-- Notify client
		UnlockProgressChangedEvent:FireClient(player, ShopConfig.INITIAL_UNLOCKED)
		for unitName, _ in ShopConfig.Units do
			local price = ShopConfig.CalculatePrice(unitName, 0)
			OwnershipChangedEvent:FireClient(player, unitName, 0, price)
		end
		
		print(string.format("âœ“ Reset shop data for %s", player.Name))
	end,
}




--------------------------------------------------
File: StockMarketBillboards.server.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\server\StockMarketBillboards.server.luau
--------------------------------------------------
--[[
	StockMarketBillboards Server Script
	
	Creates 4 giant floating billboards above the Main Island
	that display the stock market graph.
	
	Billboard positions: North, South, East, West - all facing the center
]]

-- Services
local Workspace = game:GetService("Workspace")

-- Configuration
local BILLBOARD_CONFIG = {
	SIZE = Vector3.new(80, 60, 2),     -- 80 wide, 60 tall, 2 thick
	HEIGHT_OFFSET = 120,                -- Height above MainIsland
	DISTANCE_FROM_CENTER = 100,         -- Distance from island center (further back)
	
	-- Colors
	FRAME_COLOR = Color3.fromRGB(30, 30, 40),
	SCREEN_COLOR = Color3.fromRGB(15, 15, 25),
}

-- Billboard positions relative to center (X, Z offsets and Y rotation)
local BILLBOARD_POSITIONS = {
	{ name = "North", offset = Vector3.new(0, 0, -BILLBOARD_CONFIG.DISTANCE_FROM_CENTER), rotation = 0 },
	{ name = "South", offset = Vector3.new(0, 0, BILLBOARD_CONFIG.DISTANCE_FROM_CENTER), rotation = 180 },
	{ name = "East", offset = Vector3.new(BILLBOARD_CONFIG.DISTANCE_FROM_CENTER, 0, 0), rotation = -90 },
	{ name = "West", offset = Vector3.new(-BILLBOARD_CONFIG.DISTANCE_FROM_CENTER, 0, 0), rotation = 90 },
}

--[[
	Creates a single billboard at the specified position.
]]
local function createBillboard(positionData: {name: string, offset: Vector3, rotation: number}, centerPosition: Vector3)
	-- Create the billboard model
	local billboardModel = Instance.new("Model")
	billboardModel.Name = "StockMarketBillboard_" .. positionData.name
	
	-- Create the main screen part
	local screenPart = Instance.new("Part")
	screenPart.Name = "Screen"
	screenPart.Size = BILLBOARD_CONFIG.SIZE
	screenPart.Anchored = true
	screenPart.CanCollide = false
	screenPart.Material = Enum.Material.Neon
	screenPart.Color = BILLBOARD_CONFIG.SCREEN_COLOR
	screenPart.CastShadow = false
	
	-- Position and rotate to face center
	local position = centerPosition + positionData.offset + Vector3.new(0, BILLBOARD_CONFIG.HEIGHT_OFFSET, 0)
	screenPart.CFrame = CFrame.new(position) * CFrame.Angles(0, math.rad(positionData.rotation), 0)
	screenPart.Parent = billboardModel
	
	-- Create frame/border around the screen
	local frameThickness = 2
	local frameColor = BILLBOARD_CONFIG.FRAME_COLOR
	
	-- Top frame
	local topFrame = Instance.new("Part")
	topFrame.Name = "TopFrame"
	topFrame.Size = Vector3.new(BILLBOARD_CONFIG.SIZE.X + frameThickness * 2, frameThickness, BILLBOARD_CONFIG.SIZE.Z)
	topFrame.Anchored = true
	topFrame.CanCollide = false
	topFrame.Material = Enum.Material.Metal
	topFrame.Color = frameColor
	topFrame.CFrame = screenPart.CFrame * CFrame.new(0, BILLBOARD_CONFIG.SIZE.Y / 2 + frameThickness / 2, 0)
	topFrame.Parent = billboardModel
	
	-- Bottom frame
	local bottomFrame = Instance.new("Part")
	bottomFrame.Name = "BottomFrame"
	bottomFrame.Size = Vector3.new(BILLBOARD_CONFIG.SIZE.X + frameThickness * 2, frameThickness, BILLBOARD_CONFIG.SIZE.Z)
	bottomFrame.Anchored = true
	bottomFrame.CanCollide = false
	bottomFrame.Material = Enum.Material.Metal
	bottomFrame.Color = frameColor
	bottomFrame.CFrame = screenPart.CFrame * CFrame.new(0, -BILLBOARD_CONFIG.SIZE.Y / 2 - frameThickness / 2, 0)
	bottomFrame.Parent = billboardModel
	
	-- Left frame
	local leftFrame = Instance.new("Part")
	leftFrame.Name = "LeftFrame"
	leftFrame.Size = Vector3.new(frameThickness, BILLBOARD_CONFIG.SIZE.Y, BILLBOARD_CONFIG.SIZE.Z)
	leftFrame.Anchored = true
	leftFrame.CanCollide = false
	leftFrame.Material = Enum.Material.Metal
	leftFrame.Color = frameColor
	leftFrame.CFrame = screenPart.CFrame * CFrame.new(-BILLBOARD_CONFIG.SIZE.X / 2 - frameThickness / 2, 0, 0)
	leftFrame.Parent = billboardModel
	
	-- Right frame
	local rightFrame = Instance.new("Part")
	rightFrame.Name = "RightFrame"
	rightFrame.Size = Vector3.new(frameThickness, BILLBOARD_CONFIG.SIZE.Y, BILLBOARD_CONFIG.SIZE.Z)
	rightFrame.Anchored = true
	rightFrame.CanCollide = false
	rightFrame.Material = Enum.Material.Metal
	rightFrame.Color = frameColor
	rightFrame.CFrame = screenPart.CFrame * CFrame.new(BILLBOARD_CONFIG.SIZE.X / 2 + frameThickness / 2, 0, 0)
	rightFrame.Parent = billboardModel
	
	-- Create SurfaceGui on the front face
	local surfaceGui = Instance.new("SurfaceGui")
	surfaceGui.Name = "StockMarketDisplay"
	surfaceGui.Face = Enum.NormalId.Front
	surfaceGui.CanvasSize = Vector2.new(1600, 1200) -- High resolution for detail
	surfaceGui.LightInfluence = 0
	surfaceGui.Brightness = 1
	surfaceGui.Parent = screenPart
	
	-- Create main container frame
	local container = Instance.new("Frame")
	container.Name = "Container"
	container.Size = UDim2.new(1, 0, 1, 0)
	container.BackgroundColor3 = BILLBOARD_CONFIG.SCREEN_COLOR
	container.BorderSizePixel = 0
	container.Parent = surfaceGui
	
	-- Title
	local title = Instance.new("TextLabel")
	title.Name = "Title"
	title.Size = UDim2.new(1, 0, 0.12, 0)
	title.Position = UDim2.new(0, 0, 0, 0)
	title.BackgroundTransparency = 1
	title.Text = "ðŸ“ˆ BRAINROT STOCKS"
	title.TextColor3 = Color3.fromRGB(255, 255, 255)
	title.TextScaled = true
	title.Font = Enum.Font.GothamBold
	title.Parent = container
	
	-- Current rate display
	local rateDisplay = Instance.new("TextLabel")
	rateDisplay.Name = "RateDisplay"
	rateDisplay.Size = UDim2.new(0.35, 0, 0.12, 0)
	rateDisplay.Position = UDim2.new(0.05, 0, 0.12, 0)
	rateDisplay.BackgroundTransparency = 1
	rateDisplay.Text = "BEST: 1.00x"
	rateDisplay.TextColor3 = Color3.fromRGB(100, 255, 100)
	rateDisplay.TextScaled = true
	rateDisplay.Font = Enum.Font.GothamBold
	rateDisplay.TextXAlignment = Enum.TextXAlignment.Left
	rateDisplay.Parent = container
	
	-- Rate name display
	local rateName = Instance.new("TextLabel")
	rateName.Name = "RateName"
	rateName.Size = UDim2.new(0.5, 0, 0.08, 0)
	rateName.Position = UDim2.new(0.45, 0, 0.16, 0)
	rateName.BackgroundTransparency = 1
	rateName.Text = "NORMAL"
	rateName.TextColor3 = Color3.fromRGB(180, 180, 180)
	rateName.TextScaled = true
	rateName.Font = Enum.Font.Gotham
	rateName.TextXAlignment = Enum.TextXAlignment.Right
	rateName.Parent = container
	
	-- Graph container
	local graphContainer = Instance.new("Frame")
	graphContainer.Name = "GraphContainer"
	graphContainer.Size = UDim2.new(0.9, 0, 0.6, 0)
	graphContainer.Position = UDim2.new(0.05, 0, 0.3, 0)
	graphContainer.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
	graphContainer.BorderSizePixel = 0
	graphContainer.Parent = container
	
	local graphCorner = Instance.new("UICorner")
	graphCorner.CornerRadius = UDim.new(0, 10)
	graphCorner.Parent = graphContainer
	
	-- 1.0x baseline marker
	local baselineFrame = Instance.new("Frame")
	baselineFrame.Name = "Baseline"
	baselineFrame.Size = UDim2.new(1, 0, 0, 2)
	baselineFrame.Position = UDim2.new(0, 0, 0.4, 0) -- 1.0 is at 40% from top (since range is 0.5-3.0)
	baselineFrame.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
	baselineFrame.BackgroundTransparency = 0.5
	baselineFrame.BorderSizePixel = 0
	baselineFrame.Parent = graphContainer
	
	-- Baseline label
	local baselineLabel = Instance.new("TextLabel")
	baselineLabel.Name = "BaselineLabel"
	baselineLabel.Size = UDim2.new(0.08, 0, 0.08, 0)
	baselineLabel.Position = UDim2.new(0.92, 0, 0.36, 0)
	baselineLabel.BackgroundTransparency = 1
	baselineLabel.Text = "1.0x"
	baselineLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
	baselineLabel.TextScaled = true
	baselineLabel.Font = Enum.Font.Gotham
	baselineLabel.Parent = graphContainer
	
	-- Graph lines container (will be populated by client)
	local graphLines = Instance.new("Frame")
	graphLines.Name = "GraphLines"
	graphLines.Size = UDim2.new(1, 0, 1, 0)
	graphLines.BackgroundTransparency = 1
	graphLines.Parent = graphContainer
	
	-- Timer display
	local timerDisplay = Instance.new("TextLabel")
	timerDisplay.Name = "TimerDisplay"
	timerDisplay.Size = UDim2.new(1, 0, 0.08, 0)
	timerDisplay.Position = UDim2.new(0, 0, 0.92, 0)
	timerDisplay.BackgroundTransparency = 1
	timerDisplay.Text = "Next update in: 10s"
	timerDisplay.TextColor3 = Color3.fromRGB(150, 150, 150)
	timerDisplay.TextScaled = true
	timerDisplay.Font = Enum.Font.Gotham
	timerDisplay.Parent = container
	
	billboardModel.Parent = Workspace
	
	print(string.format("âœ“ Created %s billboard at position (%d, %d, %d)", 
		positionData.name, position.X, position.Y, position.Z))
	
	return billboardModel
end

--[[
	Initializes all 4 billboards above the Main Island.
]]
local function initialize()
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	print("   StockMarketBillboards - Initializing")
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	
	-- Wait for main island
	task.wait(2)
	
	local mainIsland = Workspace:WaitForChild("MainIsland", 10)
	local centerPosition = Vector3.new(0, 30, 0) -- Default main island center
	
	if mainIsland then
		local islandPart = mainIsland:FindFirstChild("Island") or mainIsland:FindFirstChildWhichIsA("BasePart")
		if islandPart then
			centerPosition = Vector3.new(islandPart.Position.X, 30, islandPart.Position.Z)
		end
	end
	
	-- Create billboards folder
	local billboardsFolder = Instance.new("Folder")
	billboardsFolder.Name = "StockMarketBillboards"
	billboardsFolder.Parent = Workspace
	
	-- Create all 4 billboards
	for _, posData in ipairs(BILLBOARD_POSITIONS) do
		local billboard = createBillboard(posData, centerPosition)
		billboard.Parent = billboardsFolder
	end
	
	print("âœ“ StockMarketBillboards initialized (4 billboards created)")
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
end

-- Start initialization
task.spawn(initialize)



--------------------------------------------------
File: StockMarketManager.server.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\server\StockMarketManager.server.luau
--------------------------------------------------
--[[
	StockMarketManager Server Script
	
	Handles the dynamic brainrot stock market with per-category price indexes.
	- 6 independent category rates: Skibidi, Bombardiro, Tralalero, BrrBrr, Sigma, Mewer
	- Each category has independent volatility and mean reversion
	- Continuous rate range from 0.5x to 3.0x per category
	- Updates every 20 seconds with random walk + mean reversion
	- Stores 60 data points of history per category for graph display
	- Replicates rates and histories to clients via Attributes
]]

-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")

-- Configuration
local CONFIG = {
	UPDATE_INTERVAL = 20, -- Seconds between updates
	
	-- Rate Range
	MIN_RATE = 0.5,
	MAX_RATE = 3.0,
	STARTING_RATE = 1.0,
	
	-- Base Movement Settings
	BASE_VOLATILITY = 0.25,   -- Normal change range
	SPIKE_CHANCE = 0.10,      -- 10% chance of larger move
	SPIKE_MULTIPLIER = 2.5,   -- Spikes are 2.5x normal volatility
	MEAN_REVERSION = 0.05,    -- Strength of pull towards 1.0
	
	-- History
	MAX_HISTORY = 60,         -- 60 data points = 20 minutes of data
}

-- Category-specific volatility modifiers
local CATEGORY_VOLATILITY = {
	Skibidi = 0.25,     -- Low volatility (stable)
	Bombardiro = 0.45,  -- High volatility (explosive)
	Tralalero = 0.30,   -- Medium volatility
	BrrBrr = 0.35,      -- Medium-high volatility
	Sigma = 0.40,       -- High volatility
	Mewer = 0.20,       -- Very stable
}

-- All category names
local CATEGORIES = {"Skibidi", "Bombardiro", "Tralalero", "BrrBrr", "Sigma", "Mewer"}

-- Category display info (colors for client reference)
local CATEGORY_COLORS = {
	Skibidi = {148, 103, 189},    -- Purple
	Bombardiro = {255, 127, 14},  -- Orange
	Tralalero = {44, 160, 44},    -- Green
	BrrBrr = {31, 119, 180},      -- Blue
	Sigma = {214, 39, 40},        -- Red
	Mewer = {227, 119, 194},      -- Pink
}

-- State per category
local categoryRates = {}
local categoryHistories = {}

-- Initialize state for all categories
for _, category in ipairs(CATEGORIES) do
	categoryRates[category] = CONFIG.STARTING_RATE
	categoryHistories[category] = {}
	-- Fill history with starting rate
	for i = 1, CONFIG.MAX_HISTORY do
		table.insert(categoryHistories[category], CONFIG.STARTING_RATE)
	end
end

local nextUpdate = 0

-- Setup ReplicatedStorage container
local stockMarketFolder = ReplicatedStorage:FindFirstChild("StockMarket")
if not stockMarketFolder then
	stockMarketFolder = Instance.new("Folder")
	stockMarketFolder.Name = "StockMarket"
	stockMarketFolder.Parent = ReplicatedStorage
end

--[[
	Serializes a single category's history to comma-separated string.
]]
local function serializeHistory(history: {number}): string
	local parts = {}
	for _, rate in ipairs(history) do
		table.insert(parts, string.format("%.3f", rate))
	end
	return table.concat(parts, ",")
end

--[[
	Serializes all category rates to JSON for attribute storage.
]]
local function serializeCategoryRates(): string
	local ratesTable = {}
	for category, rate in pairs(categoryRates) do
		ratesTable[category] = math.floor(rate * 1000) / 1000 -- Round to 3 decimals
	end
	return HttpService:JSONEncode(ratesTable)
end

--[[
	Serializes all category histories to JSON for attribute storage.
]]
local function serializeCategoryHistories(): string
	local historiesTable = {}
	for category, history in pairs(categoryHistories) do
		historiesTable[category] = serializeHistory(history)
	end
	return HttpService:JSONEncode(historiesTable)
end

--[[
	Calculates the global rate name based on the average rate.
]]
local function getGlobalRateName(): string
	local sum = 0
	for _, rate in pairs(categoryRates) do
		sum = sum + rate
	end
	local avgRate = sum / #CATEGORIES
	
	if avgRate >= 2.5 then
		return "HYPER INFLATION"
	elseif avgRate >= 1.5 then
		return "STONKS"
	elseif avgRate <= 0.7 then
		return "CRASH"
	else
		return "NORMAL"
	end
end

--[[
	Calculates the average rate across all categories for backwards compatibility.
]]
local function getAverageRate(): number
	local sum = 0
	for _, rate in pairs(categoryRates) do
		sum = sum + rate
	end
	return sum / #CATEGORIES
end

--[[
	Calculates a new rate for a specific category using random walk with mean reversion.
]]
local function calculateNewRate(category: string): number
	local currentRate = categoryRates[category]
	local volatility = CATEGORY_VOLATILITY[category] or CONFIG.BASE_VOLATILITY
	
	-- Base random change with category-specific volatility
	local baseChange = (math.random() - 0.5) * 2 * volatility
	
	-- Occasional larger moves (volatility spikes)
	if math.random() < CONFIG.SPIKE_CHANCE then
		baseChange = baseChange * CONFIG.SPIKE_MULTIPLIER
	end
	
	-- Mean reversion: gently pull towards 1.0
	local reversion = (CONFIG.STARTING_RATE - currentRate) * CONFIG.MEAN_REVERSION
	
	-- Apply changes
	local newRate = currentRate + baseChange + reversion
	
	-- Clamp to valid range
	return math.clamp(newRate, CONFIG.MIN_RATE, CONFIG.MAX_RATE)
end

--[[
	Updates the market with new rates for all categories.
]]
local function updateMarket()
	-- Update each category
	for _, category in ipairs(CATEGORIES) do
		local newRate = calculateNewRate(category)
		categoryRates[category] = newRate
		
		-- Update history
		table.insert(categoryHistories[category], newRate)
		if #categoryHistories[category] > CONFIG.MAX_HISTORY then
			table.remove(categoryHistories[category], 1)
		end
	end
	
	-- Calculate average for backwards compatibility
	local avgRate = getAverageRate()
	local globalRateName = getGlobalRateName()
	
	-- Update Attributes for clients
	-- Per-category data (new)
	stockMarketFolder:SetAttribute("CategoryRates", serializeCategoryRates())
	stockMarketFolder:SetAttribute("CategoryHistories", serializeCategoryHistories())
	stockMarketFolder:SetAttribute("Categories", HttpService:JSONEncode(CATEGORIES))
	stockMarketFolder:SetAttribute("CategoryColors", HttpService:JSONEncode(CATEGORY_COLORS))
	
	-- Global data (backwards compatible)
	stockMarketFolder:SetAttribute("CurrentRate", avgRate)
	stockMarketFolder:SetAttribute("RateName", globalRateName)
	stockMarketFolder:SetAttribute("RateHistory", serializeHistory(categoryHistories.Skibidi)) -- Legacy fallback
	stockMarketFolder:SetAttribute("LastUpdate", os.time())
	stockMarketFolder:SetAttribute("UpdateInterval", CONFIG.UPDATE_INTERVAL)
end

-- Initialize Attributes
stockMarketFolder:SetAttribute("Categories", HttpService:JSONEncode(CATEGORIES))
stockMarketFolder:SetAttribute("CategoryColors", HttpService:JSONEncode(CATEGORY_COLORS))
stockMarketFolder:SetAttribute("CategoryRates", serializeCategoryRates())
stockMarketFolder:SetAttribute("CategoryHistories", serializeCategoryHistories())
stockMarketFolder:SetAttribute("CurrentRate", CONFIG.STARTING_RATE)
stockMarketFolder:SetAttribute("RateName", "NORMAL")
stockMarketFolder:SetAttribute("RateHistory", serializeHistory(categoryHistories.Skibidi))
stockMarketFolder:SetAttribute("LastUpdate", os.time())
stockMarketFolder:SetAttribute("UpdateInterval", CONFIG.UPDATE_INTERVAL)
stockMarketFolder:SetAttribute("MinRate", CONFIG.MIN_RATE)
stockMarketFolder:SetAttribute("MaxRate", CONFIG.MAX_RATE)

-- Main Loop
RunService.Heartbeat:Connect(function()
	local now = os.time()
	if now >= nextUpdate then
		updateMarket()
		nextUpdate = now + CONFIG.UPDATE_INTERVAL
		stockMarketFolder:SetAttribute("NextUpdate", nextUpdate)
	end
end)

-- Initial update
nextUpdate = os.time() + CONFIG.UPDATE_INTERVAL
stockMarketFolder:SetAttribute("NextUpdate", nextUpdate)

-- Export API for other scripts to get category rates
_G.StockMarketManager = {
	GetCategoryRate = function(category: string): number
		return categoryRates[category] or 1.0
	end,
	GetAllCategoryRates = function(): {[string]: number}
		return table.clone(categoryRates)
	end,
	GetCategories = function(): {string}
		return CATEGORIES
	end,
}

print("âœ“ StockMarketManager initialized (6 category stocks: 0.5x - 3.0x)")



--------------------------------------------------
File: StorageBoxManager.server.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\server\StorageBoxManager.server.luau
--------------------------------------------------
--[[
	StorageBoxManager Server Script
	
	Creates a visual storage box on each player's plot.
	Brainrots shoot their produce (via ProjectileVisuals) into this storage.
	
	The storage box is positioned at the center of the plot.
]]

-- Services
local Players = game:GetService("Players")

-- Configuration
local STORAGE_CONFIG = {
	-- Box appearance
	SIZE = Vector3.new(8, 6, 8),
	COLOR = Color3.fromRGB(80, 140, 200),
	MATERIAL = Enum.Material.SmoothPlastic,
	TRANSPARENCY = 0.2,
	
	-- Position (relative to plot center)
	OFFSET_Y = 3, -- Height above plot surface
}

--------------------------------------------------------------------------------
-- STORAGE CREATION
--------------------------------------------------------------------------------

--[[
	Finds the player's plot.
]]
local function findPlayerPlot(player)
	local plotsFolder = workspace:FindFirstChild("Plots")
	if not plotsFolder then return nil end
	
	for _, plot in plotsFolder:GetChildren() do
		if plot:GetAttribute("OwnerId") == player.UserId then
			return plot
		end
	end
	
	return nil
end

--[[
	Gets the plot floor/island part.
]]
local function getPlotFloor(plot)
	return plot:FindFirstChild("Island") 
		or plot:FindFirstChild("PlotFloor") 
		or plot:FindFirstChild("Floor")
		or plot:FindFirstChildWhichIsA("BasePart")
end

--[[
	Creates a storage box on the player's plot.
]]
local function createStorageBox(player)
	local plot = findPlayerPlot(player)
	if not plot then 
		warn("StorageBoxManager: No plot found for " .. player.Name)
		return nil
	end
	
	-- Check if storage already exists
	local existingStorage = plot:FindFirstChild("Storage")
	if existingStorage then
		return existingStorage
	end
	
	local floor = getPlotFloor(plot)
	if not floor then
		warn("StorageBoxManager: No floor found for " .. player.Name)
		return nil
	end
	
	-- Calculate position (center of plot, on top)
	local floorPos = floor.Position
	local floorSize = floor.Size
	local storageY = floorPos.Y + (floorSize.Y / 2) + STORAGE_CONFIG.OFFSET_Y + (STORAGE_CONFIG.SIZE.Y / 2)
	
	-- Create storage box
	local storage = Instance.new("Part")
	storage.Name = "Storage"
	storage.Size = STORAGE_CONFIG.SIZE
	storage.Position = Vector3.new(floorPos.X, storageY, floorPos.Z)
	storage.Anchored = true
	storage.CanCollide = false
	storage.Color = STORAGE_CONFIG.COLOR
	storage.Material = STORAGE_CONFIG.MATERIAL
	storage.Transparency = STORAGE_CONFIG.TRANSPARENCY
	
	-- Add a subtle glow
	local pointLight = Instance.new("PointLight")
	pointLight.Color = STORAGE_CONFIG.COLOR
	pointLight.Range = 15
	pointLight.Brightness = 0.3
	pointLight.Parent = storage
	
	-- Add label
	local billboard = Instance.new("BillboardGui")
	billboard.Name = "StorageLabel"
	billboard.Size = UDim2.new(0, 100, 0, 30)
	billboard.StudsOffset = Vector3.new(0, 4, 0)
	billboard.AlwaysOnTop = false
	billboard.Parent = storage
	
	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, 0, 1, 0)
	label.BackgroundTransparency = 1
	label.Text = "ðŸ“¦ STORAGE"
	label.TextColor3 = Color3.new(1, 1, 1)
	label.TextScaled = true
	label.Font = Enum.Font.GothamBold
	label.TextStrokeTransparency = 0
	label.TextStrokeColor3 = Color3.new(0, 0, 0)
	label.Parent = billboard
	
	storage.Parent = plot
	
	print("StorageBoxManager: Created storage for " .. player.Name)
	return storage
end

--[[
	Removes the storage box when player leaves (optional cleanup).
]]
local function removeStorageBox(player)
	local plot = findPlayerPlot(player)
	if plot then
		local storage = plot:FindFirstChild("Storage")
		if storage then
			storage:Destroy()
		end
	end
end

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

-- Create storage for existing players
for _, player in Players:GetPlayers() do
	task.defer(function()
		-- Wait a bit for plot to be assigned
		task.wait(1)
		createStorageBox(player)
	end)
end

-- Create storage when new players join
Players.PlayerAdded:Connect(function(player)
	task.defer(function()
		-- Wait for plot assignment
		task.wait(2)
		createStorageBox(player)
	end)
end)

-- Cleanup on player leave (optional)
-- Players.PlayerRemoving:Connect(removeStorageBox)

-- Export API
_G.StorageBoxManager = {
	CreateStorage = createStorageBox,
	RemoveStorage = removeStorageBox,
}

print("âœ“ StorageBoxManager initialized")



--------------------------------------------------
File: StorageUpgradeManager.server.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\server\StorageUpgradeManager.server.luau
--------------------------------------------------
--[[
	StorageUpgradeManager Server Script
	
	Handles the storage upgrade shop on the Main Island.
	- Storage doubles with each upgrade: 500 â†’ 1000 â†’ 2000 â†’ 4000...
	- Price doubles with each upgrade: 100 â†’ 200 â†’ 400 â†’ 800...
	- Creates StorageVendor part with ProximityPrompt on Main Island
]]

-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Configuration
local CONFIG = {
	BASE_STORAGE = 500,     -- Starting max storage
	BASE_PRICE = 100,       -- Starting upgrade price
	MULTIPLIER = 2,         -- Both storage and price multiply by 2
}

-- Wait for RemoteEvents folder
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")

-- Create RemoteFunctions for storage upgrade
local UpgradeStorageRemote = Instance.new("RemoteFunction")
UpgradeStorageRemote.Name = "UpgradeStorage"
UpgradeStorageRemote.Parent = RemoteEvents

local GetStorageInfoRemote = Instance.new("RemoteFunction")
GetStorageInfoRemote.Name = "GetStorageInfo"
GetStorageInfoRemote.Parent = RemoteEvents

-- Create RemoteEvent to notify client of storage upgrade
local StorageUpgradedEvent = Instance.new("RemoteEvent")
StorageUpgradedEvent.Name = "StorageUpgraded"
StorageUpgradedEvent.Parent = RemoteEvents

-- Wait for BrainrotManager API
local function waitForBrainrotManager()
	local attempts = 0
	while not _G.BrainrotManager and attempts < 50 do
		attempts += 1
		task.wait(0.1)
	end
	return _G.BrainrotManager
end

--------------------------------------------------------------------------------
-- STORAGE CALCULATIONS
--------------------------------------------------------------------------------

--[[
	Calculates how many upgrades a player has based on their max storage.
	
	@param maxStorage number - Current max storage
	@return number - Number of upgrades purchased
]]
local function getUpgradeLevel(maxStorage: number): number
	-- Formula: BASE_STORAGE * (2 ^ level) = maxStorage
	-- So: level = log2(maxStorage / BASE_STORAGE)
	if maxStorage <= CONFIG.BASE_STORAGE then
		return 0
	end
	return math.floor(math.log(maxStorage / CONFIG.BASE_STORAGE) / math.log(2))
end

--[[
	Calculates the price for the next storage upgrade.
	
	@param upgradeLevel number - Current upgrade level (0-based)
	@return number - Price for the next upgrade
]]
local function getUpgradePrice(upgradeLevel: number): number
	return CONFIG.BASE_PRICE * (CONFIG.MULTIPLIER ^ upgradeLevel)
end

--[[
	Calculates what the new max storage will be after upgrading.
	
	@param currentMax number - Current max storage
	@return number - New max storage after upgrade
]]
local function getNewMaxStorage(currentMax: number): number
	return currentMax * CONFIG.MULTIPLIER
end

--------------------------------------------------------------------------------
-- PURCHASE LOGIC
--------------------------------------------------------------------------------

--[[
	Handles a storage upgrade request from a client.
	
	@param player Player - The player making the purchase
	@return boolean, string? - Success status and optional message
]]
local function handleUpgradeStorage(player: Player): (boolean, string?)
	-- Security: Verify player is near StorageVendor on Main Island
	local mainIsland = workspace:FindFirstChild("MainIsland")
	local storageVendor = mainIsland and mainIsland:FindFirstChild("StorageVendor")
	if storageVendor then
		local character = player.Character
		local hrp = character and character:FindFirstChild("HumanoidRootPart")
		if hrp then
			local distance = (hrp.Position - storageVendor.Position).Magnitude
			if distance > 20 then
				return false, "You must be at the storage vendor to upgrade!"
			end
		end
	end
	
	-- Get player's plot
	local BrainrotManager = waitForBrainrotManager()
	if not BrainrotManager then
		return false, "Server error: BrainrotManager not available"
	end
	
	local plot = BrainrotManager.GetPlayerPlot(player)
	if not plot then
		return false, "You don't have a plot!"
	end
	
	-- Get current storage info
	local currentMax = plot:GetAttribute("MaxStorage") or CONFIG.BASE_STORAGE
	local upgradeLevel = getUpgradeLevel(currentMax)
	local upgradePrice = getUpgradePrice(upgradeLevel)
	
	-- Check if player has enough money
	local leaderstats = player:FindFirstChild("leaderstats")
	if not leaderstats then
		return false, "No leaderstats found"
	end
	
	local money = leaderstats:FindFirstChild("Money")
	if not money then
		return false, "No money found"
	end
	
	if money.Value < upgradePrice then
		return false, string.format("Not enough money! Need $%d, have $%d", upgradePrice, money.Value)
	end
	
	-- Deduct money
	money.Value = money.Value - upgradePrice
	
	-- Calculate new max storage (doubles)
	local newMaxStorage = getNewMaxStorage(currentMax)
	
	-- Update plot attribute
	plot:SetAttribute("MaxStorage", newMaxStorage)
	
	-- Update visual display
	local currentStorage = plot:GetAttribute("CurrentStorage") or 0
	if BrainrotManager.UpdateStorageVisual then
		BrainrotManager.UpdateStorageVisual(plot, currentStorage, newMaxStorage)
	end
	
	-- Calculate next upgrade info
	local newUpgradeLevel = upgradeLevel + 1
	local nextPrice = getUpgradePrice(newUpgradeLevel)
	local nextMaxStorage = getNewMaxStorage(newMaxStorage)
	
	-- Notify client of upgrade
	StorageUpgradedEvent:FireClient(player, {
		currentMax = newMaxStorage,
		upgradeLevel = newUpgradeLevel,
		nextPrice = nextPrice,
		nextMaxStorage = nextMaxStorage,
	})
	
	print(string.format("âœ“ %s upgraded storage: $%d â†’ %d capacity (Level %d)", 
		player.Name, upgradePrice, newMaxStorage, newUpgradeLevel))
	
	return true, "Storage upgraded!"
end

--[[
	Gets storage info for a player (for UI).
	
	@param player Player - The player to get info for
	@return table - Storage upgrade info
]]
local function handleGetStorageInfo(player: Player)
	local BrainrotManager = waitForBrainrotManager()
	if not BrainrotManager then
		return {
			currentMax = CONFIG.BASE_STORAGE,
			upgradeLevel = 0,
			nextPrice = CONFIG.BASE_PRICE,
			nextMaxStorage = CONFIG.BASE_STORAGE * 2,
		}
	end
	
	local plot = BrainrotManager.GetPlayerPlot(player)
	if not plot then
		return {
			currentMax = CONFIG.BASE_STORAGE,
			upgradeLevel = 0,
			nextPrice = CONFIG.BASE_PRICE,
			nextMaxStorage = CONFIG.BASE_STORAGE * 2,
		}
	end
	
	local currentMax = plot:GetAttribute("MaxStorage") or CONFIG.BASE_STORAGE
	local upgradeLevel = getUpgradeLevel(currentMax)
	local nextPrice = getUpgradePrice(upgradeLevel)
	local nextMaxStorage = getNewMaxStorage(currentMax)
	
	return {
		currentMax = currentMax,
		upgradeLevel = upgradeLevel,
		nextPrice = nextPrice,
		nextMaxStorage = nextMaxStorage,
	}
end

--------------------------------------------------------------------------------
-- STORAGE VENDOR CREATION
--------------------------------------------------------------------------------

--[[
	Creates the StorageVendor part on the Main Island.
]]
local function createStorageVendor()
	local mainIsland = workspace:WaitForChild("MainIsland", 30)
	if not mainIsland then
		warn("StorageUpgradeManager: MainIsland not found")
		return
	end
	
	-- Check if already exists
	if mainIsland:FindFirstChild("StorageVendor") then
		return
	end
	
	-- Create the vendor part
	local storageVendor = Instance.new("Part")
	storageVendor.Name = "StorageVendor"
	storageVendor.Size = Vector3.new(6, 8, 6)
	storageVendor.BrickColor = BrickColor.new("Deep orange")
	storageVendor.Material = Enum.Material.Neon
	storageVendor.Anchored = true
	storageVendor.CanCollide = true
	
	-- Position near the shop vendor but offset
	local shopVendor = mainIsland:FindFirstChild("ShopVendor")
	if shopVendor then
		storageVendor.Position = shopVendor.Position + Vector3.new(15, 0, 0)
	else
		local primaryPart = mainIsland.PrimaryPart or mainIsland:FindFirstChildWhichIsA("BasePart")
		if primaryPart then
			storageVendor.Position = primaryPart.Position + Vector3.new(35, 10, 0)
		else
			-- Fallback: main island is at height 30, so position at 40
			storageVendor.Position = Vector3.new(35, 40, 0)
		end
	end
	
	storageVendor.Parent = mainIsland
	
	-- Add visual label
	local billboard = Instance.new("BillboardGui")
	billboard.Size = UDim2.new(5, 0, 2, 0)
	billboard.StudsOffset = Vector3.new(0, 6, 0)
	billboard.Parent = storageVendor
	
	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, 0, 1, 0)
	label.BackgroundTransparency = 1
	label.Text = "ðŸ“¦ STORAGE"
	label.TextColor3 = Color3.fromRGB(255, 200, 100)
	label.TextScaled = true
	label.Font = Enum.Font.GothamBold
	label.Parent = billboard
	
	-- Create ProximityPrompt (client will use this to open UI)
	local prompt = Instance.new("ProximityPrompt")
	prompt.Name = "StoragePrompt"
	prompt.ActionText = "Upgrade Storage"
	prompt.ObjectText = "Storage"
	prompt.KeyboardKeyCode = Enum.KeyCode.E
	prompt.HoldDuration = 0
	prompt.MaxActivationDistance = 10
	prompt.RequiresLineOfSight = false
	prompt.Parent = storageVendor
	
	print("âœ“ StorageVendor created on Main Island")
end

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

local function initialize()
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	print("   StorageUpgradeManager - Initializing")
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	
	-- Create storage vendor on main island
	task.spawn(createStorageVendor)
	
	-- Connect remote functions
	UpgradeStorageRemote.OnServerInvoke = handleUpgradeStorage
	GetStorageInfoRemote.OnServerInvoke = handleGetStorageInfo
	
	print("âœ“ StorageUpgradeManager initialized")
	print(string.format("  â€¢ Base Storage: %d", CONFIG.BASE_STORAGE))
	print(string.format("  â€¢ Base Price: $%d", CONFIG.BASE_PRICE))
	print(string.format("  â€¢ Multiplier: x%d per upgrade", CONFIG.MULTIPLIER))
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
end

-- Start the system
initialize()

-- Export for other scripts
_G.StorageUpgradeManager = {
	CONFIG = CONFIG,
	GetUpgradeLevel = getUpgradeLevel,
	GetUpgradePrice = getUpgradePrice,
	GetNewMaxStorage = getNewMaxStorage,
}



--------------------------------------------------
File: TransportManager.server.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\server\TransportManager.server.luau
--------------------------------------------------
--[[
	TransportManager Server Script
	
	Handles the transport system for carrying items from storage to market.
	
	Features:
	- Vehicle selection and spawning
	- Item loading from storage to backpack
	- Backpack capacity management
	- Vehicle upgrades
	
	Part of the "Sell a Brainrot" system.
]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Wait for shared modules
local Shared = ReplicatedStorage:WaitForChild("Shared")
local ItemConfig = require(Shared:WaitForChild("ItemConfig"))

-- Constants
local CONFIG = {
	DEFAULT_VEHICLE = "Sneakers",
	VEHICLES = {
		Sneakers = {
			capacity = 100,
			price = 0,  -- Starter vehicle
			description = "Basic transport, small capacity",
		},
		Cart = {
			capacity = 500,
			price = 5000,
			description = "Wooden cart, medium capacity",
		},
		Hoverboard = {
			capacity = 2000,
			price = 50000,
			description = "Futuristic hover transport",
		},
		Truck = {
			capacity = 10000,
			price = 500000,
			description = "Massive hauler, huge capacity",
		},
	},
}

-- Player data: { [Player] = { vehicleContents = {}, selectedVehicle = "Sneakers" } }
local PlayerTransport = {}

-- Remote events and functions
local RemoteEvents = ReplicatedStorage:FindFirstChild("RemoteEvents")
if not RemoteEvents then
	RemoteEvents = Instance.new("Folder")
	RemoteEvents.Name = "RemoteEvents"
	RemoteEvents.Parent = ReplicatedStorage
end

local RemoteFunctions = ReplicatedStorage:FindFirstChild("RemoteFunctions")
if not RemoteFunctions then
	RemoteFunctions = Instance.new("Folder")
	RemoteFunctions.Name = "RemoteFunctions"
	RemoteFunctions.Parent = ReplicatedStorage
end

-- Create events
local VehicleUpdated = RemoteEvents:FindFirstChild("VehicleUpdated") or Instance.new("RemoteEvent")
VehicleUpdated.Name = "VehicleUpdated"
VehicleUpdated.Parent = RemoteEvents

local BackpackLoaded = RemoteEvents:FindFirstChild("BackpackLoaded") or Instance.new("RemoteEvent")
BackpackLoaded.Name = "BackpackLoaded"
BackpackLoaded.Parent = RemoteEvents

-- Create functions
local SelectVehicle = RemoteFunctions:FindFirstChild("SelectVehicle") or Instance.new("RemoteFunction")
SelectVehicle.Name = "SelectVehicle"
SelectVehicle.Parent = RemoteFunctions

local GetVehicleInfo = RemoteFunctions:FindFirstChild("GetVehicleInfo") or Instance.new("RemoteFunction")
GetVehicleInfo.Name = "GetVehicleInfo"
GetVehicleInfo.Parent = RemoteFunctions

local LoadFromStorage = RemoteFunctions:FindFirstChild("LoadFromStorage") or Instance.new("RemoteFunction")
LoadFromStorage.Name = "LoadFromStorage"
LoadFromStorage.Parent = RemoteFunctions

local LoadMaxFromStorage = RemoteFunctions:FindFirstChild("LoadMaxFromStorage") or Instance.new("RemoteFunction")
LoadMaxFromStorage.Name = "LoadMaxFromStorage"
LoadMaxFromStorage.Parent = RemoteFunctions

--------------------------------------------------------------------------------
-- HELPER FUNCTIONS
--------------------------------------------------------------------------------

--[[
	Waits for ItemStorageManager to be available.
	@return table? - The ItemStorageManager API or nil
]]
local function waitForItemStorageManager()
	local attempts = 0
	while not _G.ItemStorageManager and attempts < 50 do
		attempts += 1
		task.wait(0.1)
	end
	return _G.ItemStorageManager
end

--[[
	Gets the backpack capacity for a player based on selected vehicle.
	@param player Player - The player
	@return number - The capacity
]]
local function getBackpackCapacity(player)
	local transport = PlayerTransport[player]
	if not transport then return 100 end
	
	local vehicleId = transport.selectedVehicle or CONFIG.DEFAULT_VEHICLE
	local vehicleConfig = CONFIG.VEHICLES[vehicleId]
	return vehicleConfig and vehicleConfig.capacity or 100
end

--[[
	Gets current backpack usage for a player.
	@param player Player - The player
	@return number - Total items in backpack
]]
local function getBackpackUsage(player)
	local ItemStorageManager = _G.ItemStorageManager
	if not ItemStorageManager then return 0 end
	
	local backpack = ItemStorageManager.GetBackpackContents(player)
	local total = 0
	for _, count in pairs(backpack) do
		total = total + count
	end
	return total
end

--[[
	Gets remaining backpack space for a player.
	@param player Player - The player
	@return number - Available space
]]
local function getBackpackSpace(player)
	return getBackpackCapacity(player) - getBackpackUsage(player)
end

--[[
	Initializes transport state for a player.
	@param player Player - The player
]]
local function initializePlayer(player)
	PlayerTransport[player] = {
		selectedVehicle = CONFIG.DEFAULT_VEHICLE,
	}
	
	-- Update ItemStorageManager with new capacity
	local ItemStorageManager = _G.ItemStorageManager
	if ItemStorageManager and ItemStorageManager.SetBackpackCapacity then
		ItemStorageManager.SetBackpackCapacity(player, getBackpackCapacity(player))
	end
	
	print(string.format("âœ“ TransportManager: Initialized for %s (Vehicle: %s, Capacity: %d)", 
		player.Name, CONFIG.DEFAULT_VEHICLE, getBackpackCapacity(player)))
end

--[[
	Cleans up transport state for a player.
	@param player Player - The player
]]
local function cleanupPlayer(player)
	PlayerTransport[player] = nil
end

--------------------------------------------------------------------------------
-- API FUNCTIONS
--------------------------------------------------------------------------------

--[[
	Selects a vehicle for a player.
	@param player Player - The player
	@param vehicleId string - The vehicle to select
	@return boolean - Success
]]
local function selectVehicle(player, vehicleId)
	local transport = PlayerTransport[player]
	if not transport then return false end
	
	local vehicleConfig = CONFIG.VEHICLES[vehicleId]
	if not vehicleConfig then
		warn("TransportManager: Unknown vehicle: " .. tostring(vehicleId))
		return false
	end
	
	-- Check if player owns this vehicle (TODO: add ownership tracking)
	-- For now, only Sneakers are free
	if vehicleId ~= "Sneakers" then
		-- Check if player has enough money to buy
		local leaderstats = player:FindFirstChild("leaderstats")
		local moneyValue = leaderstats and leaderstats:FindFirstChild("Money")
		
		if not moneyValue or moneyValue.Value < vehicleConfig.price then
			return false, "Not enough money"
		end
		
		-- Deduct money
		moneyValue.Value = moneyValue.Value - vehicleConfig.price
	end
	
	transport.selectedVehicle = vehicleId
	
	-- Update ItemStorageManager with new capacity
	local ItemStorageManager = _G.ItemStorageManager
	if ItemStorageManager and ItemStorageManager.SetBackpackCapacity then
		ItemStorageManager.SetBackpackCapacity(player, getBackpackCapacity(player))
	end
	
	-- Notify client
	VehicleUpdated:FireClient(player, vehicleId, getBackpackCapacity(player))
	
	print(string.format("âœ“ %s selected vehicle: %s (Capacity: %d)", 
		player.Name, vehicleId, getBackpackCapacity(player)))
	
	return true
end

--[[
	Loads items from storage to backpack.
	@param player Player - The player
	@param itemId string - Item to load (or nil for max smart load)
	@param count number - How many to load
	@return number - How many actually loaded
]]
local function loadFromStorage(player, itemId, count)
	local ItemStorageManager = _G.ItemStorageManager
	if not ItemStorageManager then return 0 end
	
	local availableSpace = getBackpackSpace(player)
	if availableSpace <= 0 then return 0 end
	
	-- Limit to available space
	local toLoad = math.min(count, availableSpace)
	
	-- Transfer from storage to backpack
	local loaded = ItemStorageManager.TransferToBackpack(player, itemId, toLoad)
	
	if loaded > 0 then
		BackpackLoaded:FireClient(player, itemId, loaded)
		print(string.format("âœ“ %s loaded %d x %s to backpack", player.Name, loaded, itemId))
	end
	
	return loaded
end

--[[
	Loads items from storage to backpack, prioritizing highest value items.
	@param player Player - The player
	@return table - { [itemId] = count } of loaded items
]]
local function loadMaxFromStorageFn(player)
	local ItemStorageManager = _G.ItemStorageManager
	if not ItemStorageManager then return {} end
	
	local loaded = {}
	local availableSpace = getBackpackSpace(player)
	
	if availableSpace <= 0 then return {} end
	
	-- Get storage contents
	local storage = ItemStorageManager.GetStorageContents(player)
	
	-- Sort items by value (highest first)
	local itemList = {}
	for itemId, count in pairs(storage) do
		local itemInfo = ItemConfig.Items[itemId]
		if itemInfo and count > 0 then
			table.insert(itemList, {
				itemId = itemId,
				count = count,
				value = itemInfo.basePrice or 1,
			})
		end
	end
	
	table.sort(itemList, function(a, b)
		return a.value > b.value
	end)
	
	-- Load highest value items first
	for _, item in ipairs(itemList) do
		if availableSpace <= 0 then break end
		
		local toLoad = math.min(item.count, availableSpace)
		local actualLoaded = ItemStorageManager.TransferToBackpack(player, item.itemId, toLoad)
		
		if actualLoaded > 0 then
			loaded[item.itemId] = actualLoaded
			availableSpace = availableSpace - actualLoaded
		end
	end
	
	-- Notify client
	local totalLoaded = 0
	for _, count in pairs(loaded) do
		totalLoaded = totalLoaded + count
	end
	
	if totalLoaded > 0 then
		BackpackLoaded:FireClient(player, nil, totalLoaded)  -- nil = mixed
		print(string.format("âœ“ %s loaded %d items to backpack (max)", player.Name, totalLoaded))
	end
	
	return loaded
end

--[[
	Gets vehicle information for a player.
	@param player Player - The player
	@return table - Vehicle info
]]
local function getVehicleInfoFn(player)
	local transport = PlayerTransport[player]
	if not transport then
		return {
			selectedVehicle = CONFIG.DEFAULT_VEHICLE,
			capacity = 100,
			currentLoad = 0,
			availableVehicles = CONFIG.VEHICLES,
		}
	end
	
	return {
		selectedVehicle = transport.selectedVehicle,
		capacity = getBackpackCapacity(player),
		currentLoad = getBackpackUsage(player),
		availableVehicles = CONFIG.VEHICLES,
	}
end

--[[
	Gets transport data for saving via DataManager.
	@param player Player - The player
	@return table - Transport data
]]
local function getTransportData(player)
	local transport = PlayerTransport[player]
	if not transport then
		return { selectedVehicle = CONFIG.DEFAULT_VEHICLE }
	end
	
	return {
		selectedVehicle = transport.selectedVehicle,
	}
end

--[[
	Sets transport data from DataManager load.
	@param player Player - The player
	@param data table - Transport data
]]
local function setTransportData(player, data)
	if not PlayerTransport[player] then
		PlayerTransport[player] = {}
	end
	
	PlayerTransport[player].selectedVehicle = data.selectedVehicle or CONFIG.DEFAULT_VEHICLE
	
	-- Update ItemStorageManager with capacity
	local ItemStorageManager = _G.ItemStorageManager
	if ItemStorageManager and ItemStorageManager.SetBackpackCapacity then
		ItemStorageManager.SetBackpackCapacity(player, getBackpackCapacity(player))
	end
end

--------------------------------------------------------------------------------
-- REMOTE FUNCTION HANDLERS
--------------------------------------------------------------------------------

SelectVehicle.OnServerInvoke = function(player, vehicleId)
	return selectVehicle(player, vehicleId)
end

GetVehicleInfo.OnServerInvoke = function(player)
	return getVehicleInfoFn(player)
end

LoadFromStorage.OnServerInvoke = function(player, itemId, count)
	return loadFromStorage(player, itemId, count or 1)
end

LoadMaxFromStorage.OnServerInvoke = function(player)
	return loadMaxFromStorageFn(player)
end

--------------------------------------------------------------------------------
-- PLAYER EVENTS
--------------------------------------------------------------------------------

local function onPlayerAdded(player)
	-- Wait for dependencies
	task.wait(2)
	waitForItemStorageManager()
	
	initializePlayer(player)
end

local function onPlayerRemoving(player)
	cleanupPlayer(player)
end

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

local function initialize()
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	print("   TransportManager - Initializing")
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	
	-- Connect player events
	Players.PlayerAdded:Connect(onPlayerAdded)
	Players.PlayerRemoving:Connect(onPlayerRemoving)
	
	-- Handle existing players
	for _, player in Players:GetPlayers() do
		task.spawn(onPlayerAdded, player)
	end
	
	print("âœ“ TransportManager initialized")
	print("  â€¢ Default vehicle: " .. CONFIG.DEFAULT_VEHICLE)
	print("  â€¢ Vehicles: Sneakers, Cart, Hoverboard, Truck")
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
end

initialize()

-- Export API for other scripts
_G.TransportManager = {
	SelectVehicle = selectVehicle,
	LoadFromStorage = loadFromStorage,
	LoadMaxFromStorage = loadMaxFromStorageFn,
	GetVehicleInfo = getVehicleInfoFn,
	GetBackpackCapacity = getBackpackCapacity,
	GetBackpackUsage = getBackpackUsage,
	GetBackpackSpace = getBackpackSpace,
	-- Persistence functions
	GetTransportData = getTransportData,
	SetTransportData = setTransportData,
	-- Constants
	CONFIG = CONFIG,
}



--------------------------------------------------
File: ConvenienceUpgradesConfig.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\shared\ConvenienceUpgradesConfig.luau
--------------------------------------------------
--[[
	ConvenienceUpgradesConfig ModuleScript
	
	Defines all purchasable convenience upgrades for the Island Shop.
	Located in ReplicatedStorage so both Server and Client can access it.
	
	Categories:
	- Movement: Walkspeed, jump, bridge speed boosts
	- Income: Global income multipliers
	- Automation: Auto-collector bots, faster cycles
	- Premium: High-tier quality of life upgrades
]]

export type UpgradeConfig = {
	Price: number,
	Description: string,
	Category: string,
	EffectType: string,
	EffectValue: number,
	Icon: string,
	Prerequisite: string?, -- Must own this upgrade first
}

-- All convenience upgrades
local Upgrades: {[string]: UpgradeConfig} = {
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- TIER 1: Movement & Speed ($1,000 - $10,000)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	["Speed Treadmill Bridge"] = {
		Price = 1000,
		Description = "Bridges boost your speed 2x! Zoom between islands.",
		Category = "Movement",
		EffectType = "BridgeSpeed",
		EffectValue = 2, -- 2x speed on bridges
		Icon = "ðŸƒ",
	},
	
	["Walkspeed Boost I"] = {
		Price = 2500,
		Description = "Permanent +25% walkspeed everywhere.",
		Category = "Movement",
		EffectType = "Walkspeed",
		EffectValue = 0.25, -- +25%
		Icon = "ðŸ‘Ÿ",
	},
	
	["Jump Boost"] = {
		Price = 5000,
		Description = "Permanent +50% jump height. Leap tall buildings!",
		Category = "Movement",
		EffectType = "JumpPower",
		EffectValue = 0.50, -- +50%
		Icon = "ðŸ¦˜",
	},
	
	["Walkspeed Boost II"] = {
		Price = 10000,
		Description = "Additional +25% walkspeed. Stacks with Boost I!",
		Category = "Movement",
		EffectType = "Walkspeed",
		EffectValue = 0.25, -- +25% more
		Icon = "âš¡",
		Prerequisite = "Walkspeed Boost I",
	},
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- TIER 2: Income Boosters ($50,000 - $500,000)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	["Global Income +10%"] = {
		Price = 50000,
		Description = "All brainrots produce +10% more income!",
		Category = "Income",
		EffectType = "IncomeMultiplier",
		EffectValue = 0.10, -- +10%
		Icon = "ðŸ’µ",
	},
	
	["Auto-Collector Bot I"] = {
		Price = 100000,
		Description = "A cute bot collects from brainrots to storage for you!",
		Category = "Automation",
		EffectType = "AutoCollector",
		EffectValue = 1, -- 1 bot
		Icon = "ðŸ¤–",
	},
	
	["Global Income +25%"] = {
		Price = 250000,
		Description = "Even more productivity! +25% income (stacks).",
		Category = "Income",
		EffectType = "IncomeMultiplier",
		EffectValue = 0.25, -- +25%
		Icon = "ðŸ’°",
		Prerequisite = "Global Income +10%",
	},
	
	["Faster Cycles I"] = {
		Price = 500000,
		Description = "All brainrots work 15% faster!",
		Category = "Automation",
		EffectType = "CycleReduction",
		EffectValue = 0.15, -- -15% cycle time
		Icon = "â±ï¸",
	},
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- TIER 3: Automation ($1M - $10M)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	["Auto-Collector Bot II"] = {
		Price = 1000000,
		Description = "A second bot joins the collection crew!",
		Category = "Automation",
		EffectType = "AutoCollector",
		EffectValue = 1, -- +1 more bot
		Icon = "ðŸ¤–",
		Prerequisite = "Auto-Collector Bot I",
	},
	
	["Faster Cycles II"] = {
		Price = 2500000,
		Description = "Lightning speed! Additional -15% cycle time.",
		Category = "Automation",
		EffectType = "CycleReduction",
		EffectValue = 0.15, -- -15% more
		Icon = "âš¡",
		Prerequisite = "Faster Cycles I",
	},
	
	["Lucky Bonus Chance"] = {
		Price = 5000000,
		Description = "10% chance for 2x payout on each cycle!",
		Category = "Income",
		EffectType = "LuckyChance",
		EffectValue = 0.10, -- 10% chance
		Icon = "ðŸ€",
	},
	
	["Instant Teleport Home"] = {
		Price = 10000000,
		Description = "Press H to teleport to your main island anytime!",
		Category = "Movement",
		EffectType = "TeleportHome",
		EffectValue = 1, -- enabled
		Icon = "ðŸ ",
	},
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- TIER 4: Premium Upgrades ($50M+)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	["Global Income +50%"] = {
		Price = 50000000,
		Description = "Massive profits! +50% income from all brainrots.",
		Category = "Income",
		EffectType = "IncomeMultiplier",
		EffectValue = 0.50, -- +50%
		Icon = "ðŸ’Ž",
		Prerequisite = "Global Income +25%",
	},
	
	["Critical Bonus Chance"] = {
		Price = 100000000,
		Description = "5% chance for JACKPOT 5x income payout!",
		Category = "Income",
		EffectType = "CriticalChance",
		EffectValue = 0.05, -- 5% chance
		Icon = "ðŸŽ°",
		Prerequisite = "Lucky Bonus Chance",
	},
	
	["Golden Speed Bridges"] = {
		Price = 250000000,
		Description = "Bridges boost speed 3x and shine golden!",
		Category = "Movement",
		EffectType = "BridgeSpeed",
		EffectValue = 3, -- 3x speed (replaces 2x)
		Icon = "âœ¨",
		Prerequisite = "Speed Treadmill Bridge",
	},
}

-- Cache for sorted upgrades
local SortedUpgradesCache: {{name: string, config: UpgradeConfig}}? = nil

--------------------------------------------------------------------------------
-- UTILITY FUNCTIONS
--------------------------------------------------------------------------------

--[[
	Gets the config for a specific upgrade.
	
	@param upgradeName string - The name of the upgrade
	@return UpgradeConfig? - The config, or nil if not found
]]
local function GetConfig(upgradeName: string): UpgradeConfig?
	return Upgrades[upgradeName]
end

--[[
	Returns all upgrades sorted by price (ascending).
	Cached for performance.
	
	@return table - Array of {name, config} pairs sorted by Price
]]
local function GetAllUpgradesSorted(): {{name: string, config: UpgradeConfig}}
	if SortedUpgradesCache then
		return SortedUpgradesCache
	end
	
	local sorted = {}
	
	for name, config in Upgrades do
		table.insert(sorted, {name = name, config = config})
	end
	
	table.sort(sorted, function(a, b)
		return a.config.Price < b.config.Price
	end)
	
	SortedUpgradesCache = sorted
	return sorted
end

--[[
	Gets all upgrades in a specific category.
	
	@param category string - The category name
	@return table - Array of {name, config} pairs in that category
]]
local function GetUpgradesByCategory(category: string): {{name: string, config: UpgradeConfig}}
	local result = {}
	
	for name, config in Upgrades do
		if config.Category == category then
			table.insert(result, {name = name, config = config})
		end
	end
	
	table.sort(result, function(a, b)
		return a.config.Price < b.config.Price
	end)
	
	return result
end

--[[
	Gets all unique categories.
	
	@return {string} - Array of category names
]]
local function GetCategories(): {string}
	local categories = {}
	local seen = {}
	
	for _, config in Upgrades do
		if not seen[config.Category] then
			seen[config.Category] = true
			table.insert(categories, config.Category)
		end
	end
	
	-- Sort in logical order
	local order = {Movement = 1, Income = 2, Automation = 3, Premium = 4}
	table.sort(categories, function(a, b)
		return (order[a] or 99) < (order[b] or 99)
	end)
	
	return categories
end

--[[
	Checks if a player can purchase an upgrade (meets prerequisites).
	
	@param upgradeName string - The upgrade to check
	@param ownedUpgrades {string} - List of upgrades the player owns
	@return boolean, string? - Can purchase, and reason if not
]]
local function CanPurchase(upgradeName: string, ownedUpgrades: {string}): (boolean, string?)
	local config = Upgrades[upgradeName]
	if not config then
		return false, "Upgrade not found"
	end
	
	-- Check if already owned
	for _, owned in ownedUpgrades do
		if owned == upgradeName then
			return false, "Already owned"
		end
	end
	
	-- Check prerequisite
	if config.Prerequisite then
		local hasPrereq = false
		for _, owned in ownedUpgrades do
			if owned == config.Prerequisite then
				hasPrereq = true
				break
			end
		end
		if not hasPrereq then
			return false, "Requires: " .. config.Prerequisite
		end
	end
	
	return true, nil
end

--------------------------------------------------------------------------------
-- MODULE EXPORT
--------------------------------------------------------------------------------

return {
	Upgrades = Upgrades,
	GetConfig = GetConfig,
	GetAllUpgradesSorted = GetAllUpgradesSorted,
	GetUpgradesByCategory = GetUpgradesByCategory,
	GetCategories = GetCategories,
	CanPurchase = CanPurchase,
}



--------------------------------------------------
File: ItemConfig.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\shared\ItemConfig.luau
--------------------------------------------------
--[[
	ItemConfig - Shared Configuration for Producible Items
	
	Defines all items that brainrots can produce, their base prices,
	volatility profiles, and mappings to brainrot types.
	
	Located in ReplicatedStorage so both Server and Client can access it.
]]

export type ItemDefinition = {
	id: string,
	displayName: string,
	icon: string,
	tier: number,          -- 1=Common, 2=Uncommon, 3=Rare, 4=Legendary
	basePrice: number,
	volatility: number,    -- 0.1 = Â±10%, 0.8 = Â±80%, 1.0 = Â±100%
	description: string?,
}

export type BrainrotItemMapping = {
	tier1: string,  -- Item ID for tier 1 (1+ owned)
	tier2: string,  -- Item ID for tier 2 (10+ owned)
	tier3: string,  -- Item ID for tier 3 (50+ owned)
	tier4: string,  -- Item ID for tier 4 (100+ owned)
}

export type SynergyRecipe = {
	unitA: string,       -- Brainrot category (e.g., "Skibidi")
	unitB: string,       -- Second brainrot category
	itemId: string,      -- Resulting synergy item
	rate: number,        -- Production rate in seconds
}

local ItemConfig = {}

--------------------------------------------------------------------------------
-- PRODUCTION RATES (seconds per item)
--------------------------------------------------------------------------------

ItemConfig.ProductionRates = {
	tier1 = 2,    -- Common: every 2 seconds
	tier2 = 10,   -- Uncommon: every 10 seconds
	tier3 = 45,   -- Rare: every 45 seconds
	tier4 = 180,  -- Legendary: every 3 minutes
}

-- Milestone thresholds for unlocking tiers
ItemConfig.MilestoneThresholds = {
	tier1 = 1,    -- 1+ owned
	tier2 = 10,   -- 10+ owned
	tier3 = 50,   -- 50+ owned
	tier4 = 100,  -- 100+ owned
}

--------------------------------------------------------------------------------
-- ITEM DEFINITIONS
--------------------------------------------------------------------------------

ItemConfig.Items = {
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- SKIBIDI TOILET ITEMS
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	ToiletPaper = {
		id = "ToiletPaper",
		displayName = "Toilet Paper",
		icon = "ðŸ§»",
		tier = 1,
		basePrice = 5,
		volatility = 0.1,
		description = "The essentials.",
	},
	Plunger = {
		id = "Plunger",
		displayName = "Plunger",
		icon = "ðŸª ",
		tier = 2,
		basePrice = 25,
		volatility = 0.3,
		description = "For when things get serious.",
	},
	GoldenFlush = {
		id = "GoldenFlush",
		displayName = "Golden Flush",
		icon = "ðŸš½",
		tier = 3,
		basePrice = 150,
		volatility = 0.8,
		description = "Luxury porcelain experience.",
	},
	PorcelainThrone = {
		id = "PorcelainThrone",
		displayName = "Porcelain Throne",
		icon = "ðŸ‘‘",
		tier = 4,
		basePrice = 1000,
		volatility = 1.0,
		description = "Fit for royalty.",
	},
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- BOMBARDIRO ITEMS
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	Firecracker = {
		id = "Firecracker",
		displayName = "Firecracker",
		icon = "ðŸ§¨",
		tier = 1,
		basePrice = 8,
		volatility = 0.1,
		description = "Pop pop!",
	},
	Grenade = {
		id = "Grenade",
		displayName = "Grenade",
		icon = "ðŸ’£",
		tier = 2,
		basePrice = 50,
		volatility = 0.3,
		description = "Handle with care.",
	},
	Missile = {
		id = "Missile",
		displayName = "Missile",
		icon = "ðŸš€",
		tier = 3,
		basePrice = 200,
		volatility = 0.8,
		description = "Going ballistic.",
	},
	Nuke = {
		id = "Nuke",
		displayName = "Nuke",
		icon = "â˜¢ï¸",
		tier = 4,
		basePrice = 1500,
		volatility = 1.0,
		description = "The big one.",
	},
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- TRALALERO ITEMS
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	Kazoo = {
		id = "Kazoo",
		displayName = "Kazoo",
		icon = "ðŸŽµ",
		tier = 1,
		basePrice = 6,
		volatility = 0.1,
		description = "Makes any song better.",
	},
	Guitar = {
		id = "Guitar",
		displayName = "Guitar",
		icon = "ðŸŽ¸",
		tier = 2,
		basePrice = 40,
		volatility = 0.3,
		description = "Anyway, here's Wonderwall.",
	},
	ConcertTicket = {
		id = "ConcertTicket",
		displayName = "Concert Ticket",
		icon = "ðŸŽ«",
		tier = 3,
		basePrice = 175,
		volatility = 0.8,
		description = "VIP access.",
	},
	PlatinumAlbum = {
		id = "PlatinumAlbum",
		displayName = "Platinum Album",
		icon = "ðŸ’¿",
		tier = 4,
		basePrice = 1200,
		volatility = 1.0,
		description = "Certified classic.",
	},
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- BRR BRR PATAPIM ITEMS
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	Snowflake = {
		id = "Snowflake",
		displayName = "Snowflake",
		icon = "â„ï¸",
		tier = 1,
		basePrice = 4,
		volatility = 0.1,
		description = "Unique, like you.",
	},
	IceCube = {
		id = "IceCube",
		displayName = "Ice Cube",
		icon = "ðŸ§Š",
		tier = 2,
		basePrice = 30,
		volatility = 0.3,
		description = "Keep it cool.",
	},
	FrozenHeart = {
		id = "FrozenHeart",
		displayName = "Frozen Heart",
		icon = "ðŸ’™",
		tier = 3,
		basePrice = 125,
		volatility = 0.8,
		description = "Cold but valuable.",
	},
	EternalWinter = {
		id = "EternalWinter",
		displayName = "Eternal Winter",
		icon = "ðŸŒ¨ï¸",
		tier = 4,
		basePrice = 900,
		volatility = 1.0,
		description = "Winter is coming... forever.",
	},
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- SIGMA ITEMS
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	ProteinBar = {
		id = "ProteinBar",
		displayName = "Protein Bar",
		icon = "ðŸ’ª",
		tier = 1,
		basePrice = 7,
		volatility = 0.1,
		description = "Gains.",
	},
	Dumbbell = {
		id = "Dumbbell",
		displayName = "Dumbbell",
		icon = "ðŸ‹ï¸",
		tier = 2,
		basePrice = 45,
		volatility = 0.3,
		description = "No pain, no gain.",
	},
	GrindsetBook = {
		id = "GrindsetBook",
		displayName = "Grindset Book",
		icon = "ðŸ“ˆ",
		tier = 3,
		basePrice = 180,
		volatility = 0.8,
		description = "Billionaire mindset.",
	},
	MoaiStatue = {
		id = "MoaiStatue",
		displayName = "Moai Statue",
		icon = "ðŸ—¿",
		tier = 4,
		basePrice = 1100,
		volatility = 1.0,
		description = "Peak performance achieved.",
	},
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- MEWER ITEMS
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	CatTreat = {
		id = "CatTreat",
		displayName = "Cat Treat",
		icon = "ðŸ˜º",
		tier = 1,
		basePrice = 5,
		volatility = 0.1,
		description = "Meow mix.",
	},
	CatToy = {
		id = "CatToy",
		displayName = "Cat Toy",
		icon = "ðŸ±",
		tier = 2,
		basePrice = 35,
		volatility = 0.3,
		description = "Endless entertainment.",
	},
	DesignerCollar = {
		id = "DesignerCollar",
		displayName = "Designer Collar",
		icon = "ðŸŽ€",
		tier = 3,
		basePrice = 160,
		volatility = 0.8,
		description = "Fashion forward feline.",
	},
	HypnoEyes = {
		id = "HypnoEyes",
		displayName = "Hypno Eyes",
		icon = "ðŸ‘ï¸",
		tier = 4,
		basePrice = 1000,
		volatility = 1.0,
		description = "You will obey.",
	},
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- SYNERGY ITEMS
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	ExplosiveToilet = {
		id = "ExplosiveToilet",
		displayName = "Explosive Toilet",
		icon = "ðŸ’£ðŸš½",
		tier = 3,
		basePrice = 500,
		volatility = 0.8,
		description = "When chaos meets porcelain.",
	},
	FrozenFlush = {
		id = "FrozenFlush",
		displayName = "Frozen Flush",
		icon = "ðŸ§ŠðŸš½",
		tier = 3,
		basePrice = 400,
		volatility = 0.8,
		description = "Cold comfort.",
	},
	GigachadStatue = {
		id = "GigachadStatue",
		displayName = "Gigachad Statue",
		icon = "ðŸ—¿ðŸ˜º",
		tier = 3,
		basePrice = 750,
		volatility = 0.8,
		description = "Peak performance achieved.",
	},
	PowerExplosion = {
		id = "PowerExplosion",
		displayName = "Power Explosion",
		icon = "ðŸ’ªðŸ’¥",
		tier = 3,
		basePrice = 600,
		volatility = 0.8,
		description = "Explosive gains.",
	},
	FrozenSymphony = {
		id = "FrozenSymphony",
		displayName = "Frozen Symphony",
		icon = "ðŸŽµâ„ï¸",
		tier = 3,
		basePrice = 550,
		volatility = 0.8,
		description = "Chilling melodies.",
	},
	CatConcert = {
		id = "CatConcert",
		displayName = "Cat Concert",
		icon = "ðŸŽµðŸ˜º",
		tier = 3,
		basePrice = 450,
		volatility = 0.8,
		description = "Purrfect harmony.",
	},
	IceBomb = {
		id = "IceBomb",
		displayName = "Ice Bomb",
		icon = "ðŸ’£â„ï¸",
		tier = 3,
		basePrice = 700,
		volatility = 0.8,
		description = "Freeze and boom.",
	},
}

--------------------------------------------------------------------------------
-- BRAINROT â†’ ITEM MAPPINGS
--------------------------------------------------------------------------------

-- Maps brainrot categories to their item production
-- The key should match a prefix or category that groups similar brainrots
ItemConfig.BrainrotItems = {
	-- Skibidi family (Skibidi_Toilet, Skibidi_Scientist, etc.)
	Skibidi = {
		tier1 = "ToiletPaper",
		tier2 = "Plunger",
		tier3 = "GoldenFlush",
		tier4 = "PorcelainThrone",
	},
	
	-- Bombardiro family
	Bombardiro = {
		tier1 = "Firecracker",
		tier2 = "Grenade",
		tier3 = "Missile",
		tier4 = "Nuke",
	},
	
	-- Tralalero family
	Tralalero = {
		tier1 = "Kazoo",
		tier2 = "Guitar",
		tier3 = "ConcertTicket",
		tier4 = "PlatinumAlbum",
	},
	
	-- Brr Brr Patapim family
	BrrBrr = {
		tier1 = "Snowflake",
		tier2 = "IceCube",
		tier3 = "FrozenHeart",
		tier4 = "EternalWinter",
	},
	
	-- Sigma family
	Sigma = {
		tier1 = "ProteinBar",
		tier2 = "Dumbbell",
		tier3 = "GrindsetBook",
		tier4 = "MoaiStatue",
	},
	
	-- Mewer family (cats)
	Mewer = {
		tier1 = "CatTreat",
		tier2 = "CatToy",
		tier3 = "DesignerCollar",
		tier4 = "HypnoEyes",
	},
}

-- Maps actual brainrot model names to their category
-- This allows grouping similar brainrots for milestone counting
-- All 74 brainrots from ShopConfig are mapped to 6 categories
ItemConfig.BrainrotToCategory = {
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CATEGORY: Skibidi (Toilet/Bathroom theme)
	-- Items: ToiletPaper, Plunger, GoldenBowl, DiamondThrone
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	["Skibidi_Toilet"] = "Skibidi",
	["Skibidi_Scientist"] = "Skibidi",
	["Skibidi_DOP_DOP"] = "Skibidi",
	["Cappuccino_Assassino"] = "Skibidi",
	["Espresso Signora"] = "Skibidi",
	["Pot Hotspot"] = "Skibidi",
	["Rhino_Toasterino"] = "Skibidi",
	["Tim_Cheese"] = "Skibidi",
	["Noobini_Pizzanini"] = "Skibidi",
	["Piccione Macchina"] = "Skibidi",
	["Sammyni_Spyderini"] = "Skibidi",
	["Spioniro Golubiro"] = "Skibidi",
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CATEGORY: Bombardiro (Explosive/Military theme)
	-- Items: Firecracker, Bomblet, NukeCore, AtomSplitter
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	["Bombardiro_Crocodilo"] = "Bombardiro",
	["Bombombini_Gusini"] = "Bombardiro",
	["Svinina_Bombardino"] = "Bombardiro",
	["Nuclearo Dinossauro"] = "Bombardiro",
	["Tric_Trac_Baraboom"] = "Bombardiro",
	["Trenostruzzo_Turbo_3000"] = "Bombardiro",
	["Los Crocodillitos"] = "Bombardiro",
	["Gangster_Footera"] = "Bombardiro",
	["Bandito_Bobritto"] = "Bombardiro",
	["Ta_Ta_Ta_Ta_Sahur"] = "Bombardiro",
	["Tung_Tung_Tung_Sahur"] = "Bombardiro",
	["Odin_Din_Din_Dun"] = "Bombardiro",
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CATEGORY: Tralalero (Musical/Dance theme)
	-- Items: MusicNote, Microphone, GoldRecord, PlatinumAlbum
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	["Tralalero_Tralala"] = "Tralalero",
	["Las Tralaleritas"] = "Tralalero",
	["Los_Tralaleritos"] = "Tralalero",
	["Ballerina_Cappuccina"] = "Tralalero",
	["Ballerino Lololo"] = "Tralalero",
	["LirilÃ¬_LarilÃ "] = "Tralalero",
	["Burbaloni_Loliloli"] = "Tralalero",
	["Trippi_Troppi"] = "Tralalero",
	["Fluri_flura"] = "Tralalero",
	["Chicleteira Bicicleteira"] = "Tralalero",
	["Orcalero Orcala"] = "Tralalero",
	["Trulimero_Trulicina"] = "Tralalero",
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CATEGORY: BrrBrr (Cold/Winter theme)
	-- Items: Snowflake, IceCube, FrozenHeart, BlizzardCore
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	["Brr_Brr_Patapim"] = "BrrBrr",
	["Brri_Brri_Bicus_Dicus_Bombicus"] = "BrrBrr",
	["Frigo_Camelo"] = "BrrBrr",
	["Salamino Penguino"] = "BrrBrr",
	["Pipi_Kiwi"] = "BrrBrr",
	["Blueberrinni_Octopusini"] = "BrrBrr",
	["Graipuss_Medussi"] = "BrrBrr",
	["Perochello_Lemonchello"] = "BrrBrr",
	["Strawberrelli Flamingelli"] = "BrrBrr",
	["Tigrilini Watermelini"] = "BrrBrr",
	["Tigroligre Frutonni"] = "BrrBrr",
	["Torrtuginni Dragonfrutini"] = "BrrBrr",
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CATEGORY: Sigma (Meme/Internet theme)
	-- Items: ViralPost, TrendingTag, GoldenMeme, DiamondClout
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	["Chimpanzini_Bananini"] = "Sigma",
	["Chimpanzini Spiderini"] = "Sigma",
	["Orangutini_Ananassini"] = "Sigma",
	["Pandaccini Bananini"] = "Sigma",
	["Gorillo Watermelondrillo"] = "Sigma",
	["Mat_teo"] = "Sigma",
	["Glorbo_Fruttodrillo"] = "Sigma",
	["Unclito_Samito"] = "Sigma",
	["Statutino Libertino"] = "Sigma",
	["Secret Lucky Block"] = "Sigma",
	["Mythic Lucky Block"] = "Sigma",
	["Brainrot God Lucky Block"] = "Sigma",
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CATEGORY: Mewer (Animal/Creature theme)
	-- Items: Pawprint, FurBall, GoldenCollar, CrystalClaw
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	["Gattatino Neonino"] = "Mewer",
	["Gattatino_Nyanino"] = "Mewer",
	["La_Gatta_Cattini"] = "Mewer",
	["Lionel_Cactuseli"] = "Mewer",
	["Girafa_Celestre"] = "Mewer",
	["Cocofanto_Elefanto"] = "Mewer",
	["Cavallo_Virtuoso"] = "Mewer",
	["La_Vacca_Saturno_Saturnita"] = "Mewer",
	["Las Vaquitas Saturnitas"] = "Mewer",
	["Zibra Zubra Zibralini"] = "Mewer",
	["Talpa_Di_Fero"] = "Mewer",
	["La_Grande_Combinasion"] = "Mewer",
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- STARTER UNITS (All in Tralalero for simplicity - they're basic)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	["Avocadini Guffo"] = "Tralalero",
	["Bambini_Crostini"] = "Tralalero",
	["Bananita_Dolphinita"] = "BrrBrr",
	["Boneca_Ambalabu"] = "Bombardiro",
	["Cacto Hipopotamo"] = "Mewer",
	["Chef_Crabracadabra"] = "Skibidi",
	["Garama_and_Madundung"] = "Sigma",
}

--------------------------------------------------------------------------------
-- SYNERGY RECIPES
--------------------------------------------------------------------------------

ItemConfig.SynergyRecipes = {
	{
		unitA = "Skibidi",
		unitB = "Bombardiro",
		itemId = "ExplosiveToilet",
		rate = 10,
	},
	{
		unitA = "Skibidi",
		unitB = "BrrBrr",
		itemId = "FrozenFlush",
		rate = 10,
	},
	{
		unitA = "Sigma",
		unitB = "Mewer",
		itemId = "GigachadStatue",
		rate = 10,
	},
	{
		unitA = "Sigma",
		unitB = "Bombardiro",
		itemId = "PowerExplosion",
		rate = 10,
	},
	{
		unitA = "Tralalero",
		unitB = "BrrBrr",
		itemId = "FrozenSymphony",
		rate = 10,
	},
	{
		unitA = "Tralalero",
		unitB = "Mewer",
		itemId = "CatConcert",
		rate = 10,
	},
	{
		unitA = "Bombardiro",
		unitB = "BrrBrr",
		itemId = "IceBomb",
		rate = 10,
	},
}

--------------------------------------------------------------------------------
-- HELPER FUNCTIONS
--------------------------------------------------------------------------------

--[[
	Gets an item definition by ID.
	@param itemId string - The item ID
	@return ItemDefinition? - The item definition or nil
]]
function ItemConfig.GetItem(itemId: string): ItemDefinition?
	return ItemConfig.Items[itemId]
end

--[[
	Gets the category for a brainrot model name.
	@param brainrotName string - The brainrot model name
	@return string? - The category or nil if not mapped
]]
function ItemConfig.GetBrainrotCategory(brainrotName: string): string?
	-- Direct mapping check
	if ItemConfig.BrainrotToCategory[brainrotName] then
		return ItemConfig.BrainrotToCategory[brainrotName]
	end
	
	-- Fuzzy match by prefix
	local lowerName = string.lower(brainrotName)
	if string.find(lowerName, "skibidi") then return "Skibidi" end
	if string.find(lowerName, "bombard") or string.find(lowerName, "bomber") then return "Bombardiro" end
	if string.find(lowerName, "tralal") then return "Tralalero" end
	if string.find(lowerName, "brr") or string.find(lowerName, "patapim") then return "BrrBrr" end
	if string.find(lowerName, "sigma") or string.find(lowerName, "chad") then return "Sigma" end
	if string.find(lowerName, "cat") or string.find(lowerName, "gatta") or string.find(lowerName, "mew") then return "Mewer" end
	
	return nil
end

--[[
	Gets the items a brainrot category produces based on milestone tier.
	@param category string - The brainrot category
	@param ownedCount number - How many of this category the player owns
	@return {{itemId: string, rate: number}} - Array of item productions
]]
function ItemConfig.GetProductions(category: string, ownedCount: number): {{itemId: string, rate: number}}
	local mapping = ItemConfig.BrainrotItems[category]
	if not mapping then return {} end
	
	local productions = {}
	local thresholds = ItemConfig.MilestoneThresholds
	local rates = ItemConfig.ProductionRates
	
	if ownedCount >= thresholds.tier1 then
		table.insert(productions, {itemId = mapping.tier1, rate = rates.tier1})
	end
	if ownedCount >= thresholds.tier2 then
		table.insert(productions, {itemId = mapping.tier2, rate = rates.tier2})
	end
	if ownedCount >= thresholds.tier3 then
		table.insert(productions, {itemId = mapping.tier3, rate = rates.tier3})
	end
	if ownedCount >= thresholds.tier4 then
		table.insert(productions, {itemId = mapping.tier4, rate = rates.tier4})
	end
	
	return productions
end

--[[
	Finds a synergy recipe for two adjacent categories.
	@param categoryA string - First category
	@param categoryB string - Second category
	@return SynergyRecipe? - The synergy recipe or nil
]]
function ItemConfig.GetSynergyRecipe(categoryA: string, categoryB: string): SynergyRecipe?
	for _, recipe in ItemConfig.SynergyRecipes do
		if (recipe.unitA == categoryA and recipe.unitB == categoryB) or
		   (recipe.unitA == categoryB and recipe.unitB == categoryA) then
			return recipe
		end
	end
	return nil
end

--[[
	Gets all items sorted by tier then price.
	@return {ItemDefinition} - Sorted array of items
]]
function ItemConfig.GetAllItemsSorted(): {ItemDefinition}
	local items = {}
	for _, item in ItemConfig.Items do
		table.insert(items, item)
	end
	table.sort(items, function(a, b)
		if a.tier ~= b.tier then
			return a.tier < b.tier
		end
		return a.basePrice < b.basePrice
	end)
	return items
end

return ItemConfig



--------------------------------------------------
File: PrestigeConfig.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\shared\PrestigeConfig.luau
--------------------------------------------------
local PrestigeConfig = {}

-- Meatball calculation constants
PrestigeConfig.MEATBALL_DIVISOR = 1_000_000       -- Lifetime earnings divisor
PrestigeConfig.MEATBALL_MULTIPLIER = 150          -- Square root multiplier
PrestigeConfig.MEATBALL_BONUS_RATE = 0.02         -- +2% income per meatball
PrestigeConfig.MINIMUM_PRESTIGE_GAIN = 10         -- Must gain at least 10 meatballs

-- Meatball Shop items with progressive unlock
PrestigeConfig.SHOP_ITEMS = {
    -- Tier 1: Unlocked at 0 lifetime meatballs
    { 
        Id = "GoldenBoost1",
        Name = "Golden Boost I", 
        Price = 50, 
        Effect = "IncomeMultiplier", 
        Value = 0.10, 
        UnlockAt = 0,
        Description = "Increases all income by 10%"
    },
    { 
        Id = "QuickStart1",
        Name = "Quick Start I", 
        Price = 100, 
        Effect = "StartingMoney", 
        Value = 500, 
        UnlockAt = 0,
        Description = "Start with +$500 after prestige"
    },
    
    -- Tier 2: Unlocked at 500 lifetime meatballs
    { 
        Id = "GoldenBoost2",
        Name = "Golden Boost II", 
        Price = 200, 
        Effect = "IncomeMultiplier", 
        Value = 0.25, 
        UnlockAt = 500,
        Description = "Increases all income by another 25%"
    },
    { 
        Id = "UnitBooster1",
        Name = "Unit Booster: Tier 1", 
        Price = 300, 
        Effect = "UnitBoost", 
        Value = { Tier = 1, Multiplier = 5 }, 
        UnlockAt = 500,
        Description = "Tier 1 units earn 5x income"
    },
    
    -- Tier 3: Unlocked at 2000 lifetime meatballs
    { 
        Id = "GoldenBoost3",
        Name = "Golden Boost III", 
        Price = 500, 
        Effect = "IncomeMultiplier", 
        Value = 0.50, 
        UnlockAt = 2000,
        Description = "Increases all income by another 50%"
    },
    { 
        Id = "QuickStart2",
        Name = "Quick Start II", 
        Price = 400, 
        Effect = "StartingMoney", 
        Value = 2500, 
        UnlockAt = 2000,
        Description = "Start with +$2500 after prestige"
    },
}

-- Helper to get item by ID
function PrestigeConfig.GetItem(itemId)
    for _, item in ipairs(PrestigeConfig.SHOP_ITEMS) do
        if item.Id == itemId then
            return item
        end
    end
    return nil
end

return PrestigeConfig



--------------------------------------------------
File: ShopConfig.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\shared\ShopConfig.luau
--------------------------------------------------
--[[
	ShopConfig ModuleScript
	
	Central database for all 74 purchasable brainrot units.
	Located in ReplicatedStorage so both Server and Client can access it.
	
	Features:
	- Auto-sorted by BasePrice (ascending)
	- Progressive unlock system (5 unlocked initially, +1 on each purchase)
	- Per-unit cost multipliers (higher tiers have steeper curves)
	- Milestone bonuses at 10/25/50/100/200/300/400/500 owned
	- Price Formula: CurrentPrice = BasePrice * (CostMultiplier ^ AmountOwned)
]]

export type UnitConfig = {
	BasePrice: number,
	BaseIncome: number,
	CycleTime: number,
	ModelName: string,
	Description: string?,
	CostMultiplier: number?, -- Optional: overrides default 1.15 multiplier
	ProjectileColor: Color3?, -- Optional: color of income projectile (defaults to white)
}

export type MilestoneInfo = {
	quantity: number,
	milestoneType: "speed" | "profit",
	multiplier: number,
}

-- Constants
local INITIAL_UNLOCKED = 5 -- How many units are unlocked from the start
local PRICE_MULTIPLIER = 1.15 -- Default 15% increase per owned unit

-- Milestone definitions (Adventure Capitalist-inspired)
-- Speed milestones halve cycle time, profit milestones multiply income
local MILESTONES: {MilestoneInfo} = {
	{quantity = 10, milestoneType = "speed", multiplier = 2},   -- x2 speed (1/2 cycle)
	{quantity = 25, milestoneType = "speed", multiplier = 2},   -- x4 speed total
	{quantity = 50, milestoneType = "speed", multiplier = 2},   -- x8 speed total
	{quantity = 100, milestoneType = "profit", multiplier = 3}, -- x3 profit
	{quantity = 200, milestoneType = "speed", multiplier = 2},  -- x16 speed total
	{quantity = 300, milestoneType = "profit", multiplier = 3}, -- x9 profit total
	{quantity = 400, milestoneType = "speed", multiplier = 2},  -- x32 speed total
	{quantity = 500, milestoneType = "profit", multiplier = 4}, -- x36 profit total
}

--[[
	All 74 brainrot units with balanced progression.
	Sorted by BasePrice ascending.
	Model names match exactly with ReplicatedStorage.Brainrots folder.
]]
local Units: {[string]: UnitConfig} = {
	-- Tier 1: Starter Units ($50 - $400)
	["Avocadini Guffo"] = {
		BasePrice = 50,
		BaseIncome = 5,
		CycleTime = 3,
		ModelName = "Avocadini Guffo",
		Description = "A quirky avocado owl friend.",
		ProjectileColor = Color3.fromRGB(255, 255, 255),
	},
	["Ballerina_Cappuccina"] = {
		BasePrice = 100,
		BaseIncome = 8,
		CycleTime = 3,
		ModelName = "Ballerina_Cappuccina",
		Description = "Dancing coffee ballerina.",
		ProjectileColor = Color3.fromRGB(255, 255, 255),
	},
	["Ballerino Lololo"] = {
		BasePrice = 175,
		BaseIncome = 12,
		CycleTime = 3,
		ModelName = "Ballerino Lololo",
		Description = "The dancing lololo!",
		ProjectileColor = Color3.fromRGB(255, 255, 255),
	},
	["Bambini_Crostini"] = {
		BasePrice = 275,
		BaseIncome = 18,
		CycleTime = 3,
		ModelName = "Bambini_Crostini",
		Description = "Crispy little ones.",
		ProjectileColor = Color3.fromRGB(255, 255, 255),
	},
	["Bananita_Dolphinita"] = {
		BasePrice = 400,
		BaseIncome = 25,
		CycleTime = 4,
		ModelName = "Bananita_Dolphinita",
		Description = "Banana dolphin vibes!",
		ProjectileColor = Color3.fromRGB(255, 255, 255),
	},
	
	-- Tier 2: Early Game ($2.5k - $22.5k)
	["Bandito_Bobritto"] = {
		BasePrice = 2500,
		BaseIncome = 150,
		CycleTime = 4,
		ModelName = "Bandito_Bobritto",
		Description = "The sneaky beaver bandit.",
		ProjectileColor = Color3.fromRGB(255, 255, 150),
	},
	["Blueberrinni_Octopusini"] = {
		BasePrice = 3750,
		BaseIncome = 210,
		CycleTime = 4,
		ModelName = "Blueberrinni_Octopusini",
		Description = "Berry tentacle power!",
		ProjectileColor = Color3.fromRGB(255, 255, 150),
	},
	["Bombardiro_Crocodilo"] = {
		BasePrice = 5500,
		BaseIncome = 280,
		CycleTime = 4,
		ModelName = "Bombardiro_Crocodilo",
		Description = "Explosive croc energy!",
		ProjectileColor = Color3.fromRGB(255, 255, 150),
	},
	["Bombombini_Gusini"] = {
		BasePrice = 7500,
		BaseIncome = 360,
		CycleTime = 4,
		ModelName = "Bombombini_Gusini",
		Description = "Boom boom goose!",
		ProjectileColor = Color3.fromRGB(255, 255, 150),
	},
	["Boneca_Ambalabu"] = {
		BasePrice = 10000,
		BaseIncome = 450,
		CycleTime = 4,
		ModelName = "Boneca_Ambalabu",
		Description = "Mysterious doll vibes.",
		ProjectileColor = Color3.fromRGB(255, 255, 150),
	},
	["Brr_Brr_Patapim"] = {
		BasePrice = 13500,
		BaseIncome = 580,
		CycleTime = 4,
		ModelName = "Brr_Brr_Patapim",
		Description = "Cold cash generator.",
		ProjectileColor = Color3.fromRGB(255, 255, 150),
	},
	["Brri_Brri_Bicus_Dicus_Bombicus"] = {
		BasePrice = 17500,
		BaseIncome = 720,
		CycleTime = 5,
		ModelName = "Brri_Brri_Bicus_Dicus_Bombicus",
		Description = "The ultimate combo name!",
		ProjectileColor = Color3.fromRGB(255, 255, 150),
	},
	["Burbaloni_Loliloli"] = {
		BasePrice = 22500,
		BaseIncome = 900,
		CycleTime = 5,
		ModelName = "Burbaloni_Loliloli",
		Description = "Bubbly personality.",
		ProjectileColor = Color3.fromRGB(255, 255, 150),
	},
	
	-- Tier 3: Mid Game ($150k - $3.2M)
	["Cacto Hipopotamo"] = {
		BasePrice = 150000,
		BaseIncome = 5000,
		CycleTime = 5,
		ModelName = "Cacto Hipopotamo",
		Description = "Prickly hippo power!",
		ProjectileColor = Color3.fromRGB(255, 215, 0),
	},
	["Cappuccino_Assassino"] = {
		BasePrice = 225000,
		BaseIncome = 7200,
		CycleTime = 5,
		ModelName = "Cappuccino_Assassino",
		Description = "Deadly coffee vibes.",
		ProjectileColor = Color3.fromRGB(255, 215, 0),
	},
	["Cavallo_Virtuoso"] = {
		BasePrice = 325000,
		BaseIncome = 10000,
		CycleTime = 5,
		ModelName = "Cavallo_Virtuoso",
		Description = "Virtuoso horse!",
		ProjectileColor = Color3.fromRGB(255, 215, 0),
	},
	["Chef_Crabracadabra"] = {
		BasePrice = 450000,
		BaseIncome = 13500,
		CycleTime = 5,
		ModelName = "Chef_Crabracadabra",
		Description = "Magic crab chef!",
		ProjectileColor = Color3.fromRGB(255, 215, 0),
	},
	["Chicleteira Bicicleteira"] = {
		BasePrice = 600000,
		BaseIncome = 17500,
		CycleTime = 5,
		ModelName = "Chicleteira Bicicleteira",
		Description = "Gum on wheels!",
		ProjectileColor = Color3.fromRGB(255, 215, 0),
	},
	["Chimpanzini Spiderini"] = {
		BasePrice = 800000,
		BaseIncome = 22500,
		CycleTime = 5,
		ModelName = "Chimpanzini Spiderini",
		Description = "Spider monkey fusion!",
		ProjectileColor = Color3.fromRGB(255, 215, 0),
	},
	["Chimpanzini_Bananini"] = {
		BasePrice = 1000000,
		BaseIncome = 27500,
		CycleTime = 6,
		ModelName = "Chimpanzini_Bananini",
		Description = "Monke banana business!",
		ProjectileColor = Color3.fromRGB(255, 215, 0),
	},
	["Cocofanto_Elefanto"] = {
		BasePrice = 1300000,
		BaseIncome = 35000,
		CycleTime = 6,
		ModelName = "Cocofanto_Elefanto",
		Description = "Coconut elephant!",
		ProjectileColor = Color3.fromRGB(255, 215, 0),
	},
	["Espresso Signora"] = {
		BasePrice = 1600000,
		BaseIncome = 42500,
		CycleTime = 6,
		ModelName = "Espresso Signora",
		Description = "The espresso lady!",
		ProjectileColor = Color3.fromRGB(255, 215, 0),
	},
	["Fluri_flura"] = {
		BasePrice = 2000000,
		BaseIncome = 52000,
		CycleTime = 6,
		ModelName = "Fluri_flura",
		Description = "Flowery friend.",
		ProjectileColor = Color3.fromRGB(255, 215, 0),
	},
	["Frigo_Camelo"] = {
		BasePrice = 2500000,
		BaseIncome = 64000,
		CycleTime = 6,
		ModelName = "Frigo_Camelo",
		Description = "Cool camel cash!",
		ProjectileColor = Color3.fromRGB(255, 215, 0),
	},
	["Gangster_Footera"] = {
		BasePrice = 3200000,
		BaseIncome = 80000,
		CycleTime = 6,
		ModelName = "Gangster_Footera",
		Description = "Gangster football!",
		ProjectileColor = Color3.fromRGB(255, 215, 0),
	},
	
	-- Tier 4: Mid-Late Game ($15M - $2.3B) - CostMultiplier: 1.20
	["Garama_and_Madundung"] = {
		BasePrice = 15000000,
		BaseIncome = 350000,
		CycleTime = 6,
		ModelName = "Garama_and_Madundung",
		Description = "Dynamic duo!",
		CostMultiplier = 1.20,
		ProjectileColor = Color3.fromRGB(255, 165, 0),
	},
	["Gattatino Neonino"] = {
		BasePrice = 25000000,
		BaseIncome = 550000,
		CycleTime = 6,
		ModelName = "Gattatino Neonino",
		Description = "Neon kitty glow!",
		CostMultiplier = 1.20,
		ProjectileColor = Color3.fromRGB(255, 165, 0),
	},
	["Gattatino_Nyanino"] = {
		BasePrice = 40000000,
		BaseIncome = 850000,
		CycleTime = 6,
		ModelName = "Gattatino_Nyanino",
		Description = "Nyan cat vibes!",
		CostMultiplier = 1.20,
		ProjectileColor = Color3.fromRGB(255, 165, 0),
	},
	["Girafa_Celestre"] = {
		BasePrice = 65000000,
		BaseIncome = 1300000,
		CycleTime = 7,
		ModelName = "Girafa_Celestre",
		Description = "Heavenly giraffe!",
		CostMultiplier = 1.20,
		ProjectileColor = Color3.fromRGB(255, 165, 0),
	},
	["Glorbo_Fruttodrillo"] = {
		BasePrice = 100000000,
		BaseIncome = 1900000,
		CycleTime = 7,
		ModelName = "Glorbo_Fruttodrillo",
		Description = "The legendary Glorbo!",
		CostMultiplier = 1.20,
		ProjectileColor = Color3.fromRGB(255, 165, 0),
	},
	["Gorillo Watermelondrillo"] = {
		BasePrice = 150000000,
		BaseIncome = 2800000,
		CycleTime = 7,
		ModelName = "Gorillo Watermelondrillo",
		Description = "Watermelon gorilla!",
		CostMultiplier = 1.20,
		ProjectileColor = Color3.fromRGB(255, 165, 0),
	},
	["Graipuss_Medussi"] = {
		BasePrice = 225000000,
		BaseIncome = 4000000,
		CycleTime = 7,
		ModelName = "Graipuss_Medussi",
		Description = "Grape medusa power!",
		CostMultiplier = 1.20,
		ProjectileColor = Color3.fromRGB(255, 165, 0),
	},
	["La_Grande_Combinasion"] = {
		BasePrice = 350000000,
		BaseIncome = 6000000,
		CycleTime = 7,
		ModelName = "La_Grande_Combinasion",
		Description = "The grand combination!",
		CostMultiplier = 1.20,
		ProjectileColor = Color3.fromRGB(255, 165, 0),
	},
	["La_Vacca_Saturno_Saturnita"] = {
		BasePrice = 500000000,
		BaseIncome = 8500000,
		CycleTime = 7,
		ModelName = "La_Vacca_Saturno_Saturnita",
		Description = "Cosmic cow powers!",
		CostMultiplier = 1.20,
		ProjectileColor = Color3.fromRGB(255, 165, 0),
	},
	["Las Tralaleritas"] = {
		BasePrice = 750000000,
		BaseIncome = 12000000,
		CycleTime = 7,
		ModelName = "Las Tralaleritas",
		Description = "The little tralala girls!",
		CostMultiplier = 1.20,
		ProjectileColor = Color3.fromRGB(255, 165, 0),
	},
	["Las Vaquitas Saturnitas"] = {
		BasePrice = 1100000000,
		BaseIncome = 17000000,
		CycleTime = 8,
		ModelName = "Las Vaquitas Saturnitas",
		Description = "Little Saturn cows!",
		CostMultiplier = 1.20,
		ProjectileColor = Color3.fromRGB(255, 165, 0),
	},
	["Lionel_Cactuseli"] = {
		BasePrice = 1600000000,
		BaseIncome = 24000000,
		CycleTime = 8,
		ModelName = "Lionel_Cactuseli",
		Description = "Cactus lion legend!",
		CostMultiplier = 1.20,
		ProjectileColor = Color3.fromRGB(255, 165, 0),
	},
	
	-- Tier 5: Late Game ($2.5B - $175B) - CostMultiplier: 1.22
	["LirilÃ¬_LarilÃ "] = {
		BasePrice = 2500000000,
		BaseIncome = 35000000,
		CycleTime = 8,
		ModelName = "LirilÃ¬_LarilÃ ",
		Description = "Musical magic!",
		CostMultiplier = 1.22,
		ProjectileColor = Color3.fromRGB(255, 105, 180),
	},
	["Los Crocodillitos"] = {
		BasePrice = 4000000000,
		BaseIncome = 55000000,
		CycleTime = 8,
		ModelName = "Los Crocodillitos",
		Description = "Little croc gang!",
		CostMultiplier = 1.22,
		ProjectileColor = Color3.fromRGB(255, 105, 180),
	},
	["Los_Tralaleritos"] = {
		BasePrice = 6500000000,
		BaseIncome = 85000000,
		CycleTime = 8,
		ModelName = "Los_Tralaleritos",
		Description = "The tralala boys!",
		CostMultiplier = 1.22,
		ProjectileColor = Color3.fromRGB(255, 105, 180),
	},
	["Mat_teo"] = {
		BasePrice = 10000000000,
		BaseIncome = 125000000,
		CycleTime = 8,
		ModelName = "Mat_teo",
		Description = "It's Mat Teo!",
		CostMultiplier = 1.22,
		ProjectileColor = Color3.fromRGB(255, 105, 180),
	},
	["Noobini_Pizzanini"] = {
		BasePrice = 15000000000,
		BaseIncome = 180000000,
		CycleTime = 8,
		ModelName = "Noobini_Pizzanini",
		Description = "Noob pizza power!",
		CostMultiplier = 1.22,
		ProjectileColor = Color3.fromRGB(255, 105, 180),
	},
	["Nuclearo Dinossauro"] = {
		BasePrice = 22500000000,
		BaseIncome = 260000000,
		CycleTime = 8,
		ModelName = "Nuclearo Dinossauro",
		Description = "Nuclear dino!",
		CostMultiplier = 1.22,
		ProjectileColor = Color3.fromRGB(255, 105, 180),
	},
	["Odin_Din_Din_Dun"] = {
		BasePrice = 32500000000,
		BaseIncome = 360000000,
		CycleTime = 9,
		ModelName = "Odin_Din_Din_Dun",
		Description = "Norse god energy!",
		CostMultiplier = 1.22,
		ProjectileColor = Color3.fromRGB(255, 105, 180),
	},
	["Orangutini_Ananassini"] = {
		BasePrice = 45000000000,
		BaseIncome = 480000000,
		CycleTime = 9,
		ModelName = "Orangutini_Ananassini",
		Description = "Pineapple orangutan!",
		CostMultiplier = 1.22,
		ProjectileColor = Color3.fromRGB(255, 105, 180),
	},
	["Orcalero Orcala"] = {
		BasePrice = 60000000000,
		BaseIncome = 620000000,
		CycleTime = 9,
		ModelName = "Orcalero Orcala",
		Description = "Orca power!",
		CostMultiplier = 1.22,
		ProjectileColor = Color3.fromRGB(255, 105, 180),
	},
	["Pandaccini Bananini"] = {
		BasePrice = 80000000000,
		BaseIncome = 800000000,
		CycleTime = 9,
		ModelName = "Pandaccini Bananini",
		Description = "Panda banana combo!",
		CostMultiplier = 1.22,
		ProjectileColor = Color3.fromRGB(255, 105, 180),
	},
	["Perochello_Lemonchello"] = {
		BasePrice = 105000000000,
		BaseIncome = 1000000000,
		CycleTime = 9,
		ModelName = "Perochello_Lemonchello",
		Description = "Lemon parrot drinks!",
		CostMultiplier = 1.22,
		ProjectileColor = Color3.fromRGB(255, 105, 180),
	},
	["Piccione Macchina"] = {
		BasePrice = 135000000000,
		BaseIncome = 1250000000,
		CycleTime = 9,
		ModelName = "Piccione Macchina",
		Description = "Pigeon machine!",
		CostMultiplier = 1.22,
		ProjectileColor = Color3.fromRGB(255, 105, 180),
	},
	["Pipi_Kiwi"] = {
		BasePrice = 175000000000,
		BaseIncome = 1550000000,
		CycleTime = 9,
		ModelName = "Pipi_Kiwi",
		Description = "Kiwi bird vibes!",
		CostMultiplier = 1.22,
		ProjectileColor = Color3.fromRGB(255, 105, 180),
	},
	
	-- Tier 6: End Game ($500B - $650T) - CostMultiplier: 1.25
	["Pot Hotspot"] = {
		BasePrice = 500000000000,
		BaseIncome = 4000000000,
		CycleTime = 9,
		ModelName = "Pot Hotspot",
		Description = "Hot pot spot!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
	},
	["Rhino_Toasterino"] = {
		BasePrice = 850000000000,
		BaseIncome = 6500000000,
		CycleTime = 9,
		ModelName = "Rhino_Toasterino",
		Description = "Toaster rhino!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
	},
	["Salamino Penguino"] = {
		BasePrice = 1500000000000,
		BaseIncome = 10000000000,
		CycleTime = 9,
		ModelName = "Salamino Penguino",
		Description = "Salami penguin!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
	},
	["Sammyni_Spyderini"] = {
		BasePrice = 2500000000000,
		BaseIncome = 15000000000,
		CycleTime = 10,
		ModelName = "Sammyni_Spyderini",
		Description = "Sammy the spider!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
	},
	["Spioniro Golubiro"] = {
		BasePrice = 4000000000000,
		BaseIncome = 22000000000,
		CycleTime = 10,
		ModelName = "Spioniro Golubiro",
		Description = "Spy pigeon!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
	},
	["Statutino Libertino"] = {
		BasePrice = 6500000000000,
		BaseIncome = 32000000000,
		CycleTime = 10,
		ModelName = "Statutino Libertino",
		Description = "Liberty statue!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
	},
	["Strawberrelli Flamingelli"] = {
		BasePrice = 10000000000000,
		BaseIncome = 45000000000,
		CycleTime = 10,
		ModelName = "Strawberrelli Flamingelli",
		Description = "Strawberry flamingo!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
	},
	["Svinina_Bombardino"] = {
		BasePrice = 15000000000000,
		BaseIncome = 60000000000,
		CycleTime = 10,
		ModelName = "Svinina_Bombardino",
		Description = "Bomber pig!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
	},
	["Ta_Ta_Ta_Ta_Sahur"] = {
		BasePrice = 22500000000000,
		BaseIncome = 85000000000,
		CycleTime = 10,
		ModelName = "Ta_Ta_Ta_Ta_Sahur",
		Description = "Sahur rhythm!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
	},
	["Talpa_Di_Fero"] = {
		BasePrice = 35000000000000,
		BaseIncome = 120000000000,
		CycleTime = 10,
		ModelName = "Talpa_Di_Fero",
		Description = "Iron mole!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
	},
	["Tigrilini Watermelini"] = {
		BasePrice = 50000000000000,
		BaseIncome = 160000000000,
		CycleTime = 10,
		ModelName = "Tigrilini Watermelini",
		Description = "Watermelon tiger!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
	},
	["Tigroligre Frutonni"] = {
		BasePrice = 75000000000000,
		BaseIncome = 220000000000,
		CycleTime = 10,
		ModelName = "Tigroligre Frutonni",
		Description = "Fruit tiger-lion!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
	},
	["Tim_Cheese"] = {
		BasePrice = 110000000000000,
		BaseIncome = 300000000000,
		CycleTime = 10,
		ModelName = "Tim_Cheese",
		Description = "It's Tim Cheese!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
	},
	["Torrtuginni Dragonfrutini"] = {
		BasePrice = 160000000000000,
		BaseIncome = 400000000000,
		CycleTime = 10,
		ModelName = "Torrtuginni Dragonfrutini",
		Description = "Dragonfruit turtle!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
	},
	["Tralalero_Tralala"] = {
		BasePrice = 225000000000000,
		BaseIncome = 550000000000,
		CycleTime = 10,
		ModelName = "Tralalero_Tralala",
		Description = "The OG tralala!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
	},
	["Trenostruzzo_Turbo_3000"] = {
		BasePrice = 325000000000000,
		BaseIncome = 750000000000,
		CycleTime = 10,
		ModelName = "Trenostruzzo_Turbo_3000",
		Description = "Turbo train ostrich!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
	},
	["Tric_Trac_Baraboom"] = {
		BasePrice = 450000000000000,
		BaseIncome = 1000000000000,
		CycleTime = 10,
		ModelName = "Tric_Trac_Baraboom",
		Description = "Boom tric trac!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
	},
	["Trippi_Troppi"] = {
		BasePrice = 650000000000000,
		BaseIncome = 1400000000000,
		CycleTime = 10,
		ModelName = "Trippi_Troppi",
		Description = "Trippy toppy!",
		CostMultiplier = 1.25,
		ProjectileColor = Color3.fromRGB(255, 50, 50),
	},
	
	-- Tier 7: Legendary ($1Qa - $10Qa) - CostMultiplier: 1.30
	["Trulimero_Trulicina"] = {
		BasePrice = 1000000000000000,
		BaseIncome = 2000000000000,
		CycleTime = 10,
		ModelName = "Trulimero_Trulicina",
		Description = "Trulli power!",
		CostMultiplier = 1.30,
		ProjectileColor = Color3.fromRGB(148, 0, 211),
	},
	["Tung_Tung_Tung_Sahur"] = {
		BasePrice = 2500000000000000,
		BaseIncome = 4500000000000,
		CycleTime = 10,
		ModelName = "Tung_Tung_Tung_Sahur",
		Description = "Wake up to riches!",
		CostMultiplier = 1.30,
		ProjectileColor = Color3.fromRGB(148, 0, 211),
	},
	["Unclito_Samito"] = {
		BasePrice = 5000000000000000,
		BaseIncome = 8500000000000,
		CycleTime = 10,
		ModelName = "Unclito_Samito",
		Description = "Uncle Sam power!",
		CostMultiplier = 1.30,
		ProjectileColor = Color3.fromRGB(148, 0, 211),
	},
	["Zibra Zubra Zibralini"] = {
		BasePrice = 10000000000000000,
		BaseIncome = 16000000000000,
		CycleTime = 10,
		ModelName = "Zibra Zubra Zibralini",
		Description = "Triple zebra!",
		CostMultiplier = 1.30,
		ProjectileColor = Color3.fromRGB(148, 0, 211),
	},
	
	-- Tier 8: Lucky Blocks (Special Units) - CostMultiplier: 1.45
	["Secret Lucky Block"] = {
		BasePrice = 50000000000000000,
		BaseIncome = 75000000000000,
		CycleTime = 10,
		ModelName = "Secret Lucky Block",
		Description = "Secret lucky power!",
		CostMultiplier = 1.45,
		ProjectileColor = Color3.fromRGB(0, 255, 255),
	},
	["Mythic Lucky Block"] = {
		BasePrice = 250000000000000000,
		BaseIncome = 350000000000000,
		CycleTime = 10,
		ModelName = "Mythic Lucky Block",
		Description = "Mythic luck!",
		CostMultiplier = 1.45,
		ProjectileColor = Color3.fromRGB(0, 255, 255),
	},
	["Brainrot God Lucky Block"] = {
		BasePrice = 1000000000000000000,
		BaseIncome = 1250000000000000,
		CycleTime = 10,
		ModelName = "Brainrot God Lucky Block",
		Description = "The ultimate brainrot deity!",
		CostMultiplier = 1.45,
		ProjectileColor = Color3.fromRGB(0, 255, 255),
	},
}

-- Pre-sorted list cache
local SortedUnitsCache: {{name: string, config: UnitConfig}}? = nil

--------------------------------------------------------------------------------
-- UTILITY FUNCTIONS
--------------------------------------------------------------------------------

--[[
	Calculates the current price for a unit based on how many the player owns.
	
	Formula: BasePrice * (CostMultiplier ^ amountOwned)
	Uses per-unit CostMultiplier if defined, otherwise default 1.15.
	
	@param unitName string - The name of the unit
	@param amountOwned number - How many of this unit the player currently owns
	@return number - The calculated price (floored to integer)
]]
local function CalculatePrice(unitName: string, amountOwned: number): number
	local config = Units[unitName]
	if not config then
		warn("ShopConfig: Unknown unit " .. unitName)
		return 0
	end
	
	-- Use per-unit multiplier if defined, otherwise fall back to default
	local multiplier = config.CostMultiplier or PRICE_MULTIPLIER
	local price = config.BasePrice * (multiplier ^ amountOwned)
	return math.floor(price)
end

--[[
	Calculates the effective income for a unit with milestone bonuses.
	
	@param unitName string - The name of the unit
	@param amountOwned number - How many of this unit the player owns
	@return number - The effective income per cycle
]]
local function CalculateEffectiveIncome(unitName: string, amountOwned: number): number
	local config = Units[unitName]
	if not config then
		warn("ShopConfig: Unknown unit " .. unitName)
		return 0
	end
	
	local profitMultiplier = 1
	
	-- Apply all profit milestones that have been reached
	for _, milestone in MILESTONES do
		if amountOwned >= milestone.quantity and milestone.milestoneType == "profit" then
			profitMultiplier = profitMultiplier * milestone.multiplier
		end
	end
	
	return math.floor(config.BaseIncome * profitMultiplier)
end

--[[
	Calculates the effective cycle time for a unit with milestone bonuses.
	
	@param unitName string - The name of the unit
	@param amountOwned number - How many of this unit the player owns
	@return number - The effective cycle time in seconds
]]
local function CalculateEffectiveCycleTime(unitName: string, amountOwned: number): number
	local config = Units[unitName]
	if not config then
		warn("ShopConfig: Unknown unit " .. unitName)
		return 3 -- Default fallback
	end
	
	local speedMultiplier = 1
	
	-- Apply all speed milestones that have been reached
	for _, milestone in MILESTONES do
		if amountOwned >= milestone.quantity and milestone.milestoneType == "speed" then
			speedMultiplier = speedMultiplier * milestone.multiplier
		end
	end
	
	-- Speed multiplier reduces cycle time (higher speed = lower time)
	return math.max(0.1, config.CycleTime / speedMultiplier) -- Min 0.1s cycle
end

--[[
	Gets the next milestone info for a unit.
	
	@param amountOwned number - How many of this unit the player owns
	@return MilestoneInfo?, number - Next milestone and progress, or nil if all reached
]]
local function GetNextMilestone(amountOwned: number): (MilestoneInfo?, number)
	for _, milestone in MILESTONES do
		if amountOwned < milestone.quantity then
			return milestone, amountOwned
		end
	end
	
	return nil, amountOwned -- All milestones reached
end

--[[
	Gets all milestones that have been reached.
	
	@param amountOwned number - How many of this unit the player owns
	@return {MilestoneInfo} - Array of reached milestones
]]
local function GetMilestonesReached(amountOwned: number): {MilestoneInfo}
	local reached = {}
	
	for _, milestone in MILESTONES do
		if amountOwned >= milestone.quantity then
			table.insert(reached, milestone)
		end
	end
	
	return reached
end

--[[
	Gets the configuration for a specific unit.
	
	@param unitName string - The name of the unit
	@return UnitConfig? - The config table, or nil if not found
]]
local function GetConfig(unitName: string): UnitConfig?
	return Units[unitName]
end

--[[
	Returns an array of all units sorted by BasePrice (ascending).
	Cached for performance.
	
	@return table - Array of {name, config} pairs sorted by BasePrice
]]
local function GetAllUnitsSorted(): {{name: string, config: UnitConfig}}
	if SortedUnitsCache then
		return SortedUnitsCache
	end
	
	local sorted = {}
	
	for name, config in Units do
		table.insert(sorted, {name = name, config = config})
	end
	
	table.sort(sorted, function(a, b)
		return a.config.BasePrice < b.config.BasePrice
	end)
	
	SortedUnitsCache = sorted
	return sorted
end

--[[
	Returns which units should be visible based on unlock progress.
	Shows (unlockProgress) unlocked + 1 locked preview.
	
	@param unlockProgress number - How many units are unlocked (default: INITIAL_UNLOCKED)
	@return table - Array of {name, config, isLocked} for visible units
]]
local function GetVisibleUnits(unlockProgress: number?): {{name: string, config: UnitConfig, isLocked: boolean}}
	local progress = unlockProgress or INITIAL_UNLOCKED
	local allUnits = GetAllUnitsSorted()
	local visible = {}
	
	-- Show unlocked units + 1 locked preview
	local showCount = math.min(progress + 1, #allUnits)
	
	for i = 1, showCount do
		local unit = allUnits[i]
		table.insert(visible, {
			name = unit.name,
			config = unit.config,
			isLocked = i > progress,
		})
	end
	
	return visible
end

--[[
	Checks if a unit is unlocked based on unlock progress.
	
	@param unitName string - The name of the unit
	@param unlockProgress number - Current unlock progress
	@return boolean - Whether the unit is unlocked
]]
local function IsUnitUnlocked(unitName: string, unlockProgress: number?): boolean
	local progress = unlockProgress or INITIAL_UNLOCKED
	local allUnits = GetAllUnitsSorted()
	
	for i, unit in allUnits do
		if unit.name == unitName then
			return i <= progress
		end
	end
	
	return false
end

--[[
	Gets the total number of units available.
]]
local function GetTotalUnits(): number
	return #GetAllUnitsSorted()
end

-- Return module with both data and functions
return {
	Units = Units,
	CalculatePrice = CalculatePrice,
	CalculateEffectiveIncome = CalculateEffectiveIncome,
	CalculateEffectiveCycleTime = CalculateEffectiveCycleTime,
	GetNextMilestone = GetNextMilestone,
	GetMilestonesReached = GetMilestonesReached,
	GetConfig = GetConfig,
	GetAllUnitsSorted = GetAllUnitsSorted,
	GetVisibleUnits = GetVisibleUnits,
	IsUnitUnlocked = IsUnitUnlocked,
	GetTotalUnits = GetTotalUnits,
	
	-- Constants
	PRICE_MULTIPLIER = PRICE_MULTIPLIER,
	INITIAL_UNLOCKED = INITIAL_UNLOCKED,
	MILESTONES = MILESTONES,
}



--------------------------------------------------
File: SynergyConfig.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\shared\SynergyConfig.luau
--------------------------------------------------
--[[
	SynergyConfig - Shared Configuration for Brainrot Synergies
	
	Defines synergy combinations that provide bonuses when requirements are met.
	
	Synergy Types:
	- Global: Affects all brainrots or player stats
	- Local: Only affects the specific brainrots involved in the synergy
	
	Requirements can specify:
	- Unit type (required)
	- Minimum count (required)
	- Specific rarity (optional - nil means any rarity counts)
]]

export type SynergyRequirement = {
	UnitName: string,           -- The brainrot type required
	MinCount: number,           -- Minimum number needed
	Rarity: string?,            -- Optional: specific rarity required (nil = any)
}

export type SynergyEffect = {
	Type: "IncomeMultiplier" | "CycleReduction" | "GlobalIncomeBoost",
	Target: "All" | "Specific",  -- All brainrots or specific units
	TargetUnits: {string}?,      -- If Target is "Specific", which units are affected
	Value: number,               -- Multiplier or percentage value
}

export type SynergyDefinition = {
	Id: string,                  -- Unique identifier
	Name: string,                -- Display name
	Description: string,         -- What the synergy does
	Icon: string,                -- Emoji icon for display
	Requirements: {SynergyRequirement}, -- What's needed to unlock
	Effects: {SynergyEffect},    -- What bonuses are applied
}

local SynergyConfig = {}

--------------------------------------------------------------------------------
-- SYNERGY DEFINITIONS
--------------------------------------------------------------------------------

SynergyConfig.Synergies = {
	--[[
		Example Synergy: Italian Brainrot Alliance
		Requires 10 Avocadini Guffo + 100 Brr_Brr_Patapim
		Result: Brr_Brr_Patapim gains 100% income multiplier
	]]
	ItalianAlliance = {
		Id = "ItalianAlliance",
		Name = "Italian Brainrot Alliance",
		Description = "Brr Brr Patapim gains +100% income!",
		Icon = "ðŸ‡®ðŸ‡¹",
		Requirements = {
			{
				UnitName = "Avocadini Guffo",
				MinCount = 10,
				Rarity = nil, -- Any rarity counts
			},
			{
				UnitName = "Brr_Brr_Patapim",
				MinCount = 100,
				Rarity = nil,
			},
		},
		Effects = {
			{
				Type = "IncomeMultiplier",
				Target = "Specific",
				TargetUnits = {"Brr_Brr_Patapim"},
				Value = 2.0, -- 2x = +100% income
			},
		},
	},
	
	--[[
		Example Synergy: Spicy Collection
		Requires 5 Spicy rarity of any brainrot type
		Result: All brainrots gain +25% income
	]]
	-- SpicyCollection = {
	-- 	Id = "SpicyCollection",
	-- 	Name = "Spicy Collection",
	-- 	Description = "All brainrots gain +25% income!",
	-- 	Icon = "ðŸŒ¶ï¸",
	-- 	Requirements = {
	-- 		{
	-- 			UnitName = "*", -- Wildcard: any unit type
	-- 			MinCount = 5,
	-- 			Rarity = "Spicy",
	-- 		},
	-- 	},
	-- 	Effects = {
	-- 		{
	-- 			Type = "IncomeMultiplier",
	-- 			Target = "All",
	-- 			TargetUnits = nil,
	-- 			Value = 1.25, -- 1.25x = +25% income
	-- 		},
	-- 	},
	-- },
}

-- Ordered list for display
SynergyConfig.SynergyOrder = {"ItalianAlliance"}

--------------------------------------------------------------------------------
-- HELPER FUNCTIONS
--------------------------------------------------------------------------------

--[[
	Gets a synergy definition by ID.
	@param synergyId string - The synergy ID
	@return SynergyDefinition? - The synergy definition or nil
]]
function SynergyConfig.GetSynergy(synergyId: string): SynergyDefinition?
	return SynergyConfig.Synergies[synergyId]
end

--[[
	Gets all synergy definitions in display order.
	@return {SynergyDefinition} - Array of synergy definitions
]]
function SynergyConfig.GetAllSynergies(): {SynergyDefinition}
	local synergies = {}
	for _, synergyId in SynergyConfig.SynergyOrder do
		local synergy = SynergyConfig.Synergies[synergyId]
		if synergy then
			table.insert(synergies, synergy)
		end
	end
	return synergies
end

--[[
	Checks if a player meets the requirements for a synergy.
	@param synergyId string - The synergy ID to check
	@param inventoryData table - Player's inventory {[unitName]: {[rarity]: {total, active}}}
	@return boolean, {[string]: {current: number, required: number}} - Met status and progress
]]
function SynergyConfig.CheckSynergyProgress(
	synergyId: string, 
	inventoryData: {[string]: {[string]: {total: number, active: number}}}
): (boolean, {[string]: {current: number, required: number}})
	local synergy = SynergyConfig.Synergies[synergyId]
	if not synergy then
		return false, {}
	end
	
	local progress = {}
	local allMet = true
	
	for _, req in synergy.Requirements do
		local current = 0
		local key = req.UnitName .. (req.Rarity and ("_" .. req.Rarity) or "")
		
		if req.UnitName == "*" then
			-- Wildcard: count all units of this rarity
			for _, unitRarities in inventoryData do
				if req.Rarity then
					local rarityData = unitRarities[req.Rarity]
					if rarityData then
						current = current + rarityData.total
					end
				else
					for _, rarityData in unitRarities do
						current = current + rarityData.total
					end
				end
			end
		else
			-- Specific unit
			local unitData = inventoryData[req.UnitName]
			if unitData then
				if req.Rarity then
					local rarityData = unitData[req.Rarity]
					if rarityData then
						current = rarityData.total
					end
				else
					-- Sum all rarities
					for _, rarityData in unitData do
						current = current + rarityData.total
					end
				end
			end
		end
		
		progress[key] = {
			current = current,
			required = req.MinCount,
			unitName = req.UnitName,
			rarity = req.Rarity,
		}
		
		if current < req.MinCount then
			allMet = false
		end
	end
	
	return allMet, progress
end

return SynergyConfig



--------------------------------------------------
File: ViewportPreview.luau
Path: C:\Users\Soren\Desktop\BrainrotClicker\BrainRotClicker\src\shared\ViewportPreview.luau
--------------------------------------------------
--[[
	ViewportPreview Module
	
	Creates spinning 3D previews of models inside ViewportFrames.
	Used for inventory UI to show brainrot models instead of static images.
	
	Usage:
		local ViewportPreview = require(path.to.ViewportPreview)
		local preview = ViewportPreview.Create(model, parentFrame)
		-- Later:
		preview:Destroy()
]]

local RunService = game:GetService("RunService")

local ViewportPreview = {}
ViewportPreview.__index = ViewportPreview

-- Configuration
local CONFIG = {
	SPIN_SPEED = 30, -- degrees per second
	CAMERA_FOV = 50,
	DEFAULT_SIZE = UDim2.new(1, 0, 1, 0),
	BACKGROUND_COLOR = Color3.fromRGB(30, 25, 40),
	BACKGROUND_TRANSPARENCY = 0.5,
}

--[[
	Calculates the bounding box of a model.
	@param model Model - The model to measure
	@return CFrame, Vector3 - The center CFrame and size
]]
local function getModelBounds(model: Model): (CFrame, Vector3)
	local cf, size = model:GetBoundingBox()
	return cf, size
end

--[[
	Positions the camera to fit the model in view.
	@param camera Camera - The viewport camera
	@param model Model - The model to frame
	@param size Vector3 - The bounding box size
]]
local function positionCamera(camera: Camera, model: Model, size: Vector3)
	local cf, _ = getModelBounds(model)
	
	-- Calculate distance based on model size
	local maxDimension = math.max(size.X, size.Y, size.Z)
	local fovRad = math.rad(CONFIG.CAMERA_FOV / 2)
	local distance = (maxDimension / 2) / math.tan(fovRad) * 1.5
	
	-- Position camera higher and looking down at model center
	local cameraOffset = Vector3.new(distance * 0.6, distance * 0.6, distance * 0.6)
	
	-- Look slightly higher than center to frame the head better
	local targetPos = cf.Position + Vector3.new(0, size.Y * 0.1, 0)
	
	camera.CFrame = CFrame.new(cf.Position + cameraOffset, targetPos)
	camera.FieldOfView = CONFIG.CAMERA_FOV
end

--[[
	Creates a new ViewportPreview.
	@param model Model - The model to preview (will be cloned)
	@param parent GuiObject - The parent UI element
	@param size UDim2? - Optional size override
	@return ViewportPreview
]]
function ViewportPreview.Create(model: Model, parent: GuiObject, size: UDim2?): any
	local self = setmetatable({}, ViewportPreview)
	
	-- Create ViewportFrame
	local viewport = Instance.new("ViewportFrame")
	viewport.Name = "ModelPreview"
	viewport.Size = size or CONFIG.DEFAULT_SIZE
	viewport.Position = UDim2.new(0, 0, 0, 0)
	viewport.BackgroundColor3 = CONFIG.BACKGROUND_COLOR
	viewport.BackgroundTransparency = CONFIG.BACKGROUND_TRANSPARENCY
	viewport.BorderSizePixel = 0
	viewport.Parent = parent
	
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 4)
	corner.Parent = viewport
	
	-- Clone model for viewport
	local previewModel = model:Clone()
	previewModel.Parent = viewport
	
	-- Create WorldModel container (required for proper rendering)
	local worldModel = Instance.new("WorldModel")
	worldModel.Parent = viewport
	previewModel.Parent = worldModel
	
	-- Create camera
	local camera = Instance.new("Camera")
	camera.Parent = viewport
	viewport.CurrentCamera = camera
	
	-- Get model bounds and position camera
	local _, modelSize = getModelBounds(previewModel)
	positionCamera(camera, previewModel, modelSize)
	
	-- Store references
	self.viewport = viewport
	self.model = previewModel
	self.worldModel = worldModel
	self.camera = camera
	self.modelCenter, _ = getModelBounds(previewModel)
	self.rotation = 0
	self.spinConnection = nil
	
	-- Start spinning
	self:StartSpin()
	
	return self
end

--[[
	Starts the spin animation.
]]
function ViewportPreview:StartSpin()
	if self.spinConnection then return end
	
	self.spinConnection = RunService.RenderStepped:Connect(function(dt)
		if not self.model or not self.model.Parent then
			self:Destroy()
			return
		end
		
		-- Update rotation
		self.rotation = self.rotation + CONFIG.SPIN_SPEED * dt
		
		-- Rotate model around Y axis
		local centerCF = self.modelCenter
		local rotationCF = CFrame.Angles(0, math.rad(self.rotation), 0)
		self.model:PivotTo(CFrame.new(centerCF.Position) * rotationCF)
	end)
end

--[[
	Stops the spin animation.
]]
function ViewportPreview:StopSpin()
	if self.spinConnection then
		self.spinConnection:Disconnect()
		self.spinConnection = nil
	end
end

--[[
	Destroys the preview and cleans up.
]]
function ViewportPreview:Destroy()
	self:StopSpin()
	
	if self.viewport then
		self.viewport:Destroy()
		self.viewport = nil
	end
	
	self.model = nil
	self.worldModel = nil
	self.camera = nil
end

return ViewportPreview



